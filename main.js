function _mergeNamespaces(o,e){for(var s=0;s<e.length;s++){const a=e[s];if(typeof a!="string"&&!Array.isArray(a)){for(const d in a)if(d!=="default"&&!(d in o)){const h=Object.getOwnPropertyDescriptor(a,d);h&&Object.defineProperty(o,d,h.get?h:{enumerable:!0,get:()=>a[d]})}}}return Object.freeze(Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const d of document.querySelectorAll('link[rel="modulepreload"]'))a(d);new MutationObserver(d=>{for(const h of d)if(h.type==="childList")for(const b of h.addedNodes)b.tagName==="LINK"&&b.rel==="modulepreload"&&a(b)}).observe(document,{childList:!0,subtree:!0});function s(d){const h={};return d.integrity&&(h.integrity=d.integrity),d.referrerPolicy&&(h.referrerPolicy=d.referrerPolicy),d.crossOrigin==="use-credentials"?h.credentials="include":d.crossOrigin==="anonymous"?h.credentials="omit":h.credentials="same-origin",h}function a(d){if(d.ep)return;d.ep=!0;const h=s(d);fetch(d.href,h)}})();function getDefaultExportFromCjs(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}function getAugmentedNamespace(o){if(o.__esModule)return o;var e=o.default;if(typeof e=="function"){var s=function a(){return this instanceof a?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};s.prototype=e.prototype}else s={};return Object.defineProperty(s,"__esModule",{value:!0}),Object.keys(o).forEach(function(a){var d=Object.getOwnPropertyDescriptor(o,a);Object.defineProperty(s,a,d.get?d:{enumerable:!0,get:function(){return o[a]}})}),s}var jsxRuntime={exports:{}},reactJsxRuntime_production_min={},react={exports:{}},react_production_min={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$1=Symbol.for("react.element"),n$1=Symbol.for("react.portal"),p$2=Symbol.for("react.fragment"),q$1=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v$1=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z$1=Symbol.iterator;function A$1(o){return o===null||typeof o!="object"?null:(o=z$1&&o[z$1]||o["@@iterator"],typeof o=="function"?o:null)}var B$1={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$1=Object.assign,D$1={};function E$1(o,e,s){this.props=o,this.context=e,this.refs=D$1,this.updater=s||B$1}E$1.prototype.isReactComponent={};E$1.prototype.setState=function(o,e){if(typeof o!="object"&&typeof o!="function"&&o!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,o,e,"setState")};E$1.prototype.forceUpdate=function(o){this.updater.enqueueForceUpdate(this,o,"forceUpdate")};function F(){}F.prototype=E$1.prototype;function G$1(o,e,s){this.props=o,this.context=e,this.refs=D$1,this.updater=s||B$1}var H$1=G$1.prototype=new F;H$1.constructor=G$1;C$1(H$1,E$1.prototype);H$1.isPureReactComponent=!0;var I$1=Array.isArray,J=Object.prototype.hasOwnProperty,K$2={current:null},L$1={key:!0,ref:!0,__self:!0,__source:!0};function M$2(o,e,s){var a,d={},h=null,b=null;if(e!=null)for(a in e.ref!==void 0&&(b=e.ref),e.key!==void 0&&(h=""+e.key),e)J.call(e,a)&&!L$1.hasOwnProperty(a)&&(d[a]=e[a]);var et=arguments.length-2;if(et===1)d.children=s;else if(1<et){for(var st=Array(et),$=0;$<et;$++)st[$]=arguments[$+2];d.children=st}if(o&&o.defaultProps)for(a in et=o.defaultProps,et)d[a]===void 0&&(d[a]=et[a]);return{$$typeof:l$1,type:o,key:h,ref:b,props:d,_owner:K$2.current}}function N$1(o,e){return{$$typeof:l$1,type:o.type,key:e,ref:o.ref,props:o.props,_owner:o._owner}}function O$1(o){return typeof o=="object"&&o!==null&&o.$$typeof===l$1}function escape$2(o){var e={"=":"=0",":":"=2"};return"$"+o.replace(/[=:]/g,function(s){return e[s]})}var P$1=/\/+/g;function Q$1(o,e){return typeof o=="object"&&o!==null&&o.key!=null?escape$2(""+o.key):e.toString(36)}function R$1(o,e,s,a,d){var h=typeof o;(h==="undefined"||h==="boolean")&&(o=null);var b=!1;if(o===null)b=!0;else switch(h){case"string":case"number":b=!0;break;case"object":switch(o.$$typeof){case l$1:case n$1:b=!0}}if(b)return b=o,d=d(b),o=a===""?"."+Q$1(b,0):a,I$1(d)?(s="",o!=null&&(s=o.replace(P$1,"$&/")+"/"),R$1(d,e,s,"",function($){return $})):d!=null&&(O$1(d)&&(d=N$1(d,s+(!d.key||b&&b.key===d.key?"":(""+d.key).replace(P$1,"$&/")+"/")+o)),e.push(d)),1;if(b=0,a=a===""?".":a+":",I$1(o))for(var et=0;et<o.length;et++){h=o[et];var st=a+Q$1(h,et);b+=R$1(h,e,s,st,d)}else if(st=A$1(o),typeof st=="function")for(o=st.call(o),et=0;!(h=o.next()).done;)h=h.value,st=a+Q$1(h,et++),b+=R$1(h,e,s,st,d);else if(h==="object")throw e=String(o),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(o).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return b}function S$1(o,e,s){if(o==null)return o;var a=[],d=0;return R$1(o,a,"","",function(h){return e.call(s,h,d++)}),a}function T$1(o){if(o._status===-1){var e=o._result;e=e(),e.then(function(s){(o._status===0||o._status===-1)&&(o._status=1,o._result=s)},function(s){(o._status===0||o._status===-1)&&(o._status=2,o._result=s)}),o._status===-1&&(o._status=0,o._result=e)}if(o._status===1)return o._result.default;throw o._result}var U$2={current:null},V$1={transition:null},W$1={ReactCurrentDispatcher:U$2,ReactCurrentBatchConfig:V$1,ReactCurrentOwner:K$2};function X$3(){throw Error("act(...) is not supported in production builds of React.")}react_production_min.Children={map:S$1,forEach:function(o,e,s){S$1(o,function(){e.apply(this,arguments)},s)},count:function(o){var e=0;return S$1(o,function(){e++}),e},toArray:function(o){return S$1(o,function(e){return e})||[]},only:function(o){if(!O$1(o))throw Error("React.Children.only expected to receive a single React element child.");return o}};react_production_min.Component=E$1;react_production_min.Fragment=p$2;react_production_min.Profiler=r;react_production_min.PureComponent=G$1;react_production_min.StrictMode=q$1;react_production_min.Suspense=w;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$1;react_production_min.act=X$3;react_production_min.cloneElement=function(o,e,s){if(o==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+o+".");var a=C$1({},o.props),d=o.key,h=o.ref,b=o._owner;if(e!=null){if(e.ref!==void 0&&(h=e.ref,b=K$2.current),e.key!==void 0&&(d=""+e.key),o.type&&o.type.defaultProps)var et=o.type.defaultProps;for(st in e)J.call(e,st)&&!L$1.hasOwnProperty(st)&&(a[st]=e[st]===void 0&&et!==void 0?et[st]:e[st])}var st=arguments.length-2;if(st===1)a.children=s;else if(1<st){et=Array(st);for(var $=0;$<st;$++)et[$]=arguments[$+2];a.children=et}return{$$typeof:l$1,type:o.type,key:d,ref:h,props:a,_owner:b}};react_production_min.createContext=function(o){return o={$$typeof:u,_currentValue:o,_currentValue2:o,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},o.Provider={$$typeof:t,_context:o},o.Consumer=o};react_production_min.createElement=M$2;react_production_min.createFactory=function(o){var e=M$2.bind(null,o);return e.type=o,e};react_production_min.createRef=function(){return{current:null}};react_production_min.forwardRef=function(o){return{$$typeof:v$1,render:o}};react_production_min.isValidElement=O$1;react_production_min.lazy=function(o){return{$$typeof:y,_payload:{_status:-1,_result:o},_init:T$1}};react_production_min.memo=function(o,e){return{$$typeof:x,type:o,compare:e===void 0?null:e}};react_production_min.startTransition=function(o){var e=V$1.transition;V$1.transition={};try{o()}finally{V$1.transition=e}};react_production_min.unstable_act=X$3;react_production_min.useCallback=function(o,e){return U$2.current.useCallback(o,e)};react_production_min.useContext=function(o){return U$2.current.useContext(o)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(o){return U$2.current.useDeferredValue(o)};react_production_min.useEffect=function(o,e){return U$2.current.useEffect(o,e)};react_production_min.useId=function(){return U$2.current.useId()};react_production_min.useImperativeHandle=function(o,e,s){return U$2.current.useImperativeHandle(o,e,s)};react_production_min.useInsertionEffect=function(o,e){return U$2.current.useInsertionEffect(o,e)};react_production_min.useLayoutEffect=function(o,e){return U$2.current.useLayoutEffect(o,e)};react_production_min.useMemo=function(o,e){return U$2.current.useMemo(o,e)};react_production_min.useReducer=function(o,e,s){return U$2.current.useReducer(o,e,s)};react_production_min.useRef=function(o){return U$2.current.useRef(o)};react_production_min.useState=function(o){return U$2.current.useState(o)};react_production_min.useSyncExternalStore=function(o,e,s){return U$2.current.useSyncExternalStore(o,e,s)};react_production_min.useTransition=function(){return U$2.current.useTransition()};react_production_min.version="18.3.1";react.exports=react_production_min;var reactExports=react.exports;const React=getDefaultExportFromCjs(reactExports),React$1=_mergeNamespaces({__proto__:null,default:React},[reactExports]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f=reactExports,k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m$1=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$1={key:!0,ref:!0,__self:!0,__source:!0};function q(o,e,s){var a,d={},h=null,b=null;s!==void 0&&(h=""+s),e.key!==void 0&&(h=""+e.key),e.ref!==void 0&&(b=e.ref);for(a in e)m$1.call(e,a)&&!p$1.hasOwnProperty(a)&&(d[a]=e[a]);if(o&&o.defaultProps)for(a in e=o.defaultProps,e)d[a]===void 0&&(d[a]=e[a]);return{$$typeof:k,type:o,key:h,ref:b,props:d,_owner:n.current}}reactJsxRuntime_production_min.Fragment=l;reactJsxRuntime_production_min.jsx=q;reactJsxRuntime_production_min.jsxs=q;jsxRuntime.exports=reactJsxRuntime_production_min;var jsxRuntimeExports=jsxRuntime.exports,client={},reactDom={exports:{}},reactDom_production_min={},scheduler={exports:{}},scheduler_production_min={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(o){function e(xn,dn){var wn=xn.length;xn.push(dn);e:for(;0<wn;){var gn=wn-1>>>1,En=xn[gn];if(0<d(En,dn))xn[gn]=dn,xn[wn]=En,wn=gn;else break e}}function s(xn){return xn.length===0?null:xn[0]}function a(xn){if(xn.length===0)return null;var dn=xn[0],wn=xn.pop();if(wn!==dn){xn[0]=wn;e:for(var gn=0,En=xn.length,_r=En>>>1;gn<_r;){var Sr=2*(gn+1)-1,xr=xn[Sr],Vr=Sr+1,Fr=xn[Vr];if(0>d(xr,wn))Vr<En&&0>d(Fr,xr)?(xn[gn]=Fr,xn[Vr]=wn,gn=Vr):(xn[gn]=xr,xn[Sr]=wn,gn=Sr);else if(Vr<En&&0>d(Fr,wn))xn[gn]=Fr,xn[Vr]=wn,gn=Vr;else break e}}return dn}function d(xn,dn){var wn=xn.sortIndex-dn.sortIndex;return wn!==0?wn:xn.id-dn.id}if(typeof performance=="object"&&typeof performance.now=="function"){var h=performance;o.unstable_now=function(){return h.now()}}else{var b=Date,et=b.now();o.unstable_now=function(){return b.now()-et}}var st=[],$=[],it=1,g=null,c=3,_=!1,ot=!1,ct=!1,dt=typeof setTimeout=="function"?setTimeout:null,pt=typeof clearTimeout=="function"?clearTimeout:null,ft=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function ht(xn){for(var dn=s($);dn!==null;){if(dn.callback===null)a($);else if(dn.startTime<=xn)a($),dn.sortIndex=dn.expirationTime,e(st,dn);else break;dn=s($)}}function bt(xn){if(ct=!1,ht(xn),!ot)if(s(st)!==null)ot=!0,Gt(mt);else{var dn=s($);dn!==null&&cn(bt,dn.startTime-xn)}}function mt(xn,dn){ot=!1,ct&&(ct=!1,pt(Nt),Nt=-1),_=!0;var wn=c;try{for(ht(dn),g=s(st);g!==null&&(!(g.expirationTime>dn)||xn&&!ln());){var gn=g.callback;if(typeof gn=="function"){g.callback=null,c=g.priorityLevel;var En=gn(g.expirationTime<=dn);dn=o.unstable_now(),typeof En=="function"?g.callback=En:g===s(st)&&a(st),ht(dn)}else a(st);g=s(st)}if(g!==null)var _r=!0;else{var Sr=s($);Sr!==null&&cn(bt,Sr.startTime-dn),_r=!1}return _r}finally{g=null,c=wn,_=!1}}var $t=!1,Tt=null,Nt=-1,Ct=5,Ft=-1;function ln(){return!(o.unstable_now()-Ft<Ct)}function mn(){if(Tt!==null){var xn=o.unstable_now();Ft=xn;var dn=!0;try{dn=Tt(!0,xn)}finally{dn?yn():($t=!1,Tt=null)}}else $t=!1}var yn;if(typeof ft=="function")yn=function(){ft(mn)};else if(typeof MessageChannel<"u"){var pn=new MessageChannel,Ht=pn.port2;pn.port1.onmessage=mn,yn=function(){Ht.postMessage(null)}}else yn=function(){dt(mn,0)};function Gt(xn){Tt=xn,$t||($t=!0,yn())}function cn(xn,dn){Nt=dt(function(){xn(o.unstable_now())},dn)}o.unstable_IdlePriority=5,o.unstable_ImmediatePriority=1,o.unstable_LowPriority=4,o.unstable_NormalPriority=3,o.unstable_Profiling=null,o.unstable_UserBlockingPriority=2,o.unstable_cancelCallback=function(xn){xn.callback=null},o.unstable_continueExecution=function(){ot||_||(ot=!0,Gt(mt))},o.unstable_forceFrameRate=function(xn){0>xn||125<xn?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):Ct=0<xn?Math.floor(1e3/xn):5},o.unstable_getCurrentPriorityLevel=function(){return c},o.unstable_getFirstCallbackNode=function(){return s(st)},o.unstable_next=function(xn){switch(c){case 1:case 2:case 3:var dn=3;break;default:dn=c}var wn=c;c=dn;try{return xn()}finally{c=wn}},o.unstable_pauseExecution=function(){},o.unstable_requestPaint=function(){},o.unstable_runWithPriority=function(xn,dn){switch(xn){case 1:case 2:case 3:case 4:case 5:break;default:xn=3}var wn=c;c=xn;try{return dn()}finally{c=wn}},o.unstable_scheduleCallback=function(xn,dn,wn){var gn=o.unstable_now();switch(typeof wn=="object"&&wn!==null?(wn=wn.delay,wn=typeof wn=="number"&&0<wn?gn+wn:gn):wn=gn,xn){case 1:var En=-1;break;case 2:En=250;break;case 5:En=1073741823;break;case 4:En=1e4;break;default:En=5e3}return En=wn+En,xn={id:it++,callback:dn,priorityLevel:xn,startTime:wn,expirationTime:En,sortIndex:-1},wn>gn?(xn.sortIndex=wn,e($,xn),s(st)===null&&xn===s($)&&(ct?(pt(Nt),Nt=-1):ct=!0,cn(bt,wn-gn))):(xn.sortIndex=En,e(st,xn),ot||_||(ot=!0,Gt(mt))),xn},o.unstable_shouldYield=ln,o.unstable_wrapCallback=function(xn){var dn=c;return function(){var wn=c;c=dn;try{return xn.apply(this,arguments)}finally{c=wn}}}})(scheduler_production_min);scheduler.exports=scheduler_production_min;var schedulerExports=scheduler.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aa$1=reactExports,ca$1=schedulerExports;function p(o){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+o,s=1;s<arguments.length;s++)e+="&args[]="+encodeURIComponent(arguments[s]);return"Minified React error #"+o+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da$1=new Set,ea$1={};function fa$1(o,e){ha$1(o,e),ha$1(o+"Capture",e)}function ha$1(o,e){for(ea$1[o]=e,o=0;o<e.length;o++)da$1.add(e[o])}var ia$1=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la$1={},ma$1={};function oa$1(o){return ja.call(ma$1,o)?!0:ja.call(la$1,o)?!1:ka.test(o)?ma$1[o]=!0:(la$1[o]=!0,!1)}function pa$1(o,e,s,a){if(s!==null&&s.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return a?!1:s!==null?!s.acceptsBooleans:(o=o.toLowerCase().slice(0,5),o!=="data-"&&o!=="aria-");default:return!1}}function qa(o,e,s,a){if(e===null||typeof e>"u"||pa$1(o,e,s,a))return!0;if(a)return!1;if(s!==null)switch(s.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function v(o,e,s,a,d,h,b){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=a,this.attributeNamespace=d,this.mustUseProperty=s,this.propertyName=o,this.type=e,this.sanitizeURL=h,this.removeEmptyString=b}var z={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(o){z[o]=new v(o,0,!1,o,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(o){var e=o[0];z[e]=new v(e,1,!1,o[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(o){z[o]=new v(o,2,!1,o.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(o){z[o]=new v(o,2,!1,o,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(o){z[o]=new v(o,3,!1,o.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(o){z[o]=new v(o,3,!0,o,null,!1,!1)});["capture","download"].forEach(function(o){z[o]=new v(o,4,!1,o,null,!1,!1)});["cols","rows","size","span"].forEach(function(o){z[o]=new v(o,6,!1,o,null,!1,!1)});["rowSpan","start"].forEach(function(o){z[o]=new v(o,5,!1,o.toLowerCase(),null,!1,!1)});var ra$1=/[\-:]([a-z])/g;function sa$1(o){return o[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(o){var e=o.replace(ra$1,sa$1);z[e]=new v(e,1,!1,o,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(o){var e=o.replace(ra$1,sa$1);z[e]=new v(e,1,!1,o,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(o){var e=o.replace(ra$1,sa$1);z[e]=new v(e,1,!1,o,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(o){z[o]=new v(o,1,!1,o.toLowerCase(),null,!1,!1)});z.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(o){z[o]=new v(o,1,!1,o.toLowerCase(),null,!0,!0)});function ta$1(o,e,s,a){var d=z.hasOwnProperty(e)?z[e]:null;(d!==null?d.type!==0:a||!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N")&&(qa(e,s,d,a)&&(s=null),a||d===null?oa$1(e)&&(s===null?o.removeAttribute(e):o.setAttribute(e,""+s)):d.mustUseProperty?o[d.propertyName]=s===null?d.type===3?!1:"":s:(e=d.attributeName,a=d.attributeNamespace,s===null?o.removeAttribute(e):(d=d.type,s=d===3||d===4&&s===!0?"":""+s,a?o.setAttributeNS(a,e,s):o.setAttribute(e,s))))}var ua$1=aa$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va$1=Symbol.for("react.element"),wa$1=Symbol.for("react.portal"),ya$1=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca$1=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy"),Ia$1=Symbol.for("react.offscreen"),Ja=Symbol.iterator;function Ka(o){return o===null||typeof o!="object"?null:(o=Ja&&o[Ja]||o["@@iterator"],typeof o=="function"?o:null)}var A=Object.assign,La;function Ma(o){if(La===void 0)try{throw Error()}catch(s){var e=s.stack.trim().match(/\n( *(at )?)/);La=e&&e[1]||""}return`
`+La+o}var Na=!1;function Oa(o,e){if(!o||Na)return"";Na=!0;var s=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch($){var a=$}Reflect.construct(o,[],e)}else{try{e.call()}catch($){a=$}o.call(e.prototype)}else{try{throw Error()}catch($){a=$}o()}}catch($){if($&&a&&typeof $.stack=="string"){for(var d=$.stack.split(`
`),h=a.stack.split(`
`),b=d.length-1,et=h.length-1;1<=b&&0<=et&&d[b]!==h[et];)et--;for(;1<=b&&0<=et;b--,et--)if(d[b]!==h[et]){if(b!==1||et!==1)do if(b--,et--,0>et||d[b]!==h[et]){var st=`
`+d[b].replace(" at new "," at ");return o.displayName&&st.includes("<anonymous>")&&(st=st.replace("<anonymous>",o.displayName)),st}while(1<=b&&0<=et);break}}}finally{Na=!1,Error.prepareStackTrace=s}return(o=o?o.displayName||o.name:"")?Ma(o):""}function Pa(o){switch(o.tag){case 5:return Ma(o.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return o=Oa(o.type,!1),o;case 11:return o=Oa(o.type.render,!1),o;case 1:return o=Oa(o.type,!0),o;default:return""}}function Qa(o){if(o==null)return null;if(typeof o=="function")return o.displayName||o.name||null;if(typeof o=="string")return o;switch(o){case ya$1:return"Fragment";case wa$1:return"Portal";case Aa:return"Profiler";case za:return"StrictMode";case Ea:return"Suspense";case Fa:return"SuspenseList"}if(typeof o=="object")switch(o.$$typeof){case Ca$1:return(o.displayName||"Context")+".Consumer";case Ba:return(o._context.displayName||"Context")+".Provider";case Da:var e=o.render;return o=o.displayName,o||(o=e.displayName||e.name||"",o=o!==""?"ForwardRef("+o+")":"ForwardRef"),o;case Ga:return e=o.displayName||null,e!==null?e:Qa(o.type)||"Memo";case Ha:e=o._payload,o=o._init;try{return Qa(o(e))}catch{}}return null}function Ra(o){var e=o.type;switch(o.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return o=e.render,o=o.displayName||o.name||"",e.displayName||(o!==""?"ForwardRef("+o+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa(e);case 8:return e===za?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e}return null}function Sa$1(o){switch(typeof o){case"boolean":case"number":case"string":case"undefined":return o;case"object":return o;default:return""}}function Ta(o){var e=o.type;return(o=o.nodeName)&&o.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function Ua(o){var e=Ta(o)?"checked":"value",s=Object.getOwnPropertyDescriptor(o.constructor.prototype,e),a=""+o[e];if(!o.hasOwnProperty(e)&&typeof s<"u"&&typeof s.get=="function"&&typeof s.set=="function"){var d=s.get,h=s.set;return Object.defineProperty(o,e,{configurable:!0,get:function(){return d.call(this)},set:function(b){a=""+b,h.call(this,b)}}),Object.defineProperty(o,e,{enumerable:s.enumerable}),{getValue:function(){return a},setValue:function(b){a=""+b},stopTracking:function(){o._valueTracker=null,delete o[e]}}}}function Va(o){o._valueTracker||(o._valueTracker=Ua(o))}function Wa(o){if(!o)return!1;var e=o._valueTracker;if(!e)return!0;var s=e.getValue(),a="";return o&&(a=Ta(o)?o.checked?"true":"false":o.value),o=a,o!==s?(e.setValue(o),!0):!1}function Xa(o){if(o=o||(typeof document<"u"?document:void 0),typeof o>"u")return null;try{return o.activeElement||o.body}catch{return o.body}}function Ya(o,e){var s=e.checked;return A({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:s??o._wrapperState.initialChecked})}function Za(o,e){var s=e.defaultValue==null?"":e.defaultValue,a=e.checked!=null?e.checked:e.defaultChecked;s=Sa$1(e.value!=null?e.value:s),o._wrapperState={initialChecked:a,initialValue:s,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function ab(o,e){e=e.checked,e!=null&&ta$1(o,"checked",e,!1)}function bb(o,e){ab(o,e);var s=Sa$1(e.value),a=e.type;if(s!=null)a==="number"?(s===0&&o.value===""||o.value!=s)&&(o.value=""+s):o.value!==""+s&&(o.value=""+s);else if(a==="submit"||a==="reset"){o.removeAttribute("value");return}e.hasOwnProperty("value")?cb(o,e.type,s):e.hasOwnProperty("defaultValue")&&cb(o,e.type,Sa$1(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(o.defaultChecked=!!e.defaultChecked)}function db(o,e,s){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var a=e.type;if(!(a!=="submit"&&a!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+o._wrapperState.initialValue,s||e===o.value||(o.value=e),o.defaultValue=e}s=o.name,s!==""&&(o.name=""),o.defaultChecked=!!o._wrapperState.initialChecked,s!==""&&(o.name=s)}function cb(o,e,s){(e!=="number"||Xa(o.ownerDocument)!==o)&&(s==null?o.defaultValue=""+o._wrapperState.initialValue:o.defaultValue!==""+s&&(o.defaultValue=""+s))}var eb=Array.isArray;function fb(o,e,s,a){if(o=o.options,e){e={};for(var d=0;d<s.length;d++)e["$"+s[d]]=!0;for(s=0;s<o.length;s++)d=e.hasOwnProperty("$"+o[s].value),o[s].selected!==d&&(o[s].selected=d),d&&a&&(o[s].defaultSelected=!0)}else{for(s=""+Sa$1(s),e=null,d=0;d<o.length;d++){if(o[d].value===s){o[d].selected=!0,a&&(o[d].defaultSelected=!0);return}e!==null||o[d].disabled||(e=o[d])}e!==null&&(e.selected=!0)}}function gb(o,e){if(e.dangerouslySetInnerHTML!=null)throw Error(p(91));return A({},e,{value:void 0,defaultValue:void 0,children:""+o._wrapperState.initialValue})}function hb(o,e){var s=e.value;if(s==null){if(s=e.children,e=e.defaultValue,s!=null){if(e!=null)throw Error(p(92));if(eb(s)){if(1<s.length)throw Error(p(93));s=s[0]}e=s}e==null&&(e=""),s=e}o._wrapperState={initialValue:Sa$1(s)}}function ib(o,e){var s=Sa$1(e.value),a=Sa$1(e.defaultValue);s!=null&&(s=""+s,s!==o.value&&(o.value=s),e.defaultValue==null&&o.defaultValue!==s&&(o.defaultValue=s)),a!=null&&(o.defaultValue=""+a)}function jb(o){var e=o.textContent;e===o._wrapperState.initialValue&&e!==""&&e!==null&&(o.value=e)}function kb(o){switch(o){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lb(o,e){return o==null||o==="http://www.w3.org/1999/xhtml"?kb(e):o==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":o}var mb,nb=function(o){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(e,s,a,d){MSApp.execUnsafeLocalFunction(function(){return o(e,s,a,d)})}:o}(function(o,e){if(o.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in o)o.innerHTML=e;else{for(mb=mb||document.createElement("div"),mb.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=mb.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;e.firstChild;)o.appendChild(e.firstChild)}});function ob(o,e){if(e){var s=o.firstChild;if(s&&s===o.lastChild&&s.nodeType===3){s.nodeValue=e;return}}o.textContent=e}var pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(o){qb.forEach(function(e){e=e+o.charAt(0).toUpperCase()+o.substring(1),pb[e]=pb[o]})});function rb(o,e,s){return e==null||typeof e=="boolean"||e===""?"":s||typeof e!="number"||e===0||pb.hasOwnProperty(o)&&pb[o]?(""+e).trim():e+"px"}function sb(o,e){o=o.style;for(var s in e)if(e.hasOwnProperty(s)){var a=s.indexOf("--")===0,d=rb(s,e[s],a);s==="float"&&(s="cssFloat"),a?o.setProperty(s,d):o[s]=d}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ub(o,e){if(e){if(tb[o]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(p(137,o));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(p(60));if(typeof e.dangerouslySetInnerHTML!="object"||!("__html"in e.dangerouslySetInnerHTML))throw Error(p(61))}if(e.style!=null&&typeof e.style!="object")throw Error(p(62))}}function vb(o,e){if(o.indexOf("-")===-1)return typeof e.is=="string";switch(o){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wb=null;function xb(o){return o=o.target||o.srcElement||window,o.correspondingUseElement&&(o=o.correspondingUseElement),o.nodeType===3?o.parentNode:o}var yb=null,zb=null,Ab=null;function Bb(o){if(o=Cb(o)){if(typeof yb!="function")throw Error(p(280));var e=o.stateNode;e&&(e=Db(e),yb(o.stateNode,o.type,e))}}function Eb(o){zb?Ab?Ab.push(o):Ab=[o]:zb=o}function Fb(){if(zb){var o=zb,e=Ab;if(Ab=zb=null,Bb(o),e)for(o=0;o<e.length;o++)Bb(e[o])}}function Gb(o,e){return o(e)}function Hb(){}var Ib=!1;function Jb(o,e,s){if(Ib)return o(e,s);Ib=!0;try{return Gb(o,e,s)}finally{Ib=!1,(zb!==null||Ab!==null)&&(Hb(),Fb())}}function Kb(o,e){var s=o.stateNode;if(s===null)return null;var a=Db(s);if(a===null)return null;s=a[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(o=o.type,a=!(o==="button"||o==="input"||o==="select"||o==="textarea")),o=!a;break e;default:o=!1}if(o)return null;if(s&&typeof s!="function")throw Error(p(231,e,typeof s));return s}var Lb=!1;if(ia$1)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0}}),window.addEventListener("test",Mb,Mb),window.removeEventListener("test",Mb,Mb)}catch{Lb=!1}function Nb(o,e,s,a,d,h,b,et,st){var $=Array.prototype.slice.call(arguments,3);try{e.apply(s,$)}catch(it){this.onError(it)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(o){Ob=!0,Pb=o}};function Tb(o,e,s,a,d,h,b,et,st){Ob=!1,Pb=null,Nb.apply(Sb,arguments)}function Ub(o,e,s,a,d,h,b,et,st){if(Tb.apply(this,arguments),Ob){if(Ob){var $=Pb;Ob=!1,Pb=null}else throw Error(p(198));Qb||(Qb=!0,Rb=$)}}function Vb(o){var e=o,s=o;if(o.alternate)for(;e.return;)e=e.return;else{o=e;do e=o,e.flags&4098&&(s=e.return),o=e.return;while(o)}return e.tag===3?s:null}function Wb(o){if(o.tag===13){var e=o.memoizedState;if(e===null&&(o=o.alternate,o!==null&&(e=o.memoizedState)),e!==null)return e.dehydrated}return null}function Xb(o){if(Vb(o)!==o)throw Error(p(188))}function Yb(o){var e=o.alternate;if(!e){if(e=Vb(o),e===null)throw Error(p(188));return e!==o?null:o}for(var s=o,a=e;;){var d=s.return;if(d===null)break;var h=d.alternate;if(h===null){if(a=d.return,a!==null){s=a;continue}break}if(d.child===h.child){for(h=d.child;h;){if(h===s)return Xb(d),o;if(h===a)return Xb(d),e;h=h.sibling}throw Error(p(188))}if(s.return!==a.return)s=d,a=h;else{for(var b=!1,et=d.child;et;){if(et===s){b=!0,s=d,a=h;break}if(et===a){b=!0,a=d,s=h;break}et=et.sibling}if(!b){for(et=h.child;et;){if(et===s){b=!0,s=h,a=d;break}if(et===a){b=!0,a=h,s=d;break}et=et.sibling}if(!b)throw Error(p(189))}}if(s.alternate!==a)throw Error(p(190))}if(s.tag!==3)throw Error(p(188));return s.stateNode.current===s?o:e}function Zb(o){return o=Yb(o),o!==null?$b(o):null}function $b(o){if(o.tag===5||o.tag===6)return o;for(o=o.child;o!==null;){var e=$b(o);if(e!==null)return e;o=o.sibling}return null}var ac$1=ca$1.unstable_scheduleCallback,bc$1=ca$1.unstable_cancelCallback,cc$1=ca$1.unstable_shouldYield,dc$1=ca$1.unstable_requestPaint,B=ca$1.unstable_now,ec=ca$1.unstable_getCurrentPriorityLevel,fc$1=ca$1.unstable_ImmediatePriority,gc$1=ca$1.unstable_UserBlockingPriority,hc=ca$1.unstable_NormalPriority,ic$1=ca$1.unstable_LowPriority,jc$1=ca$1.unstable_IdlePriority,kc$1=null,lc$1=null;function mc$1(o){if(lc$1&&typeof lc$1.onCommitFiberRoot=="function")try{lc$1.onCommitFiberRoot(kc$1,o,void 0,(o.current.flags&128)===128)}catch{}}var oc$1=Math.clz32?Math.clz32:nc$1,pc$1=Math.log,qc$1=Math.LN2;function nc$1(o){return o>>>=0,o===0?32:31-(pc$1(o)/qc$1|0)|0}var rc=64,sc$1=4194304;function tc(o){switch(o&-o){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return o&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return o&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return o}}function uc$1(o,e){var s=o.pendingLanes;if(s===0)return 0;var a=0,d=o.suspendedLanes,h=o.pingedLanes,b=s&268435455;if(b!==0){var et=b&~d;et!==0?a=tc(et):(h&=b,h!==0&&(a=tc(h)))}else b=s&~d,b!==0?a=tc(b):h!==0&&(a=tc(h));if(a===0)return 0;if(e!==0&&e!==a&&!(e&d)&&(d=a&-a,h=e&-e,d>=h||d===16&&(h&4194240)!==0))return e;if(a&4&&(a|=s&16),e=o.entangledLanes,e!==0)for(o=o.entanglements,e&=a;0<e;)s=31-oc$1(e),d=1<<s,a|=o[s],e&=~d;return a}function vc$1(o,e){switch(o){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function wc$1(o,e){for(var s=o.suspendedLanes,a=o.pingedLanes,d=o.expirationTimes,h=o.pendingLanes;0<h;){var b=31-oc$1(h),et=1<<b,st=d[b];st===-1?(!(et&s)||et&a)&&(d[b]=vc$1(et,e)):st<=e&&(o.expiredLanes|=et),h&=~et}}function xc$1(o){return o=o.pendingLanes&-1073741825,o!==0?o:o&1073741824?1073741824:0}function yc$1(){var o=rc;return rc<<=1,!(rc&4194240)&&(rc=64),o}function zc$1(o){for(var e=[],s=0;31>s;s++)e.push(o);return e}function Ac$1(o,e,s){o.pendingLanes|=e,e!==536870912&&(o.suspendedLanes=0,o.pingedLanes=0),o=o.eventTimes,e=31-oc$1(e),o[e]=s}function Bc$1(o,e){var s=o.pendingLanes&~e;o.pendingLanes=e,o.suspendedLanes=0,o.pingedLanes=0,o.expiredLanes&=e,o.mutableReadLanes&=e,o.entangledLanes&=e,e=o.entanglements;var a=o.eventTimes;for(o=o.expirationTimes;0<s;){var d=31-oc$1(s),h=1<<d;e[d]=0,a[d]=-1,o[d]=-1,s&=~h}}function Cc$1(o,e){var s=o.entangledLanes|=e;for(o=o.entanglements;s;){var a=31-oc$1(s),d=1<<a;d&e|o[a]&e&&(o[a]|=e),s&=~d}}var C=0;function Dc$1(o){return o&=-o,1<o?4<o?o&268435455?16:536870912:4:1}var Ec$1,Fc$1,Gc$1,Hc$1,Ic$1,Jc$1=!1,Kc$1=[],Lc$1=null,Mc$1=null,Nc$1=null,Oc$1=new Map,Pc$1=new Map,Qc$1=[],Rc$1="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Sc$1(o,e){switch(o){case"focusin":case"focusout":Lc$1=null;break;case"dragenter":case"dragleave":Mc$1=null;break;case"mouseover":case"mouseout":Nc$1=null;break;case"pointerover":case"pointerout":Oc$1.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":Pc$1.delete(e.pointerId)}}function Tc$1(o,e,s,a,d,h){return o===null||o.nativeEvent!==h?(o={blockedOn:e,domEventName:s,eventSystemFlags:a,nativeEvent:h,targetContainers:[d]},e!==null&&(e=Cb(e),e!==null&&Fc$1(e)),o):(o.eventSystemFlags|=a,e=o.targetContainers,d!==null&&e.indexOf(d)===-1&&e.push(d),o)}function Uc$1(o,e,s,a,d){switch(e){case"focusin":return Lc$1=Tc$1(Lc$1,o,e,s,a,d),!0;case"dragenter":return Mc$1=Tc$1(Mc$1,o,e,s,a,d),!0;case"mouseover":return Nc$1=Tc$1(Nc$1,o,e,s,a,d),!0;case"pointerover":var h=d.pointerId;return Oc$1.set(h,Tc$1(Oc$1.get(h)||null,o,e,s,a,d)),!0;case"gotpointercapture":return h=d.pointerId,Pc$1.set(h,Tc$1(Pc$1.get(h)||null,o,e,s,a,d)),!0}return!1}function Vc$1(o){var e=Wc$1(o.target);if(e!==null){var s=Vb(e);if(s!==null){if(e=s.tag,e===13){if(e=Wb(s),e!==null){o.blockedOn=e,Ic$1(o.priority,function(){Gc$1(s)});return}}else if(e===3&&s.stateNode.current.memoizedState.isDehydrated){o.blockedOn=s.tag===3?s.stateNode.containerInfo:null;return}}}o.blockedOn=null}function Xc$1(o){if(o.blockedOn!==null)return!1;for(var e=o.targetContainers;0<e.length;){var s=Yc$1(o.domEventName,o.eventSystemFlags,e[0],o.nativeEvent);if(s===null){s=o.nativeEvent;var a=new s.constructor(s.type,s);wb=a,s.target.dispatchEvent(a),wb=null}else return e=Cb(s),e!==null&&Fc$1(e),o.blockedOn=s,!1;e.shift()}return!0}function Zc$1(o,e,s){Xc$1(o)&&s.delete(e)}function $c$1(){Jc$1=!1,Lc$1!==null&&Xc$1(Lc$1)&&(Lc$1=null),Mc$1!==null&&Xc$1(Mc$1)&&(Mc$1=null),Nc$1!==null&&Xc$1(Nc$1)&&(Nc$1=null),Oc$1.forEach(Zc$1),Pc$1.forEach(Zc$1)}function ad$1(o,e){o.blockedOn===e&&(o.blockedOn=null,Jc$1||(Jc$1=!0,ca$1.unstable_scheduleCallback(ca$1.unstable_NormalPriority,$c$1)))}function bd$1(o){function e(d){return ad$1(d,o)}if(0<Kc$1.length){ad$1(Kc$1[0],o);for(var s=1;s<Kc$1.length;s++){var a=Kc$1[s];a.blockedOn===o&&(a.blockedOn=null)}}for(Lc$1!==null&&ad$1(Lc$1,o),Mc$1!==null&&ad$1(Mc$1,o),Nc$1!==null&&ad$1(Nc$1,o),Oc$1.forEach(e),Pc$1.forEach(e),s=0;s<Qc$1.length;s++)a=Qc$1[s],a.blockedOn===o&&(a.blockedOn=null);for(;0<Qc$1.length&&(s=Qc$1[0],s.blockedOn===null);)Vc$1(s),s.blockedOn===null&&Qc$1.shift()}var cd$1=ua$1.ReactCurrentBatchConfig,dd$1=!0;function ed$1(o,e,s,a){var d=C,h=cd$1.transition;cd$1.transition=null;try{C=1,fd$1(o,e,s,a)}finally{C=d,cd$1.transition=h}}function gd$1(o,e,s,a){var d=C,h=cd$1.transition;cd$1.transition=null;try{C=4,fd$1(o,e,s,a)}finally{C=d,cd$1.transition=h}}function fd$1(o,e,s,a){if(dd$1){var d=Yc$1(o,e,s,a);if(d===null)hd$1(o,e,a,id$1,s),Sc$1(o,a);else if(Uc$1(d,o,e,s,a))a.stopPropagation();else if(Sc$1(o,a),e&4&&-1<Rc$1.indexOf(o)){for(;d!==null;){var h=Cb(d);if(h!==null&&Ec$1(h),h=Yc$1(o,e,s,a),h===null&&hd$1(o,e,a,id$1,s),h===d)break;d=h}d!==null&&a.stopPropagation()}else hd$1(o,e,a,null,s)}}var id$1=null;function Yc$1(o,e,s,a){if(id$1=null,o=xb(a),o=Wc$1(o),o!==null)if(e=Vb(o),e===null)o=null;else if(s=e.tag,s===13){if(o=Wb(e),o!==null)return o;o=null}else if(s===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;o=null}else e!==o&&(o=null);return id$1=o,null}function jd$1(o){switch(o){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(ec()){case fc$1:return 1;case gc$1:return 4;case hc:case ic$1:return 16;case jc$1:return 536870912;default:return 16}default:return 16}}var kd$1=null,ld$1=null,md$1=null;function nd$1(){if(md$1)return md$1;var o,e=ld$1,s=e.length,a,d="value"in kd$1?kd$1.value:kd$1.textContent,h=d.length;for(o=0;o<s&&e[o]===d[o];o++);var b=s-o;for(a=1;a<=b&&e[s-a]===d[h-a];a++);return md$1=d.slice(o,1<a?1-a:void 0)}function od$1(o){var e=o.keyCode;return"charCode"in o?(o=o.charCode,o===0&&e===13&&(o=13)):o=e,o===10&&(o=13),32<=o||o===13?o:0}function pd$1(){return!0}function qd$1(){return!1}function rd$1(o){function e(s,a,d,h,b){this._reactName=s,this._targetInst=d,this.type=a,this.nativeEvent=h,this.target=b,this.currentTarget=null;for(var et in o)o.hasOwnProperty(et)&&(s=o[et],this[et]=s?s(h):h[et]);return this.isDefaultPrevented=(h.defaultPrevented!=null?h.defaultPrevented:h.returnValue===!1)?pd$1:qd$1,this.isPropagationStopped=qd$1,this}return A(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var s=this.nativeEvent;s&&(s.preventDefault?s.preventDefault():typeof s.returnValue!="unknown"&&(s.returnValue=!1),this.isDefaultPrevented=pd$1)},stopPropagation:function(){var s=this.nativeEvent;s&&(s.stopPropagation?s.stopPropagation():typeof s.cancelBubble!="unknown"&&(s.cancelBubble=!0),this.isPropagationStopped=pd$1)},persist:function(){},isPersistent:pd$1}),e}var sd$1={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(o){return o.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td$1=rd$1(sd$1),ud$1=A({},sd$1,{view:0,detail:0}),vd$1=rd$1(ud$1),wd$1,xd$1,yd$1,Ad$1=A({},ud$1,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd$1,button:0,buttons:0,relatedTarget:function(o){return o.relatedTarget===void 0?o.fromElement===o.srcElement?o.toElement:o.fromElement:o.relatedTarget},movementX:function(o){return"movementX"in o?o.movementX:(o!==yd$1&&(yd$1&&o.type==="mousemove"?(wd$1=o.screenX-yd$1.screenX,xd$1=o.screenY-yd$1.screenY):xd$1=wd$1=0,yd$1=o),wd$1)},movementY:function(o){return"movementY"in o?o.movementY:xd$1}}),Bd$1=rd$1(Ad$1),Cd$1=A({},Ad$1,{dataTransfer:0}),Dd$1=rd$1(Cd$1),Ed$1=A({},ud$1,{relatedTarget:0}),Fd$1=rd$1(Ed$1),Gd$1=A({},sd$1,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd$1=rd$1(Gd$1),Id$1=A({},sd$1,{clipboardData:function(o){return"clipboardData"in o?o.clipboardData:window.clipboardData}}),Jd=rd$1(Id$1),Kd$1=A({},sd$1,{data:0}),Ld$1=rd$1(Kd$1),Md$1={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd$1={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od$1={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd$1(o){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(o):(o=Od$1[o])?!!e[o]:!1}function zd$1(){return Pd$1}var Qd=A({},ud$1,{key:function(o){if(o.key){var e=Md$1[o.key]||o.key;if(e!=="Unidentified")return e}return o.type==="keypress"?(o=od$1(o),o===13?"Enter":String.fromCharCode(o)):o.type==="keydown"||o.type==="keyup"?Nd$1[o.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd$1,charCode:function(o){return o.type==="keypress"?od$1(o):0},keyCode:function(o){return o.type==="keydown"||o.type==="keyup"?o.keyCode:0},which:function(o){return o.type==="keypress"?od$1(o):o.type==="keydown"||o.type==="keyup"?o.keyCode:0}}),Rd$1=rd$1(Qd),Sd$1=A({},Ad$1,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td$1=rd$1(Sd$1),Ud$1=A({},ud$1,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd$1}),Vd$1=rd$1(Ud$1),Wd$1=A({},sd$1,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd$1=rd$1(Wd$1),Yd$1=A({},Ad$1,{deltaX:function(o){return"deltaX"in o?o.deltaX:"wheelDeltaX"in o?-o.wheelDeltaX:0},deltaY:function(o){return"deltaY"in o?o.deltaY:"wheelDeltaY"in o?-o.wheelDeltaY:"wheelDelta"in o?-o.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd$1(Yd$1),$d$1=[9,13,27,32],ae=ia$1&&"CompositionEvent"in window,be=null;ia$1&&"documentMode"in document&&(be=document.documentMode);var ce=ia$1&&"TextEvent"in window&&!be,de=ia$1&&(!ae||be&&8<be&&11>=be),ee=" ",fe$1=!1;function ge(o,e){switch(o){case"keyup":return $d$1.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function he(o){return o=o.detail,typeof o=="object"&&"data"in o?o.data:null}var ie=!1;function je(o,e){switch(o){case"compositionend":return he(e);case"keypress":return e.which!==32?null:(fe$1=!0,ee);case"textInput":return o=e.data,o===ee&&fe$1?null:o;default:return null}}function ke$1(o,e){if(ie)return o==="compositionend"||!ae&&ge(o,e)?(o=nd$1(),md$1=ld$1=kd$1=null,ie=!1,o):null;switch(o){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return de&&e.locale!=="ko"?null:e.data;default:return null}}var le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(o){var e=o&&o.nodeName&&o.nodeName.toLowerCase();return e==="input"?!!le[o.type]:e==="textarea"}function ne(o,e,s,a){Eb(a),e=oe(e,"onChange"),0<e.length&&(s=new td$1("onChange","change",null,s,a),o.push({event:s,listeners:e}))}var pe=null,qe$1=null;function re(o){se(o,0)}function te(o){var e=ue(o);if(Wa(e))return o}function ve(o,e){if(o==="change")return e}var we$1=!1;if(ia$1){var xe$1;if(ia$1){var ye$1="oninput"in document;if(!ye$1){var ze=document.createElement("div");ze.setAttribute("oninput","return;"),ye$1=typeof ze.oninput=="function"}xe$1=ye$1}else xe$1=!1;we$1=xe$1&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be$1),qe$1=pe=null)}function Be$1(o){if(o.propertyName==="value"&&te(qe$1)){var e=[];ne(e,qe$1,o,xb(o)),Jb(re,e)}}function Ce(o,e,s){o==="focusin"?(Ae(),pe=e,qe$1=s,pe.attachEvent("onpropertychange",Be$1)):o==="focusout"&&Ae()}function De(o){if(o==="selectionchange"||o==="keyup"||o==="keydown")return te(qe$1)}function Ee(o,e){if(o==="click")return te(e)}function Fe$1(o,e){if(o==="input"||o==="change")return te(e)}function Ge(o,e){return o===e&&(o!==0||1/o===1/e)||o!==o&&e!==e}var He=typeof Object.is=="function"?Object.is:Ge;function Ie(o,e){if(He(o,e))return!0;if(typeof o!="object"||o===null||typeof e!="object"||e===null)return!1;var s=Object.keys(o),a=Object.keys(e);if(s.length!==a.length)return!1;for(a=0;a<s.length;a++){var d=s[a];if(!ja.call(e,d)||!He(o[d],e[d]))return!1}return!0}function Je(o){for(;o&&o.firstChild;)o=o.firstChild;return o}function Ke(o,e){var s=Je(o);o=0;for(var a;s;){if(s.nodeType===3){if(a=o+s.textContent.length,o<=e&&a>=e)return{node:s,offset:e-o};o=a}e:{for(;s;){if(s.nextSibling){s=s.nextSibling;break e}s=s.parentNode}s=void 0}s=Je(s)}}function Le(o,e){return o&&e?o===e?!0:o&&o.nodeType===3?!1:e&&e.nodeType===3?Le(o,e.parentNode):"contains"in o?o.contains(e):o.compareDocumentPosition?!!(o.compareDocumentPosition(e)&16):!1:!1}function Me(){for(var o=window,e=Xa();e instanceof o.HTMLIFrameElement;){try{var s=typeof e.contentWindow.location.href=="string"}catch{s=!1}if(s)o=e.contentWindow;else break;e=Xa(o.document)}return e}function Ne$1(o){var e=o&&o.nodeName&&o.nodeName.toLowerCase();return e&&(e==="input"&&(o.type==="text"||o.type==="search"||o.type==="tel"||o.type==="url"||o.type==="password")||e==="textarea"||o.contentEditable==="true")}function Oe(o){var e=Me(),s=o.focusedElem,a=o.selectionRange;if(e!==s&&s&&s.ownerDocument&&Le(s.ownerDocument.documentElement,s)){if(a!==null&&Ne$1(s)){if(e=a.start,o=a.end,o===void 0&&(o=e),"selectionStart"in s)s.selectionStart=e,s.selectionEnd=Math.min(o,s.value.length);else if(o=(e=s.ownerDocument||document)&&e.defaultView||window,o.getSelection){o=o.getSelection();var d=s.textContent.length,h=Math.min(a.start,d);a=a.end===void 0?h:Math.min(a.end,d),!o.extend&&h>a&&(d=a,a=h,h=d),d=Ke(s,h);var b=Ke(s,a);d&&b&&(o.rangeCount!==1||o.anchorNode!==d.node||o.anchorOffset!==d.offset||o.focusNode!==b.node||o.focusOffset!==b.offset)&&(e=e.createRange(),e.setStart(d.node,d.offset),o.removeAllRanges(),h>a?(o.addRange(e),o.extend(b.node,b.offset)):(e.setEnd(b.node,b.offset),o.addRange(e)))}}for(e=[],o=s;o=o.parentNode;)o.nodeType===1&&e.push({element:o,left:o.scrollLeft,top:o.scrollTop});for(typeof s.focus=="function"&&s.focus(),s=0;s<e.length;s++)o=e[s],o.element.scrollLeft=o.left,o.element.scrollTop=o.top}}var Pe$1=ia$1&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;function Ue$1(o,e,s){var a=s.window===s?s.document:s.nodeType===9?s:s.ownerDocument;Te||Qe==null||Qe!==Xa(a)||(a=Qe,"selectionStart"in a&&Ne$1(a)?a={start:a.selectionStart,end:a.selectionEnd}:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection(),a={anchorNode:a.anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset}),Se&&Ie(Se,a)||(Se=a,a=oe(Re,"onSelect"),0<a.length&&(e=new td$1("onSelect","select",null,e,s),o.push({event:e,listeners:a}),e.target=Qe)))}function Ve(o,e){var s={};return s[o.toLowerCase()]=e.toLowerCase(),s["Webkit"+o]="webkit"+e,s["Moz"+o]="moz"+e,s}var We$1={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye={};ia$1&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We$1.animationend.animation,delete We$1.animationiteration.animation,delete We$1.animationstart.animation),"TransitionEvent"in window||delete We$1.transitionend.transition);function Ze$1(o){if(Xe[o])return Xe[o];if(!We$1[o])return o;var e=We$1[o],s;for(s in e)if(e.hasOwnProperty(s)&&s in Ye)return Xe[o]=e[s];return o}var $e=Ze$1("animationend"),af$1=Ze$1("animationiteration"),bf=Ze$1("animationstart"),cf=Ze$1("transitionend"),df=new Map,ef$1="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ff$1(o,e){df.set(o,e),fa$1(e,[o])}for(var gf=0;gf<ef$1.length;gf++){var hf$1=ef$1[gf],jf=hf$1.toLowerCase(),kf=hf$1[0].toUpperCase()+hf$1.slice(1);ff$1(jf,"on"+kf)}ff$1($e,"onAnimationEnd");ff$1(af$1,"onAnimationIteration");ff$1(bf,"onAnimationStart");ff$1("dblclick","onDoubleClick");ff$1("focusin","onFocus");ff$1("focusout","onBlur");ff$1(cf,"onTransitionEnd");ha$1("onMouseEnter",["mouseout","mouseover"]);ha$1("onMouseLeave",["mouseout","mouseover"]);ha$1("onPointerEnter",["pointerout","pointerover"]);ha$1("onPointerLeave",["pointerout","pointerover"]);fa$1("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa$1("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa$1("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa$1("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa$1("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));fa$1("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf$1="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf$1=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf$1));function nf$1(o,e,s){var a=o.type||"unknown-event";o.currentTarget=s,Ub(a,e,void 0,o),o.currentTarget=null}function se(o,e){e=(e&4)!==0;for(var s=0;s<o.length;s++){var a=o[s],d=a.event;a=a.listeners;e:{var h=void 0;if(e)for(var b=a.length-1;0<=b;b--){var et=a[b],st=et.instance,$=et.currentTarget;if(et=et.listener,st!==h&&d.isPropagationStopped())break e;nf$1(d,et,$),h=st}else for(b=0;b<a.length;b++){if(et=a[b],st=et.instance,$=et.currentTarget,et=et.listener,st!==h&&d.isPropagationStopped())break e;nf$1(d,et,$),h=st}}}if(Qb)throw o=Rb,Qb=!1,Rb=null,o}function D(o,e){var s=e[of$1];s===void 0&&(s=e[of$1]=new Set);var a=o+"__bubble";s.has(a)||(pf$1(e,o,2,!1),s.add(a))}function qf(o,e,s){var a=0;e&&(a|=4),pf$1(s,o,a,e)}var rf$1="_reactListening"+Math.random().toString(36).slice(2);function sf$1(o){if(!o[rf$1]){o[rf$1]=!0,da$1.forEach(function(s){s!=="selectionchange"&&(mf$1.has(s)||qf(s,!1,o),qf(s,!0,o))});var e=o.nodeType===9?o:o.ownerDocument;e===null||e[rf$1]||(e[rf$1]=!0,qf("selectionchange",!1,e))}}function pf$1(o,e,s,a){switch(jd$1(e)){case 1:var d=ed$1;break;case 4:d=gd$1;break;default:d=fd$1}s=d.bind(null,e,s,o),d=void 0,!Lb||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(d=!0),a?d!==void 0?o.addEventListener(e,s,{capture:!0,passive:d}):o.addEventListener(e,s,!0):d!==void 0?o.addEventListener(e,s,{passive:d}):o.addEventListener(e,s,!1)}function hd$1(o,e,s,a,d){var h=a;if(!(e&1)&&!(e&2)&&a!==null)e:for(;;){if(a===null)return;var b=a.tag;if(b===3||b===4){var et=a.stateNode.containerInfo;if(et===d||et.nodeType===8&&et.parentNode===d)break;if(b===4)for(b=a.return;b!==null;){var st=b.tag;if((st===3||st===4)&&(st=b.stateNode.containerInfo,st===d||st.nodeType===8&&st.parentNode===d))return;b=b.return}for(;et!==null;){if(b=Wc$1(et),b===null)return;if(st=b.tag,st===5||st===6){a=h=b;continue e}et=et.parentNode}}a=a.return}Jb(function(){var $=h,it=xb(s),g=[];e:{var c=df.get(o);if(c!==void 0){var _=td$1,ot=o;switch(o){case"keypress":if(od$1(s)===0)break e;case"keydown":case"keyup":_=Rd$1;break;case"focusin":ot="focus",_=Fd$1;break;case"focusout":ot="blur",_=Fd$1;break;case"beforeblur":case"afterblur":_=Fd$1;break;case"click":if(s.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":_=Bd$1;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":_=Dd$1;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":_=Vd$1;break;case $e:case af$1:case bf:_=Hd$1;break;case cf:_=Xd$1;break;case"scroll":_=vd$1;break;case"wheel":_=Zd;break;case"copy":case"cut":case"paste":_=Jd;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":_=Td$1}var ct=(e&4)!==0,dt=!ct&&o==="scroll",pt=ct?c!==null?c+"Capture":null:c;ct=[];for(var ft=$,ht;ft!==null;){ht=ft;var bt=ht.stateNode;if(ht.tag===5&&bt!==null&&(ht=bt,pt!==null&&(bt=Kb(ft,pt),bt!=null&&ct.push(tf$1(ft,bt,ht)))),dt)break;ft=ft.return}0<ct.length&&(c=new _(c,ot,null,s,it),g.push({event:c,listeners:ct}))}}if(!(e&7)){e:{if(c=o==="mouseover"||o==="pointerover",_=o==="mouseout"||o==="pointerout",c&&s!==wb&&(ot=s.relatedTarget||s.fromElement)&&(Wc$1(ot)||ot[uf$1]))break e;if((_||c)&&(c=it.window===it?it:(c=it.ownerDocument)?c.defaultView||c.parentWindow:window,_?(ot=s.relatedTarget||s.toElement,_=$,ot=ot?Wc$1(ot):null,ot!==null&&(dt=Vb(ot),ot!==dt||ot.tag!==5&&ot.tag!==6)&&(ot=null)):(_=null,ot=$),_!==ot)){if(ct=Bd$1,bt="onMouseLeave",pt="onMouseEnter",ft="mouse",(o==="pointerout"||o==="pointerover")&&(ct=Td$1,bt="onPointerLeave",pt="onPointerEnter",ft="pointer"),dt=_==null?c:ue(_),ht=ot==null?c:ue(ot),c=new ct(bt,ft+"leave",_,s,it),c.target=dt,c.relatedTarget=ht,bt=null,Wc$1(it)===$&&(ct=new ct(pt,ft+"enter",ot,s,it),ct.target=ht,ct.relatedTarget=dt,bt=ct),dt=bt,_&&ot)t:{for(ct=_,pt=ot,ft=0,ht=ct;ht;ht=vf(ht))ft++;for(ht=0,bt=pt;bt;bt=vf(bt))ht++;for(;0<ft-ht;)ct=vf(ct),ft--;for(;0<ht-ft;)pt=vf(pt),ht--;for(;ft--;){if(ct===pt||pt!==null&&ct===pt.alternate)break t;ct=vf(ct),pt=vf(pt)}ct=null}else ct=null;_!==null&&wf(g,c,_,ct,!1),ot!==null&&dt!==null&&wf(g,dt,ot,ct,!0)}}e:{if(c=$?ue($):window,_=c.nodeName&&c.nodeName.toLowerCase(),_==="select"||_==="input"&&c.type==="file")var mt=ve;else if(me(c))if(we$1)mt=Fe$1;else{mt=De;var $t=Ce}else(_=c.nodeName)&&_.toLowerCase()==="input"&&(c.type==="checkbox"||c.type==="radio")&&(mt=Ee);if(mt&&(mt=mt(o,$))){ne(g,mt,s,it);break e}$t&&$t(o,c,$),o==="focusout"&&($t=c._wrapperState)&&$t.controlled&&c.type==="number"&&cb(c,"number",c.value)}switch($t=$?ue($):window,o){case"focusin":(me($t)||$t.contentEditable==="true")&&(Qe=$t,Re=$,Se=null);break;case"focusout":Se=Re=Qe=null;break;case"mousedown":Te=!0;break;case"contextmenu":case"mouseup":case"dragend":Te=!1,Ue$1(g,s,it);break;case"selectionchange":if(Pe$1)break;case"keydown":case"keyup":Ue$1(g,s,it)}var Tt;if(ae)e:{switch(o){case"compositionstart":var Nt="onCompositionStart";break e;case"compositionend":Nt="onCompositionEnd";break e;case"compositionupdate":Nt="onCompositionUpdate";break e}Nt=void 0}else ie?ge(o,s)&&(Nt="onCompositionEnd"):o==="keydown"&&s.keyCode===229&&(Nt="onCompositionStart");Nt&&(de&&s.locale!=="ko"&&(ie||Nt!=="onCompositionStart"?Nt==="onCompositionEnd"&&ie&&(Tt=nd$1()):(kd$1=it,ld$1="value"in kd$1?kd$1.value:kd$1.textContent,ie=!0)),$t=oe($,Nt),0<$t.length&&(Nt=new Ld$1(Nt,o,null,s,it),g.push({event:Nt,listeners:$t}),Tt?Nt.data=Tt:(Tt=he(s),Tt!==null&&(Nt.data=Tt)))),(Tt=ce?je(o,s):ke$1(o,s))&&($=oe($,"onBeforeInput"),0<$.length&&(it=new Ld$1("onBeforeInput","beforeinput",null,s,it),g.push({event:it,listeners:$}),it.data=Tt))}se(g,e)})}function tf$1(o,e,s){return{instance:o,listener:e,currentTarget:s}}function oe(o,e){for(var s=e+"Capture",a=[];o!==null;){var d=o,h=d.stateNode;d.tag===5&&h!==null&&(d=h,h=Kb(o,s),h!=null&&a.unshift(tf$1(o,h,d)),h=Kb(o,e),h!=null&&a.push(tf$1(o,h,d))),o=o.return}return a}function vf(o){if(o===null)return null;do o=o.return;while(o&&o.tag!==5);return o||null}function wf(o,e,s,a,d){for(var h=e._reactName,b=[];s!==null&&s!==a;){var et=s,st=et.alternate,$=et.stateNode;if(st!==null&&st===a)break;et.tag===5&&$!==null&&(et=$,d?(st=Kb(s,h),st!=null&&b.unshift(tf$1(s,st,et))):d||(st=Kb(s,h),st!=null&&b.push(tf$1(s,st,et)))),s=s.return}b.length!==0&&o.push({event:e,listeners:b})}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(o){return(typeof o=="string"?o:""+o).replace(xf,`
`).replace(yf,"")}function Af(o,e,s){if(e=zf(e),zf(o)!==e&&s)throw Error(p(425))}function Bf(){}var Cf=null,Df=null;function Ef(o,e){return o==="textarea"||o==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var Ff=typeof setTimeout=="function"?setTimeout:void 0,Gf=typeof clearTimeout=="function"?clearTimeout:void 0,Hf=typeof Promise=="function"?Promise:void 0,Jf=typeof queueMicrotask=="function"?queueMicrotask:typeof Hf<"u"?function(o){return Hf.resolve(null).then(o).catch(If$1)}:Ff;function If$1(o){setTimeout(function(){throw o})}function Kf(o,e){var s=e,a=0;do{var d=s.nextSibling;if(o.removeChild(s),d&&d.nodeType===8)if(s=d.data,s==="/$"){if(a===0){o.removeChild(d),bd$1(e);return}a--}else s!=="$"&&s!=="$?"&&s!=="$!"||a++;s=d}while(s);bd$1(e)}function Lf(o){for(;o!=null;o=o.nextSibling){var e=o.nodeType;if(e===1||e===3)break;if(e===8){if(e=o.data,e==="$"||e==="$!"||e==="$?")break;if(e==="/$")return null}}return o}function Mf(o){o=o.previousSibling;for(var e=0;o;){if(o.nodeType===8){var s=o.data;if(s==="$"||s==="$!"||s==="$?"){if(e===0)return o;e--}else s==="/$"&&e++}o=o.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf$1="__reactContainer$"+Nf,of$1="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;function Wc$1(o){var e=o[Of];if(e)return e;for(var s=o.parentNode;s;){if(e=s[uf$1]||s[Of]){if(s=e.alternate,e.child!==null||s!==null&&s.child!==null)for(o=Mf(o);o!==null;){if(s=o[Of])return s;o=Mf(o)}return e}o=s,s=o.parentNode}return null}function Cb(o){return o=o[Of]||o[uf$1],!o||o.tag!==5&&o.tag!==6&&o.tag!==13&&o.tag!==3?null:o}function ue(o){if(o.tag===5||o.tag===6)return o.stateNode;throw Error(p(33))}function Db(o){return o[Pf]||null}var Sf=[],Tf=-1;function Uf(o){return{current:o}}function E(o){0>Tf||(o.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(o,e){Tf++,Sf[Tf]=o.current,o.current=e}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(o,e){var s=o.type.contextTypes;if(!s)return Vf;var a=o.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===e)return a.__reactInternalMemoizedMaskedChildContext;var d={},h;for(h in s)d[h]=e[h];return a&&(o=o.stateNode,o.__reactInternalMemoizedUnmaskedChildContext=e,o.__reactInternalMemoizedMaskedChildContext=d),d}function Zf(o){return o=o.childContextTypes,o!=null}function $f(){E(Wf),E(H)}function ag(o,e,s){if(H.current!==Vf)throw Error(p(168));G(H,e),G(Wf,s)}function bg(o,e,s){var a=o.stateNode;if(e=e.childContextTypes,typeof a.getChildContext!="function")return s;a=a.getChildContext();for(var d in a)if(!(d in e))throw Error(p(108,Ra(o)||"Unknown",d));return A({},s,a)}function cg(o){return o=(o=o.stateNode)&&o.__reactInternalMemoizedMergedChildContext||Vf,Xf=H.current,G(H,o),G(Wf,Wf.current),!0}function dg(o,e,s){var a=o.stateNode;if(!a)throw Error(p(169));s?(o=bg(o,e,Xf),a.__reactInternalMemoizedMergedChildContext=o,E(Wf),E(H),G(H,o)):E(Wf),G(Wf,s)}var eg=null,fg=!1,gg=!1;function hg(o){eg===null?eg=[o]:eg.push(o)}function ig(o){fg=!0,hg(o)}function jg(){if(!gg&&eg!==null){gg=!0;var o=0,e=C;try{var s=eg;for(C=1;o<s.length;o++){var a=s[o];do a=a(!0);while(a!==null)}eg=null,fg=!1}catch(d){throw eg!==null&&(eg=eg.slice(o+1)),ac$1(fc$1,jg),d}finally{C=e,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(o,e){kg[lg++]=ng,kg[lg++]=mg,mg=o,ng=e}function ug(o,e,s){og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,qg=o;var a=rg;o=sg;var d=32-oc$1(a)-1;a&=~(1<<d),s+=1;var h=32-oc$1(e)+d;if(30<h){var b=d-d%5;h=(a&(1<<b)-1).toString(32),a>>=b,d-=b,rg=1<<32-oc$1(e)+d|s<<d|a,sg=h+o}else rg=1<<h|s<<d|a,sg=o}function vg(o){o.return!==null&&(tg(o,1),ug(o,1,0))}function wg(o){for(;o===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;o===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;function Ag(o,e){var s=Bg(5,null,null,0);s.elementType="DELETED",s.stateNode=e,s.return=o,e=o.deletions,e===null?(o.deletions=[s],o.flags|=16):e.push(s)}function Cg(o,e){switch(o.tag){case 5:var s=o.type;return e=e.nodeType!==1||s.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(o.stateNode=e,xg=o,yg=Lf(e.firstChild),!0):!1;case 6:return e=o.pendingProps===""||e.nodeType!==3?null:e,e!==null?(o.stateNode=e,xg=o,yg=null,!0):!1;case 13:return e=e.nodeType!==8?null:e,e!==null?(s=qg!==null?{id:rg,overflow:sg}:null,o.memoizedState={dehydrated:e,treeContext:s,retryLane:1073741824},s=Bg(18,null,null,0),s.stateNode=e,s.return=o,o.child=s,xg=o,yg=null,!0):!1;default:return!1}}function Dg(o){return(o.mode&1)!==0&&(o.flags&128)===0}function Eg(o){if(I){var e=yg;if(e){var s=e;if(!Cg(o,e)){if(Dg(o))throw Error(p(418));e=Lf(s.nextSibling);var a=xg;e&&Cg(o,e)?Ag(a,s):(o.flags=o.flags&-4097|2,I=!1,xg=o)}}else{if(Dg(o))throw Error(p(418));o.flags=o.flags&-4097|2,I=!1,xg=o}}}function Fg(o){for(o=o.return;o!==null&&o.tag!==5&&o.tag!==3&&o.tag!==13;)o=o.return;xg=o}function Gg(o){if(o!==xg)return!1;if(!I)return Fg(o),I=!0,!1;var e;if((e=o.tag!==3)&&!(e=o.tag!==5)&&(e=o.type,e=e!=="head"&&e!=="body"&&!Ef(o.type,o.memoizedProps)),e&&(e=yg)){if(Dg(o))throw Hg(),Error(p(418));for(;e;)Ag(o,e),e=Lf(e.nextSibling)}if(Fg(o),o.tag===13){if(o=o.memoizedState,o=o!==null?o.dehydrated:null,!o)throw Error(p(317));e:{for(o=o.nextSibling,e=0;o;){if(o.nodeType===8){var s=o.data;if(s==="/$"){if(e===0){yg=Lf(o.nextSibling);break e}e--}else s!=="$"&&s!=="$!"&&s!=="$?"||e++}o=o.nextSibling}yg=null}}else yg=xg?Lf(o.stateNode.nextSibling):null;return!0}function Hg(){for(var o=yg;o;)o=Lf(o.nextSibling)}function Ig(){yg=xg=null,I=!1}function Jg(o){zg===null?zg=[o]:zg.push(o)}var Kg=ua$1.ReactCurrentBatchConfig;function Lg(o,e,s){if(o=s.ref,o!==null&&typeof o!="function"&&typeof o!="object"){if(s._owner){if(s=s._owner,s){if(s.tag!==1)throw Error(p(309));var a=s.stateNode}if(!a)throw Error(p(147,o));var d=a,h=""+o;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===h?e.ref:(e=function(b){var et=d.refs;b===null?delete et[h]:et[h]=b},e._stringRef=h,e)}if(typeof o!="string")throw Error(p(284));if(!s._owner)throw Error(p(290,o))}return o}function Mg(o,e){throw o=Object.prototype.toString.call(e),Error(p(31,o==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":o))}function Ng(o){var e=o._init;return e(o._payload)}function Og(o){function e(pt,ft){if(o){var ht=pt.deletions;ht===null?(pt.deletions=[ft],pt.flags|=16):ht.push(ft)}}function s(pt,ft){if(!o)return null;for(;ft!==null;)e(pt,ft),ft=ft.sibling;return null}function a(pt,ft){for(pt=new Map;ft!==null;)ft.key!==null?pt.set(ft.key,ft):pt.set(ft.index,ft),ft=ft.sibling;return pt}function d(pt,ft){return pt=Pg(pt,ft),pt.index=0,pt.sibling=null,pt}function h(pt,ft,ht){return pt.index=ht,o?(ht=pt.alternate,ht!==null?(ht=ht.index,ht<ft?(pt.flags|=2,ft):ht):(pt.flags|=2,ft)):(pt.flags|=1048576,ft)}function b(pt){return o&&pt.alternate===null&&(pt.flags|=2),pt}function et(pt,ft,ht,bt){return ft===null||ft.tag!==6?(ft=Qg(ht,pt.mode,bt),ft.return=pt,ft):(ft=d(ft,ht),ft.return=pt,ft)}function st(pt,ft,ht,bt){var mt=ht.type;return mt===ya$1?it(pt,ft,ht.props.children,bt,ht.key):ft!==null&&(ft.elementType===mt||typeof mt=="object"&&mt!==null&&mt.$$typeof===Ha&&Ng(mt)===ft.type)?(bt=d(ft,ht.props),bt.ref=Lg(pt,ft,ht),bt.return=pt,bt):(bt=Rg(ht.type,ht.key,ht.props,null,pt.mode,bt),bt.ref=Lg(pt,ft,ht),bt.return=pt,bt)}function $(pt,ft,ht,bt){return ft===null||ft.tag!==4||ft.stateNode.containerInfo!==ht.containerInfo||ft.stateNode.implementation!==ht.implementation?(ft=Sg(ht,pt.mode,bt),ft.return=pt,ft):(ft=d(ft,ht.children||[]),ft.return=pt,ft)}function it(pt,ft,ht,bt,mt){return ft===null||ft.tag!==7?(ft=Tg(ht,pt.mode,bt,mt),ft.return=pt,ft):(ft=d(ft,ht),ft.return=pt,ft)}function g(pt,ft,ht){if(typeof ft=="string"&&ft!==""||typeof ft=="number")return ft=Qg(""+ft,pt.mode,ht),ft.return=pt,ft;if(typeof ft=="object"&&ft!==null){switch(ft.$$typeof){case va$1:return ht=Rg(ft.type,ft.key,ft.props,null,pt.mode,ht),ht.ref=Lg(pt,null,ft),ht.return=pt,ht;case wa$1:return ft=Sg(ft,pt.mode,ht),ft.return=pt,ft;case Ha:var bt=ft._init;return g(pt,bt(ft._payload),ht)}if(eb(ft)||Ka(ft))return ft=Tg(ft,pt.mode,ht,null),ft.return=pt,ft;Mg(pt,ft)}return null}function c(pt,ft,ht,bt){var mt=ft!==null?ft.key:null;if(typeof ht=="string"&&ht!==""||typeof ht=="number")return mt!==null?null:et(pt,ft,""+ht,bt);if(typeof ht=="object"&&ht!==null){switch(ht.$$typeof){case va$1:return ht.key===mt?st(pt,ft,ht,bt):null;case wa$1:return ht.key===mt?$(pt,ft,ht,bt):null;case Ha:return mt=ht._init,c(pt,ft,mt(ht._payload),bt)}if(eb(ht)||Ka(ht))return mt!==null?null:it(pt,ft,ht,bt,null);Mg(pt,ht)}return null}function _(pt,ft,ht,bt,mt){if(typeof bt=="string"&&bt!==""||typeof bt=="number")return pt=pt.get(ht)||null,et(ft,pt,""+bt,mt);if(typeof bt=="object"&&bt!==null){switch(bt.$$typeof){case va$1:return pt=pt.get(bt.key===null?ht:bt.key)||null,st(ft,pt,bt,mt);case wa$1:return pt=pt.get(bt.key===null?ht:bt.key)||null,$(ft,pt,bt,mt);case Ha:var $t=bt._init;return _(pt,ft,ht,$t(bt._payload),mt)}if(eb(bt)||Ka(bt))return pt=pt.get(ht)||null,it(ft,pt,bt,mt,null);Mg(ft,bt)}return null}function ot(pt,ft,ht,bt){for(var mt=null,$t=null,Tt=ft,Nt=ft=0,Ct=null;Tt!==null&&Nt<ht.length;Nt++){Tt.index>Nt?(Ct=Tt,Tt=null):Ct=Tt.sibling;var Ft=c(pt,Tt,ht[Nt],bt);if(Ft===null){Tt===null&&(Tt=Ct);break}o&&Tt&&Ft.alternate===null&&e(pt,Tt),ft=h(Ft,ft,Nt),$t===null?mt=Ft:$t.sibling=Ft,$t=Ft,Tt=Ct}if(Nt===ht.length)return s(pt,Tt),I&&tg(pt,Nt),mt;if(Tt===null){for(;Nt<ht.length;Nt++)Tt=g(pt,ht[Nt],bt),Tt!==null&&(ft=h(Tt,ft,Nt),$t===null?mt=Tt:$t.sibling=Tt,$t=Tt);return I&&tg(pt,Nt),mt}for(Tt=a(pt,Tt);Nt<ht.length;Nt++)Ct=_(Tt,pt,Nt,ht[Nt],bt),Ct!==null&&(o&&Ct.alternate!==null&&Tt.delete(Ct.key===null?Nt:Ct.key),ft=h(Ct,ft,Nt),$t===null?mt=Ct:$t.sibling=Ct,$t=Ct);return o&&Tt.forEach(function(ln){return e(pt,ln)}),I&&tg(pt,Nt),mt}function ct(pt,ft,ht,bt){var mt=Ka(ht);if(typeof mt!="function")throw Error(p(150));if(ht=mt.call(ht),ht==null)throw Error(p(151));for(var $t=mt=null,Tt=ft,Nt=ft=0,Ct=null,Ft=ht.next();Tt!==null&&!Ft.done;Nt++,Ft=ht.next()){Tt.index>Nt?(Ct=Tt,Tt=null):Ct=Tt.sibling;var ln=c(pt,Tt,Ft.value,bt);if(ln===null){Tt===null&&(Tt=Ct);break}o&&Tt&&ln.alternate===null&&e(pt,Tt),ft=h(ln,ft,Nt),$t===null?mt=ln:$t.sibling=ln,$t=ln,Tt=Ct}if(Ft.done)return s(pt,Tt),I&&tg(pt,Nt),mt;if(Tt===null){for(;!Ft.done;Nt++,Ft=ht.next())Ft=g(pt,Ft.value,bt),Ft!==null&&(ft=h(Ft,ft,Nt),$t===null?mt=Ft:$t.sibling=Ft,$t=Ft);return I&&tg(pt,Nt),mt}for(Tt=a(pt,Tt);!Ft.done;Nt++,Ft=ht.next())Ft=_(Tt,pt,Nt,Ft.value,bt),Ft!==null&&(o&&Ft.alternate!==null&&Tt.delete(Ft.key===null?Nt:Ft.key),ft=h(Ft,ft,Nt),$t===null?mt=Ft:$t.sibling=Ft,$t=Ft);return o&&Tt.forEach(function(mn){return e(pt,mn)}),I&&tg(pt,Nt),mt}function dt(pt,ft,ht,bt){if(typeof ht=="object"&&ht!==null&&ht.type===ya$1&&ht.key===null&&(ht=ht.props.children),typeof ht=="object"&&ht!==null){switch(ht.$$typeof){case va$1:e:{for(var mt=ht.key,$t=ft;$t!==null;){if($t.key===mt){if(mt=ht.type,mt===ya$1){if($t.tag===7){s(pt,$t.sibling),ft=d($t,ht.props.children),ft.return=pt,pt=ft;break e}}else if($t.elementType===mt||typeof mt=="object"&&mt!==null&&mt.$$typeof===Ha&&Ng(mt)===$t.type){s(pt,$t.sibling),ft=d($t,ht.props),ft.ref=Lg(pt,$t,ht),ft.return=pt,pt=ft;break e}s(pt,$t);break}else e(pt,$t);$t=$t.sibling}ht.type===ya$1?(ft=Tg(ht.props.children,pt.mode,bt,ht.key),ft.return=pt,pt=ft):(bt=Rg(ht.type,ht.key,ht.props,null,pt.mode,bt),bt.ref=Lg(pt,ft,ht),bt.return=pt,pt=bt)}return b(pt);case wa$1:e:{for($t=ht.key;ft!==null;){if(ft.key===$t)if(ft.tag===4&&ft.stateNode.containerInfo===ht.containerInfo&&ft.stateNode.implementation===ht.implementation){s(pt,ft.sibling),ft=d(ft,ht.children||[]),ft.return=pt,pt=ft;break e}else{s(pt,ft);break}else e(pt,ft);ft=ft.sibling}ft=Sg(ht,pt.mode,bt),ft.return=pt,pt=ft}return b(pt);case Ha:return $t=ht._init,dt(pt,ft,$t(ht._payload),bt)}if(eb(ht))return ot(pt,ft,ht,bt);if(Ka(ht))return ct(pt,ft,ht,bt);Mg(pt,ht)}return typeof ht=="string"&&ht!==""||typeof ht=="number"?(ht=""+ht,ft!==null&&ft.tag===6?(s(pt,ft.sibling),ft=d(ft,ht),ft.return=pt,pt=ft):(s(pt,ft),ft=Qg(ht,pt.mode,bt),ft.return=pt,pt=ft),b(pt)):s(pt,ft)}return dt}var Ug=Og(!0),Vg=Og(!1),Wg=Uf(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null}function ah(o){var e=Wg.current;E(Wg),o._currentValue=e}function bh(o,e,s){for(;o!==null;){var a=o.alternate;if((o.childLanes&e)!==e?(o.childLanes|=e,a!==null&&(a.childLanes|=e)):a!==null&&(a.childLanes&e)!==e&&(a.childLanes|=e),o===s)break;o=o.return}}function ch(o,e){Xg=o,Zg=Yg=null,o=o.dependencies,o!==null&&o.firstContext!==null&&(o.lanes&e&&(dh=!0),o.firstContext=null)}function eh(o){var e=o._currentValue;if(Zg!==o)if(o={context:o,memoizedValue:e,next:null},Yg===null){if(Xg===null)throw Error(p(308));Yg=o,Xg.dependencies={lanes:0,firstContext:o}}else Yg=Yg.next=o;return e}var fh=null;function gh(o){fh===null?fh=[o]:fh.push(o)}function hh(o,e,s,a){var d=e.interleaved;return d===null?(s.next=s,gh(e)):(s.next=d.next,d.next=s),e.interleaved=s,ih(o,a)}function ih(o,e){o.lanes|=e;var s=o.alternate;for(s!==null&&(s.lanes|=e),s=o,o=o.return;o!==null;)o.childLanes|=e,s=o.alternate,s!==null&&(s.childLanes|=e),s=o,o=o.return;return s.tag===3?s.stateNode:null}var jh=!1;function kh(o){o.updateQueue={baseState:o.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function lh(o,e){o=o.updateQueue,e.updateQueue===o&&(e.updateQueue={baseState:o.baseState,firstBaseUpdate:o.firstBaseUpdate,lastBaseUpdate:o.lastBaseUpdate,shared:o.shared,effects:o.effects})}function mh(o,e){return{eventTime:o,lane:e,tag:0,payload:null,callback:null,next:null}}function nh(o,e,s){var a=o.updateQueue;if(a===null)return null;if(a=a.shared,K$1&2){var d=a.pending;return d===null?e.next=e:(e.next=d.next,d.next=e),a.pending=e,ih(o,s)}return d=a.interleaved,d===null?(e.next=e,gh(a)):(e.next=d.next,d.next=e),a.interleaved=e,ih(o,s)}function oh(o,e,s){if(e=e.updateQueue,e!==null&&(e=e.shared,(s&4194240)!==0)){var a=e.lanes;a&=o.pendingLanes,s|=a,e.lanes=s,Cc$1(o,s)}}function ph(o,e){var s=o.updateQueue,a=o.alternate;if(a!==null&&(a=a.updateQueue,s===a)){var d=null,h=null;if(s=s.firstBaseUpdate,s!==null){do{var b={eventTime:s.eventTime,lane:s.lane,tag:s.tag,payload:s.payload,callback:s.callback,next:null};h===null?d=h=b:h=h.next=b,s=s.next}while(s!==null);h===null?d=h=e:h=h.next=e}else d=h=e;s={baseState:a.baseState,firstBaseUpdate:d,lastBaseUpdate:h,shared:a.shared,effects:a.effects},o.updateQueue=s;return}o=s.lastBaseUpdate,o===null?s.firstBaseUpdate=e:o.next=e,s.lastBaseUpdate=e}function qh(o,e,s,a){var d=o.updateQueue;jh=!1;var h=d.firstBaseUpdate,b=d.lastBaseUpdate,et=d.shared.pending;if(et!==null){d.shared.pending=null;var st=et,$=st.next;st.next=null,b===null?h=$:b.next=$,b=st;var it=o.alternate;it!==null&&(it=it.updateQueue,et=it.lastBaseUpdate,et!==b&&(et===null?it.firstBaseUpdate=$:et.next=$,it.lastBaseUpdate=st))}if(h!==null){var g=d.baseState;b=0,it=$=st=null,et=h;do{var c=et.lane,_=et.eventTime;if((a&c)===c){it!==null&&(it=it.next={eventTime:_,lane:0,tag:et.tag,payload:et.payload,callback:et.callback,next:null});e:{var ot=o,ct=et;switch(c=e,_=s,ct.tag){case 1:if(ot=ct.payload,typeof ot=="function"){g=ot.call(_,g,c);break e}g=ot;break e;case 3:ot.flags=ot.flags&-65537|128;case 0:if(ot=ct.payload,c=typeof ot=="function"?ot.call(_,g,c):ot,c==null)break e;g=A({},g,c);break e;case 2:jh=!0}}et.callback!==null&&et.lane!==0&&(o.flags|=64,c=d.effects,c===null?d.effects=[et]:c.push(et))}else _={eventTime:_,lane:c,tag:et.tag,payload:et.payload,callback:et.callback,next:null},it===null?($=it=_,st=g):it=it.next=_,b|=c;if(et=et.next,et===null){if(et=d.shared.pending,et===null)break;c=et,et=c.next,c.next=null,d.lastBaseUpdate=c,d.shared.pending=null}}while(!0);if(it===null&&(st=g),d.baseState=st,d.firstBaseUpdate=$,d.lastBaseUpdate=it,e=d.shared.interleaved,e!==null){d=e;do b|=d.lane,d=d.next;while(d!==e)}else h===null&&(d.shared.lanes=0);rh|=b,o.lanes=b,o.memoizedState=g}}function sh(o,e,s){if(o=e.effects,e.effects=null,o!==null)for(e=0;e<o.length;e++){var a=o[e],d=a.callback;if(d!==null){if(a.callback=null,a=s,typeof d!="function")throw Error(p(191,d));d.call(a)}}}var th={},uh=Uf(th),vh=Uf(th),wh=Uf(th);function xh(o){if(o===th)throw Error(p(174));return o}function yh(o,e){switch(G(wh,e),G(vh,o),G(uh,th),o=e.nodeType,o){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:lb(null,"");break;default:o=o===8?e.parentNode:e,e=o.namespaceURI||null,o=o.tagName,e=lb(e,o)}E(uh),G(uh,e)}function zh(){E(uh),E(vh),E(wh)}function Ah(o){xh(wh.current);var e=xh(uh.current),s=lb(e,o.type);e!==s&&(G(vh,o),G(uh,s))}function Bh(o){vh.current===o&&(E(uh),E(vh))}var L=Uf(0);function Ch(o){for(var e=o;e!==null;){if(e.tag===13){var s=e.memoizedState;if(s!==null&&(s=s.dehydrated,s===null||s.data==="$?"||s.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if(e.flags&128)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===o)break;for(;e.sibling===null;){if(e.return===null||e.return===o)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var Dh=[];function Eh(){for(var o=0;o<Dh.length;o++)Dh[o]._workInProgressVersionPrimary=null;Dh.length=0}var Fh=ua$1.ReactCurrentDispatcher,Gh=ua$1.ReactCurrentBatchConfig,Hh=0,M$1=null,N=null,O=null,Ih=!1,Jh=!1,Kh=0,Lh=0;function P(){throw Error(p(321))}function Mh(o,e){if(e===null)return!1;for(var s=0;s<e.length&&s<o.length;s++)if(!He(o[s],e[s]))return!1;return!0}function Nh(o,e,s,a,d,h){if(Hh=h,M$1=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,Fh.current=o===null||o.memoizedState===null?Oh:Ph,o=s(a,d),Jh){h=0;do{if(Jh=!1,Kh=0,25<=h)throw Error(p(301));h+=1,O=N=null,e.updateQueue=null,Fh.current=Qh,o=s(a,d)}while(Jh)}if(Fh.current=Rh,e=N!==null&&N.next!==null,Hh=0,O=N=M$1=null,Ih=!1,e)throw Error(p(300));return o}function Sh(){var o=Kh!==0;return Kh=0,o}function Th(){var o={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return O===null?M$1.memoizedState=O=o:O=O.next=o,O}function Uh(){if(N===null){var o=M$1.alternate;o=o!==null?o.memoizedState:null}else o=N.next;var e=O===null?M$1.memoizedState:O.next;if(e!==null)O=e,N=o;else{if(o===null)throw Error(p(310));N=o,o={memoizedState:N.memoizedState,baseState:N.baseState,baseQueue:N.baseQueue,queue:N.queue,next:null},O===null?M$1.memoizedState=O=o:O=O.next=o}return O}function Vh(o,e){return typeof e=="function"?e(o):e}function Wh(o){var e=Uh(),s=e.queue;if(s===null)throw Error(p(311));s.lastRenderedReducer=o;var a=N,d=a.baseQueue,h=s.pending;if(h!==null){if(d!==null){var b=d.next;d.next=h.next,h.next=b}a.baseQueue=d=h,s.pending=null}if(d!==null){h=d.next,a=a.baseState;var et=b=null,st=null,$=h;do{var it=$.lane;if((Hh&it)===it)st!==null&&(st=st.next={lane:0,action:$.action,hasEagerState:$.hasEagerState,eagerState:$.eagerState,next:null}),a=$.hasEagerState?$.eagerState:o(a,$.action);else{var g={lane:it,action:$.action,hasEagerState:$.hasEagerState,eagerState:$.eagerState,next:null};st===null?(et=st=g,b=a):st=st.next=g,M$1.lanes|=it,rh|=it}$=$.next}while($!==null&&$!==h);st===null?b=a:st.next=et,He(a,e.memoizedState)||(dh=!0),e.memoizedState=a,e.baseState=b,e.baseQueue=st,s.lastRenderedState=a}if(o=s.interleaved,o!==null){d=o;do h=d.lane,M$1.lanes|=h,rh|=h,d=d.next;while(d!==o)}else d===null&&(s.lanes=0);return[e.memoizedState,s.dispatch]}function Xh(o){var e=Uh(),s=e.queue;if(s===null)throw Error(p(311));s.lastRenderedReducer=o;var a=s.dispatch,d=s.pending,h=e.memoizedState;if(d!==null){s.pending=null;var b=d=d.next;do h=o(h,b.action),b=b.next;while(b!==d);He(h,e.memoizedState)||(dh=!0),e.memoizedState=h,e.baseQueue===null&&(e.baseState=h),s.lastRenderedState=h}return[h,a]}function Yh(){}function Zh(o,e){var s=M$1,a=Uh(),d=e(),h=!He(a.memoizedState,d);if(h&&(a.memoizedState=d,dh=!0),a=a.queue,$h(ai$1.bind(null,s,a,o),[o]),a.getSnapshot!==e||h||O!==null&&O.memoizedState.tag&1){if(s.flags|=2048,bi(9,ci$1.bind(null,s,a,d,e),void 0,null),Q===null)throw Error(p(349));Hh&30||di$1(s,e,d)}return d}function di$1(o,e,s){o.flags|=16384,o={getSnapshot:e,value:s},e=M$1.updateQueue,e===null?(e={lastEffect:null,stores:null},M$1.updateQueue=e,e.stores=[o]):(s=e.stores,s===null?e.stores=[o]:s.push(o))}function ci$1(o,e,s,a){e.value=s,e.getSnapshot=a,ei$1(e)&&fi$1(o)}function ai$1(o,e,s){return s(function(){ei$1(e)&&fi$1(o)})}function ei$1(o){var e=o.getSnapshot;o=o.value;try{var s=e();return!He(o,s)}catch{return!0}}function fi$1(o){var e=ih(o,1);e!==null&&gi(e,o,1,-1)}function hi$1(o){var e=Th();return typeof o=="function"&&(o=o()),e.memoizedState=e.baseState=o,o={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:o},e.queue=o,o=o.dispatch=ii$1.bind(null,M$1,o),[e.memoizedState,o]}function bi(o,e,s,a){return o={tag:o,create:e,destroy:s,deps:a,next:null},e=M$1.updateQueue,e===null?(e={lastEffect:null,stores:null},M$1.updateQueue=e,e.lastEffect=o.next=o):(s=e.lastEffect,s===null?e.lastEffect=o.next=o:(a=s.next,s.next=o,o.next=a,e.lastEffect=o)),o}function ji$1(){return Uh().memoizedState}function ki(o,e,s,a){var d=Th();M$1.flags|=o,d.memoizedState=bi(1|e,s,void 0,a===void 0?null:a)}function li$1(o,e,s,a){var d=Uh();a=a===void 0?null:a;var h=void 0;if(N!==null){var b=N.memoizedState;if(h=b.destroy,a!==null&&Mh(a,b.deps)){d.memoizedState=bi(e,s,h,a);return}}M$1.flags|=o,d.memoizedState=bi(1|e,s,h,a)}function mi$1(o,e){return ki(8390656,8,o,e)}function $h(o,e){return li$1(2048,8,o,e)}function ni$1(o,e){return li$1(4,2,o,e)}function oi$1(o,e){return li$1(4,4,o,e)}function pi$1(o,e){if(typeof e=="function")return o=o(),e(o),function(){e(null)};if(e!=null)return o=o(),e.current=o,function(){e.current=null}}function qi$1(o,e,s){return s=s!=null?s.concat([o]):null,li$1(4,4,pi$1.bind(null,e,o),s)}function ri$1(){}function si$1(o,e){var s=Uh();e=e===void 0?null:e;var a=s.memoizedState;return a!==null&&e!==null&&Mh(e,a[1])?a[0]:(s.memoizedState=[o,e],o)}function ti$1(o,e){var s=Uh();e=e===void 0?null:e;var a=s.memoizedState;return a!==null&&e!==null&&Mh(e,a[1])?a[0]:(o=o(),s.memoizedState=[o,e],o)}function ui$1(o,e,s){return Hh&21?(He(s,e)||(s=yc$1(),M$1.lanes|=s,rh|=s,o.baseState=!0),e):(o.baseState&&(o.baseState=!1,dh=!0),o.memoizedState=s)}function vi(o,e){var s=C;C=s!==0&&4>s?s:4,o(!0);var a=Gh.transition;Gh.transition={};try{o(!1),e()}finally{C=s,Gh.transition=a}}function wi(){return Uh().memoizedState}function xi(o,e,s){var a=yi(o);if(s={lane:a,action:s,hasEagerState:!1,eagerState:null,next:null},zi$1(o))Ai(e,s);else if(s=hh(o,e,s,a),s!==null){var d=R();gi(s,o,a,d),Bi$1(s,e,a)}}function ii$1(o,e,s){var a=yi(o),d={lane:a,action:s,hasEagerState:!1,eagerState:null,next:null};if(zi$1(o))Ai(e,d);else{var h=o.alternate;if(o.lanes===0&&(h===null||h.lanes===0)&&(h=e.lastRenderedReducer,h!==null))try{var b=e.lastRenderedState,et=h(b,s);if(d.hasEagerState=!0,d.eagerState=et,He(et,b)){var st=e.interleaved;st===null?(d.next=d,gh(e)):(d.next=st.next,st.next=d),e.interleaved=d;return}}catch{}finally{}s=hh(o,e,d,a),s!==null&&(d=R(),gi(s,o,a,d),Bi$1(s,e,a))}}function zi$1(o){var e=o.alternate;return o===M$1||e!==null&&e===M$1}function Ai(o,e){Jh=Ih=!0;var s=o.pending;s===null?e.next=e:(e.next=s.next,s.next=e),o.pending=e}function Bi$1(o,e,s){if(s&4194240){var a=e.lanes;a&=o.pendingLanes,s|=a,e.lanes=s,Cc$1(o,s)}}var Rh={readContext:eh,useCallback:P,useContext:P,useEffect:P,useImperativeHandle:P,useInsertionEffect:P,useLayoutEffect:P,useMemo:P,useReducer:P,useRef:P,useState:P,useDebugValue:P,useDeferredValue:P,useTransition:P,useMutableSource:P,useSyncExternalStore:P,useId:P,unstable_isNewReconciler:!1},Oh={readContext:eh,useCallback:function(o,e){return Th().memoizedState=[o,e===void 0?null:e],o},useContext:eh,useEffect:mi$1,useImperativeHandle:function(o,e,s){return s=s!=null?s.concat([o]):null,ki(4194308,4,pi$1.bind(null,e,o),s)},useLayoutEffect:function(o,e){return ki(4194308,4,o,e)},useInsertionEffect:function(o,e){return ki(4,2,o,e)},useMemo:function(o,e){var s=Th();return e=e===void 0?null:e,o=o(),s.memoizedState=[o,e],o},useReducer:function(o,e,s){var a=Th();return e=s!==void 0?s(e):e,a.memoizedState=a.baseState=e,o={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:o,lastRenderedState:e},a.queue=o,o=o.dispatch=xi.bind(null,M$1,o),[a.memoizedState,o]},useRef:function(o){var e=Th();return o={current:o},e.memoizedState=o},useState:hi$1,useDebugValue:ri$1,useDeferredValue:function(o){return Th().memoizedState=o},useTransition:function(){var o=hi$1(!1),e=o[0];return o=vi.bind(null,o[1]),Th().memoizedState=o,[e,o]},useMutableSource:function(){},useSyncExternalStore:function(o,e,s){var a=M$1,d=Th();if(I){if(s===void 0)throw Error(p(407));s=s()}else{if(s=e(),Q===null)throw Error(p(349));Hh&30||di$1(a,e,s)}d.memoizedState=s;var h={value:s,getSnapshot:e};return d.queue=h,mi$1(ai$1.bind(null,a,h,o),[o]),a.flags|=2048,bi(9,ci$1.bind(null,a,h,s,e),void 0,null),s},useId:function(){var o=Th(),e=Q.identifierPrefix;if(I){var s=sg,a=rg;s=(a&~(1<<32-oc$1(a)-1)).toString(32)+s,e=":"+e+"R"+s,s=Kh++,0<s&&(e+="H"+s.toString(32)),e+=":"}else s=Lh++,e=":"+e+"r"+s.toString(32)+":";return o.memoizedState=e},unstable_isNewReconciler:!1},Ph={readContext:eh,useCallback:si$1,useContext:eh,useEffect:$h,useImperativeHandle:qi$1,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti$1,useReducer:Wh,useRef:ji$1,useState:function(){return Wh(Vh)},useDebugValue:ri$1,useDeferredValue:function(o){var e=Uh();return ui$1(e,N.memoizedState,o)},useTransition:function(){var o=Wh(Vh)[0],e=Uh().memoizedState;return[o,e]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1},Qh={readContext:eh,useCallback:si$1,useContext:eh,useEffect:$h,useImperativeHandle:qi$1,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti$1,useReducer:Xh,useRef:ji$1,useState:function(){return Xh(Vh)},useDebugValue:ri$1,useDeferredValue:function(o){var e=Uh();return N===null?e.memoizedState=o:ui$1(e,N.memoizedState,o)},useTransition:function(){var o=Xh(Vh)[0],e=Uh().memoizedState;return[o,e]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1};function Ci(o,e){if(o&&o.defaultProps){e=A({},e),o=o.defaultProps;for(var s in o)e[s]===void 0&&(e[s]=o[s]);return e}return e}function Di$1(o,e,s,a){e=o.memoizedState,s=s(a,e),s=s==null?e:A({},e,s),o.memoizedState=s,o.lanes===0&&(o.updateQueue.baseState=s)}var Ei={isMounted:function(o){return(o=o._reactInternals)?Vb(o)===o:!1},enqueueSetState:function(o,e,s){o=o._reactInternals;var a=R(),d=yi(o),h=mh(a,d);h.payload=e,s!=null&&(h.callback=s),e=nh(o,h,d),e!==null&&(gi(e,o,d,a),oh(e,o,d))},enqueueReplaceState:function(o,e,s){o=o._reactInternals;var a=R(),d=yi(o),h=mh(a,d);h.tag=1,h.payload=e,s!=null&&(h.callback=s),e=nh(o,h,d),e!==null&&(gi(e,o,d,a),oh(e,o,d))},enqueueForceUpdate:function(o,e){o=o._reactInternals;var s=R(),a=yi(o),d=mh(s,a);d.tag=2,e!=null&&(d.callback=e),e=nh(o,d,a),e!==null&&(gi(e,o,a,s),oh(e,o,a))}};function Fi$1(o,e,s,a,d,h,b){return o=o.stateNode,typeof o.shouldComponentUpdate=="function"?o.shouldComponentUpdate(a,h,b):e.prototype&&e.prototype.isPureReactComponent?!Ie(s,a)||!Ie(d,h):!0}function Gi$1(o,e,s){var a=!1,d=Vf,h=e.contextType;return typeof h=="object"&&h!==null?h=eh(h):(d=Zf(e)?Xf:H.current,a=e.contextTypes,h=(a=a!=null)?Yf(o,d):Vf),e=new e(s,h),o.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=Ei,o.stateNode=e,e._reactInternals=o,a&&(o=o.stateNode,o.__reactInternalMemoizedUnmaskedChildContext=d,o.__reactInternalMemoizedMaskedChildContext=h),e}function Hi$1(o,e,s,a){o=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(s,a),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(s,a),e.state!==o&&Ei.enqueueReplaceState(e,e.state,null)}function Ii(o,e,s,a){var d=o.stateNode;d.props=s,d.state=o.memoizedState,d.refs={},kh(o);var h=e.contextType;typeof h=="object"&&h!==null?d.context=eh(h):(h=Zf(e)?Xf:H.current,d.context=Yf(o,h)),d.state=o.memoizedState,h=e.getDerivedStateFromProps,typeof h=="function"&&(Di$1(o,e,h,s),d.state=o.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof d.getSnapshotBeforeUpdate=="function"||typeof d.UNSAFE_componentWillMount!="function"&&typeof d.componentWillMount!="function"||(e=d.state,typeof d.componentWillMount=="function"&&d.componentWillMount(),typeof d.UNSAFE_componentWillMount=="function"&&d.UNSAFE_componentWillMount(),e!==d.state&&Ei.enqueueReplaceState(d,d.state,null),qh(o,s,d,a),d.state=o.memoizedState),typeof d.componentDidMount=="function"&&(o.flags|=4194308)}function Ji$1(o,e){try{var s="",a=e;do s+=Pa(a),a=a.return;while(a);var d=s}catch(h){d=`
Error generating stack: `+h.message+`
`+h.stack}return{value:o,source:e,stack:d,digest:null}}function Ki$1(o,e,s){return{value:o,source:null,stack:s??null,digest:e??null}}function Li$1(o,e){try{console.error(e.value)}catch(s){setTimeout(function(){throw s})}}var Mi$1=typeof WeakMap=="function"?WeakMap:Map;function Ni(o,e,s){s=mh(-1,s),s.tag=3,s.payload={element:null};var a=e.value;return s.callback=function(){Oi$1||(Oi$1=!0,Pi$1=a),Li$1(o,e)},s}function Qi$1(o,e,s){s=mh(-1,s),s.tag=3;var a=o.type.getDerivedStateFromError;if(typeof a=="function"){var d=e.value;s.payload=function(){return a(d)},s.callback=function(){Li$1(o,e)}}var h=o.stateNode;return h!==null&&typeof h.componentDidCatch=="function"&&(s.callback=function(){Li$1(o,e),typeof a!="function"&&(Ri$1===null?Ri$1=new Set([this]):Ri$1.add(this));var b=e.stack;this.componentDidCatch(e.value,{componentStack:b!==null?b:""})}),s}function Si(o,e,s){var a=o.pingCache;if(a===null){a=o.pingCache=new Mi$1;var d=new Set;a.set(e,d)}else d=a.get(e),d===void 0&&(d=new Set,a.set(e,d));d.has(s)||(d.add(s),o=Ti.bind(null,o,e,s),e.then(o,o))}function Ui$1(o){do{var e;if((e=o.tag===13)&&(e=o.memoizedState,e=e!==null?e.dehydrated!==null:!0),e)return o;o=o.return}while(o!==null);return null}function Vi(o,e,s,a,d){return o.mode&1?(o.flags|=65536,o.lanes=d,o):(o===e?o.flags|=65536:(o.flags|=128,s.flags|=131072,s.flags&=-52805,s.tag===1&&(s.alternate===null?s.tag=17:(e=mh(-1,1),e.tag=2,nh(s,e,1))),s.lanes|=1),o)}var Wi$1=ua$1.ReactCurrentOwner,dh=!1;function Xi$1(o,e,s,a){e.child=o===null?Vg(e,null,s,a):Ug(e,o.child,s,a)}function Yi$1(o,e,s,a,d){s=s.render;var h=e.ref;return ch(e,d),a=Nh(o,e,s,a,h,d),s=Sh(),o!==null&&!dh?(e.updateQueue=o.updateQueue,e.flags&=-2053,o.lanes&=~d,Zi$1(o,e,d)):(I&&s&&vg(e),e.flags|=1,Xi$1(o,e,a,d),e.child)}function $i(o,e,s,a,d){if(o===null){var h=s.type;return typeof h=="function"&&!aj(h)&&h.defaultProps===void 0&&s.compare===null&&s.defaultProps===void 0?(e.tag=15,e.type=h,bj(o,e,h,a,d)):(o=Rg(s.type,null,a,e,e.mode,d),o.ref=e.ref,o.return=e,e.child=o)}if(h=o.child,!(o.lanes&d)){var b=h.memoizedProps;if(s=s.compare,s=s!==null?s:Ie,s(b,a)&&o.ref===e.ref)return Zi$1(o,e,d)}return e.flags|=1,o=Pg(h,a),o.ref=e.ref,o.return=e,e.child=o}function bj(o,e,s,a,d){if(o!==null){var h=o.memoizedProps;if(Ie(h,a)&&o.ref===e.ref)if(dh=!1,e.pendingProps=a=h,(o.lanes&d)!==0)o.flags&131072&&(dh=!0);else return e.lanes=o.lanes,Zi$1(o,e,d)}return cj(o,e,s,a,d)}function dj(o,e,s){var a=e.pendingProps,d=a.children,h=o!==null?o.memoizedState:null;if(a.mode==="hidden")if(!(e.mode&1))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(ej,fj),fj|=s;else{if(!(s&1073741824))return o=h!==null?h.baseLanes|s:s,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:o,cachePool:null,transitions:null},e.updateQueue=null,G(ej,fj),fj|=o,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},a=h!==null?h.baseLanes:s,G(ej,fj),fj|=a}else h!==null?(a=h.baseLanes|s,e.memoizedState=null):a=s,G(ej,fj),fj|=a;return Xi$1(o,e,d,s),e.child}function gj(o,e){var s=e.ref;(o===null&&s!==null||o!==null&&o.ref!==s)&&(e.flags|=512,e.flags|=2097152)}function cj(o,e,s,a,d){var h=Zf(s)?Xf:H.current;return h=Yf(e,h),ch(e,d),s=Nh(o,e,s,a,h,d),a=Sh(),o!==null&&!dh?(e.updateQueue=o.updateQueue,e.flags&=-2053,o.lanes&=~d,Zi$1(o,e,d)):(I&&a&&vg(e),e.flags|=1,Xi$1(o,e,s,d),e.child)}function hj(o,e,s,a,d){if(Zf(s)){var h=!0;cg(e)}else h=!1;if(ch(e,d),e.stateNode===null)ij(o,e),Gi$1(e,s,a),Ii(e,s,a,d),a=!0;else if(o===null){var b=e.stateNode,et=e.memoizedProps;b.props=et;var st=b.context,$=s.contextType;typeof $=="object"&&$!==null?$=eh($):($=Zf(s)?Xf:H.current,$=Yf(e,$));var it=s.getDerivedStateFromProps,g=typeof it=="function"||typeof b.getSnapshotBeforeUpdate=="function";g||typeof b.UNSAFE_componentWillReceiveProps!="function"&&typeof b.componentWillReceiveProps!="function"||(et!==a||st!==$)&&Hi$1(e,b,a,$),jh=!1;var c=e.memoizedState;b.state=c,qh(e,a,b,d),st=e.memoizedState,et!==a||c!==st||Wf.current||jh?(typeof it=="function"&&(Di$1(e,s,it,a),st=e.memoizedState),(et=jh||Fi$1(e,s,et,a,c,st,$))?(g||typeof b.UNSAFE_componentWillMount!="function"&&typeof b.componentWillMount!="function"||(typeof b.componentWillMount=="function"&&b.componentWillMount(),typeof b.UNSAFE_componentWillMount=="function"&&b.UNSAFE_componentWillMount()),typeof b.componentDidMount=="function"&&(e.flags|=4194308)):(typeof b.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=a,e.memoizedState=st),b.props=a,b.state=st,b.context=$,a=et):(typeof b.componentDidMount=="function"&&(e.flags|=4194308),a=!1)}else{b=e.stateNode,lh(o,e),et=e.memoizedProps,$=e.type===e.elementType?et:Ci(e.type,et),b.props=$,g=e.pendingProps,c=b.context,st=s.contextType,typeof st=="object"&&st!==null?st=eh(st):(st=Zf(s)?Xf:H.current,st=Yf(e,st));var _=s.getDerivedStateFromProps;(it=typeof _=="function"||typeof b.getSnapshotBeforeUpdate=="function")||typeof b.UNSAFE_componentWillReceiveProps!="function"&&typeof b.componentWillReceiveProps!="function"||(et!==g||c!==st)&&Hi$1(e,b,a,st),jh=!1,c=e.memoizedState,b.state=c,qh(e,a,b,d);var ot=e.memoizedState;et!==g||c!==ot||Wf.current||jh?(typeof _=="function"&&(Di$1(e,s,_,a),ot=e.memoizedState),($=jh||Fi$1(e,s,$,a,c,ot,st)||!1)?(it||typeof b.UNSAFE_componentWillUpdate!="function"&&typeof b.componentWillUpdate!="function"||(typeof b.componentWillUpdate=="function"&&b.componentWillUpdate(a,ot,st),typeof b.UNSAFE_componentWillUpdate=="function"&&b.UNSAFE_componentWillUpdate(a,ot,st)),typeof b.componentDidUpdate=="function"&&(e.flags|=4),typeof b.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof b.componentDidUpdate!="function"||et===o.memoizedProps&&c===o.memoizedState||(e.flags|=4),typeof b.getSnapshotBeforeUpdate!="function"||et===o.memoizedProps&&c===o.memoizedState||(e.flags|=1024),e.memoizedProps=a,e.memoizedState=ot),b.props=a,b.state=ot,b.context=st,a=$):(typeof b.componentDidUpdate!="function"||et===o.memoizedProps&&c===o.memoizedState||(e.flags|=4),typeof b.getSnapshotBeforeUpdate!="function"||et===o.memoizedProps&&c===o.memoizedState||(e.flags|=1024),a=!1)}return jj(o,e,s,a,h,d)}function jj(o,e,s,a,d,h){gj(o,e);var b=(e.flags&128)!==0;if(!a&&!b)return d&&dg(e,s,!1),Zi$1(o,e,h);a=e.stateNode,Wi$1.current=e;var et=b&&typeof s.getDerivedStateFromError!="function"?null:a.render();return e.flags|=1,o!==null&&b?(e.child=Ug(e,o.child,null,h),e.child=Ug(e,null,et,h)):Xi$1(o,e,et,h),e.memoizedState=a.state,d&&dg(e,s,!0),e.child}function kj(o){var e=o.stateNode;e.pendingContext?ag(o,e.pendingContext,e.pendingContext!==e.context):e.context&&ag(o,e.context,!1),yh(o,e.containerInfo)}function lj(o,e,s,a,d){return Ig(),Jg(d),e.flags|=256,Xi$1(o,e,s,a),e.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(o){return{baseLanes:o,cachePool:null,transitions:null}}function oj(o,e,s){var a=e.pendingProps,d=L.current,h=!1,b=(e.flags&128)!==0,et;if((et=b)||(et=o!==null&&o.memoizedState===null?!1:(d&2)!==0),et?(h=!0,e.flags&=-129):(o===null||o.memoizedState!==null)&&(d|=1),G(L,d&1),o===null)return Eg(e),o=e.memoizedState,o!==null&&(o=o.dehydrated,o!==null)?(e.mode&1?o.data==="$!"?e.lanes=8:e.lanes=1073741824:e.lanes=1,null):(b=a.children,o=a.fallback,h?(a=e.mode,h=e.child,b={mode:"hidden",children:b},!(a&1)&&h!==null?(h.childLanes=0,h.pendingProps=b):h=pj(b,a,0,null),o=Tg(o,a,s,null),h.return=e,o.return=e,h.sibling=o,e.child=h,e.child.memoizedState=nj(s),e.memoizedState=mj,o):qj(e,b));if(d=o.memoizedState,d!==null&&(et=d.dehydrated,et!==null))return rj(o,e,b,a,et,d,s);if(h){h=a.fallback,b=e.mode,d=o.child,et=d.sibling;var st={mode:"hidden",children:a.children};return!(b&1)&&e.child!==d?(a=e.child,a.childLanes=0,a.pendingProps=st,e.deletions=null):(a=Pg(d,st),a.subtreeFlags=d.subtreeFlags&14680064),et!==null?h=Pg(et,h):(h=Tg(h,b,s,null),h.flags|=2),h.return=e,a.return=e,a.sibling=h,e.child=a,a=h,h=e.child,b=o.child.memoizedState,b=b===null?nj(s):{baseLanes:b.baseLanes|s,cachePool:null,transitions:b.transitions},h.memoizedState=b,h.childLanes=o.childLanes&~s,e.memoizedState=mj,a}return h=o.child,o=h.sibling,a=Pg(h,{mode:"visible",children:a.children}),!(e.mode&1)&&(a.lanes=s),a.return=e,a.sibling=null,o!==null&&(s=e.deletions,s===null?(e.deletions=[o],e.flags|=16):s.push(o)),e.child=a,e.memoizedState=null,a}function qj(o,e){return e=pj({mode:"visible",children:e},o.mode,0,null),e.return=o,o.child=e}function sj(o,e,s,a){return a!==null&&Jg(a),Ug(e,o.child,null,s),o=qj(e,e.pendingProps.children),o.flags|=2,e.memoizedState=null,o}function rj(o,e,s,a,d,h,b){if(s)return e.flags&256?(e.flags&=-257,a=Ki$1(Error(p(422))),sj(o,e,b,a)):e.memoizedState!==null?(e.child=o.child,e.flags|=128,null):(h=a.fallback,d=e.mode,a=pj({mode:"visible",children:a.children},d,0,null),h=Tg(h,d,b,null),h.flags|=2,a.return=e,h.return=e,a.sibling=h,e.child=a,e.mode&1&&Ug(e,o.child,null,b),e.child.memoizedState=nj(b),e.memoizedState=mj,h);if(!(e.mode&1))return sj(o,e,b,null);if(d.data==="$!"){if(a=d.nextSibling&&d.nextSibling.dataset,a)var et=a.dgst;return a=et,h=Error(p(419)),a=Ki$1(h,a,void 0),sj(o,e,b,a)}if(et=(b&o.childLanes)!==0,dh||et){if(a=Q,a!==null){switch(b&-b){case 4:d=2;break;case 16:d=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:d=32;break;case 536870912:d=268435456;break;default:d=0}d=d&(a.suspendedLanes|b)?0:d,d!==0&&d!==h.retryLane&&(h.retryLane=d,ih(o,d),gi(a,o,d,-1))}return tj(),a=Ki$1(Error(p(421))),sj(o,e,b,a)}return d.data==="$?"?(e.flags|=128,e.child=o.child,e=uj.bind(null,o),d._reactRetry=e,null):(o=h.treeContext,yg=Lf(d.nextSibling),xg=e,I=!0,zg=null,o!==null&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=o.id,sg=o.overflow,qg=e),e=qj(e,a.children),e.flags|=4096,e)}function vj(o,e,s){o.lanes|=e;var a=o.alternate;a!==null&&(a.lanes|=e),bh(o.return,e,s)}function wj(o,e,s,a,d){var h=o.memoizedState;h===null?o.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:a,tail:s,tailMode:d}:(h.isBackwards=e,h.rendering=null,h.renderingStartTime=0,h.last=a,h.tail=s,h.tailMode=d)}function xj(o,e,s){var a=e.pendingProps,d=a.revealOrder,h=a.tail;if(Xi$1(o,e,a.children,s),a=L.current,a&2)a=a&1|2,e.flags|=128;else{if(o!==null&&o.flags&128)e:for(o=e.child;o!==null;){if(o.tag===13)o.memoizedState!==null&&vj(o,s,e);else if(o.tag===19)vj(o,s,e);else if(o.child!==null){o.child.return=o,o=o.child;continue}if(o===e)break e;for(;o.sibling===null;){if(o.return===null||o.return===e)break e;o=o.return}o.sibling.return=o.return,o=o.sibling}a&=1}if(G(L,a),!(e.mode&1))e.memoizedState=null;else switch(d){case"forwards":for(s=e.child,d=null;s!==null;)o=s.alternate,o!==null&&Ch(o)===null&&(d=s),s=s.sibling;s=d,s===null?(d=e.child,e.child=null):(d=s.sibling,s.sibling=null),wj(e,!1,d,s,h);break;case"backwards":for(s=null,d=e.child,e.child=null;d!==null;){if(o=d.alternate,o!==null&&Ch(o)===null){e.child=d;break}o=d.sibling,d.sibling=s,s=d,d=o}wj(e,!0,s,null,h);break;case"together":wj(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function ij(o,e){!(e.mode&1)&&o!==null&&(o.alternate=null,e.alternate=null,e.flags|=2)}function Zi$1(o,e,s){if(o!==null&&(e.dependencies=o.dependencies),rh|=e.lanes,!(s&e.childLanes))return null;if(o!==null&&e.child!==o.child)throw Error(p(153));if(e.child!==null){for(o=e.child,s=Pg(o,o.pendingProps),e.child=s,s.return=e;o.sibling!==null;)o=o.sibling,s=s.sibling=Pg(o,o.pendingProps),s.return=e;s.sibling=null}return e.child}function yj(o,e,s){switch(e.tag){case 3:kj(e),Ig();break;case 5:Ah(e);break;case 1:Zf(e.type)&&cg(e);break;case 4:yh(e,e.stateNode.containerInfo);break;case 10:var a=e.type._context,d=e.memoizedProps.value;G(Wg,a._currentValue),a._currentValue=d;break;case 13:if(a=e.memoizedState,a!==null)return a.dehydrated!==null?(G(L,L.current&1),e.flags|=128,null):s&e.child.childLanes?oj(o,e,s):(G(L,L.current&1),o=Zi$1(o,e,s),o!==null?o.sibling:null);G(L,L.current&1);break;case 19:if(a=(s&e.childLanes)!==0,o.flags&128){if(a)return xj(o,e,s);e.flags|=128}if(d=e.memoizedState,d!==null&&(d.rendering=null,d.tail=null,d.lastEffect=null),G(L,L.current),a)break;return null;case 22:case 23:return e.lanes=0,dj(o,e,s)}return Zi$1(o,e,s)}var zj,Aj,Bj,Cj;zj=function(o,e){for(var s=e.child;s!==null;){if(s.tag===5||s.tag===6)o.appendChild(s.stateNode);else if(s.tag!==4&&s.child!==null){s.child.return=s,s=s.child;continue}if(s===e)break;for(;s.sibling===null;){if(s.return===null||s.return===e)return;s=s.return}s.sibling.return=s.return,s=s.sibling}};Aj=function(){};Bj=function(o,e,s,a){var d=o.memoizedProps;if(d!==a){o=e.stateNode,xh(uh.current);var h=null;switch(s){case"input":d=Ya(o,d),a=Ya(o,a),h=[];break;case"select":d=A({},d,{value:void 0}),a=A({},a,{value:void 0}),h=[];break;case"textarea":d=gb(o,d),a=gb(o,a),h=[];break;default:typeof d.onClick!="function"&&typeof a.onClick=="function"&&(o.onclick=Bf)}ub(s,a);var b;s=null;for($ in d)if(!a.hasOwnProperty($)&&d.hasOwnProperty($)&&d[$]!=null)if($==="style"){var et=d[$];for(b in et)et.hasOwnProperty(b)&&(s||(s={}),s[b]="")}else $!=="dangerouslySetInnerHTML"&&$!=="children"&&$!=="suppressContentEditableWarning"&&$!=="suppressHydrationWarning"&&$!=="autoFocus"&&(ea$1.hasOwnProperty($)?h||(h=[]):(h=h||[]).push($,null));for($ in a){var st=a[$];if(et=d?.[$],a.hasOwnProperty($)&&st!==et&&(st!=null||et!=null))if($==="style")if(et){for(b in et)!et.hasOwnProperty(b)||st&&st.hasOwnProperty(b)||(s||(s={}),s[b]="");for(b in st)st.hasOwnProperty(b)&&et[b]!==st[b]&&(s||(s={}),s[b]=st[b])}else s||(h||(h=[]),h.push($,s)),s=st;else $==="dangerouslySetInnerHTML"?(st=st?st.__html:void 0,et=et?et.__html:void 0,st!=null&&et!==st&&(h=h||[]).push($,st)):$==="children"?typeof st!="string"&&typeof st!="number"||(h=h||[]).push($,""+st):$!=="suppressContentEditableWarning"&&$!=="suppressHydrationWarning"&&(ea$1.hasOwnProperty($)?(st!=null&&$==="onScroll"&&D("scroll",o),h||et===st||(h=[])):(h=h||[]).push($,st))}s&&(h=h||[]).push("style",s);var $=h;(e.updateQueue=$)&&(e.flags|=4)}};Cj=function(o,e,s,a){s!==a&&(e.flags|=4)};function Dj(o,e){if(!I)switch(o.tailMode){case"hidden":e=o.tail;for(var s=null;e!==null;)e.alternate!==null&&(s=e),e=e.sibling;s===null?o.tail=null:s.sibling=null;break;case"collapsed":s=o.tail;for(var a=null;s!==null;)s.alternate!==null&&(a=s),s=s.sibling;a===null?e||o.tail===null?o.tail=null:o.tail.sibling=null:a.sibling=null}}function S(o){var e=o.alternate!==null&&o.alternate.child===o.child,s=0,a=0;if(e)for(var d=o.child;d!==null;)s|=d.lanes|d.childLanes,a|=d.subtreeFlags&14680064,a|=d.flags&14680064,d.return=o,d=d.sibling;else for(d=o.child;d!==null;)s|=d.lanes|d.childLanes,a|=d.subtreeFlags,a|=d.flags,d.return=o,d=d.sibling;return o.subtreeFlags|=a,o.childLanes=s,e}function Ej(o,e,s){var a=e.pendingProps;switch(wg(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(e),null;case 1:return Zf(e.type)&&$f(),S(e),null;case 3:return a=e.stateNode,zh(),E(Wf),E(H),Eh(),a.pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),(o===null||o.child===null)&&(Gg(e)?e.flags|=4:o===null||o.memoizedState.isDehydrated&&!(e.flags&256)||(e.flags|=1024,zg!==null&&(Fj(zg),zg=null))),Aj(o,e),S(e),null;case 5:Bh(e);var d=xh(wh.current);if(s=e.type,o!==null&&e.stateNode!=null)Bj(o,e,s,a,d),o.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!a){if(e.stateNode===null)throw Error(p(166));return S(e),null}if(o=xh(uh.current),Gg(e)){a=e.stateNode,s=e.type;var h=e.memoizedProps;switch(a[Of]=e,a[Pf]=h,o=(e.mode&1)!==0,s){case"dialog":D("cancel",a),D("close",a);break;case"iframe":case"object":case"embed":D("load",a);break;case"video":case"audio":for(d=0;d<lf$1.length;d++)D(lf$1[d],a);break;case"source":D("error",a);break;case"img":case"image":case"link":D("error",a),D("load",a);break;case"details":D("toggle",a);break;case"input":Za(a,h),D("invalid",a);break;case"select":a._wrapperState={wasMultiple:!!h.multiple},D("invalid",a);break;case"textarea":hb(a,h),D("invalid",a)}ub(s,h),d=null;for(var b in h)if(h.hasOwnProperty(b)){var et=h[b];b==="children"?typeof et=="string"?a.textContent!==et&&(h.suppressHydrationWarning!==!0&&Af(a.textContent,et,o),d=["children",et]):typeof et=="number"&&a.textContent!==""+et&&(h.suppressHydrationWarning!==!0&&Af(a.textContent,et,o),d=["children",""+et]):ea$1.hasOwnProperty(b)&&et!=null&&b==="onScroll"&&D("scroll",a)}switch(s){case"input":Va(a),db(a,h,!0);break;case"textarea":Va(a),jb(a);break;case"select":case"option":break;default:typeof h.onClick=="function"&&(a.onclick=Bf)}a=d,e.updateQueue=a,a!==null&&(e.flags|=4)}else{b=d.nodeType===9?d:d.ownerDocument,o==="http://www.w3.org/1999/xhtml"&&(o=kb(s)),o==="http://www.w3.org/1999/xhtml"?s==="script"?(o=b.createElement("div"),o.innerHTML="<script><\/script>",o=o.removeChild(o.firstChild)):typeof a.is=="string"?o=b.createElement(s,{is:a.is}):(o=b.createElement(s),s==="select"&&(b=o,a.multiple?b.multiple=!0:a.size&&(b.size=a.size))):o=b.createElementNS(o,s),o[Of]=e,o[Pf]=a,zj(o,e,!1,!1),e.stateNode=o;e:{switch(b=vb(s,a),s){case"dialog":D("cancel",o),D("close",o),d=a;break;case"iframe":case"object":case"embed":D("load",o),d=a;break;case"video":case"audio":for(d=0;d<lf$1.length;d++)D(lf$1[d],o);d=a;break;case"source":D("error",o),d=a;break;case"img":case"image":case"link":D("error",o),D("load",o),d=a;break;case"details":D("toggle",o),d=a;break;case"input":Za(o,a),d=Ya(o,a),D("invalid",o);break;case"option":d=a;break;case"select":o._wrapperState={wasMultiple:!!a.multiple},d=A({},a,{value:void 0}),D("invalid",o);break;case"textarea":hb(o,a),d=gb(o,a),D("invalid",o);break;default:d=a}ub(s,d),et=d;for(h in et)if(et.hasOwnProperty(h)){var st=et[h];h==="style"?sb(o,st):h==="dangerouslySetInnerHTML"?(st=st?st.__html:void 0,st!=null&&nb(o,st)):h==="children"?typeof st=="string"?(s!=="textarea"||st!=="")&&ob(o,st):typeof st=="number"&&ob(o,""+st):h!=="suppressContentEditableWarning"&&h!=="suppressHydrationWarning"&&h!=="autoFocus"&&(ea$1.hasOwnProperty(h)?st!=null&&h==="onScroll"&&D("scroll",o):st!=null&&ta$1(o,h,st,b))}switch(s){case"input":Va(o),db(o,a,!1);break;case"textarea":Va(o),jb(o);break;case"option":a.value!=null&&o.setAttribute("value",""+Sa$1(a.value));break;case"select":o.multiple=!!a.multiple,h=a.value,h!=null?fb(o,!!a.multiple,h,!1):a.defaultValue!=null&&fb(o,!!a.multiple,a.defaultValue,!0);break;default:typeof d.onClick=="function"&&(o.onclick=Bf)}switch(s){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break e;case"img":a=!0;break e;default:a=!1}}a&&(e.flags|=4)}e.ref!==null&&(e.flags|=512,e.flags|=2097152)}return S(e),null;case 6:if(o&&e.stateNode!=null)Cj(o,e,o.memoizedProps,a);else{if(typeof a!="string"&&e.stateNode===null)throw Error(p(166));if(s=xh(wh.current),xh(uh.current),Gg(e)){if(a=e.stateNode,s=e.memoizedProps,a[Of]=e,(h=a.nodeValue!==s)&&(o=xg,o!==null))switch(o.tag){case 3:Af(a.nodeValue,s,(o.mode&1)!==0);break;case 5:o.memoizedProps.suppressHydrationWarning!==!0&&Af(a.nodeValue,s,(o.mode&1)!==0)}h&&(e.flags|=4)}else a=(s.nodeType===9?s:s.ownerDocument).createTextNode(a),a[Of]=e,e.stateNode=a}return S(e),null;case 13:if(E(L),a=e.memoizedState,o===null||o.memoizedState!==null&&o.memoizedState.dehydrated!==null){if(I&&yg!==null&&e.mode&1&&!(e.flags&128))Hg(),Ig(),e.flags|=98560,h=!1;else if(h=Gg(e),a!==null&&a.dehydrated!==null){if(o===null){if(!h)throw Error(p(318));if(h=e.memoizedState,h=h!==null?h.dehydrated:null,!h)throw Error(p(317));h[Of]=e}else Ig(),!(e.flags&128)&&(e.memoizedState=null),e.flags|=4;S(e),h=!1}else zg!==null&&(Fj(zg),zg=null),h=!0;if(!h)return e.flags&65536?e:null}return e.flags&128?(e.lanes=s,e):(a=a!==null,a!==(o!==null&&o.memoizedState!==null)&&a&&(e.child.flags|=8192,e.mode&1&&(o===null||L.current&1?T===0&&(T=3):tj())),e.updateQueue!==null&&(e.flags|=4),S(e),null);case 4:return zh(),Aj(o,e),o===null&&sf$1(e.stateNode.containerInfo),S(e),null;case 10:return ah(e.type._context),S(e),null;case 17:return Zf(e.type)&&$f(),S(e),null;case 19:if(E(L),h=e.memoizedState,h===null)return S(e),null;if(a=(e.flags&128)!==0,b=h.rendering,b===null)if(a)Dj(h,!1);else{if(T!==0||o!==null&&o.flags&128)for(o=e.child;o!==null;){if(b=Ch(o),b!==null){for(e.flags|=128,Dj(h,!1),a=b.updateQueue,a!==null&&(e.updateQueue=a,e.flags|=4),e.subtreeFlags=0,a=s,s=e.child;s!==null;)h=s,o=a,h.flags&=14680066,b=h.alternate,b===null?(h.childLanes=0,h.lanes=o,h.child=null,h.subtreeFlags=0,h.memoizedProps=null,h.memoizedState=null,h.updateQueue=null,h.dependencies=null,h.stateNode=null):(h.childLanes=b.childLanes,h.lanes=b.lanes,h.child=b.child,h.subtreeFlags=0,h.deletions=null,h.memoizedProps=b.memoizedProps,h.memoizedState=b.memoizedState,h.updateQueue=b.updateQueue,h.type=b.type,o=b.dependencies,h.dependencies=o===null?null:{lanes:o.lanes,firstContext:o.firstContext}),s=s.sibling;return G(L,L.current&1|2),e.child}o=o.sibling}h.tail!==null&&B()>Gj&&(e.flags|=128,a=!0,Dj(h,!1),e.lanes=4194304)}else{if(!a)if(o=Ch(b),o!==null){if(e.flags|=128,a=!0,s=o.updateQueue,s!==null&&(e.updateQueue=s,e.flags|=4),Dj(h,!0),h.tail===null&&h.tailMode==="hidden"&&!b.alternate&&!I)return S(e),null}else 2*B()-h.renderingStartTime>Gj&&s!==1073741824&&(e.flags|=128,a=!0,Dj(h,!1),e.lanes=4194304);h.isBackwards?(b.sibling=e.child,e.child=b):(s=h.last,s!==null?s.sibling=b:e.child=b,h.last=b)}return h.tail!==null?(e=h.tail,h.rendering=e,h.tail=e.sibling,h.renderingStartTime=B(),e.sibling=null,s=L.current,G(L,a?s&1|2:s&1),e):(S(e),null);case 22:case 23:return Hj(),a=e.memoizedState!==null,o!==null&&o.memoizedState!==null!==a&&(e.flags|=8192),a&&e.mode&1?fj&1073741824&&(S(e),e.subtreeFlags&6&&(e.flags|=8192)):S(e),null;case 24:return null;case 25:return null}throw Error(p(156,e.tag))}function Ij(o,e){switch(wg(e),e.tag){case 1:return Zf(e.type)&&$f(),o=e.flags,o&65536?(e.flags=o&-65537|128,e):null;case 3:return zh(),E(Wf),E(H),Eh(),o=e.flags,o&65536&&!(o&128)?(e.flags=o&-65537|128,e):null;case 5:return Bh(e),null;case 13:if(E(L),o=e.memoizedState,o!==null&&o.dehydrated!==null){if(e.alternate===null)throw Error(p(340));Ig()}return o=e.flags,o&65536?(e.flags=o&-65537|128,e):null;case 19:return E(L),null;case 4:return zh(),null;case 10:return ah(e.type._context),null;case 22:case 23:return Hj(),null;case 24:return null;default:return null}}var Jj=!1,U$1=!1,Kj=typeof WeakSet=="function"?WeakSet:Set,V=null;function Lj(o,e){var s=o.ref;if(s!==null)if(typeof s=="function")try{s(null)}catch(a){W(o,e,a)}else s.current=null}function Mj(o,e,s){try{s()}catch(a){W(o,e,a)}}var Nj=!1;function Oj(o,e){if(Cf=dd$1,o=Me(),Ne$1(o)){if("selectionStart"in o)var s={start:o.selectionStart,end:o.selectionEnd};else e:{s=(s=o.ownerDocument)&&s.defaultView||window;var a=s.getSelection&&s.getSelection();if(a&&a.rangeCount!==0){s=a.anchorNode;var d=a.anchorOffset,h=a.focusNode;a=a.focusOffset;try{s.nodeType,h.nodeType}catch{s=null;break e}var b=0,et=-1,st=-1,$=0,it=0,g=o,c=null;t:for(;;){for(var _;g!==s||d!==0&&g.nodeType!==3||(et=b+d),g!==h||a!==0&&g.nodeType!==3||(st=b+a),g.nodeType===3&&(b+=g.nodeValue.length),(_=g.firstChild)!==null;)c=g,g=_;for(;;){if(g===o)break t;if(c===s&&++$===d&&(et=b),c===h&&++it===a&&(st=b),(_=g.nextSibling)!==null)break;g=c,c=g.parentNode}g=_}s=et===-1||st===-1?null:{start:et,end:st}}else s=null}s=s||{start:0,end:0}}else s=null;for(Df={focusedElem:o,selectionRange:s},dd$1=!1,V=e;V!==null;)if(e=V,o=e.child,(e.subtreeFlags&1028)!==0&&o!==null)o.return=e,V=o;else for(;V!==null;){e=V;try{var ot=e.alternate;if(e.flags&1024)switch(e.tag){case 0:case 11:case 15:break;case 1:if(ot!==null){var ct=ot.memoizedProps,dt=ot.memoizedState,pt=e.stateNode,ft=pt.getSnapshotBeforeUpdate(e.elementType===e.type?ct:Ci(e.type,ct),dt);pt.__reactInternalSnapshotBeforeUpdate=ft}break;case 3:var ht=e.stateNode.containerInfo;ht.nodeType===1?ht.textContent="":ht.nodeType===9&&ht.documentElement&&ht.removeChild(ht.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163))}}catch(bt){W(e,e.return,bt)}if(o=e.sibling,o!==null){o.return=e.return,V=o;break}V=e.return}return ot=Nj,Nj=!1,ot}function Pj(o,e,s){var a=e.updateQueue;if(a=a!==null?a.lastEffect:null,a!==null){var d=a=a.next;do{if((d.tag&o)===o){var h=d.destroy;d.destroy=void 0,h!==void 0&&Mj(e,s,h)}d=d.next}while(d!==a)}}function Qj(o,e){if(e=e.updateQueue,e=e!==null?e.lastEffect:null,e!==null){var s=e=e.next;do{if((s.tag&o)===o){var a=s.create;s.destroy=a()}s=s.next}while(s!==e)}}function Rj(o){var e=o.ref;if(e!==null){var s=o.stateNode;switch(o.tag){case 5:o=s;break;default:o=s}typeof e=="function"?e(o):e.current=o}}function Sj(o){var e=o.alternate;e!==null&&(o.alternate=null,Sj(e)),o.child=null,o.deletions=null,o.sibling=null,o.tag===5&&(e=o.stateNode,e!==null&&(delete e[Of],delete e[Pf],delete e[of$1],delete e[Qf],delete e[Rf])),o.stateNode=null,o.return=null,o.dependencies=null,o.memoizedProps=null,o.memoizedState=null,o.pendingProps=null,o.stateNode=null,o.updateQueue=null}function Tj(o){return o.tag===5||o.tag===3||o.tag===4}function Uj(o){e:for(;;){for(;o.sibling===null;){if(o.return===null||Tj(o.return))return null;o=o.return}for(o.sibling.return=o.return,o=o.sibling;o.tag!==5&&o.tag!==6&&o.tag!==18;){if(o.flags&2||o.child===null||o.tag===4)continue e;o.child.return=o,o=o.child}if(!(o.flags&2))return o.stateNode}}function Vj(o,e,s){var a=o.tag;if(a===5||a===6)o=o.stateNode,e?s.nodeType===8?s.parentNode.insertBefore(o,e):s.insertBefore(o,e):(s.nodeType===8?(e=s.parentNode,e.insertBefore(o,s)):(e=s,e.appendChild(o)),s=s._reactRootContainer,s!=null||e.onclick!==null||(e.onclick=Bf));else if(a!==4&&(o=o.child,o!==null))for(Vj(o,e,s),o=o.sibling;o!==null;)Vj(o,e,s),o=o.sibling}function Wj(o,e,s){var a=o.tag;if(a===5||a===6)o=o.stateNode,e?s.insertBefore(o,e):s.appendChild(o);else if(a!==4&&(o=o.child,o!==null))for(Wj(o,e,s),o=o.sibling;o!==null;)Wj(o,e,s),o=o.sibling}var X$2=null,Xj=!1;function Yj(o,e,s){for(s=s.child;s!==null;)Zj(o,e,s),s=s.sibling}function Zj(o,e,s){if(lc$1&&typeof lc$1.onCommitFiberUnmount=="function")try{lc$1.onCommitFiberUnmount(kc$1,s)}catch{}switch(s.tag){case 5:U$1||Lj(s,e);case 6:var a=X$2,d=Xj;X$2=null,Yj(o,e,s),X$2=a,Xj=d,X$2!==null&&(Xj?(o=X$2,s=s.stateNode,o.nodeType===8?o.parentNode.removeChild(s):o.removeChild(s)):X$2.removeChild(s.stateNode));break;case 18:X$2!==null&&(Xj?(o=X$2,s=s.stateNode,o.nodeType===8?Kf(o.parentNode,s):o.nodeType===1&&Kf(o,s),bd$1(o)):Kf(X$2,s.stateNode));break;case 4:a=X$2,d=Xj,X$2=s.stateNode.containerInfo,Xj=!0,Yj(o,e,s),X$2=a,Xj=d;break;case 0:case 11:case 14:case 15:if(!U$1&&(a=s.updateQueue,a!==null&&(a=a.lastEffect,a!==null))){d=a=a.next;do{var h=d,b=h.destroy;h=h.tag,b!==void 0&&(h&2||h&4)&&Mj(s,e,b),d=d.next}while(d!==a)}Yj(o,e,s);break;case 1:if(!U$1&&(Lj(s,e),a=s.stateNode,typeof a.componentWillUnmount=="function"))try{a.props=s.memoizedProps,a.state=s.memoizedState,a.componentWillUnmount()}catch(et){W(s,e,et)}Yj(o,e,s);break;case 21:Yj(o,e,s);break;case 22:s.mode&1?(U$1=(a=U$1)||s.memoizedState!==null,Yj(o,e,s),U$1=a):Yj(o,e,s);break;default:Yj(o,e,s)}}function ak(o){var e=o.updateQueue;if(e!==null){o.updateQueue=null;var s=o.stateNode;s===null&&(s=o.stateNode=new Kj),e.forEach(function(a){var d=bk.bind(null,o,a);s.has(a)||(s.add(a),a.then(d,d))})}}function ck(o,e){var s=e.deletions;if(s!==null)for(var a=0;a<s.length;a++){var d=s[a];try{var h=o,b=e,et=b;e:for(;et!==null;){switch(et.tag){case 5:X$2=et.stateNode,Xj=!1;break e;case 3:X$2=et.stateNode.containerInfo,Xj=!0;break e;case 4:X$2=et.stateNode.containerInfo,Xj=!0;break e}et=et.return}if(X$2===null)throw Error(p(160));Zj(h,b,d),X$2=null,Xj=!1;var st=d.alternate;st!==null&&(st.return=null),d.return=null}catch($){W(d,e,$)}}if(e.subtreeFlags&12854)for(e=e.child;e!==null;)dk(e,o),e=e.sibling}function dk(o,e){var s=o.alternate,a=o.flags;switch(o.tag){case 0:case 11:case 14:case 15:if(ck(e,o),ek(o),a&4){try{Pj(3,o,o.return),Qj(3,o)}catch(ct){W(o,o.return,ct)}try{Pj(5,o,o.return)}catch(ct){W(o,o.return,ct)}}break;case 1:ck(e,o),ek(o),a&512&&s!==null&&Lj(s,s.return);break;case 5:if(ck(e,o),ek(o),a&512&&s!==null&&Lj(s,s.return),o.flags&32){var d=o.stateNode;try{ob(d,"")}catch(ct){W(o,o.return,ct)}}if(a&4&&(d=o.stateNode,d!=null)){var h=o.memoizedProps,b=s!==null?s.memoizedProps:h,et=o.type,st=o.updateQueue;if(o.updateQueue=null,st!==null)try{et==="input"&&h.type==="radio"&&h.name!=null&&ab(d,h),vb(et,b);var $=vb(et,h);for(b=0;b<st.length;b+=2){var it=st[b],g=st[b+1];it==="style"?sb(d,g):it==="dangerouslySetInnerHTML"?nb(d,g):it==="children"?ob(d,g):ta$1(d,it,g,$)}switch(et){case"input":bb(d,h);break;case"textarea":ib(d,h);break;case"select":var c=d._wrapperState.wasMultiple;d._wrapperState.wasMultiple=!!h.multiple;var _=h.value;_!=null?fb(d,!!h.multiple,_,!1):c!==!!h.multiple&&(h.defaultValue!=null?fb(d,!!h.multiple,h.defaultValue,!0):fb(d,!!h.multiple,h.multiple?[]:"",!1))}d[Pf]=h}catch(ct){W(o,o.return,ct)}}break;case 6:if(ck(e,o),ek(o),a&4){if(o.stateNode===null)throw Error(p(162));d=o.stateNode,h=o.memoizedProps;try{d.nodeValue=h}catch(ct){W(o,o.return,ct)}}break;case 3:if(ck(e,o),ek(o),a&4&&s!==null&&s.memoizedState.isDehydrated)try{bd$1(e.containerInfo)}catch(ct){W(o,o.return,ct)}break;case 4:ck(e,o),ek(o);break;case 13:ck(e,o),ek(o),d=o.child,d.flags&8192&&(h=d.memoizedState!==null,d.stateNode.isHidden=h,!h||d.alternate!==null&&d.alternate.memoizedState!==null||(fk=B())),a&4&&ak(o);break;case 22:if(it=s!==null&&s.memoizedState!==null,o.mode&1?(U$1=($=U$1)||it,ck(e,o),U$1=$):ck(e,o),ek(o),a&8192){if($=o.memoizedState!==null,(o.stateNode.isHidden=$)&&!it&&o.mode&1)for(V=o,it=o.child;it!==null;){for(g=V=it;V!==null;){switch(c=V,_=c.child,c.tag){case 0:case 11:case 14:case 15:Pj(4,c,c.return);break;case 1:Lj(c,c.return);var ot=c.stateNode;if(typeof ot.componentWillUnmount=="function"){a=c,s=c.return;try{e=a,ot.props=e.memoizedProps,ot.state=e.memoizedState,ot.componentWillUnmount()}catch(ct){W(a,s,ct)}}break;case 5:Lj(c,c.return);break;case 22:if(c.memoizedState!==null){gk(g);continue}}_!==null?(_.return=c,V=_):gk(g)}it=it.sibling}e:for(it=null,g=o;;){if(g.tag===5){if(it===null){it=g;try{d=g.stateNode,$?(h=d.style,typeof h.setProperty=="function"?h.setProperty("display","none","important"):h.display="none"):(et=g.stateNode,st=g.memoizedProps.style,b=st!=null&&st.hasOwnProperty("display")?st.display:null,et.style.display=rb("display",b))}catch(ct){W(o,o.return,ct)}}}else if(g.tag===6){if(it===null)try{g.stateNode.nodeValue=$?"":g.memoizedProps}catch(ct){W(o,o.return,ct)}}else if((g.tag!==22&&g.tag!==23||g.memoizedState===null||g===o)&&g.child!==null){g.child.return=g,g=g.child;continue}if(g===o)break e;for(;g.sibling===null;){if(g.return===null||g.return===o)break e;it===g&&(it=null),g=g.return}it===g&&(it=null),g.sibling.return=g.return,g=g.sibling}}break;case 19:ck(e,o),ek(o),a&4&&ak(o);break;case 21:break;default:ck(e,o),ek(o)}}function ek(o){var e=o.flags;if(e&2){try{e:{for(var s=o.return;s!==null;){if(Tj(s)){var a=s;break e}s=s.return}throw Error(p(160))}switch(a.tag){case 5:var d=a.stateNode;a.flags&32&&(ob(d,""),a.flags&=-33);var h=Uj(o);Wj(o,h,d);break;case 3:case 4:var b=a.stateNode.containerInfo,et=Uj(o);Vj(o,et,b);break;default:throw Error(p(161))}}catch(st){W(o,o.return,st)}o.flags&=-3}e&4096&&(o.flags&=-4097)}function hk(o,e,s){V=o,ik(o)}function ik(o,e,s){for(var a=(o.mode&1)!==0;V!==null;){var d=V,h=d.child;if(d.tag===22&&a){var b=d.memoizedState!==null||Jj;if(!b){var et=d.alternate,st=et!==null&&et.memoizedState!==null||U$1;et=Jj;var $=U$1;if(Jj=b,(U$1=st)&&!$)for(V=d;V!==null;)b=V,st=b.child,b.tag===22&&b.memoizedState!==null?jk(d):st!==null?(st.return=b,V=st):jk(d);for(;h!==null;)V=h,ik(h),h=h.sibling;V=d,Jj=et,U$1=$}kk(o)}else d.subtreeFlags&8772&&h!==null?(h.return=d,V=h):kk(o)}}function kk(o){for(;V!==null;){var e=V;if(e.flags&8772){var s=e.alternate;try{if(e.flags&8772)switch(e.tag){case 0:case 11:case 15:U$1||Qj(5,e);break;case 1:var a=e.stateNode;if(e.flags&4&&!U$1)if(s===null)a.componentDidMount();else{var d=e.elementType===e.type?s.memoizedProps:Ci(e.type,s.memoizedProps);a.componentDidUpdate(d,s.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}var h=e.updateQueue;h!==null&&sh(e,h,a);break;case 3:var b=e.updateQueue;if(b!==null){if(s=null,e.child!==null)switch(e.child.tag){case 5:s=e.child.stateNode;break;case 1:s=e.child.stateNode}sh(e,b,s)}break;case 5:var et=e.stateNode;if(s===null&&e.flags&4){s=et;var st=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":st.autoFocus&&s.focus();break;case"img":st.src&&(s.src=st.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(e.memoizedState===null){var $=e.alternate;if($!==null){var it=$.memoizedState;if(it!==null){var g=it.dehydrated;g!==null&&bd$1(g)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(p(163))}U$1||e.flags&512&&Rj(e)}catch(c){W(e,e.return,c)}}if(e===o){V=null;break}if(s=e.sibling,s!==null){s.return=e.return,V=s;break}V=e.return}}function gk(o){for(;V!==null;){var e=V;if(e===o){V=null;break}var s=e.sibling;if(s!==null){s.return=e.return,V=s;break}V=e.return}}function jk(o){for(;V!==null;){var e=V;try{switch(e.tag){case 0:case 11:case 15:var s=e.return;try{Qj(4,e)}catch(st){W(e,s,st)}break;case 1:var a=e.stateNode;if(typeof a.componentDidMount=="function"){var d=e.return;try{a.componentDidMount()}catch(st){W(e,d,st)}}var h=e.return;try{Rj(e)}catch(st){W(e,h,st)}break;case 5:var b=e.return;try{Rj(e)}catch(st){W(e,b,st)}}}catch(st){W(e,e.return,st)}if(e===o){V=null;break}var et=e.sibling;if(et!==null){et.return=e.return,V=et;break}V=e.return}}var lk=Math.ceil,mk=ua$1.ReactCurrentDispatcher,nk=ua$1.ReactCurrentOwner,ok=ua$1.ReactCurrentBatchConfig,K$1=0,Q=null,Y=null,Z=0,fj=0,ej=Uf(0),T=0,pk=null,rh=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=1/0,uk=null,Oi$1=!1,Pi$1=null,Ri$1=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R(){return K$1&6?B():Ak!==-1?Ak:Ak=B()}function yi(o){return o.mode&1?K$1&2&&Z!==0?Z&-Z:Kg.transition!==null?(Bk===0&&(Bk=yc$1()),Bk):(o=C,o!==0||(o=window.event,o=o===void 0?16:jd$1(o.type)),o):1}function gi(o,e,s,a){if(50<yk)throw yk=0,zk=null,Error(p(185));Ac$1(o,s,a),(!(K$1&2)||o!==Q)&&(o===Q&&(!(K$1&2)&&(qk|=s),T===4&&Ck(o,Z)),Dk(o,a),s===1&&K$1===0&&!(e.mode&1)&&(Gj=B()+500,fg&&jg()))}function Dk(o,e){var s=o.callbackNode;wc$1(o,e);var a=uc$1(o,o===Q?Z:0);if(a===0)s!==null&&bc$1(s),o.callbackNode=null,o.callbackPriority=0;else if(e=a&-a,o.callbackPriority!==e){if(s!=null&&bc$1(s),e===1)o.tag===0?ig(Ek.bind(null,o)):hg(Ek.bind(null,o)),Jf(function(){!(K$1&6)&&jg()}),s=null;else{switch(Dc$1(a)){case 1:s=fc$1;break;case 4:s=gc$1;break;case 16:s=hc;break;case 536870912:s=jc$1;break;default:s=hc}s=Fk(s,Gk.bind(null,o))}o.callbackPriority=e,o.callbackNode=s}}function Gk(o,e){if(Ak=-1,Bk=0,K$1&6)throw Error(p(327));var s=o.callbackNode;if(Hk()&&o.callbackNode!==s)return null;var a=uc$1(o,o===Q?Z:0);if(a===0)return null;if(a&30||a&o.expiredLanes||e)e=Ik(o,a);else{e=a;var d=K$1;K$1|=2;var h=Jk();(Q!==o||Z!==e)&&(uk=null,Gj=B()+500,Kk(o,e));do try{Lk();break}catch(et){Mk(o,et)}while(!0);$g(),mk.current=h,K$1=d,Y!==null?e=0:(Q=null,Z=0,e=T)}if(e!==0){if(e===2&&(d=xc$1(o),d!==0&&(a=d,e=Nk(o,d))),e===1)throw s=pk,Kk(o,0),Ck(o,a),Dk(o,B()),s;if(e===6)Ck(o,a);else{if(d=o.current.alternate,!(a&30)&&!Ok(d)&&(e=Ik(o,a),e===2&&(h=xc$1(o),h!==0&&(a=h,e=Nk(o,h))),e===1))throw s=pk,Kk(o,0),Ck(o,a),Dk(o,B()),s;switch(o.finishedWork=d,o.finishedLanes=a,e){case 0:case 1:throw Error(p(345));case 2:Pk(o,tk,uk);break;case 3:if(Ck(o,a),(a&130023424)===a&&(e=fk+500-B(),10<e)){if(uc$1(o,0)!==0)break;if(d=o.suspendedLanes,(d&a)!==a){R(),o.pingedLanes|=o.suspendedLanes&d;break}o.timeoutHandle=Ff(Pk.bind(null,o,tk,uk),e);break}Pk(o,tk,uk);break;case 4:if(Ck(o,a),(a&4194240)===a)break;for(e=o.eventTimes,d=-1;0<a;){var b=31-oc$1(a);h=1<<b,b=e[b],b>d&&(d=b),a&=~h}if(a=d,a=B()-a,a=(120>a?120:480>a?480:1080>a?1080:1920>a?1920:3e3>a?3e3:4320>a?4320:1960*lk(a/1960))-a,10<a){o.timeoutHandle=Ff(Pk.bind(null,o,tk,uk),a);break}Pk(o,tk,uk);break;case 5:Pk(o,tk,uk);break;default:throw Error(p(329))}}}return Dk(o,B()),o.callbackNode===s?Gk.bind(null,o):null}function Nk(o,e){var s=sk;return o.current.memoizedState.isDehydrated&&(Kk(o,e).flags|=256),o=Ik(o,e),o!==2&&(e=tk,tk=s,e!==null&&Fj(e)),o}function Fj(o){tk===null?tk=o:tk.push.apply(tk,o)}function Ok(o){for(var e=o;;){if(e.flags&16384){var s=e.updateQueue;if(s!==null&&(s=s.stores,s!==null))for(var a=0;a<s.length;a++){var d=s[a],h=d.getSnapshot;d=d.value;try{if(!He(h(),d))return!1}catch{return!1}}}if(s=e.child,e.subtreeFlags&16384&&s!==null)s.return=e,e=s;else{if(e===o)break;for(;e.sibling===null;){if(e.return===null||e.return===o)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function Ck(o,e){for(e&=~rk,e&=~qk,o.suspendedLanes|=e,o.pingedLanes&=~e,o=o.expirationTimes;0<e;){var s=31-oc$1(e),a=1<<s;o[s]=-1,e&=~a}}function Ek(o){if(K$1&6)throw Error(p(327));Hk();var e=uc$1(o,0);if(!(e&1))return Dk(o,B()),null;var s=Ik(o,e);if(o.tag!==0&&s===2){var a=xc$1(o);a!==0&&(e=a,s=Nk(o,a))}if(s===1)throw s=pk,Kk(o,0),Ck(o,e),Dk(o,B()),s;if(s===6)throw Error(p(345));return o.finishedWork=o.current.alternate,o.finishedLanes=e,Pk(o,tk,uk),Dk(o,B()),null}function Qk(o,e){var s=K$1;K$1|=1;try{return o(e)}finally{K$1=s,K$1===0&&(Gj=B()+500,fg&&jg())}}function Rk(o){wk!==null&&wk.tag===0&&!(K$1&6)&&Hk();var e=K$1;K$1|=1;var s=ok.transition,a=C;try{if(ok.transition=null,C=1,o)return o()}finally{C=a,ok.transition=s,K$1=e,!(K$1&6)&&jg()}}function Hj(){fj=ej.current,E(ej)}function Kk(o,e){o.finishedWork=null,o.finishedLanes=0;var s=o.timeoutHandle;if(s!==-1&&(o.timeoutHandle=-1,Gf(s)),Y!==null)for(s=Y.return;s!==null;){var a=s;switch(wg(a),a.tag){case 1:a=a.type.childContextTypes,a!=null&&$f();break;case 3:zh(),E(Wf),E(H),Eh();break;case 5:Bh(a);break;case 4:zh();break;case 13:E(L);break;case 19:E(L);break;case 10:ah(a.type._context);break;case 22:case 23:Hj()}s=s.return}if(Q=o,Y=o=Pg(o.current,null),Z=fj=e,T=0,pk=null,rk=qk=rh=0,tk=sk=null,fh!==null){for(e=0;e<fh.length;e++)if(s=fh[e],a=s.interleaved,a!==null){s.interleaved=null;var d=a.next,h=s.pending;if(h!==null){var b=h.next;h.next=d,a.next=b}s.pending=a}fh=null}return o}function Mk(o,e){do{var s=Y;try{if($g(),Fh.current=Rh,Ih){for(var a=M$1.memoizedState;a!==null;){var d=a.queue;d!==null&&(d.pending=null),a=a.next}Ih=!1}if(Hh=0,O=N=M$1=null,Jh=!1,Kh=0,nk.current=null,s===null||s.return===null){T=1,pk=e,Y=null;break}e:{var h=o,b=s.return,et=s,st=e;if(e=Z,et.flags|=32768,st!==null&&typeof st=="object"&&typeof st.then=="function"){var $=st,it=et,g=it.tag;if(!(it.mode&1)&&(g===0||g===11||g===15)){var c=it.alternate;c?(it.updateQueue=c.updateQueue,it.memoizedState=c.memoizedState,it.lanes=c.lanes):(it.updateQueue=null,it.memoizedState=null)}var _=Ui$1(b);if(_!==null){_.flags&=-257,Vi(_,b,et,h,e),_.mode&1&&Si(h,$,e),e=_,st=$;var ot=e.updateQueue;if(ot===null){var ct=new Set;ct.add(st),e.updateQueue=ct}else ot.add(st);break e}else{if(!(e&1)){Si(h,$,e),tj();break e}st=Error(p(426))}}else if(I&&et.mode&1){var dt=Ui$1(b);if(dt!==null){!(dt.flags&65536)&&(dt.flags|=256),Vi(dt,b,et,h,e),Jg(Ji$1(st,et));break e}}h=st=Ji$1(st,et),T!==4&&(T=2),sk===null?sk=[h]:sk.push(h),h=b;do{switch(h.tag){case 3:h.flags|=65536,e&=-e,h.lanes|=e;var pt=Ni(h,st,e);ph(h,pt);break e;case 1:et=st;var ft=h.type,ht=h.stateNode;if(!(h.flags&128)&&(typeof ft.getDerivedStateFromError=="function"||ht!==null&&typeof ht.componentDidCatch=="function"&&(Ri$1===null||!Ri$1.has(ht)))){h.flags|=65536,e&=-e,h.lanes|=e;var bt=Qi$1(h,et,e);ph(h,bt);break e}}h=h.return}while(h!==null)}Sk(s)}catch(mt){e=mt,Y===s&&s!==null&&(Y=s=s.return);continue}break}while(!0)}function Jk(){var o=mk.current;return mk.current=Rh,o===null?Rh:o}function tj(){(T===0||T===3||T===2)&&(T=4),Q===null||!(rh&268435455)&&!(qk&268435455)||Ck(Q,Z)}function Ik(o,e){var s=K$1;K$1|=2;var a=Jk();(Q!==o||Z!==e)&&(uk=null,Kk(o,e));do try{Tk();break}catch(d){Mk(o,d)}while(!0);if($g(),K$1=s,mk.current=a,Y!==null)throw Error(p(261));return Q=null,Z=0,T}function Tk(){for(;Y!==null;)Uk(Y)}function Lk(){for(;Y!==null&&!cc$1();)Uk(Y)}function Uk(o){var e=Vk(o.alternate,o,fj);o.memoizedProps=o.pendingProps,e===null?Sk(o):Y=e,nk.current=null}function Sk(o){var e=o;do{var s=e.alternate;if(o=e.return,e.flags&32768){if(s=Ij(s,e),s!==null){s.flags&=32767,Y=s;return}if(o!==null)o.flags|=32768,o.subtreeFlags=0,o.deletions=null;else{T=6,Y=null;return}}else if(s=Ej(s,e,fj),s!==null){Y=s;return}if(e=e.sibling,e!==null){Y=e;return}Y=e=o}while(e!==null);T===0&&(T=5)}function Pk(o,e,s){var a=C,d=ok.transition;try{ok.transition=null,C=1,Wk(o,e,s,a)}finally{ok.transition=d,C=a}return null}function Wk(o,e,s,a){do Hk();while(wk!==null);if(K$1&6)throw Error(p(327));s=o.finishedWork;var d=o.finishedLanes;if(s===null)return null;if(o.finishedWork=null,o.finishedLanes=0,s===o.current)throw Error(p(177));o.callbackNode=null,o.callbackPriority=0;var h=s.lanes|s.childLanes;if(Bc$1(o,h),o===Q&&(Y=Q=null,Z=0),!(s.subtreeFlags&2064)&&!(s.flags&2064)||vk||(vk=!0,Fk(hc,function(){return Hk(),null})),h=(s.flags&15990)!==0,s.subtreeFlags&15990||h){h=ok.transition,ok.transition=null;var b=C;C=1;var et=K$1;K$1|=4,nk.current=null,Oj(o,s),dk(s,o),Oe(Df),dd$1=!!Cf,Df=Cf=null,o.current=s,hk(s),dc$1(),K$1=et,C=b,ok.transition=h}else o.current=s;if(vk&&(vk=!1,wk=o,xk=d),h=o.pendingLanes,h===0&&(Ri$1=null),mc$1(s.stateNode),Dk(o,B()),e!==null)for(a=o.onRecoverableError,s=0;s<e.length;s++)d=e[s],a(d.value,{componentStack:d.stack,digest:d.digest});if(Oi$1)throw Oi$1=!1,o=Pi$1,Pi$1=null,o;return xk&1&&o.tag!==0&&Hk(),h=o.pendingLanes,h&1?o===zk?yk++:(yk=0,zk=o):yk=0,jg(),null}function Hk(){if(wk!==null){var o=Dc$1(xk),e=ok.transition,s=C;try{if(ok.transition=null,C=16>o?16:o,wk===null)var a=!1;else{if(o=wk,wk=null,xk=0,K$1&6)throw Error(p(331));var d=K$1;for(K$1|=4,V=o.current;V!==null;){var h=V,b=h.child;if(V.flags&16){var et=h.deletions;if(et!==null){for(var st=0;st<et.length;st++){var $=et[st];for(V=$;V!==null;){var it=V;switch(it.tag){case 0:case 11:case 15:Pj(8,it,h)}var g=it.child;if(g!==null)g.return=it,V=g;else for(;V!==null;){it=V;var c=it.sibling,_=it.return;if(Sj(it),it===$){V=null;break}if(c!==null){c.return=_,V=c;break}V=_}}}var ot=h.alternate;if(ot!==null){var ct=ot.child;if(ct!==null){ot.child=null;do{var dt=ct.sibling;ct.sibling=null,ct=dt}while(ct!==null)}}V=h}}if(h.subtreeFlags&2064&&b!==null)b.return=h,V=b;else e:for(;V!==null;){if(h=V,h.flags&2048)switch(h.tag){case 0:case 11:case 15:Pj(9,h,h.return)}var pt=h.sibling;if(pt!==null){pt.return=h.return,V=pt;break e}V=h.return}}var ft=o.current;for(V=ft;V!==null;){b=V;var ht=b.child;if(b.subtreeFlags&2064&&ht!==null)ht.return=b,V=ht;else e:for(b=ft;V!==null;){if(et=V,et.flags&2048)try{switch(et.tag){case 0:case 11:case 15:Qj(9,et)}}catch(mt){W(et,et.return,mt)}if(et===b){V=null;break e}var bt=et.sibling;if(bt!==null){bt.return=et.return,V=bt;break e}V=et.return}}if(K$1=d,jg(),lc$1&&typeof lc$1.onPostCommitFiberRoot=="function")try{lc$1.onPostCommitFiberRoot(kc$1,o)}catch{}a=!0}return a}finally{C=s,ok.transition=e}}return!1}function Xk(o,e,s){e=Ji$1(s,e),e=Ni(o,e,1),o=nh(o,e,1),e=R(),o!==null&&(Ac$1(o,1,e),Dk(o,e))}function W(o,e,s){if(o.tag===3)Xk(o,o,s);else for(;e!==null;){if(e.tag===3){Xk(e,o,s);break}else if(e.tag===1){var a=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof a.componentDidCatch=="function"&&(Ri$1===null||!Ri$1.has(a))){o=Ji$1(s,o),o=Qi$1(e,o,1),e=nh(e,o,1),o=R(),e!==null&&(Ac$1(e,1,o),Dk(e,o));break}}e=e.return}}function Ti(o,e,s){var a=o.pingCache;a!==null&&a.delete(e),e=R(),o.pingedLanes|=o.suspendedLanes&s,Q===o&&(Z&s)===s&&(T===4||T===3&&(Z&130023424)===Z&&500>B()-fk?Kk(o,0):rk|=s),Dk(o,e)}function Yk(o,e){e===0&&(o.mode&1?(e=sc$1,sc$1<<=1,!(sc$1&130023424)&&(sc$1=4194304)):e=1);var s=R();o=ih(o,e),o!==null&&(Ac$1(o,e,s),Dk(o,s))}function uj(o){var e=o.memoizedState,s=0;e!==null&&(s=e.retryLane),Yk(o,s)}function bk(o,e){var s=0;switch(o.tag){case 13:var a=o.stateNode,d=o.memoizedState;d!==null&&(s=d.retryLane);break;case 19:a=o.stateNode;break;default:throw Error(p(314))}a!==null&&a.delete(e),Yk(o,s)}var Vk;Vk=function(o,e,s){if(o!==null)if(o.memoizedProps!==e.pendingProps||Wf.current)dh=!0;else{if(!(o.lanes&s)&&!(e.flags&128))return dh=!1,yj(o,e,s);dh=!!(o.flags&131072)}else dh=!1,I&&e.flags&1048576&&ug(e,ng,e.index);switch(e.lanes=0,e.tag){case 2:var a=e.type;ij(o,e),o=e.pendingProps;var d=Yf(e,H.current);ch(e,s),d=Nh(null,e,a,o,d,s);var h=Sh();return e.flags|=1,typeof d=="object"&&d!==null&&typeof d.render=="function"&&d.$$typeof===void 0?(e.tag=1,e.memoizedState=null,e.updateQueue=null,Zf(a)?(h=!0,cg(e)):h=!1,e.memoizedState=d.state!==null&&d.state!==void 0?d.state:null,kh(e),d.updater=Ei,e.stateNode=d,d._reactInternals=e,Ii(e,a,o,s),e=jj(null,e,a,!0,h,s)):(e.tag=0,I&&h&&vg(e),Xi$1(null,e,d,s),e=e.child),e;case 16:a=e.elementType;e:{switch(ij(o,e),o=e.pendingProps,d=a._init,a=d(a._payload),e.type=a,d=e.tag=Zk(a),o=Ci(a,o),d){case 0:e=cj(null,e,a,o,s);break e;case 1:e=hj(null,e,a,o,s);break e;case 11:e=Yi$1(null,e,a,o,s);break e;case 14:e=$i(null,e,a,Ci(a.type,o),s);break e}throw Error(p(306,a,""))}return e;case 0:return a=e.type,d=e.pendingProps,d=e.elementType===a?d:Ci(a,d),cj(o,e,a,d,s);case 1:return a=e.type,d=e.pendingProps,d=e.elementType===a?d:Ci(a,d),hj(o,e,a,d,s);case 3:e:{if(kj(e),o===null)throw Error(p(387));a=e.pendingProps,h=e.memoizedState,d=h.element,lh(o,e),qh(e,a,null,s);var b=e.memoizedState;if(a=b.element,h.isDehydrated)if(h={element:a,isDehydrated:!1,cache:b.cache,pendingSuspenseBoundaries:b.pendingSuspenseBoundaries,transitions:b.transitions},e.updateQueue.baseState=h,e.memoizedState=h,e.flags&256){d=Ji$1(Error(p(423)),e),e=lj(o,e,a,s,d);break e}else if(a!==d){d=Ji$1(Error(p(424)),e),e=lj(o,e,a,s,d);break e}else for(yg=Lf(e.stateNode.containerInfo.firstChild),xg=e,I=!0,zg=null,s=Vg(e,null,a,s),e.child=s;s;)s.flags=s.flags&-3|4096,s=s.sibling;else{if(Ig(),a===d){e=Zi$1(o,e,s);break e}Xi$1(o,e,a,s)}e=e.child}return e;case 5:return Ah(e),o===null&&Eg(e),a=e.type,d=e.pendingProps,h=o!==null?o.memoizedProps:null,b=d.children,Ef(a,d)?b=null:h!==null&&Ef(a,h)&&(e.flags|=32),gj(o,e),Xi$1(o,e,b,s),e.child;case 6:return o===null&&Eg(e),null;case 13:return oj(o,e,s);case 4:return yh(e,e.stateNode.containerInfo),a=e.pendingProps,o===null?e.child=Ug(e,null,a,s):Xi$1(o,e,a,s),e.child;case 11:return a=e.type,d=e.pendingProps,d=e.elementType===a?d:Ci(a,d),Yi$1(o,e,a,d,s);case 7:return Xi$1(o,e,e.pendingProps,s),e.child;case 8:return Xi$1(o,e,e.pendingProps.children,s),e.child;case 12:return Xi$1(o,e,e.pendingProps.children,s),e.child;case 10:e:{if(a=e.type._context,d=e.pendingProps,h=e.memoizedProps,b=d.value,G(Wg,a._currentValue),a._currentValue=b,h!==null)if(He(h.value,b)){if(h.children===d.children&&!Wf.current){e=Zi$1(o,e,s);break e}}else for(h=e.child,h!==null&&(h.return=e);h!==null;){var et=h.dependencies;if(et!==null){b=h.child;for(var st=et.firstContext;st!==null;){if(st.context===a){if(h.tag===1){st=mh(-1,s&-s),st.tag=2;var $=h.updateQueue;if($!==null){$=$.shared;var it=$.pending;it===null?st.next=st:(st.next=it.next,it.next=st),$.pending=st}}h.lanes|=s,st=h.alternate,st!==null&&(st.lanes|=s),bh(h.return,s,e),et.lanes|=s;break}st=st.next}}else if(h.tag===10)b=h.type===e.type?null:h.child;else if(h.tag===18){if(b=h.return,b===null)throw Error(p(341));b.lanes|=s,et=b.alternate,et!==null&&(et.lanes|=s),bh(b,s,e),b=h.sibling}else b=h.child;if(b!==null)b.return=h;else for(b=h;b!==null;){if(b===e){b=null;break}if(h=b.sibling,h!==null){h.return=b.return,b=h;break}b=b.return}h=b}Xi$1(o,e,d.children,s),e=e.child}return e;case 9:return d=e.type,a=e.pendingProps.children,ch(e,s),d=eh(d),a=a(d),e.flags|=1,Xi$1(o,e,a,s),e.child;case 14:return a=e.type,d=Ci(a,e.pendingProps),d=Ci(a.type,d),$i(o,e,a,d,s);case 15:return bj(o,e,e.type,e.pendingProps,s);case 17:return a=e.type,d=e.pendingProps,d=e.elementType===a?d:Ci(a,d),ij(o,e),e.tag=1,Zf(a)?(o=!0,cg(e)):o=!1,ch(e,s),Gi$1(e,a,d),Ii(e,a,d,s),jj(null,e,a,!0,o,s);case 19:return xj(o,e,s);case 22:return dj(o,e,s)}throw Error(p(156,e.tag))};function Fk(o,e){return ac$1(o,e)}function $k(o,e,s,a){this.tag=o,this.key=s,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Bg(o,e,s,a){return new $k(o,e,s,a)}function aj(o){return o=o.prototype,!(!o||!o.isReactComponent)}function Zk(o){if(typeof o=="function")return aj(o)?1:0;if(o!=null){if(o=o.$$typeof,o===Da)return 11;if(o===Ga)return 14}return 2}function Pg(o,e){var s=o.alternate;return s===null?(s=Bg(o.tag,e,o.key,o.mode),s.elementType=o.elementType,s.type=o.type,s.stateNode=o.stateNode,s.alternate=o,o.alternate=s):(s.pendingProps=e,s.type=o.type,s.flags=0,s.subtreeFlags=0,s.deletions=null),s.flags=o.flags&14680064,s.childLanes=o.childLanes,s.lanes=o.lanes,s.child=o.child,s.memoizedProps=o.memoizedProps,s.memoizedState=o.memoizedState,s.updateQueue=o.updateQueue,e=o.dependencies,s.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},s.sibling=o.sibling,s.index=o.index,s.ref=o.ref,s}function Rg(o,e,s,a,d,h){var b=2;if(a=o,typeof o=="function")aj(o)&&(b=1);else if(typeof o=="string")b=5;else e:switch(o){case ya$1:return Tg(s.children,d,h,e);case za:b=8,d|=8;break;case Aa:return o=Bg(12,s,e,d|2),o.elementType=Aa,o.lanes=h,o;case Ea:return o=Bg(13,s,e,d),o.elementType=Ea,o.lanes=h,o;case Fa:return o=Bg(19,s,e,d),o.elementType=Fa,o.lanes=h,o;case Ia$1:return pj(s,d,h,e);default:if(typeof o=="object"&&o!==null)switch(o.$$typeof){case Ba:b=10;break e;case Ca$1:b=9;break e;case Da:b=11;break e;case Ga:b=14;break e;case Ha:b=16,a=null;break e}throw Error(p(130,o==null?o:typeof o,""))}return e=Bg(b,s,e,d),e.elementType=o,e.type=a,e.lanes=h,e}function Tg(o,e,s,a){return o=Bg(7,o,a,e),o.lanes=s,o}function pj(o,e,s,a){return o=Bg(22,o,a,e),o.elementType=Ia$1,o.lanes=s,o.stateNode={isHidden:!1},o}function Qg(o,e,s){return o=Bg(6,o,null,e),o.lanes=s,o}function Sg(o,e,s){return e=Bg(4,o.children!==null?o.children:[],o.key,e),e.lanes=s,e.stateNode={containerInfo:o.containerInfo,pendingChildren:null,implementation:o.implementation},e}function al$1(o,e,s,a,d){this.tag=e,this.containerInfo=o,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=zc$1(0),this.expirationTimes=zc$1(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zc$1(0),this.identifierPrefix=a,this.onRecoverableError=d,this.mutableSourceEagerHydrationData=null}function bl$1(o,e,s,a,d,h,b,et,st){return o=new al$1(o,e,s,et,st),e===1?(e=1,h===!0&&(e|=8)):e=0,h=Bg(3,null,null,e),o.current=h,h.stateNode=o,h.memoizedState={element:a,isDehydrated:s,cache:null,transitions:null,pendingSuspenseBoundaries:null},kh(h),o}function cl$1(o,e,s){var a=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:wa$1,key:a==null?null:""+a,children:o,containerInfo:e,implementation:s}}function dl$1(o){if(!o)return Vf;o=o._reactInternals;e:{if(Vb(o)!==o||o.tag!==1)throw Error(p(170));var e=o;do{switch(e.tag){case 3:e=e.stateNode.context;break e;case 1:if(Zf(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break e}}e=e.return}while(e!==null);throw Error(p(171))}if(o.tag===1){var s=o.type;if(Zf(s))return bg(o,s,e)}return e}function el$1(o,e,s,a,d,h,b,et,st){return o=bl$1(s,a,!0,o,d,h,b,et,st),o.context=dl$1(null),s=o.current,a=R(),d=yi(s),h=mh(a,d),h.callback=e??null,nh(s,h,d),o.current.lanes=d,Ac$1(o,d,a),Dk(o,a),o}function fl$1(o,e,s,a){var d=e.current,h=R(),b=yi(d);return s=dl$1(s),e.context===null?e.context=s:e.pendingContext=s,e=mh(h,b),e.payload={element:o},a=a===void 0?null:a,a!==null&&(e.callback=a),o=nh(d,e,b),o!==null&&(gi(o,d,b,h),oh(o,d,b)),b}function gl$1(o){if(o=o.current,!o.child)return null;switch(o.child.tag){case 5:return o.child.stateNode;default:return o.child.stateNode}}function hl$1(o,e){if(o=o.memoizedState,o!==null&&o.dehydrated!==null){var s=o.retryLane;o.retryLane=s!==0&&s<e?s:e}}function il$1(o,e){hl$1(o,e),(o=o.alternate)&&hl$1(o,e)}function jl$1(){return null}var kl$1=typeof reportError=="function"?reportError:function(o){console.error(o)};function ll$1(o){this._internalRoot=o}ml$1.prototype.render=ll$1.prototype.render=function(o){var e=this._internalRoot;if(e===null)throw Error(p(409));fl$1(o,e,null,null)};ml$1.prototype.unmount=ll$1.prototype.unmount=function(){var o=this._internalRoot;if(o!==null){this._internalRoot=null;var e=o.containerInfo;Rk(function(){fl$1(null,o,null,null)}),e[uf$1]=null}};function ml$1(o){this._internalRoot=o}ml$1.prototype.unstable_scheduleHydration=function(o){if(o){var e=Hc$1();o={blockedOn:null,target:o,priority:e};for(var s=0;s<Qc$1.length&&e!==0&&e<Qc$1[s].priority;s++);Qc$1.splice(s,0,o),s===0&&Vc$1(o)}};function nl$1(o){return!(!o||o.nodeType!==1&&o.nodeType!==9&&o.nodeType!==11)}function ol$1(o){return!(!o||o.nodeType!==1&&o.nodeType!==9&&o.nodeType!==11&&(o.nodeType!==8||o.nodeValue!==" react-mount-point-unstable "))}function pl$1(){}function ql$1(o,e,s,a,d){if(d){if(typeof a=="function"){var h=a;a=function(){var $=gl$1(b);h.call($)}}var b=el$1(e,a,o,0,null,!1,!1,"",pl$1);return o._reactRootContainer=b,o[uf$1]=b.current,sf$1(o.nodeType===8?o.parentNode:o),Rk(),b}for(;d=o.lastChild;)o.removeChild(d);if(typeof a=="function"){var et=a;a=function(){var $=gl$1(st);et.call($)}}var st=bl$1(o,0,!1,null,null,!1,!1,"",pl$1);return o._reactRootContainer=st,o[uf$1]=st.current,sf$1(o.nodeType===8?o.parentNode:o),Rk(function(){fl$1(e,st,s,a)}),st}function rl$1(o,e,s,a,d){var h=s._reactRootContainer;if(h){var b=h;if(typeof d=="function"){var et=d;d=function(){var st=gl$1(b);et.call(st)}}fl$1(e,b,o,d)}else b=ql$1(s,e,o,d,a);return gl$1(b)}Ec$1=function(o){switch(o.tag){case 3:var e=o.stateNode;if(e.current.memoizedState.isDehydrated){var s=tc(e.pendingLanes);s!==0&&(Cc$1(e,s|1),Dk(e,B()),!(K$1&6)&&(Gj=B()+500,jg()))}break;case 13:Rk(function(){var a=ih(o,1);if(a!==null){var d=R();gi(a,o,1,d)}}),il$1(o,1)}};Fc$1=function(o){if(o.tag===13){var e=ih(o,134217728);if(e!==null){var s=R();gi(e,o,134217728,s)}il$1(o,134217728)}};Gc$1=function(o){if(o.tag===13){var e=yi(o),s=ih(o,e);if(s!==null){var a=R();gi(s,o,e,a)}il$1(o,e)}};Hc$1=function(){return C};Ic$1=function(o,e){var s=C;try{return C=o,e()}finally{C=s}};yb=function(o,e,s){switch(e){case"input":if(bb(o,s),e=s.name,s.type==="radio"&&e!=null){for(s=o;s.parentNode;)s=s.parentNode;for(s=s.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<s.length;e++){var a=s[e];if(a!==o&&a.form===o.form){var d=Db(a);if(!d)throw Error(p(90));Wa(a),bb(a,d)}}}break;case"textarea":ib(o,s);break;case"select":e=s.value,e!=null&&fb(o,!!s.multiple,e,!1)}};Gb=Qk;Hb=Rk;var sl$1={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Qk]},tl$1={findFiberByHostInstance:Wc$1,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},ul$1={bundleType:tl$1.bundleType,version:tl$1.version,rendererPackageName:tl$1.rendererPackageName,rendererConfig:tl$1.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua$1.ReactCurrentDispatcher,findHostInstanceByFiber:function(o){return o=Zb(o),o===null?null:o.stateNode},findFiberByHostInstance:tl$1.findFiberByHostInstance||jl$1,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var vl$1=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl$1.isDisabled&&vl$1.supportsFiber)try{kc$1=vl$1.inject(ul$1),lc$1=vl$1}catch{}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl$1;reactDom_production_min.createPortal=function(o,e){var s=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!nl$1(e))throw Error(p(200));return cl$1(o,e,null,s)};reactDom_production_min.createRoot=function(o,e){if(!nl$1(o))throw Error(p(299));var s=!1,a="",d=kl$1;return e!=null&&(e.unstable_strictMode===!0&&(s=!0),e.identifierPrefix!==void 0&&(a=e.identifierPrefix),e.onRecoverableError!==void 0&&(d=e.onRecoverableError)),e=bl$1(o,1,!1,null,null,s,!1,a,d),o[uf$1]=e.current,sf$1(o.nodeType===8?o.parentNode:o),new ll$1(e)};reactDom_production_min.findDOMNode=function(o){if(o==null)return null;if(o.nodeType===1)return o;var e=o._reactInternals;if(e===void 0)throw typeof o.render=="function"?Error(p(188)):(o=Object.keys(o).join(","),Error(p(268,o)));return o=Zb(e),o=o===null?null:o.stateNode,o};reactDom_production_min.flushSync=function(o){return Rk(o)};reactDom_production_min.hydrate=function(o,e,s){if(!ol$1(e))throw Error(p(200));return rl$1(null,o,e,!0,s)};reactDom_production_min.hydrateRoot=function(o,e,s){if(!nl$1(o))throw Error(p(405));var a=s!=null&&s.hydratedSources||null,d=!1,h="",b=kl$1;if(s!=null&&(s.unstable_strictMode===!0&&(d=!0),s.identifierPrefix!==void 0&&(h=s.identifierPrefix),s.onRecoverableError!==void 0&&(b=s.onRecoverableError)),e=el$1(e,null,o,1,s??null,d,!1,h,b),o[uf$1]=e.current,sf$1(o),a)for(o=0;o<a.length;o++)s=a[o],d=s._getVersion,d=d(s._source),e.mutableSourceEagerHydrationData==null?e.mutableSourceEagerHydrationData=[s,d]:e.mutableSourceEagerHydrationData.push(s,d);return new ml$1(e)};reactDom_production_min.render=function(o,e,s){if(!ol$1(e))throw Error(p(200));return rl$1(null,o,e,!1,s)};reactDom_production_min.unmountComponentAtNode=function(o){if(!ol$1(o))throw Error(p(40));return o._reactRootContainer?(Rk(function(){rl$1(null,null,o,!1,function(){o._reactRootContainer=null,o[uf$1]=null})}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Qk;reactDom_production_min.unstable_renderSubtreeIntoContainer=function(o,e,s,a){if(!ol$1(s))throw Error(p(200));if(o==null||o._reactInternals===void 0)throw Error(p(38));return rl$1(o,e,s,!1,a)};reactDom_production_min.version="18.3.1-next-f1338f8080-20240426";function checkDCE(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)}catch(o){console.error(o)}}checkDCE(),reactDom.exports=reactDom_production_min;var reactDomExports=reactDom.exports;const ReactDOM=getDefaultExportFromCjs(reactDomExports);var m=reactDomExports;client.createRoot=m.createRoot,client.hydrateRoot=m.hydrateRoot;function _getDefaults(){return{async:!1,breaks:!1,extensions:null,gfm:!0,hooks:null,pedantic:!1,renderer:null,silent:!1,tokenizer:null,walkTokens:null}}let _defaults=_getDefaults();function changeDefaults(o){_defaults=o}const escapeTest=/[&<>"']/,escapeReplace=new RegExp(escapeTest.source,"g"),escapeTestNoEncode=/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,escapeReplaceNoEncode=new RegExp(escapeTestNoEncode.source,"g"),escapeReplacements={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},getEscapeReplacement=o=>escapeReplacements[o];function escape$1(o,e){if(e){if(escapeTest.test(o))return o.replace(escapeReplace,getEscapeReplacement)}else if(escapeTestNoEncode.test(o))return o.replace(escapeReplaceNoEncode,getEscapeReplacement);return o}const unescapeTest=/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;function unescape$1(o){return o.replace(unescapeTest,(e,s)=>(s=s.toLowerCase(),s==="colon"?":":s.charAt(0)==="#"?s.charAt(1)==="x"?String.fromCharCode(parseInt(s.substring(2),16)):String.fromCharCode(+s.substring(1)):""))}const caret=/(^|[^\[])\^/g;function edit(o,e){let s=typeof o=="string"?o:o.source;e=e||"";const a={replace:(d,h)=>{let b=typeof h=="string"?h:h.source;return b=b.replace(caret,"$1"),s=s.replace(d,b),a},getRegex:()=>new RegExp(s,e)};return a}function cleanUrl(o){try{o=encodeURI(o).replace(/%25/g,"%")}catch{return null}return o}const noopTest={exec:()=>null};function splitCells(o,e){const s=o.replace(/\|/g,(h,b,et)=>{let st=!1,$=b;for(;--$>=0&&et[$]==="\\";)st=!st;return st?"|":" |"}),a=s.split(/ \|/);let d=0;if(a[0].trim()||a.shift(),a.length>0&&!a[a.length-1].trim()&&a.pop(),e)if(a.length>e)a.splice(e);else for(;a.length<e;)a.push("");for(;d<a.length;d++)a[d]=a[d].trim().replace(/\\\|/g,"|");return a}function rtrim(o,e,s){const a=o.length;if(a===0)return"";let d=0;for(;d<a;){const h=o.charAt(a-d-1);if(h===e&&!s)d++;else if(h!==e&&s)d++;else break}return o.slice(0,a-d)}function findClosingBracket(o,e){if(o.indexOf(e[1])===-1)return-1;let s=0;for(let a=0;a<o.length;a++)if(o[a]==="\\")a++;else if(o[a]===e[0])s++;else if(o[a]===e[1]&&(s--,s<0))return a;return-1}function outputLink(o,e,s,a){const d=e.href,h=e.title?escape$1(e.title):null,b=o[1].replace(/\\([\[\]])/g,"$1");if(o[0].charAt(0)!=="!"){a.state.inLink=!0;const et={type:"link",raw:s,href:d,title:h,text:b,tokens:a.inlineTokens(b)};return a.state.inLink=!1,et}return{type:"image",raw:s,href:d,title:h,text:escape$1(b)}}function indentCodeCompensation(o,e){const s=o.match(/^(\s+)(?:```)/);if(s===null)return e;const a=s[1];return e.split(`
`).map(d=>{const h=d.match(/^\s+/);if(h===null)return d;const[b]=h;return b.length>=a.length?d.slice(a.length):d}).join(`
`)}class _Tokenizer{options;rules;lexer;constructor(e){this.options=e||_defaults}space(e){const s=this.rules.block.newline.exec(e);if(s&&s[0].length>0)return{type:"space",raw:s[0]}}code(e){const s=this.rules.block.code.exec(e);if(s){const a=s[0].replace(/^ {1,4}/gm,"");return{type:"code",raw:s[0],codeBlockStyle:"indented",text:this.options.pedantic?a:rtrim(a,`
`)}}}fences(e){const s=this.rules.block.fences.exec(e);if(s){const a=s[0],d=indentCodeCompensation(a,s[3]||"");return{type:"code",raw:a,lang:s[2]?s[2].trim().replace(this.rules.inline.anyPunctuation,"$1"):s[2],text:d}}}heading(e){const s=this.rules.block.heading.exec(e);if(s){let a=s[2].trim();if(/#$/.test(a)){const d=rtrim(a,"#");(this.options.pedantic||!d||/ $/.test(d))&&(a=d.trim())}return{type:"heading",raw:s[0],depth:s[1].length,text:a,tokens:this.lexer.inline(a)}}}hr(e){const s=this.rules.block.hr.exec(e);if(s)return{type:"hr",raw:s[0]}}blockquote(e){const s=this.rules.block.blockquote.exec(e);if(s){let a=s[0].replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,`
    $1`);a=rtrim(a.replace(/^ *>[ \t]?/gm,""),`
`);const d=this.lexer.state.top;this.lexer.state.top=!0;const h=this.lexer.blockTokens(a);return this.lexer.state.top=d,{type:"blockquote",raw:s[0],tokens:h,text:a}}}list(e){let s=this.rules.block.list.exec(e);if(s){let a=s[1].trim();const d=a.length>1,h={type:"list",raw:"",ordered:d,start:d?+a.slice(0,-1):"",loose:!1,items:[]};a=d?`\\d{1,9}\\${a.slice(-1)}`:`\\${a}`,this.options.pedantic&&(a=d?a:"[*+-]");const b=new RegExp(`^( {0,3}${a})((?:[	 ][^\\n]*)?(?:\\n|$))`);let et="",st="",$=!1;for(;e;){let it=!1;if(!(s=b.exec(e))||this.rules.block.hr.test(e))break;et=s[0],e=e.substring(et.length);let g=s[2].split(`
`,1)[0].replace(/^\t+/,pt=>" ".repeat(3*pt.length)),c=e.split(`
`,1)[0],_=0;this.options.pedantic?(_=2,st=g.trimStart()):(_=s[2].search(/[^ ]/),_=_>4?1:_,st=g.slice(_),_+=s[1].length);let ot=!1;if(!g&&/^ *$/.test(c)&&(et+=c+`
`,e=e.substring(c.length+1),it=!0),!it){const pt=new RegExp(`^ {0,${Math.min(3,_-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),ft=new RegExp(`^ {0,${Math.min(3,_-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),ht=new RegExp(`^ {0,${Math.min(3,_-1)}}(?:\`\`\`|~~~)`),bt=new RegExp(`^ {0,${Math.min(3,_-1)}}#`);for(;e;){const mt=e.split(`
`,1)[0];if(c=mt,this.options.pedantic&&(c=c.replace(/^ {1,4}(?=( {4})*[^ ])/g,"  ")),ht.test(c)||bt.test(c)||pt.test(c)||ft.test(e))break;if(c.search(/[^ ]/)>=_||!c.trim())st+=`
`+c.slice(_);else{if(ot||g.search(/[^ ]/)>=4||ht.test(g)||bt.test(g)||ft.test(g))break;st+=`
`+c}!ot&&!c.trim()&&(ot=!0),et+=mt+`
`,e=e.substring(mt.length+1),g=c.slice(_)}}h.loose||($?h.loose=!0:/\n *\n *$/.test(et)&&($=!0));let ct=null,dt;this.options.gfm&&(ct=/^\[[ xX]\] /.exec(st),ct&&(dt=ct[0]!=="[ ] ",st=st.replace(/^\[[ xX]\] +/,""))),h.items.push({type:"list_item",raw:et,task:!!ct,checked:dt,loose:!1,text:st,tokens:[]}),h.raw+=et}h.items[h.items.length-1].raw=et.trimEnd(),h.items[h.items.length-1].text=st.trimEnd(),h.raw=h.raw.trimEnd();for(let it=0;it<h.items.length;it++)if(this.lexer.state.top=!1,h.items[it].tokens=this.lexer.blockTokens(h.items[it].text,[]),!h.loose){const g=h.items[it].tokens.filter(_=>_.type==="space"),c=g.length>0&&g.some(_=>/\n.*\n/.test(_.raw));h.loose=c}if(h.loose)for(let it=0;it<h.items.length;it++)h.items[it].loose=!0;return h}}html(e){const s=this.rules.block.html.exec(e);if(s)return{type:"html",block:!0,raw:s[0],pre:s[1]==="pre"||s[1]==="script"||s[1]==="style",text:s[0]}}def(e){const s=this.rules.block.def.exec(e);if(s){const a=s[1].toLowerCase().replace(/\s+/g," "),d=s[2]?s[2].replace(/^<(.*)>$/,"$1").replace(this.rules.inline.anyPunctuation,"$1"):"",h=s[3]?s[3].substring(1,s[3].length-1).replace(this.rules.inline.anyPunctuation,"$1"):s[3];return{type:"def",tag:a,raw:s[0],href:d,title:h}}}table(e){const s=this.rules.block.table.exec(e);if(!s||!/[:|]/.test(s[2]))return;const a=splitCells(s[1]),d=s[2].replace(/^\||\| *$/g,"").split("|"),h=s[3]&&s[3].trim()?s[3].replace(/\n[ \t]*$/,"").split(`
`):[],b={type:"table",raw:s[0],header:[],align:[],rows:[]};if(a.length===d.length){for(const et of d)/^ *-+: *$/.test(et)?b.align.push("right"):/^ *:-+: *$/.test(et)?b.align.push("center"):/^ *:-+ *$/.test(et)?b.align.push("left"):b.align.push(null);for(const et of a)b.header.push({text:et,tokens:this.lexer.inline(et)});for(const et of h)b.rows.push(splitCells(et,b.header.length).map(st=>({text:st,tokens:this.lexer.inline(st)})));return b}}lheading(e){const s=this.rules.block.lheading.exec(e);if(s)return{type:"heading",raw:s[0],depth:s[2].charAt(0)==="="?1:2,text:s[1],tokens:this.lexer.inline(s[1])}}paragraph(e){const s=this.rules.block.paragraph.exec(e);if(s){const a=s[1].charAt(s[1].length-1)===`
`?s[1].slice(0,-1):s[1];return{type:"paragraph",raw:s[0],text:a,tokens:this.lexer.inline(a)}}}text(e){const s=this.rules.block.text.exec(e);if(s)return{type:"text",raw:s[0],text:s[0],tokens:this.lexer.inline(s[0])}}escape(e){const s=this.rules.inline.escape.exec(e);if(s)return{type:"escape",raw:s[0],text:escape$1(s[1])}}tag(e){const s=this.rules.inline.tag.exec(e);if(s)return!this.lexer.state.inLink&&/^<a /i.test(s[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&/^<\/a>/i.test(s[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(s[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(s[0])&&(this.lexer.state.inRawBlock=!1),{type:"html",raw:s[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:!1,text:s[0]}}link(e){const s=this.rules.inline.link.exec(e);if(s){const a=s[2].trim();if(!this.options.pedantic&&/^</.test(a)){if(!/>$/.test(a))return;const b=rtrim(a.slice(0,-1),"\\");if((a.length-b.length)%2===0)return}else{const b=findClosingBracket(s[2],"()");if(b>-1){const st=(s[0].indexOf("!")===0?5:4)+s[1].length+b;s[2]=s[2].substring(0,b),s[0]=s[0].substring(0,st).trim(),s[3]=""}}let d=s[2],h="";if(this.options.pedantic){const b=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(d);b&&(d=b[1],h=b[3])}else h=s[3]?s[3].slice(1,-1):"";return d=d.trim(),/^</.test(d)&&(this.options.pedantic&&!/>$/.test(a)?d=d.slice(1):d=d.slice(1,-1)),outputLink(s,{href:d&&d.replace(this.rules.inline.anyPunctuation,"$1"),title:h&&h.replace(this.rules.inline.anyPunctuation,"$1")},s[0],this.lexer)}}reflink(e,s){let a;if((a=this.rules.inline.reflink.exec(e))||(a=this.rules.inline.nolink.exec(e))){const d=(a[2]||a[1]).replace(/\s+/g," "),h=s[d.toLowerCase()];if(!h){const b=a[0].charAt(0);return{type:"text",raw:b,text:b}}return outputLink(a,h,a[0],this.lexer)}}emStrong(e,s,a=""){let d=this.rules.inline.emStrongLDelim.exec(e);if(!d||d[3]&&a.match(/[\p{L}\p{N}]/u))return;if(!(d[1]||d[2]||"")||!a||this.rules.inline.punctuation.exec(a)){const b=[...d[0]].length-1;let et,st,$=b,it=0;const g=d[0][0]==="*"?this.rules.inline.emStrongRDelimAst:this.rules.inline.emStrongRDelimUnd;for(g.lastIndex=0,s=s.slice(-1*e.length+b);(d=g.exec(s))!=null;){if(et=d[1]||d[2]||d[3]||d[4]||d[5]||d[6],!et)continue;if(st=[...et].length,d[3]||d[4]){$+=st;continue}else if((d[5]||d[6])&&b%3&&!((b+st)%3)){it+=st;continue}if($-=st,$>0)continue;st=Math.min(st,st+$+it);const c=[...d[0]][0].length,_=e.slice(0,b+d.index+c+st);if(Math.min(b,st)%2){const ct=_.slice(1,-1);return{type:"em",raw:_,text:ct,tokens:this.lexer.inlineTokens(ct)}}const ot=_.slice(2,-2);return{type:"strong",raw:_,text:ot,tokens:this.lexer.inlineTokens(ot)}}}}codespan(e){const s=this.rules.inline.code.exec(e);if(s){let a=s[2].replace(/\n/g," ");const d=/[^ ]/.test(a),h=/^ /.test(a)&&/ $/.test(a);return d&&h&&(a=a.substring(1,a.length-1)),a=escape$1(a,!0),{type:"codespan",raw:s[0],text:a}}}br(e){const s=this.rules.inline.br.exec(e);if(s)return{type:"br",raw:s[0]}}del(e){const s=this.rules.inline.del.exec(e);if(s)return{type:"del",raw:s[0],text:s[2],tokens:this.lexer.inlineTokens(s[2])}}autolink(e){const s=this.rules.inline.autolink.exec(e);if(s){let a,d;return s[2]==="@"?(a=escape$1(s[1]),d="mailto:"+a):(a=escape$1(s[1]),d=a),{type:"link",raw:s[0],text:a,href:d,tokens:[{type:"text",raw:a,text:a}]}}}url(e){let s;if(s=this.rules.inline.url.exec(e)){let a,d;if(s[2]==="@")a=escape$1(s[0]),d="mailto:"+a;else{let h;do h=s[0],s[0]=this.rules.inline._backpedal.exec(s[0])?.[0]??"";while(h!==s[0]);a=escape$1(s[0]),s[1]==="www."?d="http://"+s[0]:d=s[0]}return{type:"link",raw:s[0],text:a,href:d,tokens:[{type:"text",raw:a,text:a}]}}}inlineText(e){const s=this.rules.inline.text.exec(e);if(s){let a;return this.lexer.state.inRawBlock?a=s[0]:a=escape$1(s[0]),{type:"text",raw:s[0],text:a}}}}const newline=/^(?: *(?:\n|$))+/,blockCode=/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,fences=/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,hr$1=/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,heading=/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,bullet=/(?:[*+-]|\d{1,9}[.)])/,lheading=edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g,bullet).replace(/blockCode/g,/ {4}/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).getRegex(),_paragraph=/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,blockText=/^[^\n]+/,_blockLabel=/(?!\s*\])(?:\\.|[^\[\]\\])+/,def=edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label",_blockLabel).replace("title",/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(),list=edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g,bullet).getRegex(),_tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",_comment=/<!--(?:-?>|[\s\S]*?(?:-->|$))/,html=edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))","i").replace("comment",_comment).replace("tag",_tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),paragraph=edit(_paragraph).replace("hr",hr$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",_tag).getRegex(),blockquote=edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph",paragraph).getRegex(),blockNormal={blockquote,code:blockCode,def,fences,heading,hr:hr$1,html,lheading,list,newline,paragraph,table:noopTest,text:blockText},gfmTable=edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr",hr$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("blockquote"," {0,3}>").replace("code"," {4}[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",_tag).getRegex(),blockGfm={...blockNormal,table:gfmTable,paragraph:edit(_paragraph).replace("hr",hr$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("table",gfmTable).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",_tag).getRegex()},blockPedantic={...blockNormal,html:edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",_comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:noopTest,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:edit(_paragraph).replace("hr",hr$1).replace("heading",` *#{1,6} *[^
]`).replace("lheading",lheading).replace("|table","").replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").replace("|tag","").getRegex()},escape=/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,inlineCode=/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br=/^( {2,}|\\)\n(?!\s*$)/,inlineText=/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,_punctuation="\\p{P}\\p{S}",punctuation=edit(/^((?![*_])[\spunctuation])/,"u").replace(/punctuation/g,_punctuation).getRegex(),blockSkip=/\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g,emStrongLDelim=edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,"u").replace(/punct/g,_punctuation).getRegex(),emStrongRDelimAst=edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])","gu").replace(/punct/g,_punctuation).getRegex(),emStrongRDelimUnd=edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])","gu").replace(/punct/g,_punctuation).getRegex(),anyPunctuation=edit(/\\([punct])/,"gu").replace(/punct/g,_punctuation).getRegex(),autolink=edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme",/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email",/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),_inlineComment=edit(_comment).replace("(?:-->|$)","-->").getRegex(),tag=edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment",_inlineComment).replace("attribute",/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(),_inlineLabel=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,link=edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label",_inlineLabel).replace("href",/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title",/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(),reflink=edit(/^!?\[(label)\]\[(ref)\]/).replace("label",_inlineLabel).replace("ref",_blockLabel).getRegex(),nolink=edit(/^!?\[(ref)\](?:\[\])?/).replace("ref",_blockLabel).getRegex(),reflinkSearch=edit("reflink|nolink(?!\\()","g").replace("reflink",reflink).replace("nolink",nolink).getRegex(),inlineNormal={_backpedal:noopTest,anyPunctuation,autolink,blockSkip,br,code:inlineCode,del:noopTest,emStrongLDelim,emStrongRDelimAst,emStrongRDelimUnd,escape,link,nolink,punctuation,reflink,reflinkSearch,tag,text:inlineText,url:noopTest},inlinePedantic={...inlineNormal,link:edit(/^!?\[(label)\]\((.*?)\)/).replace("label",_inlineLabel).getRegex(),reflink:edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",_inlineLabel).getRegex()},inlineGfm={...inlineNormal,escape:edit(escape).replace("])","~|])").getRegex(),url:edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,"i").replace("email",/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/},inlineBreaks={...inlineGfm,br:edit(br).replace("{2,}","*").getRegex(),text:edit(inlineGfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()},block={normal:blockNormal,gfm:blockGfm,pedantic:blockPedantic},inline={normal:inlineNormal,gfm:inlineGfm,breaks:inlineBreaks,pedantic:inlinePedantic};class _Lexer{tokens;options;state;tokenizer;inlineQueue;constructor(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||_defaults,this.options.tokenizer=this.options.tokenizer||new _Tokenizer,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};const s={block:block.normal,inline:inline.normal};this.options.pedantic?(s.block=block.pedantic,s.inline=inline.pedantic):this.options.gfm&&(s.block=block.gfm,this.options.breaks?s.inline=inline.breaks:s.inline=inline.gfm),this.tokenizer.rules=s}static get rules(){return{block,inline}}static lex(e,s){return new _Lexer(s).lex(e)}static lexInline(e,s){return new _Lexer(s).inlineTokens(e)}lex(e){e=e.replace(/\r\n|\r/g,`
`),this.blockTokens(e,this.tokens);for(let s=0;s<this.inlineQueue.length;s++){const a=this.inlineQueue[s];this.inlineTokens(a.src,a.tokens)}return this.inlineQueue=[],this.tokens}blockTokens(e,s=[]){this.options.pedantic?e=e.replace(/\t/g,"    ").replace(/^ +$/gm,""):e=e.replace(/^( *)(\t+)/gm,(et,st,$)=>st+"    ".repeat($.length));let a,d,h,b;for(;e;)if(!(this.options.extensions&&this.options.extensions.block&&this.options.extensions.block.some(et=>(a=et.call({lexer:this},e,s))?(e=e.substring(a.raw.length),s.push(a),!0):!1))){if(a=this.tokenizer.space(e)){e=e.substring(a.raw.length),a.raw.length===1&&s.length>0?s[s.length-1].raw+=`
`:s.push(a);continue}if(a=this.tokenizer.code(e)){e=e.substring(a.raw.length),d=s[s.length-1],d&&(d.type==="paragraph"||d.type==="text")?(d.raw+=`
`+a.raw,d.text+=`
`+a.text,this.inlineQueue[this.inlineQueue.length-1].src=d.text):s.push(a);continue}if(a=this.tokenizer.fences(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.heading(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.hr(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.blockquote(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.list(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.html(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.def(e)){e=e.substring(a.raw.length),d=s[s.length-1],d&&(d.type==="paragraph"||d.type==="text")?(d.raw+=`
`+a.raw,d.text+=`
`+a.raw,this.inlineQueue[this.inlineQueue.length-1].src=d.text):this.tokens.links[a.tag]||(this.tokens.links[a.tag]={href:a.href,title:a.title});continue}if(a=this.tokenizer.table(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.lheading(e)){e=e.substring(a.raw.length),s.push(a);continue}if(h=e,this.options.extensions&&this.options.extensions.startBlock){let et=1/0;const st=e.slice(1);let $;this.options.extensions.startBlock.forEach(it=>{$=it.call({lexer:this},st),typeof $=="number"&&$>=0&&(et=Math.min(et,$))}),et<1/0&&et>=0&&(h=e.substring(0,et+1))}if(this.state.top&&(a=this.tokenizer.paragraph(h))){d=s[s.length-1],b&&d.type==="paragraph"?(d.raw+=`
`+a.raw,d.text+=`
`+a.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=d.text):s.push(a),b=h.length!==e.length,e=e.substring(a.raw.length);continue}if(a=this.tokenizer.text(e)){e=e.substring(a.raw.length),d=s[s.length-1],d&&d.type==="text"?(d.raw+=`
`+a.raw,d.text+=`
`+a.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=d.text):s.push(a);continue}if(e){const et="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(et);break}else throw new Error(et)}}return this.state.top=!0,s}inline(e,s=[]){return this.inlineQueue.push({src:e,tokens:s}),s}inlineTokens(e,s=[]){let a,d,h,b=e,et,st,$;if(this.tokens.links){const it=Object.keys(this.tokens.links);if(it.length>0)for(;(et=this.tokenizer.rules.inline.reflinkSearch.exec(b))!=null;)it.includes(et[0].slice(et[0].lastIndexOf("[")+1,-1))&&(b=b.slice(0,et.index)+"["+"a".repeat(et[0].length-2)+"]"+b.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;(et=this.tokenizer.rules.inline.blockSkip.exec(b))!=null;)b=b.slice(0,et.index)+"["+"a".repeat(et[0].length-2)+"]"+b.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;(et=this.tokenizer.rules.inline.anyPunctuation.exec(b))!=null;)b=b.slice(0,et.index)+"++"+b.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);for(;e;)if(st||($=""),st=!1,!(this.options.extensions&&this.options.extensions.inline&&this.options.extensions.inline.some(it=>(a=it.call({lexer:this},e,s))?(e=e.substring(a.raw.length),s.push(a),!0):!1))){if(a=this.tokenizer.escape(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.tag(e)){e=e.substring(a.raw.length),d=s[s.length-1],d&&a.type==="text"&&d.type==="text"?(d.raw+=a.raw,d.text+=a.text):s.push(a);continue}if(a=this.tokenizer.link(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.reflink(e,this.tokens.links)){e=e.substring(a.raw.length),d=s[s.length-1],d&&a.type==="text"&&d.type==="text"?(d.raw+=a.raw,d.text+=a.text):s.push(a);continue}if(a=this.tokenizer.emStrong(e,b,$)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.codespan(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.br(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.del(e)){e=e.substring(a.raw.length),s.push(a);continue}if(a=this.tokenizer.autolink(e)){e=e.substring(a.raw.length),s.push(a);continue}if(!this.state.inLink&&(a=this.tokenizer.url(e))){e=e.substring(a.raw.length),s.push(a);continue}if(h=e,this.options.extensions&&this.options.extensions.startInline){let it=1/0;const g=e.slice(1);let c;this.options.extensions.startInline.forEach(_=>{c=_.call({lexer:this},g),typeof c=="number"&&c>=0&&(it=Math.min(it,c))}),it<1/0&&it>=0&&(h=e.substring(0,it+1))}if(a=this.tokenizer.inlineText(h)){e=e.substring(a.raw.length),a.raw.slice(-1)!=="_"&&($=a.raw.slice(-1)),st=!0,d=s[s.length-1],d&&d.type==="text"?(d.raw+=a.raw,d.text+=a.text):s.push(a);continue}if(e){const it="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(it);break}else throw new Error(it)}}return s}}class _Renderer{options;constructor(e){this.options=e||_defaults}code(e,s,a){const d=(s||"").match(/^\S*/)?.[0];return e=e.replace(/\n$/,"")+`
`,d?'<pre><code class="language-'+escape$1(d)+'">'+(a?e:escape$1(e,!0))+`</code></pre>
`:"<pre><code>"+(a?e:escape$1(e,!0))+`</code></pre>
`}blockquote(e){return`<blockquote>
${e}</blockquote>
`}html(e,s){return e}heading(e,s,a){return`<h${s}>${e}</h${s}>
`}hr(){return`<hr>
`}list(e,s,a){const d=s?"ol":"ul",h=s&&a!==1?' start="'+a+'"':"";return"<"+d+h+`>
`+e+"</"+d+`>
`}listitem(e,s,a){return`<li>${e}</li>
`}checkbox(e){return"<input "+(e?'checked="" ':"")+'disabled="" type="checkbox">'}paragraph(e){return`<p>${e}</p>
`}table(e,s){return s&&(s=`<tbody>${s}</tbody>`),`<table>
<thead>
`+e+`</thead>
`+s+`</table>
`}tablerow(e){return`<tr>
${e}</tr>
`}tablecell(e,s){const a=s.header?"th":"td";return(s.align?`<${a} align="${s.align}">`:`<${a}>`)+e+`</${a}>
`}strong(e){return`<strong>${e}</strong>`}em(e){return`<em>${e}</em>`}codespan(e){return`<code>${e}</code>`}br(){return"<br>"}del(e){return`<del>${e}</del>`}link(e,s,a){const d=cleanUrl(e);if(d===null)return a;e=d;let h='<a href="'+e+'"';return s&&(h+=' title="'+s+'"'),h+=">"+a+"</a>",h}image(e,s,a){const d=cleanUrl(e);if(d===null)return a;e=d;let h=`<img src="${e}" alt="${a}"`;return s&&(h+=` title="${s}"`),h+=">",h}text(e){return e}}class _TextRenderer{strong(e){return e}em(e){return e}codespan(e){return e}del(e){return e}html(e){return e}text(e){return e}link(e,s,a){return""+a}image(e,s,a){return""+a}br(){return""}}class _Parser{options;renderer;textRenderer;constructor(e){this.options=e||_defaults,this.options.renderer=this.options.renderer||new _Renderer,this.renderer=this.options.renderer,this.renderer.options=this.options,this.textRenderer=new _TextRenderer}static parse(e,s){return new _Parser(s).parse(e)}static parseInline(e,s){return new _Parser(s).parseInline(e)}parse(e,s=!0){let a="";for(let d=0;d<e.length;d++){const h=e[d];if(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[h.type]){const b=h,et=this.options.extensions.renderers[b.type].call({parser:this},b);if(et!==!1||!["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(b.type)){a+=et||"";continue}}switch(h.type){case"space":continue;case"hr":{a+=this.renderer.hr();continue}case"heading":{const b=h;a+=this.renderer.heading(this.parseInline(b.tokens),b.depth,unescape$1(this.parseInline(b.tokens,this.textRenderer)));continue}case"code":{const b=h;a+=this.renderer.code(b.text,b.lang,!!b.escaped);continue}case"table":{const b=h;let et="",st="";for(let it=0;it<b.header.length;it++)st+=this.renderer.tablecell(this.parseInline(b.header[it].tokens),{header:!0,align:b.align[it]});et+=this.renderer.tablerow(st);let $="";for(let it=0;it<b.rows.length;it++){const g=b.rows[it];st="";for(let c=0;c<g.length;c++)st+=this.renderer.tablecell(this.parseInline(g[c].tokens),{header:!1,align:b.align[c]});$+=this.renderer.tablerow(st)}a+=this.renderer.table(et,$);continue}case"blockquote":{const b=h,et=this.parse(b.tokens);a+=this.renderer.blockquote(et);continue}case"list":{const b=h,et=b.ordered,st=b.start,$=b.loose;let it="";for(let g=0;g<b.items.length;g++){const c=b.items[g],_=c.checked,ot=c.task;let ct="";if(c.task){const dt=this.renderer.checkbox(!!_);$?c.tokens.length>0&&c.tokens[0].type==="paragraph"?(c.tokens[0].text=dt+" "+c.tokens[0].text,c.tokens[0].tokens&&c.tokens[0].tokens.length>0&&c.tokens[0].tokens[0].type==="text"&&(c.tokens[0].tokens[0].text=dt+" "+c.tokens[0].tokens[0].text)):c.tokens.unshift({type:"text",text:dt+" "}):ct+=dt+" "}ct+=this.parse(c.tokens,$),it+=this.renderer.listitem(ct,ot,!!_)}a+=this.renderer.list(it,et,st);continue}case"html":{const b=h;a+=this.renderer.html(b.text,b.block);continue}case"paragraph":{const b=h;a+=this.renderer.paragraph(this.parseInline(b.tokens));continue}case"text":{let b=h,et=b.tokens?this.parseInline(b.tokens):b.text;for(;d+1<e.length&&e[d+1].type==="text";)b=e[++d],et+=`
`+(b.tokens?this.parseInline(b.tokens):b.text);a+=s?this.renderer.paragraph(et):et;continue}default:{const b='Token with "'+h.type+'" type was not found.';if(this.options.silent)return console.error(b),"";throw new Error(b)}}}return a}parseInline(e,s){s=s||this.renderer;let a="";for(let d=0;d<e.length;d++){const h=e[d];if(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[h.type]){const b=this.options.extensions.renderers[h.type].call({parser:this},h);if(b!==!1||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(h.type)){a+=b||"";continue}}switch(h.type){case"escape":{const b=h;a+=s.text(b.text);break}case"html":{const b=h;a+=s.html(b.text);break}case"link":{const b=h;a+=s.link(b.href,b.title,this.parseInline(b.tokens,s));break}case"image":{const b=h;a+=s.image(b.href,b.title,b.text);break}case"strong":{const b=h;a+=s.strong(this.parseInline(b.tokens,s));break}case"em":{const b=h;a+=s.em(this.parseInline(b.tokens,s));break}case"codespan":{const b=h;a+=s.codespan(b.text);break}case"br":{a+=s.br();break}case"del":{const b=h;a+=s.del(this.parseInline(b.tokens,s));break}case"text":{const b=h;a+=s.text(b.text);break}default:{const b='Token with "'+h.type+'" type was not found.';if(this.options.silent)return console.error(b),"";throw new Error(b)}}}return a}}class _Hooks{options;constructor(e){this.options=e||_defaults}static passThroughHooks=new Set(["preprocess","postprocess","processAllTokens"]);preprocess(e){return e}postprocess(e){return e}processAllTokens(e){return e}}class Marked{defaults=_getDefaults();options=this.setOptions;parse=this.#e(_Lexer.lex,_Parser.parse);parseInline=this.#e(_Lexer.lexInline,_Parser.parseInline);Parser=_Parser;Renderer=_Renderer;TextRenderer=_TextRenderer;Lexer=_Lexer;Tokenizer=_Tokenizer;Hooks=_Hooks;constructor(...e){this.use(...e)}walkTokens(e,s){let a=[];for(const d of e)switch(a=a.concat(s.call(this,d)),d.type){case"table":{const h=d;for(const b of h.header)a=a.concat(this.walkTokens(b.tokens,s));for(const b of h.rows)for(const et of b)a=a.concat(this.walkTokens(et.tokens,s));break}case"list":{const h=d;a=a.concat(this.walkTokens(h.items,s));break}default:{const h=d;this.defaults.extensions?.childTokens?.[h.type]?this.defaults.extensions.childTokens[h.type].forEach(b=>{const et=h[b].flat(1/0);a=a.concat(this.walkTokens(et,s))}):h.tokens&&(a=a.concat(this.walkTokens(h.tokens,s)))}}return a}use(...e){const s=this.defaults.extensions||{renderers:{},childTokens:{}};return e.forEach(a=>{const d={...a};if(d.async=this.defaults.async||d.async||!1,a.extensions&&(a.extensions.forEach(h=>{if(!h.name)throw new Error("extension name required");if("renderer"in h){const b=s.renderers[h.name];b?s.renderers[h.name]=function(...et){let st=h.renderer.apply(this,et);return st===!1&&(st=b.apply(this,et)),st}:s.renderers[h.name]=h.renderer}if("tokenizer"in h){if(!h.level||h.level!=="block"&&h.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");const b=s[h.level];b?b.unshift(h.tokenizer):s[h.level]=[h.tokenizer],h.start&&(h.level==="block"?s.startBlock?s.startBlock.push(h.start):s.startBlock=[h.start]:h.level==="inline"&&(s.startInline?s.startInline.push(h.start):s.startInline=[h.start]))}"childTokens"in h&&h.childTokens&&(s.childTokens[h.name]=h.childTokens)}),d.extensions=s),a.renderer){const h=this.defaults.renderer||new _Renderer(this.defaults);for(const b in a.renderer){if(!(b in h))throw new Error(`renderer '${b}' does not exist`);if(b==="options")continue;const et=b,st=a.renderer[et],$=h[et];h[et]=(...it)=>{let g=st.apply(h,it);return g===!1&&(g=$.apply(h,it)),g||""}}d.renderer=h}if(a.tokenizer){const h=this.defaults.tokenizer||new _Tokenizer(this.defaults);for(const b in a.tokenizer){if(!(b in h))throw new Error(`tokenizer '${b}' does not exist`);if(["options","rules","lexer"].includes(b))continue;const et=b,st=a.tokenizer[et],$=h[et];h[et]=(...it)=>{let g=st.apply(h,it);return g===!1&&(g=$.apply(h,it)),g}}d.tokenizer=h}if(a.hooks){const h=this.defaults.hooks||new _Hooks;for(const b in a.hooks){if(!(b in h))throw new Error(`hook '${b}' does not exist`);if(b==="options")continue;const et=b,st=a.hooks[et],$=h[et];_Hooks.passThroughHooks.has(b)?h[et]=it=>{if(this.defaults.async)return Promise.resolve(st.call(h,it)).then(c=>$.call(h,c));const g=st.call(h,it);return $.call(h,g)}:h[et]=(...it)=>{let g=st.apply(h,it);return g===!1&&(g=$.apply(h,it)),g}}d.hooks=h}if(a.walkTokens){const h=this.defaults.walkTokens,b=a.walkTokens;d.walkTokens=function(et){let st=[];return st.push(b.call(this,et)),h&&(st=st.concat(h.call(this,et))),st}}this.defaults={...this.defaults,...d}}),this}setOptions(e){return this.defaults={...this.defaults,...e},this}lexer(e,s){return _Lexer.lex(e,s??this.defaults)}parser(e,s){return _Parser.parse(e,s??this.defaults)}#e(e,s){return(a,d)=>{const h={...d},b={...this.defaults,...h};this.defaults.async===!0&&h.async===!1&&(b.silent||console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored."),b.async=!0);const et=this.#t(!!b.silent,!!b.async);if(typeof a>"u"||a===null)return et(new Error("marked(): input parameter is undefined or null"));if(typeof a!="string")return et(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(a)+", string expected"));if(b.hooks&&(b.hooks.options=b),b.async)return Promise.resolve(b.hooks?b.hooks.preprocess(a):a).then(st=>e(st,b)).then(st=>b.hooks?b.hooks.processAllTokens(st):st).then(st=>b.walkTokens?Promise.all(this.walkTokens(st,b.walkTokens)).then(()=>st):st).then(st=>s(st,b)).then(st=>b.hooks?b.hooks.postprocess(st):st).catch(et);try{b.hooks&&(a=b.hooks.preprocess(a));let st=e(a,b);b.hooks&&(st=b.hooks.processAllTokens(st)),b.walkTokens&&this.walkTokens(st,b.walkTokens);let $=s(st,b);return b.hooks&&($=b.hooks.postprocess($)),$}catch(st){return et(st)}}}#t(e,s){return a=>{if(a.message+=`
Please report this to https://github.com/markedjs/marked.`,e){const d="<p>An error occurred:</p><pre>"+escape$1(a.message+"",!0)+"</pre>";return s?Promise.resolve(d):d}if(s)return Promise.reject(a);throw a}}}const markedInstance=new Marked;function marked(o,e){return markedInstance.parse(o,e)}marked.options=marked.setOptions=function(o){return markedInstance.setOptions(o),marked.defaults=markedInstance.defaults,changeDefaults(marked.defaults),marked};marked.getDefaults=_getDefaults;marked.defaults=_defaults;marked.use=function(...o){return markedInstance.use(...o),marked.defaults=markedInstance.defaults,changeDefaults(marked.defaults),marked};marked.walkTokens=function(o,e){return markedInstance.walkTokens(o,e)};marked.parseInline=markedInstance.parseInline;marked.Parser=_Parser;marked.parser=_Parser.parse;marked.Renderer=_Renderer;marked.TextRenderer=_TextRenderer;marked.Lexer=_Lexer;marked.lexer=_Lexer.lex;marked.Tokenizer=_Tokenizer;marked.Hooks=_Hooks;marked.parse=marked;marked.options;marked.setOptions;marked.use;marked.walkTokens;marked.parseInline;_Parser.parse;_Lexer.lex;var byteToHex=[];for(var i=0;i<256;++i)byteToHex.push((i+256).toString(16).slice(1));function unsafeStringify(o,e=0){return(byteToHex[o[e+0]]+byteToHex[o[e+1]]+byteToHex[o[e+2]]+byteToHex[o[e+3]]+"-"+byteToHex[o[e+4]]+byteToHex[o[e+5]]+"-"+byteToHex[o[e+6]]+byteToHex[o[e+7]]+"-"+byteToHex[o[e+8]]+byteToHex[o[e+9]]+"-"+byteToHex[o[e+10]]+byteToHex[o[e+11]]+byteToHex[o[e+12]]+byteToHex[o[e+13]]+byteToHex[o[e+14]]+byteToHex[o[e+15]]).toLowerCase()}var getRandomValues,rnds8=new Uint8Array(16);function rng(){if(!getRandomValues&&(getRandomValues=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!getRandomValues))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return getRandomValues(rnds8)}var randomUUID=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);const native={randomUUID};function v4(o,e,s){if(native.randomUUID&&!e&&!o)return native.randomUUID();o=o||{};var a=o.random||(o.rng||rng)();return a[6]=a[6]&15|64,a[8]=a[8]&63|128,unsafeStringify(a)}const generatePrompt=(o,e)=>`<|system|>
${e}<|end|>
<|user|>
${o}<|end|>
<|assistant|>
`,token_to_text=(o,e,s,a)=>o.decode(e.slice(s),{skip_special_tokens:a.show_special!=1});function findJsonInString(o){const e=o.match(/\{[^]*?\}/);if(e)try{return JSON.parse(e[0])}catch(s){return console.error("Error parsing JSON:",s),null}else return console.error("No JSON object found in the input string."),null}function extractJsonString(o){const e=/```json\s*([\s\S]*?)\s*```/,s=o.match(e);try{if(s&&s[1]){const a=s[1];return JSON.parse(a)}else return JSON.parse(o)}catch{const d=findJsonInString(o);if(d)return d}}function bind(o,e){return function(){return o.apply(e,arguments)}}const{toString}=Object.prototype,{getPrototypeOf}=Object,kindOf=(o=>e=>{const s=toString.call(e);return o[s]||(o[s]=s.slice(8,-1).toLowerCase())})(Object.create(null)),kindOfTest=o=>(o=o.toLowerCase(),e=>kindOf(e)===o),typeOfTest=o=>e=>typeof e===o,{isArray}=Array,isUndefined=typeOfTest("undefined");function isBuffer(o){return o!==null&&!isUndefined(o)&&o.constructor!==null&&!isUndefined(o.constructor)&&isFunction(o.constructor.isBuffer)&&o.constructor.isBuffer(o)}const isArrayBuffer=kindOfTest("ArrayBuffer");function isArrayBufferView(o){let e;return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?e=ArrayBuffer.isView(o):e=o&&o.buffer&&isArrayBuffer(o.buffer),e}const isString=typeOfTest("string"),isFunction=typeOfTest("function"),isNumber=typeOfTest("number"),isObject=o=>o!==null&&typeof o=="object",isBoolean=o=>o===!0||o===!1,isPlainObject=o=>{if(kindOf(o)!=="object")return!1;const e=getPrototypeOf(o);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in o)&&!(Symbol.iterator in o)},isDate=kindOfTest("Date"),isFile=kindOfTest("File"),isBlob=kindOfTest("Blob"),isFileList=kindOfTest("FileList"),isStream=o=>isObject(o)&&isFunction(o.pipe),isFormData=o=>{let e;return o&&(typeof FormData=="function"&&o instanceof FormData||isFunction(o.append)&&((e=kindOf(o))==="formdata"||e==="object"&&isFunction(o.toString)&&o.toString()==="[object FormData]"))},isURLSearchParams=kindOfTest("URLSearchParams"),[isReadableStream,isRequest,isResponse,isHeaders]=["ReadableStream","Request","Response","Headers"].map(kindOfTest),trim=o=>o.trim?o.trim():o.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"");function forEach(o,e,{allOwnKeys:s=!1}={}){if(o===null||typeof o>"u")return;let a,d;if(typeof o!="object"&&(o=[o]),isArray(o))for(a=0,d=o.length;a<d;a++)e.call(null,o[a],a,o);else{const h=s?Object.getOwnPropertyNames(o):Object.keys(o),b=h.length;let et;for(a=0;a<b;a++)et=h[a],e.call(null,o[et],et,o)}}function findKey(o,e){e=e.toLowerCase();const s=Object.keys(o);let a=s.length,d;for(;a-- >0;)if(d=s[a],e===d.toLowerCase())return d;return null}const _global=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:global,isContextDefined=o=>!isUndefined(o)&&o!==_global;function merge(){const{caseless:o}=isContextDefined(this)&&this||{},e={},s=(a,d)=>{const h=o&&findKey(e,d)||d;isPlainObject(e[h])&&isPlainObject(a)?e[h]=merge(e[h],a):isPlainObject(a)?e[h]=merge({},a):isArray(a)?e[h]=a.slice():e[h]=a};for(let a=0,d=arguments.length;a<d;a++)arguments[a]&&forEach(arguments[a],s);return e}const extend=(o,e,s,{allOwnKeys:a}={})=>(forEach(e,(d,h)=>{s&&isFunction(d)?o[h]=bind(d,s):o[h]=d},{allOwnKeys:a}),o),stripBOM=o=>(o.charCodeAt(0)===65279&&(o=o.slice(1)),o),inherits=(o,e,s,a)=>{o.prototype=Object.create(e.prototype,a),o.prototype.constructor=o,Object.defineProperty(o,"super",{value:e.prototype}),s&&Object.assign(o.prototype,s)},toFlatObject=(o,e,s,a)=>{let d,h,b;const et={};if(e=e||{},o==null)return e;do{for(d=Object.getOwnPropertyNames(o),h=d.length;h-- >0;)b=d[h],(!a||a(b,o,e))&&!et[b]&&(e[b]=o[b],et[b]=!0);o=s!==!1&&getPrototypeOf(o)}while(o&&(!s||s(o,e))&&o!==Object.prototype);return e},endsWith=(o,e,s)=>{o=String(o),(s===void 0||s>o.length)&&(s=o.length),s-=e.length;const a=o.indexOf(e,s);return a!==-1&&a===s},toArray=o=>{if(!o)return null;if(isArray(o))return o;let e=o.length;if(!isNumber(e))return null;const s=new Array(e);for(;e-- >0;)s[e]=o[e];return s},isTypedArray$1=(o=>e=>o&&e instanceof o)(typeof Uint8Array<"u"&&getPrototypeOf(Uint8Array)),forEachEntry=(o,e)=>{const a=(o&&o[Symbol.iterator]).call(o);let d;for(;(d=a.next())&&!d.done;){const h=d.value;e.call(o,h[0],h[1])}},matchAll=(o,e)=>{let s;const a=[];for(;(s=o.exec(e))!==null;)a.push(s);return a},isHTMLForm=kindOfTest("HTMLFormElement"),toCamelCase=o=>o.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,function(s,a,d){return a.toUpperCase()+d}),hasOwnProperty=(({hasOwnProperty:o})=>(e,s)=>o.call(e,s))(Object.prototype),isRegExp=kindOfTest("RegExp"),reduceDescriptors=(o,e)=>{const s=Object.getOwnPropertyDescriptors(o),a={};forEach(s,(d,h)=>{let b;(b=e(d,h,o))!==!1&&(a[h]=b||d)}),Object.defineProperties(o,a)},freezeMethods=o=>{reduceDescriptors(o,(e,s)=>{if(isFunction(o)&&["arguments","caller","callee"].indexOf(s)!==-1)return!1;const a=o[s];if(isFunction(a)){if(e.enumerable=!1,"writable"in e){e.writable=!1;return}e.set||(e.set=()=>{throw Error("Can not rewrite read-only method '"+s+"'")})}})},toObjectSet=(o,e)=>{const s={},a=d=>{d.forEach(h=>{s[h]=!0})};return isArray(o)?a(o):a(String(o).split(e)),s},noop=()=>{},toFiniteNumber=(o,e)=>o!=null&&Number.isFinite(o=+o)?o:e,ALPHA="abcdefghijklmnopqrstuvwxyz",DIGIT="0123456789",ALPHABET={DIGIT,ALPHA,ALPHA_DIGIT:ALPHA+ALPHA.toUpperCase()+DIGIT},generateString=(o=16,e=ALPHABET.ALPHA_DIGIT)=>{let s="";const{length:a}=e;for(;o--;)s+=e[Math.random()*a|0];return s};function isSpecCompliantForm(o){return!!(o&&isFunction(o.append)&&o[Symbol.toStringTag]==="FormData"&&o[Symbol.iterator])}const toJSONObject=o=>{const e=new Array(10),s=(a,d)=>{if(isObject(a)){if(e.indexOf(a)>=0)return;if(!("toJSON"in a)){e[d]=a;const h=isArray(a)?[]:{};return forEach(a,(b,et)=>{const st=s(b,d+1);!isUndefined(st)&&(h[et]=st)}),e[d]=void 0,h}}return a};return s(o,0)},isAsyncFn=kindOfTest("AsyncFunction"),isThenable=o=>o&&(isObject(o)||isFunction(o))&&isFunction(o.then)&&isFunction(o.catch),_setImmediate=((o,e)=>o?setImmediate:e?((s,a)=>(_global.addEventListener("message",({source:d,data:h})=>{d===_global&&h===s&&a.length&&a.shift()()},!1),d=>{a.push(d),_global.postMessage(s,"*")}))(`axios@${Math.random()}`,[]):s=>setTimeout(s))(typeof setImmediate=="function",isFunction(_global.postMessage)),asap=typeof queueMicrotask<"u"?queueMicrotask.bind(_global):typeof process<"u"&&process.nextTick||_setImmediate,utils$1={isArray,isArrayBuffer,isBuffer,isFormData,isArrayBufferView,isString,isNumber,isBoolean,isObject,isPlainObject,isReadableStream,isRequest,isResponse,isHeaders,isUndefined,isDate,isFile,isBlob,isRegExp,isFunction,isStream,isURLSearchParams,isTypedArray:isTypedArray$1,isFileList,forEach,merge,extend,trim,stripBOM,inherits,toFlatObject,kindOf,kindOfTest,endsWith,toArray,forEachEntry,matchAll,isHTMLForm,hasOwnProperty,hasOwnProp:hasOwnProperty,reduceDescriptors,freezeMethods,toObjectSet,toCamelCase,noop,toFiniteNumber,findKey,global:_global,isContextDefined,ALPHABET,generateString,isSpecCompliantForm,toJSONObject,isAsyncFn,isThenable,setImmediate:_setImmediate,asap};function AxiosError(o,e,s,a,d){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack,this.message=o,this.name="AxiosError",e&&(this.code=e),s&&(this.config=s),a&&(this.request=a),d&&(this.response=d)}utils$1.inherits(AxiosError,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:utils$1.toJSONObject(this.config),code:this.code,status:this.response&&this.response.status?this.response.status:null}}});const prototype$1=AxiosError.prototype,descriptors={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach(o=>{descriptors[o]={value:o}});Object.defineProperties(AxiosError,descriptors);Object.defineProperty(prototype$1,"isAxiosError",{value:!0});AxiosError.from=(o,e,s,a,d,h)=>{const b=Object.create(prototype$1);return utils$1.toFlatObject(o,b,function(st){return st!==Error.prototype},et=>et!=="isAxiosError"),AxiosError.call(b,o.message,e,s,a,d),b.cause=o,b.name=o.name,h&&Object.assign(b,h),b};const httpAdapter=null;function isVisitable(o){return utils$1.isPlainObject(o)||utils$1.isArray(o)}function removeBrackets(o){return utils$1.endsWith(o,"[]")?o.slice(0,-2):o}function renderKey(o,e,s){return o?o.concat(e).map(function(d,h){return d=removeBrackets(d),!s&&h?"["+d+"]":d}).join(s?".":""):e}function isFlatArray(o){return utils$1.isArray(o)&&!o.some(isVisitable)}const predicates=utils$1.toFlatObject(utils$1,{},null,function(e){return/^is[A-Z]/.test(e)});function toFormData(o,e,s){if(!utils$1.isObject(o))throw new TypeError("target must be an object");e=e||new FormData,s=utils$1.toFlatObject(s,{metaTokens:!0,dots:!1,indexes:!1},!1,function(ct,dt){return!utils$1.isUndefined(dt[ct])});const a=s.metaTokens,d=s.visitor||it,h=s.dots,b=s.indexes,st=(s.Blob||typeof Blob<"u"&&Blob)&&utils$1.isSpecCompliantForm(e);if(!utils$1.isFunction(d))throw new TypeError("visitor must be a function");function $(ot){if(ot===null)return"";if(utils$1.isDate(ot))return ot.toISOString();if(!st&&utils$1.isBlob(ot))throw new AxiosError("Blob is not supported. Use a Buffer instead.");return utils$1.isArrayBuffer(ot)||utils$1.isTypedArray(ot)?st&&typeof Blob=="function"?new Blob([ot]):Buffer.from(ot):ot}function it(ot,ct,dt){let pt=ot;if(ot&&!dt&&typeof ot=="object"){if(utils$1.endsWith(ct,"{}"))ct=a?ct:ct.slice(0,-2),ot=JSON.stringify(ot);else if(utils$1.isArray(ot)&&isFlatArray(ot)||(utils$1.isFileList(ot)||utils$1.endsWith(ct,"[]"))&&(pt=utils$1.toArray(ot)))return ct=removeBrackets(ct),pt.forEach(function(ht,bt){!(utils$1.isUndefined(ht)||ht===null)&&e.append(b===!0?renderKey([ct],bt,h):b===null?ct:ct+"[]",$(ht))}),!1}return isVisitable(ot)?!0:(e.append(renderKey(dt,ct,h),$(ot)),!1)}const g=[],c=Object.assign(predicates,{defaultVisitor:it,convertValue:$,isVisitable});function _(ot,ct){if(!utils$1.isUndefined(ot)){if(g.indexOf(ot)!==-1)throw Error("Circular reference detected in "+ct.join("."));g.push(ot),utils$1.forEach(ot,function(pt,ft){(!(utils$1.isUndefined(pt)||pt===null)&&d.call(e,pt,utils$1.isString(ft)?ft.trim():ft,ct,c))===!0&&_(pt,ct?ct.concat(ft):[ft])}),g.pop()}}if(!utils$1.isObject(o))throw new TypeError("data must be an object");return _(o),e}function encode$1(o){const e={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(o).replace(/[!'()~]|%20|%00/g,function(a){return e[a]})}function AxiosURLSearchParams(o,e){this._pairs=[],o&&toFormData(o,this,e)}const prototype=AxiosURLSearchParams.prototype;prototype.append=function(e,s){this._pairs.push([e,s])};prototype.toString=function(e){const s=e?function(a){return e.call(this,a,encode$1)}:encode$1;return this._pairs.map(function(d){return s(d[0])+"="+s(d[1])},"").join("&")};function encode(o){return encodeURIComponent(o).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function buildURL(o,e,s){if(!e)return o;const a=s&&s.encode||encode,d=s&&s.serialize;let h;if(d?h=d(e,s):h=utils$1.isURLSearchParams(e)?e.toString():new AxiosURLSearchParams(e,s).toString(a),h){const b=o.indexOf("#");b!==-1&&(o=o.slice(0,b)),o+=(o.indexOf("?")===-1?"?":"&")+h}return o}class InterceptorManager{constructor(){this.handlers=[]}use(e,s,a){return this.handlers.push({fulfilled:e,rejected:s,synchronous:a?a.synchronous:!1,runWhen:a?a.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){utils$1.forEach(this.handlers,function(a){a!==null&&e(a)})}}const transitionalDefaults={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},URLSearchParams$1=typeof URLSearchParams<"u"?URLSearchParams:AxiosURLSearchParams,FormData$1=typeof FormData<"u"?FormData:null,Blob$1=typeof Blob<"u"?Blob:null,platform$2={isBrowser:!0,classes:{URLSearchParams:URLSearchParams$1,FormData:FormData$1,Blob:Blob$1},protocols:["http","https","file","blob","url","data"]},hasBrowserEnv=typeof window<"u"&&typeof document<"u",hasStandardBrowserEnv=(o=>hasBrowserEnv&&["ReactNative","NativeScript","NS"].indexOf(o)<0)(typeof navigator<"u"&&navigator.product),hasStandardBrowserWebWorkerEnv=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&typeof self.importScripts=="function",origin=hasBrowserEnv&&window.location.href||"http://localhost",utils=Object.freeze(Object.defineProperty({__proto__:null,hasBrowserEnv,hasStandardBrowserEnv,hasStandardBrowserWebWorkerEnv,origin},Symbol.toStringTag,{value:"Module"})),platform$1={...utils,...platform$2};function toURLEncodedForm(o,e){return toFormData(o,new platform$1.classes.URLSearchParams,Object.assign({visitor:function(s,a,d,h){return platform$1.isNode&&utils$1.isBuffer(s)?(this.append(a,s.toString("base64")),!1):h.defaultVisitor.apply(this,arguments)}},e))}function parsePropPath(o){return utils$1.matchAll(/\w+|\[(\w*)]/g,o).map(e=>e[0]==="[]"?"":e[1]||e[0])}function arrayToObject(o){const e={},s=Object.keys(o);let a;const d=s.length;let h;for(a=0;a<d;a++)h=s[a],e[h]=o[h];return e}function formDataToJSON(o){function e(s,a,d,h){let b=s[h++];if(b==="__proto__")return!0;const et=Number.isFinite(+b),st=h>=s.length;return b=!b&&utils$1.isArray(d)?d.length:b,st?(utils$1.hasOwnProp(d,b)?d[b]=[d[b],a]:d[b]=a,!et):((!d[b]||!utils$1.isObject(d[b]))&&(d[b]=[]),e(s,a,d[b],h)&&utils$1.isArray(d[b])&&(d[b]=arrayToObject(d[b])),!et)}if(utils$1.isFormData(o)&&utils$1.isFunction(o.entries)){const s={};return utils$1.forEachEntry(o,(a,d)=>{e(parsePropPath(a),d,s,0)}),s}return null}function stringifySafely(o,e,s){if(utils$1.isString(o))try{return(e||JSON.parse)(o),utils$1.trim(o)}catch(a){if(a.name!=="SyntaxError")throw a}return(s||JSON.stringify)(o)}const defaults={transitional:transitionalDefaults,adapter:["xhr","http","fetch"],transformRequest:[function(e,s){const a=s.getContentType()||"",d=a.indexOf("application/json")>-1,h=utils$1.isObject(e);if(h&&utils$1.isHTMLForm(e)&&(e=new FormData(e)),utils$1.isFormData(e))return d?JSON.stringify(formDataToJSON(e)):e;if(utils$1.isArrayBuffer(e)||utils$1.isBuffer(e)||utils$1.isStream(e)||utils$1.isFile(e)||utils$1.isBlob(e)||utils$1.isReadableStream(e))return e;if(utils$1.isArrayBufferView(e))return e.buffer;if(utils$1.isURLSearchParams(e))return s.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let et;if(h){if(a.indexOf("application/x-www-form-urlencoded")>-1)return toURLEncodedForm(e,this.formSerializer).toString();if((et=utils$1.isFileList(e))||a.indexOf("multipart/form-data")>-1){const st=this.env&&this.env.FormData;return toFormData(et?{"files[]":e}:e,st&&new st,this.formSerializer)}}return h||d?(s.setContentType("application/json",!1),stringifySafely(e)):e}],transformResponse:[function(e){const s=this.transitional||defaults.transitional,a=s&&s.forcedJSONParsing,d=this.responseType==="json";if(utils$1.isResponse(e)||utils$1.isReadableStream(e))return e;if(e&&utils$1.isString(e)&&(a&&!this.responseType||d)){const b=!(s&&s.silentJSONParsing)&&d;try{return JSON.parse(e)}catch(et){if(b)throw et.name==="SyntaxError"?AxiosError.from(et,AxiosError.ERR_BAD_RESPONSE,this,null,this.response):et}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:platform$1.classes.FormData,Blob:platform$1.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};utils$1.forEach(["delete","get","head","post","put","patch"],o=>{defaults.headers[o]={}});const ignoreDuplicateOf=utils$1.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),parseHeaders=o=>{const e={};let s,a,d;return o&&o.split(`
`).forEach(function(b){d=b.indexOf(":"),s=b.substring(0,d).trim().toLowerCase(),a=b.substring(d+1).trim(),!(!s||e[s]&&ignoreDuplicateOf[s])&&(s==="set-cookie"?e[s]?e[s].push(a):e[s]=[a]:e[s]=e[s]?e[s]+", "+a:a)}),e},$internals=Symbol("internals");function normalizeHeader(o){return o&&String(o).trim().toLowerCase()}function normalizeValue(o){return o===!1||o==null?o:utils$1.isArray(o)?o.map(normalizeValue):String(o)}function parseTokens(o){const e=Object.create(null),s=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let a;for(;a=s.exec(o);)e[a[1]]=a[2];return e}const isValidHeaderName=o=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(o.trim());function matchHeaderValue(o,e,s,a,d){if(utils$1.isFunction(a))return a.call(this,e,s);if(d&&(e=s),!!utils$1.isString(e)){if(utils$1.isString(a))return e.indexOf(a)!==-1;if(utils$1.isRegExp(a))return a.test(e)}}function formatHeader(o){return o.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(e,s,a)=>s.toUpperCase()+a)}function buildAccessors(o,e){const s=utils$1.toCamelCase(" "+e);["get","set","has"].forEach(a=>{Object.defineProperty(o,a+s,{value:function(d,h,b){return this[a].call(this,e,d,h,b)},configurable:!0})})}class AxiosHeaders{constructor(e){e&&this.set(e)}set(e,s,a){const d=this;function h(et,st,$){const it=normalizeHeader(st);if(!it)throw new Error("header name must be a non-empty string");const g=utils$1.findKey(d,it);(!g||d[g]===void 0||$===!0||$===void 0&&d[g]!==!1)&&(d[g||st]=normalizeValue(et))}const b=(et,st)=>utils$1.forEach(et,($,it)=>h($,it,st));if(utils$1.isPlainObject(e)||e instanceof this.constructor)b(e,s);else if(utils$1.isString(e)&&(e=e.trim())&&!isValidHeaderName(e))b(parseHeaders(e),s);else if(utils$1.isHeaders(e))for(const[et,st]of e.entries())h(st,et,a);else e!=null&&h(s,e,a);return this}get(e,s){if(e=normalizeHeader(e),e){const a=utils$1.findKey(this,e);if(a){const d=this[a];if(!s)return d;if(s===!0)return parseTokens(d);if(utils$1.isFunction(s))return s.call(this,d,a);if(utils$1.isRegExp(s))return s.exec(d);throw new TypeError("parser must be boolean|regexp|function")}}}has(e,s){if(e=normalizeHeader(e),e){const a=utils$1.findKey(this,e);return!!(a&&this[a]!==void 0&&(!s||matchHeaderValue(this,this[a],a,s)))}return!1}delete(e,s){const a=this;let d=!1;function h(b){if(b=normalizeHeader(b),b){const et=utils$1.findKey(a,b);et&&(!s||matchHeaderValue(a,a[et],et,s))&&(delete a[et],d=!0)}}return utils$1.isArray(e)?e.forEach(h):h(e),d}clear(e){const s=Object.keys(this);let a=s.length,d=!1;for(;a--;){const h=s[a];(!e||matchHeaderValue(this,this[h],h,e,!0))&&(delete this[h],d=!0)}return d}normalize(e){const s=this,a={};return utils$1.forEach(this,(d,h)=>{const b=utils$1.findKey(a,h);if(b){s[b]=normalizeValue(d),delete s[h];return}const et=e?formatHeader(h):String(h).trim();et!==h&&delete s[h],s[et]=normalizeValue(d),a[et]=!0}),this}concat(...e){return this.constructor.concat(this,...e)}toJSON(e){const s=Object.create(null);return utils$1.forEach(this,(a,d)=>{a!=null&&a!==!1&&(s[d]=e&&utils$1.isArray(a)?a.join(", "):a)}),s}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map(([e,s])=>e+": "+s).join(`
`)}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(e){return e instanceof this?e:new this(e)}static concat(e,...s){const a=new this(e);return s.forEach(d=>a.set(d)),a}static accessor(e){const a=(this[$internals]=this[$internals]={accessors:{}}).accessors,d=this.prototype;function h(b){const et=normalizeHeader(b);a[et]||(buildAccessors(d,b),a[et]=!0)}return utils$1.isArray(e)?e.forEach(h):h(e),this}}AxiosHeaders.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]);utils$1.reduceDescriptors(AxiosHeaders.prototype,({value:o},e)=>{let s=e[0].toUpperCase()+e.slice(1);return{get:()=>o,set(a){this[s]=a}}});utils$1.freezeMethods(AxiosHeaders);function transformData(o,e){const s=this||defaults,a=e||s,d=AxiosHeaders.from(a.headers);let h=a.data;return utils$1.forEach(o,function(et){h=et.call(s,h,d.normalize(),e?e.status:void 0)}),d.normalize(),h}function isCancel(o){return!!(o&&o.__CANCEL__)}function CanceledError(o,e,s){AxiosError.call(this,o??"canceled",AxiosError.ERR_CANCELED,e,s),this.name="CanceledError"}utils$1.inherits(CanceledError,AxiosError,{__CANCEL__:!0});function settle(o,e,s){const a=s.config.validateStatus;!s.status||!a||a(s.status)?o(s):e(new AxiosError("Request failed with status code "+s.status,[AxiosError.ERR_BAD_REQUEST,AxiosError.ERR_BAD_RESPONSE][Math.floor(s.status/100)-4],s.config,s.request,s))}function parseProtocol(o){const e=/^([-+\w]{1,25})(:?\/\/|:)/.exec(o);return e&&e[1]||""}function speedometer(o,e){o=o||10;const s=new Array(o),a=new Array(o);let d=0,h=0,b;return e=e!==void 0?e:1e3,function(st){const $=Date.now(),it=a[h];b||(b=$),s[d]=st,a[d]=$;let g=h,c=0;for(;g!==d;)c+=s[g++],g=g%o;if(d=(d+1)%o,d===h&&(h=(h+1)%o),$-b<e)return;const _=it&&$-it;return _?Math.round(c*1e3/_):void 0}}function throttle(o,e){let s=0,a=1e3/e,d,h;const b=($,it=Date.now())=>{s=it,d=null,h&&(clearTimeout(h),h=null),o.apply(null,$)};return[(...$)=>{const it=Date.now(),g=it-s;g>=a?b($,it):(d=$,h||(h=setTimeout(()=>{h=null,b(d)},a-g)))},()=>d&&b(d)]}const progressEventReducer=(o,e,s=3)=>{let a=0;const d=speedometer(50,250);return throttle(h=>{const b=h.loaded,et=h.lengthComputable?h.total:void 0,st=b-a,$=d(st),it=b<=et;a=b;const g={loaded:b,total:et,progress:et?b/et:void 0,bytes:st,rate:$||void 0,estimated:$&&et&&it?(et-b)/$:void 0,event:h,lengthComputable:et!=null,[e?"download":"upload"]:!0};o(g)},s)},progressEventDecorator=(o,e)=>{const s=o!=null;return[a=>e[0]({lengthComputable:s,total:o,loaded:a}),e[1]]},asyncDecorator=o=>(...e)=>utils$1.asap(()=>o(...e)),isURLSameOrigin=platform$1.hasStandardBrowserEnv?function(){const e=/(msie|trident)/i.test(navigator.userAgent),s=document.createElement("a");let a;function d(h){let b=h;return e&&(s.setAttribute("href",b),b=s.href),s.setAttribute("href",b),{href:s.href,protocol:s.protocol?s.protocol.replace(/:$/,""):"",host:s.host,search:s.search?s.search.replace(/^\?/,""):"",hash:s.hash?s.hash.replace(/^#/,""):"",hostname:s.hostname,port:s.port,pathname:s.pathname.charAt(0)==="/"?s.pathname:"/"+s.pathname}}return a=d(window.location.href),function(b){const et=utils$1.isString(b)?d(b):b;return et.protocol===a.protocol&&et.host===a.host}}():function(){return function(){return!0}}(),cookies=platform$1.hasStandardBrowserEnv?{write(o,e,s,a,d,h){const b=[o+"="+encodeURIComponent(e)];utils$1.isNumber(s)&&b.push("expires="+new Date(s).toGMTString()),utils$1.isString(a)&&b.push("path="+a),utils$1.isString(d)&&b.push("domain="+d),h===!0&&b.push("secure"),document.cookie=b.join("; ")},read(o){const e=document.cookie.match(new RegExp("(^|;\\s*)("+o+")=([^;]*)"));return e?decodeURIComponent(e[3]):null},remove(o){this.write(o,"",Date.now()-864e5)}}:{write(){},read(){return null},remove(){}};function isAbsoluteURL(o){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(o)}function combineURLs(o,e){return e?o.replace(/\/?\/$/,"")+"/"+e.replace(/^\/+/,""):o}function buildFullPath(o,e){return o&&!isAbsoluteURL(e)?combineURLs(o,e):e}const headersToObject=o=>o instanceof AxiosHeaders?{...o}:o;function mergeConfig(o,e){e=e||{};const s={};function a($,it,g){return utils$1.isPlainObject($)&&utils$1.isPlainObject(it)?utils$1.merge.call({caseless:g},$,it):utils$1.isPlainObject(it)?utils$1.merge({},it):utils$1.isArray(it)?it.slice():it}function d($,it,g){if(utils$1.isUndefined(it)){if(!utils$1.isUndefined($))return a(void 0,$,g)}else return a($,it,g)}function h($,it){if(!utils$1.isUndefined(it))return a(void 0,it)}function b($,it){if(utils$1.isUndefined(it)){if(!utils$1.isUndefined($))return a(void 0,$)}else return a(void 0,it)}function et($,it,g){if(g in e)return a($,it);if(g in o)return a(void 0,$)}const st={url:h,method:h,data:h,baseURL:b,transformRequest:b,transformResponse:b,paramsSerializer:b,timeout:b,timeoutMessage:b,withCredentials:b,withXSRFToken:b,adapter:b,responseType:b,xsrfCookieName:b,xsrfHeaderName:b,onUploadProgress:b,onDownloadProgress:b,decompress:b,maxContentLength:b,maxBodyLength:b,beforeRedirect:b,transport:b,httpAgent:b,httpsAgent:b,cancelToken:b,socketPath:b,responseEncoding:b,validateStatus:et,headers:($,it)=>d(headersToObject($),headersToObject(it),!0)};return utils$1.forEach(Object.keys(Object.assign({},o,e)),function(it){const g=st[it]||d,c=g(o[it],e[it],it);utils$1.isUndefined(c)&&g!==et||(s[it]=c)}),s}const resolveConfig=o=>{const e=mergeConfig({},o);let{data:s,withXSRFToken:a,xsrfHeaderName:d,xsrfCookieName:h,headers:b,auth:et}=e;e.headers=b=AxiosHeaders.from(b),e.url=buildURL(buildFullPath(e.baseURL,e.url),o.params,o.paramsSerializer),et&&b.set("Authorization","Basic "+btoa((et.username||"")+":"+(et.password?unescape(encodeURIComponent(et.password)):"")));let st;if(utils$1.isFormData(s)){if(platform$1.hasStandardBrowserEnv||platform$1.hasStandardBrowserWebWorkerEnv)b.setContentType(void 0);else if((st=b.getContentType())!==!1){const[$,...it]=st?st.split(";").map(g=>g.trim()).filter(Boolean):[];b.setContentType([$||"multipart/form-data",...it].join("; "))}}if(platform$1.hasStandardBrowserEnv&&(a&&utils$1.isFunction(a)&&(a=a(e)),a||a!==!1&&isURLSameOrigin(e.url))){const $=d&&h&&cookies.read(h);$&&b.set(d,$)}return e},isXHRAdapterSupported=typeof XMLHttpRequest<"u",xhrAdapter=isXHRAdapterSupported&&function(o){return new Promise(function(s,a){const d=resolveConfig(o);let h=d.data;const b=AxiosHeaders.from(d.headers).normalize();let{responseType:et,onUploadProgress:st,onDownloadProgress:$}=d,it,g,c,_,ot;function ct(){_&&_(),ot&&ot(),d.cancelToken&&d.cancelToken.unsubscribe(it),d.signal&&d.signal.removeEventListener("abort",it)}let dt=new XMLHttpRequest;dt.open(d.method.toUpperCase(),d.url,!0),dt.timeout=d.timeout;function pt(){if(!dt)return;const ht=AxiosHeaders.from("getAllResponseHeaders"in dt&&dt.getAllResponseHeaders()),mt={data:!et||et==="text"||et==="json"?dt.responseText:dt.response,status:dt.status,statusText:dt.statusText,headers:ht,config:o,request:dt};settle(function(Tt){s(Tt),ct()},function(Tt){a(Tt),ct()},mt),dt=null}"onloadend"in dt?dt.onloadend=pt:dt.onreadystatechange=function(){!dt||dt.readyState!==4||dt.status===0&&!(dt.responseURL&&dt.responseURL.indexOf("file:")===0)||setTimeout(pt)},dt.onabort=function(){dt&&(a(new AxiosError("Request aborted",AxiosError.ECONNABORTED,o,dt)),dt=null)},dt.onerror=function(){a(new AxiosError("Network Error",AxiosError.ERR_NETWORK,o,dt)),dt=null},dt.ontimeout=function(){let bt=d.timeout?"timeout of "+d.timeout+"ms exceeded":"timeout exceeded";const mt=d.transitional||transitionalDefaults;d.timeoutErrorMessage&&(bt=d.timeoutErrorMessage),a(new AxiosError(bt,mt.clarifyTimeoutError?AxiosError.ETIMEDOUT:AxiosError.ECONNABORTED,o,dt)),dt=null},h===void 0&&b.setContentType(null),"setRequestHeader"in dt&&utils$1.forEach(b.toJSON(),function(bt,mt){dt.setRequestHeader(mt,bt)}),utils$1.isUndefined(d.withCredentials)||(dt.withCredentials=!!d.withCredentials),et&&et!=="json"&&(dt.responseType=d.responseType),$&&([c,ot]=progressEventReducer($,!0),dt.addEventListener("progress",c)),st&&dt.upload&&([g,_]=progressEventReducer(st),dt.upload.addEventListener("progress",g),dt.upload.addEventListener("loadend",_)),(d.cancelToken||d.signal)&&(it=ht=>{dt&&(a(!ht||ht.type?new CanceledError(null,o,dt):ht),dt.abort(),dt=null)},d.cancelToken&&d.cancelToken.subscribe(it),d.signal&&(d.signal.aborted?it():d.signal.addEventListener("abort",it)));const ft=parseProtocol(d.url);if(ft&&platform$1.protocols.indexOf(ft)===-1){a(new AxiosError("Unsupported protocol "+ft+":",AxiosError.ERR_BAD_REQUEST,o));return}dt.send(h||null)})},composeSignals=(o,e)=>{let s=new AbortController,a;const d=function(st){if(!a){a=!0,b();const $=st instanceof Error?st:this.reason;s.abort($ instanceof AxiosError?$:new CanceledError($ instanceof Error?$.message:$))}};let h=e&&setTimeout(()=>{d(new AxiosError(`timeout ${e} of ms exceeded`,AxiosError.ETIMEDOUT))},e);const b=()=>{o&&(h&&clearTimeout(h),h=null,o.forEach(st=>{st&&(st.removeEventListener?st.removeEventListener("abort",d):st.unsubscribe(d))}),o=null)};o.forEach(st=>st&&st.addEventListener&&st.addEventListener("abort",d));const{signal:et}=s;return et.unsubscribe=b,[et,()=>{h&&clearTimeout(h),h=null}]},streamChunk=function*(o,e){let s=o.byteLength;if(!e||s<e){yield o;return}let a=0,d;for(;a<s;)d=a+e,yield o.slice(a,d),a=d},readBytes=async function*(o,e,s){for await(const a of o)yield*streamChunk(ArrayBuffer.isView(a)?a:await s(String(a)),e)},trackStream=(o,e,s,a,d)=>{const h=readBytes(o,e,d);let b=0,et,st=$=>{et||(et=!0,a&&a($))};return new ReadableStream({async pull($){try{const{done:it,value:g}=await h.next();if(it){st(),$.close();return}let c=g.byteLength;if(s){let _=b+=c;s(_)}$.enqueue(new Uint8Array(g))}catch(it){throw st(it),it}},cancel($){return st($),h.return()}},{highWaterMark:2})},isFetchSupported=typeof fetch=="function"&&typeof Request=="function"&&typeof Response=="function",isReadableStreamSupported=isFetchSupported&&typeof ReadableStream=="function",encodeText=isFetchSupported&&(typeof TextEncoder=="function"?(o=>e=>o.encode(e))(new TextEncoder):async o=>new Uint8Array(await new Response(o).arrayBuffer())),test=(o,...e)=>{try{return!!o(...e)}catch{return!1}},supportsRequestStream=isReadableStreamSupported&&test(()=>{let o=!1;const e=new Request(platform$1.origin,{body:new ReadableStream,method:"POST",get duplex(){return o=!0,"half"}}).headers.has("Content-Type");return o&&!e}),DEFAULT_CHUNK_SIZE=64*1024,supportsResponseStream=isReadableStreamSupported&&test(()=>utils$1.isReadableStream(new Response("").body)),resolvers={stream:supportsResponseStream&&(o=>o.body)};isFetchSupported&&(o=>{["text","arrayBuffer","blob","formData","stream"].forEach(e=>{!resolvers[e]&&(resolvers[e]=utils$1.isFunction(o[e])?s=>s[e]():(s,a)=>{throw new AxiosError(`Response type '${e}' is not supported`,AxiosError.ERR_NOT_SUPPORT,a)})})})(new Response);const getBodyLength=async o=>{if(o==null)return 0;if(utils$1.isBlob(o))return o.size;if(utils$1.isSpecCompliantForm(o))return(await new Request(o).arrayBuffer()).byteLength;if(utils$1.isArrayBufferView(o)||utils$1.isArrayBuffer(o))return o.byteLength;if(utils$1.isURLSearchParams(o)&&(o=o+""),utils$1.isString(o))return(await encodeText(o)).byteLength},resolveBodyLength=async(o,e)=>{const s=utils$1.toFiniteNumber(o.getContentLength());return s??getBodyLength(e)},fetchAdapter=isFetchSupported&&(async o=>{let{url:e,method:s,data:a,signal:d,cancelToken:h,timeout:b,onDownloadProgress:et,onUploadProgress:st,responseType:$,headers:it,withCredentials:g="same-origin",fetchOptions:c}=resolveConfig(o);$=$?($+"").toLowerCase():"text";let[_,ot]=d||h||b?composeSignals([d,h],b):[],ct,dt;const pt=()=>{!ct&&setTimeout(()=>{_&&_.unsubscribe()}),ct=!0};let ft;try{if(st&&supportsRequestStream&&s!=="get"&&s!=="head"&&(ft=await resolveBodyLength(it,a))!==0){let $t=new Request(e,{method:"POST",body:a,duplex:"half"}),Tt;if(utils$1.isFormData(a)&&(Tt=$t.headers.get("content-type"))&&it.setContentType(Tt),$t.body){const[Nt,Ct]=progressEventDecorator(ft,progressEventReducer(asyncDecorator(st)));a=trackStream($t.body,DEFAULT_CHUNK_SIZE,Nt,Ct,encodeText)}}utils$1.isString(g)||(g=g?"include":"omit"),dt=new Request(e,{...c,signal:_,method:s.toUpperCase(),headers:it.normalize().toJSON(),body:a,duplex:"half",credentials:g});let ht=await fetch(dt);const bt=supportsResponseStream&&($==="stream"||$==="response");if(supportsResponseStream&&(et||bt)){const $t={};["status","statusText","headers"].forEach(Ft=>{$t[Ft]=ht[Ft]});const Tt=utils$1.toFiniteNumber(ht.headers.get("content-length")),[Nt,Ct]=et&&progressEventDecorator(Tt,progressEventReducer(asyncDecorator(et),!0))||[];ht=new Response(trackStream(ht.body,DEFAULT_CHUNK_SIZE,Nt,()=>{Ct&&Ct(),bt&&pt()},encodeText),$t)}$=$||"text";let mt=await resolvers[utils$1.findKey(resolvers,$)||"text"](ht,o);return!bt&&pt(),ot&&ot(),await new Promise(($t,Tt)=>{settle($t,Tt,{data:mt,headers:AxiosHeaders.from(ht.headers),status:ht.status,statusText:ht.statusText,config:o,request:dt})})}catch(ht){throw pt(),ht&&ht.name==="TypeError"&&/fetch/i.test(ht.message)?Object.assign(new AxiosError("Network Error",AxiosError.ERR_NETWORK,o,dt),{cause:ht.cause||ht}):AxiosError.from(ht,ht&&ht.code,o,dt)}}),knownAdapters={http:httpAdapter,xhr:xhrAdapter,fetch:fetchAdapter};utils$1.forEach(knownAdapters,(o,e)=>{if(o){try{Object.defineProperty(o,"name",{value:e})}catch{}Object.defineProperty(o,"adapterName",{value:e})}});const renderReason=o=>`- ${o}`,isResolvedHandle=o=>utils$1.isFunction(o)||o===null||o===!1,adapters={getAdapter:o=>{o=utils$1.isArray(o)?o:[o];const{length:e}=o;let s,a;const d={};for(let h=0;h<e;h++){s=o[h];let b;if(a=s,!isResolvedHandle(s)&&(a=knownAdapters[(b=String(s)).toLowerCase()],a===void 0))throw new AxiosError(`Unknown adapter '${b}'`);if(a)break;d[b||"#"+h]=a}if(!a){const h=Object.entries(d).map(([et,st])=>`adapter ${et} `+(st===!1?"is not supported by the environment":"is not available in the build"));let b=e?h.length>1?`since :
`+h.map(renderReason).join(`
`):" "+renderReason(h[0]):"as no adapter specified";throw new AxiosError("There is no suitable adapter to dispatch the request "+b,"ERR_NOT_SUPPORT")}return a},adapters:knownAdapters};function throwIfCancellationRequested(o){if(o.cancelToken&&o.cancelToken.throwIfRequested(),o.signal&&o.signal.aborted)throw new CanceledError(null,o)}function dispatchRequest(o){return throwIfCancellationRequested(o),o.headers=AxiosHeaders.from(o.headers),o.data=transformData.call(o,o.transformRequest),["post","put","patch"].indexOf(o.method)!==-1&&o.headers.setContentType("application/x-www-form-urlencoded",!1),adapters.getAdapter(o.adapter||defaults.adapter)(o).then(function(a){return throwIfCancellationRequested(o),a.data=transformData.call(o,o.transformResponse,a),a.headers=AxiosHeaders.from(a.headers),a},function(a){return isCancel(a)||(throwIfCancellationRequested(o),a&&a.response&&(a.response.data=transformData.call(o,o.transformResponse,a.response),a.response.headers=AxiosHeaders.from(a.response.headers))),Promise.reject(a)})}const VERSION$1="1.7.3",validators$1={};["object","boolean","number","function","string","symbol"].forEach((o,e)=>{validators$1[o]=function(a){return typeof a===o||"a"+(e<1?"n ":" ")+o}});const deprecatedWarnings={};validators$1.transitional=function(e,s,a){function d(h,b){return"[Axios v"+VERSION$1+"] Transitional option '"+h+"'"+b+(a?". "+a:"")}return(h,b,et)=>{if(e===!1)throw new AxiosError(d(b," has been removed"+(s?" in "+s:"")),AxiosError.ERR_DEPRECATED);return s&&!deprecatedWarnings[b]&&(deprecatedWarnings[b]=!0,console.warn(d(b," has been deprecated since v"+s+" and will be removed in the near future"))),e?e(h,b,et):!0}};function assertOptions(o,e,s){if(typeof o!="object")throw new AxiosError("options must be an object",AxiosError.ERR_BAD_OPTION_VALUE);const a=Object.keys(o);let d=a.length;for(;d-- >0;){const h=a[d],b=e[h];if(b){const et=o[h],st=et===void 0||b(et,h,o);if(st!==!0)throw new AxiosError("option "+h+" must be "+st,AxiosError.ERR_BAD_OPTION_VALUE);continue}if(s!==!0)throw new AxiosError("Unknown option "+h,AxiosError.ERR_BAD_OPTION)}}const validator={assertOptions,validators:validators$1},validators=validator.validators;class Axios{constructor(e){this.defaults=e,this.interceptors={request:new InterceptorManager,response:new InterceptorManager}}async request(e,s){try{return await this._request(e,s)}catch(a){if(a instanceof Error){let d;Error.captureStackTrace?Error.captureStackTrace(d={}):d=new Error;const h=d.stack?d.stack.replace(/^.+\n/,""):"";try{a.stack?h&&!String(a.stack).endsWith(h.replace(/^.+\n.+\n/,""))&&(a.stack+=`
`+h):a.stack=h}catch{}}throw a}}_request(e,s){typeof e=="string"?(s=s||{},s.url=e):s=e||{},s=mergeConfig(this.defaults,s);const{transitional:a,paramsSerializer:d,headers:h}=s;a!==void 0&&validator.assertOptions(a,{silentJSONParsing:validators.transitional(validators.boolean),forcedJSONParsing:validators.transitional(validators.boolean),clarifyTimeoutError:validators.transitional(validators.boolean)},!1),d!=null&&(utils$1.isFunction(d)?s.paramsSerializer={serialize:d}:validator.assertOptions(d,{encode:validators.function,serialize:validators.function},!0)),s.method=(s.method||this.defaults.method||"get").toLowerCase();let b=h&&utils$1.merge(h.common,h[s.method]);h&&utils$1.forEach(["delete","get","head","post","put","patch","common"],ot=>{delete h[ot]}),s.headers=AxiosHeaders.concat(b,h);const et=[];let st=!0;this.interceptors.request.forEach(function(ct){typeof ct.runWhen=="function"&&ct.runWhen(s)===!1||(st=st&&ct.synchronous,et.unshift(ct.fulfilled,ct.rejected))});const $=[];this.interceptors.response.forEach(function(ct){$.push(ct.fulfilled,ct.rejected)});let it,g=0,c;if(!st){const ot=[dispatchRequest.bind(this),void 0];for(ot.unshift.apply(ot,et),ot.push.apply(ot,$),c=ot.length,it=Promise.resolve(s);g<c;)it=it.then(ot[g++],ot[g++]);return it}c=et.length;let _=s;for(g=0;g<c;){const ot=et[g++],ct=et[g++];try{_=ot(_)}catch(dt){ct.call(this,dt);break}}try{it=dispatchRequest.call(this,_)}catch(ot){return Promise.reject(ot)}for(g=0,c=$.length;g<c;)it=it.then($[g++],$[g++]);return it}getUri(e){e=mergeConfig(this.defaults,e);const s=buildFullPath(e.baseURL,e.url);return buildURL(s,e.params,e.paramsSerializer)}}utils$1.forEach(["delete","get","head","options"],function(e){Axios.prototype[e]=function(s,a){return this.request(mergeConfig(a||{},{method:e,url:s,data:(a||{}).data}))}});utils$1.forEach(["post","put","patch"],function(e){function s(a){return function(h,b,et){return this.request(mergeConfig(et||{},{method:e,headers:a?{"Content-Type":"multipart/form-data"}:{},url:h,data:b}))}}Axios.prototype[e]=s(),Axios.prototype[e+"Form"]=s(!0)});class CancelToken{constructor(e){if(typeof e!="function")throw new TypeError("executor must be a function.");let s;this.promise=new Promise(function(h){s=h});const a=this;this.promise.then(d=>{if(!a._listeners)return;let h=a._listeners.length;for(;h-- >0;)a._listeners[h](d);a._listeners=null}),this.promise.then=d=>{let h;const b=new Promise(et=>{a.subscribe(et),h=et}).then(d);return b.cancel=function(){a.unsubscribe(h)},b},e(function(h,b,et){a.reason||(a.reason=new CanceledError(h,b,et),s(a.reason))})}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){if(this.reason){e(this.reason);return}this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const s=this._listeners.indexOf(e);s!==-1&&this._listeners.splice(s,1)}static source(){let e;return{token:new CancelToken(function(d){e=d}),cancel:e}}}function spread(o){return function(s){return o.apply(null,s)}}function isAxiosError(o){return utils$1.isObject(o)&&o.isAxiosError===!0}const HttpStatusCode={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(HttpStatusCode).forEach(([o,e])=>{HttpStatusCode[e]=o});function createInstance(o){const e=new Axios(o),s=bind(Axios.prototype.request,e);return utils$1.extend(s,Axios.prototype,e,{allOwnKeys:!0}),utils$1.extend(s,e,null,{allOwnKeys:!0}),s.create=function(d){return createInstance(mergeConfig(o,d))},s}const axios=createInstance(defaults);axios.Axios=Axios;axios.CanceledError=CanceledError;axios.CancelToken=CancelToken;axios.isCancel=isCancel;axios.VERSION=VERSION$1;axios.toFormData=toFormData;axios.AxiosError=AxiosError;axios.Cancel=axios.CanceledError;axios.all=function(e){return Promise.all(e)};axios.spread=spread;axios.isAxiosError=isAxiosError;axios.mergeConfig=mergeConfig;axios.AxiosHeaders=AxiosHeaders;axios.formToJSON=o=>formDataToJSON(utils$1.isHTMLForm(o)?new FormData(o):o);axios.getAdapter=adapters.getAdapter;axios.HttpStatusCode=HttpStatusCode;axios.default=axios;async function chatCompletionAPI({query:o,prompt:e,baseUrl:s,model:a},d,h){const b=new AbortController,et=setTimeout(()=>b.abort(),h);try{const st=await axios({method:"post",url:s,headers:{"Content-Type":"application/json",Accept:"application/json"},data:{model:a,messages:[{role:"system",content:e},{role:"user",content:o}],stream:!1},signal:b.signal});clearTimeout(et);const $=st.data.message.content;return d&&d($),$}catch(st){throw clearTimeout(et),axios.isCancel(st)?(console.error("Request timed out"),new Error("Request timed out")):(console.error("Error:",st.message),st)}}const proxyPOSTUrls=["https://cors-anywhere.herokuapp.com/"];function getProxyUrl(o){const e=Date.now(),a=Number(String(e).slice(-1))%o.length;return o[a]}function getProxyPOSTUrl(o,e=proxyPOSTUrls){const s=getProxyUrl(e);return console.log("getProxyPOSTUrl",s),s+o}async function chatCompletionReplicate(o,e,s,a="meta/meta-llama-3.1-405b-instruct",d){const h=getProxyPOSTUrl(`https://api.replicate.com/v1/models/${a}/predictions`),b={input:{top_k:50,top_p:.9,prompt:o,max_tokens:9999,min_tokens:0,temperature:.6,system_prompt:e,presence_penalty:1.15,frequency_penalty:.2}};try{await new Promise(it=>setTimeout(it,1e3));const{data:et}=await axios.post(h,b,{headers:{Authorization:`Bearer ${s}`,"Content-Type":"application/json"}}),st=et?.urls?.get;if(!st)throw new Error("No URL get found in the response data:"+JSON.stringify(et));return await(await getPredictionChatCompletion(st,s,d)).output.join("")}catch(et){throw console.error("Error fetching chat completion:",et),et}}async function getPredictionChatCompletion(o,e,s=void 0){await new Promise(et=>setTimeout(et,1e3));let a="processsing",d=new Date().toISOString(),h,b=1;for(;a!=="succeeded";){const et=getProxyPOSTUrl(o);console.log("Making request: "+JSON.stringify({status:a,startedAt:d,urlPrediction:o,tries:b})),await new Promise($=>setTimeout($,2e3));const{data:st}=await axios.get(et,{headers:{Authorization:`Bearer ${e}`},mode:"no-cors"});if(s!==void 0&&s(st.output.join("")),h=st,a=h.status,a=="failed")throw new Error("Failed to get response from replicate:",h);d=h.started_at,b=b+1}return console.log("Done making repicate request",h),h}function dispatchCallback(o,e){o&&o(e)}function reverseDictionary(o){return Object.fromEntries(Object.entries(o).map(([e,s])=>[s,e]))}function escapeRegExp(o){return o.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}const Callable=class{constructor(){let o=function(...e){return o._call(...e)};return Object.setPrototypeOf(o,new.target.prototype)}_call(...o){throw Error("Must implement _call method in subclass")}};function isTypedArray(o){return o?.prototype?.__proto__?.constructor?.name==="TypedArray"}function isIntegralNumber(o){return Number.isInteger(o)||typeof o=="bigint"}function exists(o){return o!=null}function mergeArrays(...o){return Array.prototype.concat.apply([],o)}const sharp={},ONNX_NODE=Object.freeze(Object.defineProperty({__proto__:null,default:sharp},Symbol.toStringTag,{value:"Module"}));var ortWeb_min$1={exports:{}};const backends={},backendsSortedByPriority=[],registerBackend=(o,e,s)=>{if(e&&typeof e.init=="function"&&typeof e.createSessionHandler=="function"){const a=backends[o];if(a===void 0)backends[o]={backend:e,priority:s};else{if(a.priority>s)return;if(a.priority===s&&a.backend!==e)throw new Error(`cannot register backend "${o}" using priority ${s}`)}if(s>=0){const d=backendsSortedByPriority.indexOf(o);d!==-1&&backendsSortedByPriority.splice(d,1);for(let h=0;h<backendsSortedByPriority.length;h++)if(backends[backendsSortedByPriority[h]].priority<=s){backendsSortedByPriority.splice(h,0,o);return}backendsSortedByPriority.push(o)}return}throw new TypeError("not a valid backend")},resolveBackend=async o=>{const e=o.length===0?backendsSortedByPriority:o,s=[];for(const a of e){const d=backends[a];if(d){if(d.initialized)return d.backend;if(d.aborted)continue;const h=!!d.initPromise;try{return h||(d.initPromise=d.backend.init()),await d.initPromise,d.initialized=!0,d.backend}catch(b){h||s.push({name:a,err:b}),d.aborted=!0}finally{delete d.initPromise}}}throw new Error(`no available backend found. ERR: ${s.map(a=>`[${a.name}] ${a.err}`).join(", ")}`)};class EnvImpl{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}}const env$2=new EnvImpl,isBigInt64ArrayAvailable=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",isBigUint64ArrayAvailable=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function",NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);isBigInt64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array,"int64"));isBigUint64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array,"uint64"));const calculateSize=o=>{let e=1;for(let s=0;s<o.length;s++){const a=o[s];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${s}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${s}] must be a non-negative integer, got: ${a}`);e*=a}return e};let Tensor$2=class Ty{constructor(e,s,a){let d,h,b;if(typeof e=="string")if(d=e,b=a,e==="string"){if(!Array.isArray(s))throw new TypeError("A string tensor's data must be a string array.");h=s}else{const st=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(e);if(st===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(s))h=st.from(s);else if(s instanceof st)h=s;else throw new TypeError(`A ${d} tensor's data must be type of ${st}`)}else if(b=s,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const st=typeof e[0];if(st==="string")d="string",h=e;else if(st==="boolean")d="bool",h=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${st}.`)}else{const st=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(e.constructor);if(st===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);d=st,h=e}if(b===void 0)b=[h.length];else if(!Array.isArray(b))throw new TypeError("A tensor's dims must be a number array");const et=calculateSize(b);if(et!==h.length)throw new Error(`Tensor's size(${et}) does not match data length(${h.length}).`);this.dims=b,this.type=d,this.data=h,this.size=et}static bufferToTensor(e,s){if(e===void 0)throw new Error("Image buffer must be defined");if(s.height===void 0||s.width===void 0)throw new Error("Image height and width must be defined");const{height:a,width:d}=s,h=s.norm;let b,et;h===void 0||h.mean===void 0?b=255:b=h.mean,h===void 0||h.bias===void 0?et=0:et=h.bias;const st=s.bitmapFormat!==void 0?s.bitmapFormat:"RGBA",$=s.tensorFormat!==void 0&&s.tensorFormat!==void 0?s.tensorFormat:"RGB",it=a*d,g=$==="RGBA"?new Float32Array(it*4):new Float32Array(it*3);let c=4,_=0,ot=1,ct=2,dt=3,pt=0,ft=it,ht=it*2,bt=-1;st==="RGB"&&(c=3,_=0,ot=1,ct=2,dt=-1),$==="RGBA"?bt=it*3:$==="RBG"?(pt=0,ht=it,ft=it*2):$==="BGR"&&(ht=0,ft=it,pt=it*2);for(let $t=0;$t<it;$t++,_+=c,ct+=c,ot+=c,dt+=c)g[pt++]=(e[_]+et)/b,g[ft++]=(e[ot]+et)/b,g[ht++]=(e[ct]+et)/b,bt!==-1&&dt!==-1&&(g[bt++]=(e[dt]+et)/b);return $==="RGBA"?new Ty("float32",g,[1,4,a,d]):new Ty("float32",g,[1,3,a,d])}static async fromImage(e,s){const a=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,d=typeof ImageData<"u"&&e instanceof ImageData,h=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,b=typeof String<"u"&&(e instanceof String||typeof e=="string");let et,st={};if(a){const $=document.createElement("canvas"),it=$.getContext("2d");if(it!=null){let g=e.naturalHeight,c=e.naturalWidth;if(s!==void 0&&s.resizedHeight!==void 0&&s.resizedWidth!==void 0&&(g=s.resizedHeight,c=s.resizedWidth),s!==void 0){if(st=s,s.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(st.tensorFormat="RGBA",s.height!==void 0&&s.height!==g)throw new Error("Image input config height doesn't match HTMLImageElement height");if(st.height=g,s.width!==void 0&&s.width!==c)throw new Error("Image input config width doesn't match HTMLImageElement width");st.width=c}else st.tensorFormat="RGBA",st.height=g,st.width=c;$.width=c,$.height=g,it.drawImage(e,0,0,c,g),et=it.getImageData(0,0,c,g).data}else throw new Error("Can not access image data")}else if(d){const $="RGBA";let it,g;if(s!==void 0&&s.resizedWidth!==void 0&&s.resizedHeight!==void 0?(it=s.resizedHeight,g=s.resizedWidth):(it=e.height,g=e.width),s!==void 0){if(st=s,s.bitmapFormat!==void 0&&s.bitmapFormat!==$)throw new Error("Image input config format must be RGBA for ImageData");st.bitmapFormat="RGBA"}else st.bitmapFormat="RGBA";if(st.height=it,st.width=g,s!==void 0){const c=document.createElement("canvas");c.width=g,c.height=it;const _=c.getContext("2d");if(_!=null)_.putImageData(e,0,0),et=_.getImageData(0,0,g,it).data;else throw new Error("Can not access image data")}else et=e.data}else if(h){if(s===void 0)throw new Error("Please provide image config with format for Imagebitmap");if(s.bitmapFormat!==void 0)throw new Error("Image input config format must be defined for ImageBitmap");const $=document.createElement("canvas").getContext("2d");if($!=null){const it=e.height,g=e.width;if($.drawImage(e,0,0,g,it),et=$.getImageData(0,0,g,it).data,s!==void 0){if(s.height!==void 0&&s.height!==it)throw new Error("Image input config height doesn't match ImageBitmap height");if(st.height=it,s.width!==void 0&&s.width!==g)throw new Error("Image input config width doesn't match ImageBitmap width");st.width=g}else st.height=it,st.width=g;return Ty.bufferToTensor(et,st)}else throw new Error("Can not access image data")}else{if(b)return new Promise(($,it)=>{const g=document.createElement("canvas"),c=g.getContext("2d");if(!e||!c)return it();const _=new Image;_.crossOrigin="Anonymous",_.src=e,_.onload=()=>{g.width=_.width,g.height=_.height,c.drawImage(_,0,0,g.width,g.height);const ot=c.getImageData(0,0,g.width,g.height);if(s!==void 0){if(s.height!==void 0&&s.height!==g.height)throw new Error("Image input config height doesn't match ImageBitmap height");if(st.height=g.height,s.width!==void 0&&s.width!==g.width)throw new Error("Image input config width doesn't match ImageBitmap width");st.width=g.width}else st.height=g.height,st.width=g.width;$(Ty.bufferToTensor(ot.data,st))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(et!==void 0)return Ty.bufferToTensor(et,st);throw new Error("Input data provided is not supported - aborted tensor creation")}toImageData(e){var s,a;const d=document.createElement("canvas").getContext("2d");let h;if(d!=null){const b=this.dims[3],et=this.dims[2],st=this.dims[1],$=e!==void 0&&e.format!==void 0?e.format:"RGB",it=e!==void 0&&((s=e.norm)===null||s===void 0?void 0:s.mean)!==void 0?e.norm.mean:255,g=e!==void 0&&((a=e.norm)===null||a===void 0?void 0:a.bias)!==void 0?e.norm.bias:0,c=et*b;if(e!==void 0){if(e.height!==void 0&&e.height!==et)throw new Error("Image output config height doesn't match tensor height");if(e.width!==void 0&&e.width!==b)throw new Error("Image output config width doesn't match tensor width");if(e.format!==void 0&&st===4&&e.format!=="RGBA"||st===3&&e.format!=="RGB"&&e.format!=="BGR")throw new Error("Tensor format doesn't match input tensor dims")}const _=4;let ot=0,ct=1,dt=2,pt=3,ft=0,ht=c,bt=c*2,mt=-1;$==="RGBA"?(ft=0,ht=c,bt=c*2,mt=c*3):$==="RGB"?(ft=0,ht=c,bt=c*2):$==="RBG"&&(ft=0,bt=c,ht=c*2),h=d.createImageData(b,et);for(let $t=0;$t<et*b;ot+=_,ct+=_,dt+=_,pt+=_,$t++)h.data[ot]=(this.data[ft++]-g)*it,h.data[ct]=(this.data[ht++]-g)*it,h.data[dt]=(this.data[bt++]-g)*it,h.data[pt]=mt===-1?255:(this.data[mt++]-g)*it}else throw new Error("Can not access image data");return h}reshape(e){return new Ty(this.type,this.data,e)}};const Tensor$1=Tensor$2;let InferenceSession$2=class n_{constructor(e){this.handler=e}async run(e,s,a){const d={};let h={};if(typeof e!="object"||e===null||e instanceof Tensor$1||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let b=!0;if(typeof s=="object"){if(s===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(s instanceof Tensor$1)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(s)){if(s.length===0)throw new TypeError("'fetches' cannot be an empty array.");b=!1;for(const $ of s){if(typeof $!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf($)===-1)throw new RangeError(`'fetches' contains invalid output name: ${$}.`);d[$]=null}if(typeof a=="object"&&a!==null)h=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let $=!1;const it=Object.getOwnPropertyNames(s);for(const g of this.outputNames)if(it.indexOf(g)!==-1){const c=s[g];(c===null||c instanceof Tensor$1)&&($=!0,b=!1,d[g]=c)}if($){if(typeof a=="object"&&a!==null)h=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else h=s}}else if(typeof s<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const $ of this.inputNames)if(typeof e[$]>"u")throw new Error(`input '${$}' is missing in 'feeds'.`);if(b)for(const $ of this.outputNames)d[$]=null;const et=await this.handler.run(e,d,h),st={};for(const $ in et)Object.hasOwnProperty.call(et,$)&&(st[$]=new Tensor$1(et[$].type,et[$].data,et[$].dims));return st}static async create(e,s,a,d){let h,b={};if(typeof e=="string"){if(h=e,typeof s=="object"&&s!==null)b=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(h=e,typeof s=="object"&&s!==null)b=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){const g=e;let c=0,_=e.byteLength;if(typeof s=="object"&&s!==null)b=s;else if(typeof s=="number"){if(c=s,!Number.isSafeInteger(c))throw new RangeError("'byteOffset' must be an integer.");if(c<0||c>=g.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${g.byteLength}).`);if(_=e.byteLength-c,typeof a=="number"){if(_=a,!Number.isSafeInteger(_))throw new RangeError("'byteLength' must be an integer.");if(_<=0||c+_>g.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${g.byteLength-c}].`);if(typeof d=="object"&&d!==null)b=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof s<"u")throw new TypeError("'options' must be an object.");h=new Uint8Array(g,c,_)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const st=(b.executionProviders||[]).map(g=>typeof g=="string"?g:g.name),it=await(await resolveBackend(st)).createSessionHandler(h,b);return new n_(it)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const InferenceSession$1=InferenceSession$2,lib=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:InferenceSession$1,Tensor:Tensor$1,env:env$2,registerBackend},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(lib);/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/(function(module,exports){(function(o,e){module.exports=e(require$$0)})(self,__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(o,e,s)=>{var a,d=(a=(a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(h){function b(){return dn.buffer!=gn&&t0(dn.buffer),En}function et(){return dn.buffer!=gn&&t0(dn.buffer),_r}function st(){return dn.buffer!=gn&&t0(dn.buffer),Sr}function $(){return dn.buffer!=gn&&t0(dn.buffer),xr}function it(){return dn.buffer!=gn&&t0(dn.buffer),Vr}var g,c,_;h=h||{},g||(g=h!==void 0?h:{}),g.ready=new Promise(function(Pt,Wt){c=Pt,_=Wt});var ot,ct,dt,pt,ft,ht,bt=Object.assign({},g),mt="./this.program",$t=(Pt,Wt)=>{throw Wt},Tt=typeof window=="object",Nt=typeof importScripts=="function",Ct=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",Ft=g.ENVIRONMENT_IS_PTHREAD||!1,ln="";function mn(Pt){return g.locateFile?g.locateFile(Pt,ln):ln+Pt}if(Ct){let Pt;ln=Nt?s(908).dirname(ln)+"/":"//",ht=()=>{ft||(pt=s(1384),ft=s(908))},ot=function(Wt,un){return ht(),Wt=ft.normalize(Wt),pt.readFileSync(Wt,un?void 0:"utf8")},dt=Wt=>((Wt=ot(Wt,!0)).buffer||(Wt=new Uint8Array(Wt)),Wt),ct=(Wt,un,bn)=>{ht(),Wt=ft.normalize(Wt),pt.readFile(Wt,function(Tn,tr){Tn?bn(Tn):un(tr.buffer)})},1<process.argv.length&&(mt=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(Wt){if(!(Wt instanceof S0))throw Wt}),process.on("unhandledRejection",function(Wt){throw Wt}),$t=(Wt,un)=>{if(v0())throw process.exitCode=Wt,un;un instanceof S0||cn("exiting due to exception: "+un),process.exit(Wt)},g.inspect=function(){return"[Emscripten Module object]"};try{Pt=s(9925)}catch(Wt){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Wt}s.g.Worker=Pt.Worker}else(Tt||Nt)&&(Nt?ln=self.location.href:typeof document<"u"&&document.currentScript&&(ln=document.currentScript.src),a&&(ln=a),ln=ln.indexOf("blob:")!==0?ln.substr(0,ln.replace(/[?#].*/,"").lastIndexOf("/")+1):"",Ct||(ot=Pt=>{var Wt=new XMLHttpRequest;return Wt.open("GET",Pt,!1),Wt.send(null),Wt.responseText},Nt&&(dt=Pt=>{var Wt=new XMLHttpRequest;return Wt.open("GET",Pt,!1),Wt.responseType="arraybuffer",Wt.send(null),new Uint8Array(Wt.response)}),ct=(Pt,Wt,un)=>{var bn=new XMLHttpRequest;bn.open("GET",Pt,!0),bn.responseType="arraybuffer",bn.onload=()=>{bn.status==200||bn.status==0&&bn.response?Wt(bn.response):un()},bn.onerror=un,bn.send(null)}));Ct&&typeof performance>"u"&&(s.g.performance=s(6953).performance);var yn=console.log.bind(console),pn=console.warn.bind(console);Ct&&(ht(),yn=Pt=>pt.writeSync(1,Pt+`
`),pn=Pt=>pt.writeSync(2,Pt+`
`));var Ht,Gt=g.print||yn,cn=g.printErr||pn;Object.assign(g,bt),bt=null,g.thisProgram&&(mt=g.thisProgram),g.quit&&($t=g.quit),g.wasmBinary&&(Ht=g.wasmBinary);var xn=g.noExitRuntime||!1;typeof WebAssembly!="object"&&Ro("no native wasm support detected");var dn,wn,gn,En,_r,Sr,xr,Vr,Fr=!1,_f=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function h0(Pt,Wt,un){var bn=(Wt>>>=0)+un;for(un=Wt;Pt[un]&&!(un>=bn);)++un;if(16<un-Wt&&Pt.buffer&&_f)return _f.decode(Pt.buffer instanceof SharedArrayBuffer?Pt.slice(Wt,un):Pt.subarray(Wt,un));for(bn="";Wt<un;){var Tn=Pt[Wt++];if(128&Tn){var tr=63&Pt[Wt++];if((224&Tn)==192)bn+=String.fromCharCode((31&Tn)<<6|tr);else{var vr=63&Pt[Wt++];65536>(Tn=(240&Tn)==224?(15&Tn)<<12|tr<<6|vr:(7&Tn)<<18|tr<<12|vr<<6|63&Pt[Wt++])?bn+=String.fromCharCode(Tn):(Tn-=65536,bn+=String.fromCharCode(55296|Tn>>10,56320|1023&Tn))}}else bn+=String.fromCharCode(Tn)}return bn}function Po(Pt,Wt){return(Pt>>>=0)?h0(et(),Pt,Wt):""}function No(Pt,Wt,un,bn){if(!(0<bn))return 0;var Tn=un>>>=0;bn=un+bn-1;for(var tr=0;tr<Pt.length;++tr){var vr=Pt.charCodeAt(tr);if(55296<=vr&&57343>=vr&&(vr=65536+((1023&vr)<<10)|1023&Pt.charCodeAt(++tr)),127>=vr){if(un>=bn)break;Wt[un++>>>0]=vr}else{if(2047>=vr){if(un+1>=bn)break;Wt[un++>>>0]=192|vr>>6}else{if(65535>=vr){if(un+2>=bn)break;Wt[un++>>>0]=224|vr>>12}else{if(un+3>=bn)break;Wt[un++>>>0]=240|vr>>18,Wt[un++>>>0]=128|vr>>12&63}Wt[un++>>>0]=128|vr>>6&63}Wt[un++>>>0]=128|63&vr}}return Wt[un>>>0]=0,un-Tn}function o0(Pt){for(var Wt=0,un=0;un<Pt.length;++un){var bn=Pt.charCodeAt(un);127>=bn?Wt++:2047>=bn?Wt+=2:55296<=bn&&57343>=bn?(Wt+=4,++un):Wt+=3}return Wt}function t0(Pt){gn=Pt,g.HEAP8=En=new Int8Array(Pt),g.HEAP16=new Int16Array(Pt),g.HEAP32=Sr=new Int32Array(Pt),g.HEAPU8=_r=new Uint8Array(Pt),g.HEAPU16=new Uint16Array(Pt),g.HEAPU32=xr=new Uint32Array(Pt),g.HEAPF32=new Float32Array(Pt),g.HEAPF64=Vr=new Float64Array(Pt)}Ft&&(gn=g.buffer);var xu=g.INITIAL_MEMORY||16777216;if(Ft)dn=g.wasmMemory,gn=g.buffer;else if(g.wasmMemory)dn=g.wasmMemory;else if(!((dn=new WebAssembly.Memory({initial:xu/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw cn("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Ct&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");dn&&(gn=dn.buffer),xu=gn.byteLength,t0(gn);var M0,k0=[],T0=[],j0=[],O0=[];function v0(){return xn||!1}function A0(){var Pt=g.preRun.shift();k0.unshift(Pt)}var _i,x0=0,y0=null;function Ro(Pt){throw Ft?postMessage({cmd:"onAbort",arg:Pt}):g.onAbort&&g.onAbort(Pt),cn(Pt="Aborted("+Pt+")"),Fr=!0,Pt=new WebAssembly.RuntimeError(Pt+". Build with -sASSERTIONS for more info."),_(Pt),Pt}function C0(){return _i.startsWith("data:application/octet-stream;base64,")}function H0(){var Pt=_i;try{if(Pt==_i&&Ht)return new Uint8Array(Ht);if(dt)return dt(Pt);throw"both async and sync fetching of the wasm failed"}catch(Wt){Ro(Wt)}}_i="ort-wasm-threaded.wasm",C0()||(_i=mn(_i));var Z0={};function S0(Pt){this.name="ExitStatus",this.message="Program terminated with exit("+Pt+")",this.status=Pt}function q0(Pt){(Pt=Ir.Vb[Pt])||Ro(),Ir.mc(Pt)}function $0(Pt){var Wt=Ir.Cc();if(!Wt)return 6;Ir.ac.push(Wt),Ir.Vb[Pt.Ub]=Wt,Wt.Ub=Pt.Ub;var un={cmd:"run",start_routine:Pt.Ic,arg:Pt.zc,pthread_ptr:Pt.Ub};return Wt.$b=()=>{un.time=performance.now(),Wt.postMessage(un,Pt.Nc)},Wt.loaded&&(Wt.$b(),delete Wt.$b),0}function m0(Pt){if(Ft)return Tr(1,1,Pt);v0()||(Ir.oc(),g.onExit&&g.onExit(Pt),Fr=!0),$t(Pt,new S0(Pt))}function U0(Pt,Wt){if(!Wt&&Ft)throw P0(Pt),"unwind";v0()||Ft||(iy(),V0(j0),by(0),dy[1].length&&_0(1,10),dy[2].length&&_0(2,10),Ir.oc()),m0(Pt)}var Ir={Yb:[],ac:[],qc:[],Vb:{},fc:function(){Ft&&Ir.Ec()},Pc:function(){},Ec:function(){Ir.receiveObjectTransfer=Ir.Gc,Ir.threadInitTLS=Ir.pc,Ir.setExitStatus=Ir.nc,xn=!1},nc:function(){},oc:function(){for(var Pt of Object.values(Ir.Vb))Ir.mc(Pt);for(Pt of Ir.Yb)Pt.terminate();Ir.Yb=[]},mc:function(Pt){var Wt=Pt.Ub;delete Ir.Vb[Wt],Ir.Yb.push(Pt),Ir.ac.splice(Ir.ac.indexOf(Pt),1),Pt.Ub=0,sy(Wt)},Gc:function(){},pc:function(){Ir.qc.forEach(Pt=>Pt())},Fc:function(Pt,Wt){Pt.onmessage=un=>{var bn=(un=un.data).cmd;if(Pt.Ub&&(Ir.Bc=Pt.Ub),un.targetThread&&un.targetThread!=ry()){var Tn=Ir.Vb[un.Qc];Tn?Tn.postMessage(un,un.transferList):cn('Internal error! Worker sent a message "'+bn+'" to target pthread '+un.targetThread+", but that thread no longer exists!")}else bn==="processProxyingQueue"?vn(un.queue):bn==="spawnThread"?$0(un):bn==="cleanupThread"?q0(un.thread):bn==="killThread"?(un=un.thread,bn=Ir.Vb[un],delete Ir.Vb[un],bn.terminate(),sy(un),Ir.ac.splice(Ir.ac.indexOf(bn),1),bn.Ub=0):bn==="cancelThread"?Ir.Vb[un.thread].postMessage({cmd:"cancel"}):bn==="loaded"?(Pt.loaded=!0,Wt&&Wt(Pt),Pt.$b&&(Pt.$b(),delete Pt.$b)):bn==="print"?Gt("Thread "+un.threadId+": "+un.text):bn==="printErr"?cn("Thread "+un.threadId+": "+un.text):bn==="alert"?alert("Thread "+un.threadId+": "+un.text):un.target==="setimmediate"?Pt.postMessage(un):bn==="onAbort"?g.onAbort&&g.onAbort(un.arg):bn&&cn("worker sent an unknown command "+bn);Ir.Bc=void 0},Pt.onerror=un=>{throw cn("worker sent an error! "+un.filename+":"+un.lineno+": "+un.message),un},Ct&&(Pt.on("message",function(un){Pt.onmessage({data:un})}),Pt.on("error",function(un){Pt.onerror(un)}),Pt.on("detachedExit",function(){})),Pt.postMessage({cmd:"load",urlOrBlob:g.mainScriptUrlOrBlob||a,wasmMemory:dn,wasmModule:wn})},yc:function(){var Pt=mn("ort-wasm-threaded.worker.js");Ir.Yb.push(new Worker(Pt))},Cc:function(){return Ir.Yb.length==0&&(Ir.yc(),Ir.Fc(Ir.Yb[0])),Ir.Yb.pop()}};function V0(Pt){for(;0<Pt.length;)Pt.shift()(g)}function Wo(Pt){var Wt=ns();return Pt=Pt(),Zr(Wt),Pt}function P0(Pt){if(Ft)return Tr(2,0,Pt);try{U0(Pt)}catch(Wt){Wt instanceof S0||Wt=="unwind"||$t(1,Wt)}}g.PThread=Ir,g.establishStackSpace=function(){var Pt=ry(),Wt=st()[Pt+44>>2>>>0];Pt=st()[Pt+48>>2>>>0],B0(Wt,Wt-Pt),Zr(Wt)};var D0=[];function n0(Pt){var Wt=D0[Pt];return Wt||(Pt>=D0.length&&(D0.length=Pt+1),D0[Pt]=Wt=M0.get(Pt)),Wt}g.invokeEntryPoint=function(Pt,Wt){Pt=n0(Pt)(Wt),v0()?Ir.nc(Pt):xy(Pt)};var K0,ay,Ur=[],Yr=0,qr=0;function eo(Pt){this.Zb=Pt,this.Sb=Pt-24,this.xc=function(Wt){$()[this.Sb+4>>2>>>0]=Wt},this.bc=function(){return $()[this.Sb+4>>2>>>0]},this.wc=function(Wt){$()[this.Sb+8>>2>>>0]=Wt},this.Dc=function(){return $()[this.Sb+8>>2>>>0]},this.rc=function(){st()[this.Sb>>2>>>0]=0},this.hc=function(Wt){Wt=Wt?1:0,b()[this.Sb+12>>0>>>0]=Wt},this.uc=function(){return b()[this.Sb+12>>0>>>0]!=0},this.ic=function(Wt){Wt=Wt?1:0,b()[this.Sb+13>>0>>>0]=Wt},this.kc=function(){return b()[this.Sb+13>>0>>>0]!=0},this.fc=function(Wt,un){this.cc(0),this.xc(Wt),this.wc(un),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(st(),this.Sb>>2,1)},this.Hc=function(){return Atomics.sub(st(),this.Sb>>2,1)===1},this.cc=function(Wt){$()[this.Sb+16>>2>>>0]=Wt},this.tc=function(){return $()[this.Sb+16>>2>>>0]},this.vc=function(){if(Lt(this.bc()))return $()[this.Zb>>2>>>0];var Wt=this.tc();return Wt!==0?Wt:this.Zb}}function uy(Pt){return Hr(new eo(Pt).Sb)}function Y0(Pt,Wt,un,bn){return Ft?Tr(3,1,Pt,Wt,un,bn):X0(Pt,Wt,un,bn)}function X0(Pt,Wt,un,bn){if(typeof SharedArrayBuffer>"u")return cn("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Tn=[];return Ft&&Tn.length===0?Y0(Pt,Wt,un,bn):(Pt={Ic:un,Ub:Pt,zc:bn,Nc:Tn},Ft?(Pt.Oc="spawnThread",postMessage(Pt,Tn),0):$0(Pt))}function J0(Pt,Wt,un){return Ft?Tr(4,1,Pt,Wt,un):0}function G0(Pt,Wt){if(Ft)return Tr(5,1,Pt,Wt)}function d0(Pt,Wt){if(Ft)return Tr(6,1,Pt,Wt)}function ly(Pt,Wt,un){if(Ft)return Tr(7,1,Pt,Wt,un)}function N0(Pt,Wt,un){return Ft?Tr(8,1,Pt,Wt,un):0}function E0(Pt,Wt){if(Ft)return Tr(9,1,Pt,Wt)}function ey(Pt,Wt,un){if(Ft)return Tr(10,1,Pt,Wt,un)}function z0(Pt,Wt,un,bn){if(Ft)return Tr(11,1,Pt,Wt,un,bn)}function ty(Pt,Wt,un,bn){if(Ft)return Tr(12,1,Pt,Wt,un,bn)}function ny(Pt,Wt,un,bn){if(Ft)return Tr(13,1,Pt,Wt,un,bn)}function cy(Pt){if(Ft)return Tr(14,1,Pt)}function Qt(Pt,Wt){if(Ft)return Tr(15,1,Pt,Wt)}function fn(Pt,Wt,un){if(Ft)return Tr(16,1,Pt,Wt,un)}function vn(Pt){Atomics.store(st(),Pt>>2,1),ry()&&_y(Pt),Atomics.compareExchange(st(),Pt>>2,1,0)}function Sn(Pt){return $()[Pt>>>2]+4294967296*st()[Pt+4>>>2]}function An(Pt,Wt,un,bn,Tn,tr){return Ft?Tr(17,1,Pt,Wt,un,bn,Tn,tr):-52}function In(Pt,Wt,un,bn,Tn,tr){if(Ft)return Tr(18,1,Pt,Wt,un,bn,Tn,tr)}function wr(Pt){var Wt=o0(Pt)+1,un=vy(Wt);return un&&No(Pt,b(),un,Wt),un}function Dr(Pt,Wt,un){function bn(vm){return(vm=vm.toTimeString().match(/\(([A-Za-z ]+)\)$/))?vm[1]:"GMT"}if(Ft)return Tr(19,1,Pt,Wt,un);var Tn=new Date().getFullYear(),tr=new Date(Tn,0,1),vr=new Date(Tn,6,1);Tn=tr.getTimezoneOffset();var Nr=vr.getTimezoneOffset(),_h=Math.max(Tn,Nr);st()[Pt>>2>>>0]=60*_h,st()[Wt>>2>>>0]=+(Tn!=Nr),Pt=bn(tr),Wt=bn(vr),Pt=wr(Pt),Wt=wr(Wt),Nr<Tn?($()[un>>2>>>0]=Pt,$()[un+4>>2>>>0]=Wt):($()[un>>2>>>0]=Wt,$()[un+4>>2>>>0]=Pt)}function Tr(Pt,Wt){var un=arguments.length-2,bn=arguments;return Wo(()=>{for(var Tn=hy(8*un),tr=Tn>>3,vr=0;vr<un;vr++){var Nr=bn[2+vr];it()[tr+vr>>>0]=Nr}return fy(Pt,un,Tn,Wt)})}g.executeNotifiedProxyingQueue=vn,ay=Ct?()=>{var Pt=process.hrtime();return 1e3*Pt[0]+Pt[1]/1e6}:Ft?()=>performance.now()-g.__performance_now_clock_drift:()=>performance.now();var Wr,r0=[],g0={};function u0(){if(!Wr){var Pt,Wt={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:mt||"./this.program"};for(Pt in g0)g0[Pt]===void 0?delete Wt[Pt]:Wt[Pt]=g0[Pt];var un=[];for(Pt in Wt)un.push(Pt+"="+Wt[Pt]);Wr=un}return Wr}function er(Pt,Wt){if(Ft)return Tr(20,1,Pt,Wt);var un=0;return u0().forEach(function(bn,Tn){var tr=Wt+un;for(Tn=$()[Pt+4*Tn>>2>>>0]=tr,tr=0;tr<bn.length;++tr)b()[Tn++>>0>>>0]=bn.charCodeAt(tr);b()[Tn>>0>>>0]=0,un+=bn.length+1}),0}function Gr(Pt,Wt){if(Ft)return Tr(21,1,Pt,Wt);var un=u0();$()[Pt>>2>>>0]=un.length;var bn=0;return un.forEach(function(Tn){bn+=Tn.length+1}),$()[Wt>>2>>>0]=bn,0}function s0(Pt){return Ft?Tr(22,1,Pt):52}function I0(Pt,Wt,un,bn){return Ft?Tr(23,1,Pt,Wt,un,bn):52}function b0(Pt,Wt,un,bn,Tn){return Ft?Tr(24,1,Pt,Wt,un,bn,Tn):70}var dy=[null,[],[]];function _0(Pt,Wt){var un=dy[Pt];Wt===0||Wt===10?((Pt===1?Gt:cn)(h0(un,0)),un.length=0):un.push(Wt)}function L0(Pt,Wt,un,bn){if(Ft)return Tr(25,1,Pt,Wt,un,bn);for(var Tn=0,tr=0;tr<un;tr++){var vr=$()[Wt>>2>>>0],Nr=$()[Wt+4>>2>>>0];Wt+=8;for(var _h=0;_h<Nr;_h++)_0(Pt,et()[vr+_h>>>0]);Tn+=Nr}return $()[bn>>2>>>0]=Tn,0}var w0=0;function gy(Pt){return Pt%4==0&&(Pt%100!=0||Pt%400==0)}var wy=[31,29,31,30,31,30,31,31,30,31,30,31],yy=[31,28,31,30,31,30,31,31,30,31,30,31];function Sy(Pt,Wt,un,bn){function Tn(nr,_g,p0){for(nr=typeof nr=="number"?nr.toString():nr||"";nr.length<_g;)nr=p0[0]+nr;return nr}function tr(nr,_g){return Tn(nr,_g,"0")}function vr(nr,_g){function p0(my){return 0>my?-1:0<my?1:0}var Q0;return(Q0=p0(nr.getFullYear()-_g.getFullYear()))===0&&(Q0=p0(nr.getMonth()-_g.getMonth()))===0&&(Q0=p0(nr.getDate()-_g.getDate())),Q0}function Nr(nr){switch(nr.getDay()){case 0:return new Date(nr.getFullYear()-1,11,29);case 1:return nr;case 2:return new Date(nr.getFullYear(),0,3);case 3:return new Date(nr.getFullYear(),0,2);case 4:return new Date(nr.getFullYear(),0,1);case 5:return new Date(nr.getFullYear()-1,11,31);case 6:return new Date(nr.getFullYear()-1,11,30)}}function _h(nr){var _g=nr.Wb;for(nr=new Date(new Date(nr.Xb+1900,0,1).getTime());0<_g;){var p0=nr.getMonth(),Q0=(gy(nr.getFullYear())?wy:yy)[p0];if(!(_g>Q0-nr.getDate())){nr.setDate(nr.getDate()+_g);break}_g-=Q0-nr.getDate()+1,nr.setDate(1),11>p0?nr.setMonth(p0+1):(nr.setMonth(0),nr.setFullYear(nr.getFullYear()+1))}return p0=new Date(nr.getFullYear()+1,0,4),_g=Nr(new Date(nr.getFullYear(),0,4)),p0=Nr(p0),0>=vr(_g,nr)?0>=vr(p0,nr)?nr.getFullYear()+1:nr.getFullYear():nr.getFullYear()-1}var vm=st()[bn+40>>2>>>0];for(var f0 in bn={Lc:st()[bn>>2>>>0],Kc:st()[bn+4>>2>>>0],dc:st()[bn+8>>2>>>0],jc:st()[bn+12>>2>>>0],ec:st()[bn+16>>2>>>0],Xb:st()[bn+20>>2>>>0],Tb:st()[bn+24>>2>>>0],Wb:st()[bn+28>>2>>>0],Rc:st()[bn+32>>2>>>0],Jc:st()[bn+36>>2>>>0],Mc:vm?Po(vm):""},un=Po(un),vm={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})un=un.replace(new RegExp(f0,"g"),vm[f0]);var W0="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),F0="January February March April May June July August September October November December".split(" ");for(f0 in vm={"%a":function(nr){return W0[nr.Tb].substring(0,3)},"%A":function(nr){return W0[nr.Tb]},"%b":function(nr){return F0[nr.ec].substring(0,3)},"%B":function(nr){return F0[nr.ec]},"%C":function(nr){return tr((nr.Xb+1900)/100|0,2)},"%d":function(nr){return tr(nr.jc,2)},"%e":function(nr){return Tn(nr.jc,2," ")},"%g":function(nr){return _h(nr).toString().substring(2)},"%G":function(nr){return _h(nr)},"%H":function(nr){return tr(nr.dc,2)},"%I":function(nr){return(nr=nr.dc)==0?nr=12:12<nr&&(nr-=12),tr(nr,2)},"%j":function(nr){for(var _g=0,p0=0;p0<=nr.ec-1;_g+=(gy(nr.Xb+1900)?wy:yy)[p0++]);return tr(nr.jc+_g,3)},"%m":function(nr){return tr(nr.ec+1,2)},"%M":function(nr){return tr(nr.Kc,2)},"%n":function(){return`
`},"%p":function(nr){return 0<=nr.dc&&12>nr.dc?"AM":"PM"},"%S":function(nr){return tr(nr.Lc,2)},"%t":function(){return"	"},"%u":function(nr){return nr.Tb||7},"%U":function(nr){return tr(Math.floor((nr.Wb+7-nr.Tb)/7),2)},"%V":function(nr){var _g=Math.floor((nr.Wb+7-(nr.Tb+6)%7)/7);if(2>=(nr.Tb+371-nr.Wb-2)%7&&_g++,_g)_g==53&&((p0=(nr.Tb+371-nr.Wb)%7)==4||p0==3&&gy(nr.Xb)||(_g=1));else{_g=52;var p0=(nr.Tb+7-nr.Wb-1)%7;(p0==4||p0==5&&gy(nr.Xb%400-1))&&_g++}return tr(_g,2)},"%w":function(nr){return nr.Tb},"%W":function(nr){return tr(Math.floor((nr.Wb+7-(nr.Tb+6)%7)/7),2)},"%y":function(nr){return(nr.Xb+1900).toString().substring(2)},"%Y":function(nr){return nr.Xb+1900},"%z":function(nr){var _g=0<=(nr=nr.Jc);return nr=Math.abs(nr)/60,(_g?"+":"-")+("0000"+(nr/60*100+nr%60)).slice(-4)},"%Z":function(nr){return nr.Mc},"%%":function(){return"%"}},un=un.replace(/%%/g,"\0\0"),vm)un.includes(f0)&&(un=un.replace(new RegExp(f0,"g"),vm[f0](bn)));return f0=function(nr){var _g=Array(o0(nr)+1);return No(nr,_g,0,_g.length),_g}(un=un.replace(/\0\0/g,"%")),f0.length>Wt?0:(function(nr,_g){b().set(nr,_g>>>0)}(f0,Pt),f0.length-1)}Ir.fc();var Ey=[null,m0,P0,Y0,J0,G0,d0,ly,N0,E0,ey,z0,ty,ny,cy,Qt,fn,An,In,Dr,er,Gr,s0,I0,b0,L0],ky={b:function(Pt){return vy(Pt+24)+24},n:function(Pt){return(Pt=new eo(Pt)).uc()||(Pt.hc(!0),Yr--),Pt.ic(!1),Ur.push(Pt),Pt.sc(),Pt.vc()},ma:function(Pt){throw cn("Unexpected exception thrown, this is not properly supported - aborting"),Fr=!0,Pt},x:function(){Xr(0);var Pt=Ur.pop();if(Pt.Hc()&&!Pt.kc()){var Wt=Pt.Dc();Wt&&n0(Wt)(Pt.Zb),uy(Pt.Zb)}qr=0},e:function(){var Pt=qr;if(!Pt)return w0=0;var Wt=new eo(Pt);Wt.cc(Pt);var un=Wt.bc();if(!un)return w0=0,Pt;for(var bn=Array.prototype.slice.call(arguments),Tn=0;Tn<bn.length;Tn++){var tr=bn[Tn];if(tr===0||tr===un)break;if(vt(tr,un,Wt.Sb+16))return w0=tr,Pt}return w0=un,Pt},l:function(){var Pt=qr;if(!Pt)return w0=0;var Wt=new eo(Pt);Wt.cc(Pt);var un=Wt.bc();if(!un)return w0=0,Pt;for(var bn=Array.prototype.slice.call(arguments),Tn=0;Tn<bn.length;Tn++){var tr=bn[Tn];if(tr===0||tr===un)break;if(vt(tr,un,Wt.Sb+16))return w0=tr,Pt}return w0=un,Pt},h:function(){var Pt=qr;if(!Pt)return w0=0;var Wt=new eo(Pt);Wt.cc(Pt);var un=Wt.bc();if(!un)return w0=0,Pt;for(var bn=Array.prototype.slice.call(arguments),Tn=0;Tn<bn.length;Tn++){var tr=bn[Tn];if(tr===0||tr===un)break;if(vt(tr,un,Wt.Sb+16))return w0=tr,Pt}return w0=un,Pt},t:uy,M:function(){var Pt=Ur.pop();Pt||Ro("no exception to throw");var Wt=Pt.Zb;throw Pt.kc()||(Ur.push(Pt),Pt.ic(!0),Pt.hc(!1),Yr++),qr=Wt,Wt},c:function(Pt,Wt,un){throw new eo(Pt).fc(Wt,un),qr=Pt,Yr++,Pt},pa:function(){return Yr},Fa:function(Pt){R0(Pt,!Nt,1,!Tt),Ir.pc()},T:function(Pt){Ft?postMessage({cmd:"cleanupThread",thread:Pt}):q0(Pt)},xa:X0,j:function(Pt){throw qr||(qr=Pt),Pt},H:J0,Ma:G0,ua:d0,wa:ly,oa:N0,Ka:E0,Ca:ey,Ja:z0,V:ty,va:ny,sa:cy,La:Qt,ta:fn,Ta:function(){},X:function(){Ro("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){Ro("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(Pt,Wt,un,bn){if(Pt==Wt)setTimeout(()=>vn(bn));else if(Ft)postMessage({targetThread:Pt,cmd:"processProxyingQueue",queue:bn});else{if(!(Pt=Ir.Vb[Pt]))return;Pt.postMessage({cmd:"processProxyingQueue",queue:bn})}return 1},Ea:function(){return-1},Pa:function(Pt,Wt){Pt=new Date(1e3*Sn(Pt)),st()[Wt>>2>>>0]=Pt.getUTCSeconds(),st()[Wt+4>>2>>>0]=Pt.getUTCMinutes(),st()[Wt+8>>2>>>0]=Pt.getUTCHours(),st()[Wt+12>>2>>>0]=Pt.getUTCDate(),st()[Wt+16>>2>>>0]=Pt.getUTCMonth(),st()[Wt+20>>2>>>0]=Pt.getUTCFullYear()-1900,st()[Wt+24>>2>>>0]=Pt.getUTCDay(),Pt=(Pt.getTime()-Date.UTC(Pt.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,st()[Wt+28>>2>>>0]=Pt},Qa:function(Pt,Wt){Pt=new Date(1e3*Sn(Pt)),st()[Wt>>2>>>0]=Pt.getSeconds(),st()[Wt+4>>2>>>0]=Pt.getMinutes(),st()[Wt+8>>2>>>0]=Pt.getHours(),st()[Wt+12>>2>>>0]=Pt.getDate(),st()[Wt+16>>2>>>0]=Pt.getMonth(),st()[Wt+20>>2>>>0]=Pt.getFullYear()-1900,st()[Wt+24>>2>>>0]=Pt.getDay();var un=new Date(Pt.getFullYear(),0,1),bn=(Pt.getTime()-un.getTime())/864e5|0;st()[Wt+28>>2>>>0]=bn,st()[Wt+36>>2>>>0]=-60*Pt.getTimezoneOffset(),bn=new Date(Pt.getFullYear(),6,1).getTimezoneOffset(),Pt=0|(bn!=(un=un.getTimezoneOffset())&&Pt.getTimezoneOffset()==Math.min(un,bn)),st()[Wt+32>>2>>>0]=Pt},Ra:function(Pt){var Wt=new Date(st()[Pt+20>>2>>>0]+1900,st()[Pt+16>>2>>>0],st()[Pt+12>>2>>>0],st()[Pt+8>>2>>>0],st()[Pt+4>>2>>>0],st()[Pt>>2>>>0],0),un=st()[Pt+32>>2>>>0],bn=Wt.getTimezoneOffset(),Tn=new Date(Wt.getFullYear(),0,1),tr=new Date(Wt.getFullYear(),6,1).getTimezoneOffset(),vr=Tn.getTimezoneOffset(),Nr=Math.min(vr,tr);return 0>un?st()[Pt+32>>2>>>0]=+(tr!=vr&&Nr==bn):0<un!=(Nr==bn)&&(tr=Math.max(vr,tr),Wt.setTime(Wt.getTime()+6e4*((0<un?Nr:tr)-bn))),st()[Pt+24>>2>>>0]=Wt.getDay(),un=(Wt.getTime()-Tn.getTime())/864e5|0,st()[Pt+28>>2>>>0]=un,st()[Pt>>2>>>0]=Wt.getSeconds(),st()[Pt+4>>2>>>0]=Wt.getMinutes(),st()[Pt+8>>2>>>0]=Wt.getHours(),st()[Pt+12>>2>>>0]=Wt.getDate(),st()[Pt+16>>2>>>0]=Wt.getMonth(),Wt.getTime()/1e3|0},Aa:An,Ba:In,Sa:function Pt(Wt,un,bn){Pt.Ac||(Pt.Ac=!0,Dr(Wt,un,bn))},y:function(){Ro("")},U:function(){if(!Ct&&!Nt){var Pt="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";K0||(K0={}),K0[Pt]||(K0[Pt]=1,Ct&&(Pt="warning: "+Pt),cn(Pt))}},ra:function(){return 4294901760},B:ay,Ia:function(Pt,Wt,un){et().copyWithin(Pt>>>0,Wt>>>0,Wt+un>>>0)},F:function(){return Ct?s(3993).cpus().length:navigator.hardwareConcurrency},Da:function(Pt,Wt,un){r0.length=Wt,un>>=3;for(var bn=0;bn<Wt;bn++)r0[bn]=it()[un+bn>>>0];return(0>Pt?Z0[-Pt-1]:Ey[Pt]).apply(null,r0)},qa:function(Pt){var Wt=et().length;if((Pt>>>=0)<=Wt||4294901760<Pt)return!1;for(var un=1;4>=un;un*=2){var bn=Wt*(1+.2/un);bn=Math.min(bn,Pt+100663296);var Tn=Math;bn=Math.max(Pt,bn),Tn=Tn.min.call(Tn,4294901760,bn+(65536-bn%65536)%65536);e:{try{dn.grow(Tn-gn.byteLength+65535>>>16),t0(dn.buffer);var tr=1;break e}catch{}tr=void 0}if(tr)return!0}return!1},Na:function(){throw"unwind"},Ga:er,Ha:Gr,J:U0,I:s0,S:I0,ga:b0,R:L0,d:function(){return w0},na:function Pt(Wt,un){Pt.lc||(Pt.lc=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var Tn=new Uint8Array(1);return()=>(crypto.getRandomValues(Tn),Tn[0])}if(Ct)try{var tr=s(Object(function(){var vr=new Error("Cannot find module 'crypto'");throw vr.code="MODULE_NOT_FOUND",vr}()));return()=>tr.randomBytes(1)[0]}catch{}return()=>Ro("randomDevice")}());for(var bn=0;bn<un;bn++)b()[Wt+bn>>0>>>0]=Pt.lc();return 0},ia:function(Pt,Wt,un){var bn=ns();try{return n0(Pt)(Wt,un)}catch(Tn){if(Zr(bn),Tn!==Tn+0)throw Tn;Xr(1,0)}},ja:function(Pt,Wt,un){var bn=ns();try{return n0(Pt)(Wt,un)}catch(Tn){if(Zr(bn),Tn!==Tn+0)throw Tn;Xr(1,0)}},K:function(Pt){var Wt=ns();try{return n0(Pt)()}catch(un){if(Zr(Wt),un!==un+0)throw un;Xr(1,0)}},f:function(Pt,Wt){var un=ns();try{return n0(Pt)(Wt)}catch(bn){if(Zr(un),bn!==bn+0)throw bn;Xr(1,0)}},P:function(Pt,Wt,un){var bn=ns();try{return n0(Pt)(Wt,un)}catch(Tn){if(Zr(bn),Tn!==Tn+0)throw Tn;Xr(1,0)}},Q:function(Pt,Wt,un){var bn=ns();try{return n0(Pt)(Wt,un)}catch(Tn){if(Zr(bn),Tn!==Tn+0)throw Tn;Xr(1,0)}},k:function(Pt,Wt,un){var bn=ns();try{return n0(Pt)(Wt,un)}catch(Tn){if(Zr(bn),Tn!==Tn+0)throw Tn;Xr(1,0)}},p:function(Pt,Wt,un,bn){var Tn=ns();try{return n0(Pt)(Wt,un,bn)}catch(tr){if(Zr(Tn),tr!==tr+0)throw tr;Xr(1,0)}},q:function(Pt,Wt,un,bn,Tn){var tr=ns();try{return n0(Pt)(Wt,un,bn,Tn)}catch(vr){if(Zr(tr),vr!==vr+0)throw vr;Xr(1,0)}},N:function(Pt,Wt,un,bn,Tn,tr){var vr=ns();try{return n0(Pt)(Wt,un,bn,Tn,tr)}catch(Nr){if(Zr(vr),Nr!==Nr+0)throw Nr;Xr(1,0)}},s:function(Pt,Wt,un,bn,Tn,tr){var vr=ns();try{return n0(Pt)(Wt,un,bn,Tn,tr)}catch(Nr){if(Zr(vr),Nr!==Nr+0)throw Nr;Xr(1,0)}},w:function(Pt,Wt,un,bn,Tn,tr,vr){var Nr=ns();try{return n0(Pt)(Wt,un,bn,Tn,tr,vr)}catch(_h){if(Zr(Nr),_h!==_h+0)throw _h;Xr(1,0)}},L:function(Pt,Wt,un,bn,Tn,tr,vr,Nr){var _h=ns();try{return n0(Pt)(Wt,un,bn,Tn,tr,vr,Nr)}catch(vm){if(Zr(_h),vm!==vm+0)throw vm;Xr(1,0)}},E:function(Pt,Wt,un,bn,Tn,tr,vr,Nr,_h,vm,f0,W0){var F0=ns();try{return n0(Pt)(Wt,un,bn,Tn,tr,vr,Nr,_h,vm,f0,W0)}catch(nr){if(Zr(F0),nr!==nr+0)throw nr;Xr(1,0)}},aa:function(Pt,Wt,un,bn,Tn,tr,vr,Nr){var _h=ns();try{return jr(Pt,Wt,un,bn,Tn,tr,vr,Nr)}catch(vm){if(Zr(_h),vm!==vm+0)throw vm;Xr(1,0)}},_:function(Pt,Wt,un,bn,Tn,tr,vr){var Nr=ns();try{return Jt(Pt,Wt,un,bn,Tn,tr,vr)}catch(_h){if(Zr(Nr),_h!==_h+0)throw _h;Xr(1,0)}},Z:function(Pt,Wt,un,bn,Tn){var tr=ns();try{return e0(Pt,Wt,un,bn,Tn)}catch(vr){if(Zr(tr),vr!==vr+0)throw vr;Xr(1,0)}},ca:function(Pt,Wt,un,bn){var Tn=ns();try{return Cr(Pt,Wt,un,bn)}catch(tr){if(Zr(Tn),tr!==tr+0)throw tr;Xr(1,0)}},$:function(Pt){var Wt=ns();try{return Vt(Pt)}catch(un){if(Zr(Wt),un!==un+0)throw un;Xr(1,0)}},ba:function(Pt,Wt){var un=ns();try{return $r(Pt,Wt)}catch(bn){if(Zr(un),bn!==bn+0)throw bn;Xr(1,0)}},Y:function(Pt,Wt,un){var bn=ns();try{return _n(Pt,Wt,un)}catch(Tn){if(Zr(bn),Tn!==Tn+0)throw Tn;Xr(1,0)}},g:function(Pt){var Wt=ns();try{n0(Pt)()}catch(un){if(Zr(Wt),un!==un+0)throw un;Xr(1,0)}},r:function(Pt,Wt){var un=ns();try{n0(Pt)(Wt)}catch(bn){if(Zr(un),bn!==bn+0)throw bn;Xr(1,0)}},i:function(Pt,Wt,un){var bn=ns();try{n0(Pt)(Wt,un)}catch(Tn){if(Zr(bn),Tn!==Tn+0)throw Tn;Xr(1,0)}},ha:function(Pt,Wt,un,bn){var Tn=ns();try{n0(Pt)(Wt,un,bn)}catch(tr){if(Zr(Tn),tr!==tr+0)throw tr;Xr(1,0)}},m:function(Pt,Wt,un,bn){var Tn=ns();try{n0(Pt)(Wt,un,bn)}catch(tr){if(Zr(Tn),tr!==tr+0)throw tr;Xr(1,0)}},v:function(Pt,Wt,un,bn,Tn){var tr=ns();try{n0(Pt)(Wt,un,bn,Tn)}catch(vr){if(Zr(tr),vr!==vr+0)throw vr;Xr(1,0)}},u:function(Pt,Wt,un,bn,Tn,tr){var vr=ns();try{n0(Pt)(Wt,un,bn,Tn,tr)}catch(Nr){if(Zr(vr),Nr!==Nr+0)throw Nr;Xr(1,0)}},O:function(Pt,Wt,un,bn,Tn,tr,vr){var Nr=ns();try{n0(Pt)(Wt,un,bn,Tn,tr,vr)}catch(_h){if(Zr(Nr),_h!==_h+0)throw _h;Xr(1,0)}},A:function(Pt,Wt,un,bn,Tn,tr,vr,Nr){var _h=ns();try{n0(Pt)(Wt,un,bn,Tn,tr,vr,Nr)}catch(vm){if(Zr(_h),vm!==vm+0)throw vm;Xr(1,0)}},ka:function(Pt,Wt,un,bn,Tn,tr,vr,Nr,_h){var vm=ns();try{n0(Pt)(Wt,un,bn,Tn,tr,vr,Nr,_h)}catch(f0){if(Zr(vm),f0!==f0+0)throw f0;Xr(1,0)}},C:function(Pt,Wt,un,bn,Tn,tr,vr,Nr,_h,vm,f0){var W0=ns();try{n0(Pt)(Wt,un,bn,Tn,tr,vr,Nr,_h,vm,f0)}catch(F0){if(Zr(W0),F0!==F0+0)throw F0;Xr(1,0)}},D:function(Pt,Wt,un,bn,Tn,tr,vr,Nr,_h,vm,f0,W0,F0,nr,_g,p0){var Q0=ns();try{n0(Pt)(Wt,un,bn,Tn,tr,vr,Nr,_h,vm,f0,W0,F0,nr,_g,p0)}catch(my){if(Zr(Q0),my!==my+0)throw my;Xr(1,0)}},fa:function(Pt,Wt,un,bn,Tn,tr,vr,Nr){var _h=ns();try{Cn(Pt,Wt,un,bn,Tn,tr,vr,Nr)}catch(vm){if(Zr(_h),vm!==vm+0)throw vm;Xr(1,0)}},da:function(Pt,Wt,un,bn,Tn,tr,vr,Nr,_h,vm,f0,W0){var F0=ns();try{yr(Pt,Wt,un,bn,Tn,tr,vr,Nr,_h,vm,f0,W0)}catch(nr){if(Zr(F0),nr!==nr+0)throw nr;Xr(1,0)}},ea:function(Pt,Wt,un,bn,Tn,tr){var vr=ns();try{or(Pt,Wt,un,bn,Tn,tr)}catch(Nr){if(Zr(vr),Nr!==Nr+0)throw Nr;Xr(1,0)}},o:function(Pt){return Pt},a:dn||g.wasmMemory,G:function(Pt){w0=Pt},la:Sy,z:function(Pt,Wt,un,bn){return Sy(Pt,Wt,un,bn)}};(function(){function Pt(Tn,tr){g.asm=Tn.exports,Ir.qc.push(g.asm.sb),M0=g.asm.ub,T0.unshift(g.asm.Va),wn=tr,Ft||(x0--,g.monitorRunDependencies&&g.monitorRunDependencies(x0),x0==0&&y0&&(Tn=y0,y0=null,Tn()))}function Wt(Tn){Pt(Tn.instance,Tn.module)}function un(Tn){return function(){if(!Ht&&(Tt||Nt)){if(typeof fetch=="function"&&!_i.startsWith("file://"))return fetch(_i,{credentials:"same-origin"}).then(function(tr){if(!tr.ok)throw"failed to load wasm binary file at '"+_i+"'";return tr.arrayBuffer()}).catch(function(){return H0()});if(ct)return new Promise(function(tr,vr){ct(_i,function(Nr){tr(new Uint8Array(Nr))},vr)})}return Promise.resolve().then(function(){return H0()})}().then(function(tr){return WebAssembly.instantiate(tr,bn)}).then(function(tr){return tr}).then(Tn,function(tr){cn("failed to asynchronously prepare wasm: "+tr),Ro(tr)})}var bn={a:ky};if(Ft||(x0++,g.monitorRunDependencies&&g.monitorRunDependencies(x0)),g.instantiateWasm)try{return g.instantiateWasm(bn,Pt)}catch(Tn){return cn("Module.instantiateWasm callback failed with error: "+Tn),!1}(Ht||typeof WebAssembly.instantiateStreaming!="function"||C0()||_i.startsWith("file://")||Ct||typeof fetch!="function"?un(Wt):fetch(_i,{credentials:"same-origin"}).then(function(Tn){return WebAssembly.instantiateStreaming(Tn,bn).then(Wt,function(tr){return cn("wasm streaming compile failed: "+tr),cn("falling back to ArrayBuffer instantiation"),un(Wt)})})).catch(_)})(),g.___wasm_call_ctors=function(){return(g.___wasm_call_ctors=g.asm.Va).apply(null,arguments)},g._OrtInit=function(){return(g._OrtInit=g.asm.Wa).apply(null,arguments)},g._OrtCreateSessionOptions=function(){return(g._OrtCreateSessionOptions=g.asm.Xa).apply(null,arguments)},g._OrtAppendExecutionProvider=function(){return(g._OrtAppendExecutionProvider=g.asm.Ya).apply(null,arguments)},g._OrtAddSessionConfigEntry=function(){return(g._OrtAddSessionConfigEntry=g.asm.Za).apply(null,arguments)},g._OrtReleaseSessionOptions=function(){return(g._OrtReleaseSessionOptions=g.asm._a).apply(null,arguments)},g._OrtCreateSession=function(){return(g._OrtCreateSession=g.asm.$a).apply(null,arguments)},g._OrtReleaseSession=function(){return(g._OrtReleaseSession=g.asm.ab).apply(null,arguments)},g._OrtGetInputCount=function(){return(g._OrtGetInputCount=g.asm.bb).apply(null,arguments)},g._OrtGetOutputCount=function(){return(g._OrtGetOutputCount=g.asm.cb).apply(null,arguments)},g._OrtGetInputName=function(){return(g._OrtGetInputName=g.asm.db).apply(null,arguments)},g._OrtGetOutputName=function(){return(g._OrtGetOutputName=g.asm.eb).apply(null,arguments)},g._OrtFree=function(){return(g._OrtFree=g.asm.fb).apply(null,arguments)},g._OrtCreateTensor=function(){return(g._OrtCreateTensor=g.asm.gb).apply(null,arguments)},g._OrtGetTensorData=function(){return(g._OrtGetTensorData=g.asm.hb).apply(null,arguments)},g._OrtReleaseTensor=function(){return(g._OrtReleaseTensor=g.asm.ib).apply(null,arguments)},g._OrtCreateRunOptions=function(){return(g._OrtCreateRunOptions=g.asm.jb).apply(null,arguments)},g._OrtAddRunConfigEntry=function(){return(g._OrtAddRunConfigEntry=g.asm.kb).apply(null,arguments)},g._OrtReleaseRunOptions=function(){return(g._OrtReleaseRunOptions=g.asm.lb).apply(null,arguments)},g._OrtRun=function(){return(g._OrtRun=g.asm.mb).apply(null,arguments)},g._OrtEndProfiling=function(){return(g._OrtEndProfiling=g.asm.nb).apply(null,arguments)};var ry=g._pthread_self=function(){return(ry=g._pthread_self=g.asm.ob).apply(null,arguments)},vy=g._malloc=function(){return(vy=g._malloc=g.asm.pb).apply(null,arguments)},Hr=g._free=function(){return(Hr=g._free=g.asm.qb).apply(null,arguments)},by=g._fflush=function(){return(by=g._fflush=g.asm.rb).apply(null,arguments)};g.__emscripten_tls_init=function(){return(g.__emscripten_tls_init=g.asm.sb).apply(null,arguments)};var iy=g.___funcs_on_exit=function(){return(iy=g.___funcs_on_exit=g.asm.tb).apply(null,arguments)},R0=g.__emscripten_thread_init=function(){return(R0=g.__emscripten_thread_init=g.asm.vb).apply(null,arguments)};g.__emscripten_thread_crashed=function(){return(g.__emscripten_thread_crashed=g.asm.wb).apply(null,arguments)};var oy,fy=g._emscripten_run_in_main_runtime_thread_js=function(){return(fy=g._emscripten_run_in_main_runtime_thread_js=g.asm.xb).apply(null,arguments)},_y=g.__emscripten_proxy_execute_task_queue=function(){return(_y=g.__emscripten_proxy_execute_task_queue=g.asm.yb).apply(null,arguments)},sy=g.__emscripten_thread_free_data=function(){return(sy=g.__emscripten_thread_free_data=g.asm.zb).apply(null,arguments)},xy=g.__emscripten_thread_exit=function(){return(xy=g.__emscripten_thread_exit=g.asm.Ab).apply(null,arguments)},Xr=g._setThrew=function(){return(Xr=g._setThrew=g.asm.Bb).apply(null,arguments)},B0=g._emscripten_stack_set_limits=function(){return(B0=g._emscripten_stack_set_limits=g.asm.Cb).apply(null,arguments)},ns=g.stackSave=function(){return(ns=g.stackSave=g.asm.Db).apply(null,arguments)},Zr=g.stackRestore=function(){return(Zr=g.stackRestore=g.asm.Eb).apply(null,arguments)},hy=g.stackAlloc=function(){return(hy=g.stackAlloc=g.asm.Fb).apply(null,arguments)},vt=g.___cxa_can_catch=function(){return(vt=g.___cxa_can_catch=g.asm.Gb).apply(null,arguments)},Lt=g.___cxa_is_pointer_type=function(){return(Lt=g.___cxa_is_pointer_type=g.asm.Hb).apply(null,arguments)},Vt=g.dynCall_j=function(){return(Vt=g.dynCall_j=g.asm.Ib).apply(null,arguments)},Jt=g.dynCall_iiiiij=function(){return(Jt=g.dynCall_iiiiij=g.asm.Jb).apply(null,arguments)},_n=g.dynCall_jii=function(){return(_n=g.dynCall_jii=g.asm.Kb).apply(null,arguments)},Cn=g.dynCall_viiiiij=function(){return(Cn=g.dynCall_viiiiij=g.asm.Lb).apply(null,arguments)},or=g.dynCall_vjji=function(){return(or=g.dynCall_vjji=g.asm.Mb).apply(null,arguments)},yr=g.dynCall_viiijjjii=function(){return(yr=g.dynCall_viiijjjii=g.asm.Nb).apply(null,arguments)},Cr=g.dynCall_iij=function(){return(Cr=g.dynCall_iij=g.asm.Ob).apply(null,arguments)},$r=g.dynCall_ji=function(){return($r=g.dynCall_ji=g.asm.Pb).apply(null,arguments)},jr=g.dynCall_iiiiiij=function(){return(jr=g.dynCall_iiiiiij=g.asm.Qb).apply(null,arguments)},e0=g.dynCall_iiij=function(){return(e0=g.dynCall_iiij=g.asm.Rb).apply(null,arguments)};function i0(){function Pt(){if(!oy&&(oy=!0,g.calledRun=!0,!Fr)&&(Ft||V0(T0),c(g),g.onRuntimeInitialized&&g.onRuntimeInitialized(),!Ft)){if(g.postRun)for(typeof g.postRun=="function"&&(g.postRun=[g.postRun]);g.postRun.length;){var Wt=g.postRun.shift();O0.unshift(Wt)}V0(O0)}}if(!(0<x0))if(Ft)c(g),Ft||V0(T0),postMessage({cmd:"loaded"});else{if(g.preRun)for(typeof g.preRun=="function"&&(g.preRun=[g.preRun]);g.preRun.length;)A0();V0(k0),0<x0||(g.setStatus?(g.setStatus("Running..."),setTimeout(function(){setTimeout(function(){g.setStatus("")},1),Pt()},1)):Pt())}}if(g.UTF8ToString=Po,g.stringToUTF8=function(Pt,Wt,un){return No(Pt,et(),Wt,un)},g.lengthBytesUTF8=o0,g.keepRuntimeAlive=v0,g.wasmMemory=dn,g.stackSave=ns,g.stackRestore=Zr,g.stackAlloc=hy,g.ExitStatus=S0,g.PThread=Ir,y0=function Pt(){oy||i0(),oy||(y0=Pt)},g.preInit)for(typeof g.preInit=="function"&&(g.preInit=[g.preInit]);0<g.preInit.length;)g.preInit.pop()();return i0(),h.ready});o.exports=d},932:(o,e,s)=>{var a,d=(a=(a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(h){var b,et,st;h=h||{},b||(b=h!==void 0?h:{}),b.ready=new Promise(function(Qt,fn){et=Qt,st=fn});var $,it,g,c,_,ot,ct=Object.assign({},b),dt="./this.program",pt=(Qt,fn)=>{throw fn},ft=typeof window=="object",ht=typeof importScripts=="function",bt=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",mt="";bt?(mt=ht?s(908).dirname(mt)+"/":"//",ot=()=>{_||(c=s(1384),_=s(908))},$=function(Qt,fn){return ot(),Qt=_.normalize(Qt),c.readFileSync(Qt,fn?void 0:"utf8")},g=Qt=>((Qt=$(Qt,!0)).buffer||(Qt=new Uint8Array(Qt)),Qt),it=(Qt,fn,vn)=>{ot(),Qt=_.normalize(Qt),c.readFile(Qt,function(Sn,An){Sn?vn(Sn):fn(An.buffer)})},1<process.argv.length&&(dt=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(Qt){if(!(Qt instanceof T0))throw Qt}),process.on("unhandledRejection",function(Qt){throw Qt}),pt=(Qt,fn)=>{if(Ct||0<_f)throw process.exitCode=Qt,fn;fn instanceof T0||Nt("exiting due to exception: "+fn),process.exit(Qt)},b.inspect=function(){return"[Emscripten Module object]"}):(ft||ht)&&(ht?mt=self.location.href:typeof document<"u"&&document.currentScript&&(mt=document.currentScript.src),a&&(mt=a),mt=mt.indexOf("blob:")!==0?mt.substr(0,mt.replace(/[?#].*/,"").lastIndexOf("/")+1):"",$=Qt=>{var fn=new XMLHttpRequest;return fn.open("GET",Qt,!1),fn.send(null),fn.responseText},ht&&(g=Qt=>{var fn=new XMLHttpRequest;return fn.open("GET",Qt,!1),fn.responseType="arraybuffer",fn.send(null),new Uint8Array(fn.response)}),it=(Qt,fn,vn)=>{var Sn=new XMLHttpRequest;Sn.open("GET",Qt,!0),Sn.responseType="arraybuffer",Sn.onload=()=>{Sn.status==200||Sn.status==0&&Sn.response?fn(Sn.response):vn()},Sn.onerror=vn,Sn.send(null)});var $t,Tt=b.print||console.log.bind(console),Nt=b.printErr||console.warn.bind(console);Object.assign(b,ct),ct=null,b.thisProgram&&(dt=b.thisProgram),b.quit&&(pt=b.quit),b.wasmBinary&&($t=b.wasmBinary);var Ct=b.noExitRuntime||!1;typeof WebAssembly!="object"&&t0("no native wasm support detected");var Ft,ln,mn,yn,pn,Ht,Gt=!1,cn=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function xn(Qt,fn,vn){var Sn=(fn>>>=0)+vn;for(vn=fn;Qt[vn]&&!(vn>=Sn);)++vn;if(16<vn-fn&&Qt.buffer&&cn)return cn.decode(Qt.subarray(fn,vn));for(Sn="";fn<vn;){var An=Qt[fn++];if(128&An){var In=63&Qt[fn++];if((224&An)==192)Sn+=String.fromCharCode((31&An)<<6|In);else{var wr=63&Qt[fn++];65536>(An=(240&An)==224?(15&An)<<12|In<<6|wr:(7&An)<<18|In<<12|wr<<6|63&Qt[fn++])?Sn+=String.fromCharCode(An):(An-=65536,Sn+=String.fromCharCode(55296|An>>10,56320|1023&An))}}else Sn+=String.fromCharCode(An)}return Sn}function dn(Qt,fn){return(Qt>>>=0)?xn(yn,Qt,fn):""}function wn(Qt,fn,vn,Sn){if(!(0<Sn))return 0;var An=vn>>>=0;Sn=vn+Sn-1;for(var In=0;In<Qt.length;++In){var wr=Qt.charCodeAt(In);if(55296<=wr&&57343>=wr&&(wr=65536+((1023&wr)<<10)|1023&Qt.charCodeAt(++In)),127>=wr){if(vn>=Sn)break;fn[vn++>>>0]=wr}else{if(2047>=wr){if(vn+1>=Sn)break;fn[vn++>>>0]=192|wr>>6}else{if(65535>=wr){if(vn+2>=Sn)break;fn[vn++>>>0]=224|wr>>12}else{if(vn+3>=Sn)break;fn[vn++>>>0]=240|wr>>18,fn[vn++>>>0]=128|wr>>12&63}fn[vn++>>>0]=128|wr>>6&63}fn[vn++>>>0]=128|63&wr}}return fn[vn>>>0]=0,vn-An}function gn(Qt){for(var fn=0,vn=0;vn<Qt.length;++vn){var Sn=Qt.charCodeAt(vn);127>=Sn?fn++:2047>=Sn?fn+=2:55296<=Sn&&57343>=Sn?(fn+=4,++vn):fn+=3}return fn}function En(){var Qt=Ft.buffer;ln=Qt,b.HEAP8=mn=new Int8Array(Qt),b.HEAP16=new Int16Array(Qt),b.HEAP32=pn=new Int32Array(Qt),b.HEAPU8=yn=new Uint8Array(Qt),b.HEAPU16=new Uint16Array(Qt),b.HEAPU32=Ht=new Uint32Array(Qt),b.HEAPF32=new Float32Array(Qt),b.HEAPF64=new Float64Array(Qt)}var _r,Sr=[],xr=[],Vr=[],Fr=[],_f=0;function h0(){var Qt=b.preRun.shift();Sr.unshift(Qt)}var Po,No=0,o0=null;function t0(Qt){throw b.onAbort&&b.onAbort(Qt),Nt(Qt="Aborted("+Qt+")"),Gt=!0,Qt=new WebAssembly.RuntimeError(Qt+". Build with -sASSERTIONS for more info."),st(Qt),Qt}function xu(){return Po.startsWith("data:application/octet-stream;base64,")}if(Po="ort-wasm.wasm",!xu()){var M0=Po;Po=b.locateFile?b.locateFile(M0,mt):mt+M0}function k0(){var Qt=Po;try{if(Qt==Po&&$t)return new Uint8Array($t);if(g)return g(Qt);throw"both async and sync fetching of the wasm failed"}catch(fn){t0(fn)}}function T0(Qt){this.name="ExitStatus",this.message="Program terminated with exit("+Qt+")",this.status=Qt}function j0(Qt){for(;0<Qt.length;)Qt.shift()(b)}var O0=[],v0=0,A0=0;function _i(Qt){this.Db=Qt,this.zb=Qt-24,this.Ub=function(fn){Ht[this.zb+4>>2>>>0]=fn},this.Eb=function(){return Ht[this.zb+4>>2>>>0]},this.Sb=function(fn){Ht[this.zb+8>>2>>>0]=fn},this.Wb=function(){return Ht[this.zb+8>>2>>>0]},this.Tb=function(){pn[this.zb>>2>>>0]=0},this.Ib=function(fn){mn[this.zb+12>>0>>>0]=fn?1:0},this.Pb=function(){return mn[this.zb+12>>0>>>0]!=0},this.Jb=function(fn){mn[this.zb+13>>0>>>0]=fn?1:0},this.Lb=function(){return mn[this.zb+13>>0>>>0]!=0},this.Rb=function(fn,vn){this.Fb(0),this.Ub(fn),this.Sb(vn),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){pn[this.zb>>2>>>0]+=1},this.Xb=function(){var fn=pn[this.zb>>2>>>0];return pn[this.zb>>2>>>0]=fn-1,fn===1},this.Fb=function(fn){Ht[this.zb+16>>2>>>0]=fn},this.Ob=function(){return Ht[this.zb+16>>2>>>0]},this.Qb=function(){if(X0(this.Eb()))return Ht[this.Db>>2>>>0];var fn=this.Ob();return fn!==0?fn:this.Db}}function x0(Qt){return K0(new _i(Qt).zb)}var y0=[];function Ro(Qt){var fn=y0[Qt];return fn||(Qt>=y0.length&&(y0.length=Qt+1),y0[Qt]=fn=_r.get(Qt)),fn}function C0(Qt){var fn=gn(Qt)+1,vn=n0(fn);return vn&&wn(Qt,mn,vn,fn),vn}var H0={};function Z0(){if(!S0){var Qt,fn={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:dt||"./this.program"};for(Qt in H0)H0[Qt]===void 0?delete fn[Qt]:fn[Qt]=H0[Qt];var vn=[];for(Qt in fn)vn.push(Qt+"="+fn[Qt]);S0=vn}return S0}var S0,q0=[null,[],[]];function $0(Qt,fn){var vn=q0[Qt];fn===0||fn===10?((Qt===1?Tt:Nt)(xn(vn,0)),vn.length=0):vn.push(fn)}var m0=0;function U0(Qt){return Qt%4==0&&(Qt%100!=0||Qt%400==0)}var Ir=[31,29,31,30,31,30,31,31,30,31,30,31],V0=[31,28,31,30,31,30,31,31,30,31,30,31];function Wo(Qt,fn,vn,Sn){function An(er,Gr,s0){for(er=typeof er=="number"?er.toString():er||"";er.length<Gr;)er=s0[0]+er;return er}function In(er,Gr){return An(er,Gr,"0")}function wr(er,Gr){function s0(b0){return 0>b0?-1:0<b0?1:0}var I0;return(I0=s0(er.getFullYear()-Gr.getFullYear()))===0&&(I0=s0(er.getMonth()-Gr.getMonth()))===0&&(I0=s0(er.getDate()-Gr.getDate())),I0}function Dr(er){switch(er.getDay()){case 0:return new Date(er.getFullYear()-1,11,29);case 1:return er;case 2:return new Date(er.getFullYear(),0,3);case 3:return new Date(er.getFullYear(),0,2);case 4:return new Date(er.getFullYear(),0,1);case 5:return new Date(er.getFullYear()-1,11,31);case 6:return new Date(er.getFullYear()-1,11,30)}}function Tr(er){var Gr=er.Bb;for(er=new Date(new Date(er.Cb+1900,0,1).getTime());0<Gr;){var s0=er.getMonth(),I0=(U0(er.getFullYear())?Ir:V0)[s0];if(!(Gr>I0-er.getDate())){er.setDate(er.getDate()+Gr);break}Gr-=I0-er.getDate()+1,er.setDate(1),11>s0?er.setMonth(s0+1):(er.setMonth(0),er.setFullYear(er.getFullYear()+1))}return s0=new Date(er.getFullYear()+1,0,4),Gr=Dr(new Date(er.getFullYear(),0,4)),s0=Dr(s0),0>=wr(Gr,er)?0>=wr(s0,er)?er.getFullYear()+1:er.getFullYear():er.getFullYear()-1}var Wr=pn[Sn+40>>2>>>0];for(var r0 in Sn={$b:pn[Sn>>2>>>0],Zb:pn[Sn+4>>2>>>0],Gb:pn[Sn+8>>2>>>0],Kb:pn[Sn+12>>2>>>0],Hb:pn[Sn+16>>2>>>0],Cb:pn[Sn+20>>2>>>0],Ab:pn[Sn+24>>2>>>0],Bb:pn[Sn+28>>2>>>0],bc:pn[Sn+32>>2>>>0],Yb:pn[Sn+36>>2>>>0],ac:Wr?dn(Wr):""},vn=dn(vn),Wr={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})vn=vn.replace(new RegExp(r0,"g"),Wr[r0]);var g0="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),u0="January February March April May June July August September October November December".split(" ");for(r0 in Wr={"%a":function(er){return g0[er.Ab].substring(0,3)},"%A":function(er){return g0[er.Ab]},"%b":function(er){return u0[er.Hb].substring(0,3)},"%B":function(er){return u0[er.Hb]},"%C":function(er){return In((er.Cb+1900)/100|0,2)},"%d":function(er){return In(er.Kb,2)},"%e":function(er){return An(er.Kb,2," ")},"%g":function(er){return Tr(er).toString().substring(2)},"%G":function(er){return Tr(er)},"%H":function(er){return In(er.Gb,2)},"%I":function(er){return(er=er.Gb)==0?er=12:12<er&&(er-=12),In(er,2)},"%j":function(er){for(var Gr=0,s0=0;s0<=er.Hb-1;Gr+=(U0(er.Cb+1900)?Ir:V0)[s0++]);return In(er.Kb+Gr,3)},"%m":function(er){return In(er.Hb+1,2)},"%M":function(er){return In(er.Zb,2)},"%n":function(){return`
`},"%p":function(er){return 0<=er.Gb&&12>er.Gb?"AM":"PM"},"%S":function(er){return In(er.$b,2)},"%t":function(){return"	"},"%u":function(er){return er.Ab||7},"%U":function(er){return In(Math.floor((er.Bb+7-er.Ab)/7),2)},"%V":function(er){var Gr=Math.floor((er.Bb+7-(er.Ab+6)%7)/7);if(2>=(er.Ab+371-er.Bb-2)%7&&Gr++,Gr)Gr==53&&((s0=(er.Ab+371-er.Bb)%7)==4||s0==3&&U0(er.Cb)||(Gr=1));else{Gr=52;var s0=(er.Ab+7-er.Bb-1)%7;(s0==4||s0==5&&U0(er.Cb%400-1))&&Gr++}return In(Gr,2)},"%w":function(er){return er.Ab},"%W":function(er){return In(Math.floor((er.Bb+7-(er.Ab+6)%7)/7),2)},"%y":function(er){return(er.Cb+1900).toString().substring(2)},"%Y":function(er){return er.Cb+1900},"%z":function(er){var Gr=0<=(er=er.Yb);return er=Math.abs(er)/60,(Gr?"+":"-")+("0000"+(er/60*100+er%60)).slice(-4)},"%Z":function(er){return er.ac},"%%":function(){return"%"}},vn=vn.replace(/%%/g,"\0\0"),Wr)vn.includes(r0)&&(vn=vn.replace(new RegExp(r0,"g"),Wr[r0](Sn)));return r0=function(er){var Gr=Array(gn(er)+1);return wn(er,Gr,0,Gr.length),Gr}(vn=vn.replace(/\0\0/g,"%")),r0.length>fn?0:(mn.set(r0,Qt>>>0),r0.length-1)}var P0={a:function(Qt){return n0(Qt+24)+24},m:function(Qt){return(Qt=new _i(Qt)).Pb()||(Qt.Ib(!0),v0--),Qt.Jb(!1),O0.push(Qt),Qt.Nb(),Qt.Qb()},ia:function(Qt){throw Nt("Unexpected exception thrown, this is not properly supported - aborting"),Gt=!0,Qt},w:function(){Yr(0);var Qt=O0.pop();if(Qt.Xb()&&!Qt.Lb()){var fn=Qt.Wb();fn&&Ro(fn)(Qt.Db),x0(Qt.Db)}A0=0},d:function(){var Qt=A0;if(!Qt)return m0=0;var fn=new _i(Qt);fn.Fb(Qt);var vn=fn.Eb();if(!vn)return m0=0,Qt;for(var Sn=Array.prototype.slice.call(arguments),An=0;An<Sn.length;An++){var In=Sn[An];if(In===0||In===vn)break;if(Y0(In,vn,fn.zb+16))return m0=In,Qt}return m0=vn,Qt},k:function(){var Qt=A0;if(!Qt)return m0=0;var fn=new _i(Qt);fn.Fb(Qt);var vn=fn.Eb();if(!vn)return m0=0,Qt;for(var Sn=Array.prototype.slice.call(arguments),An=0;An<Sn.length;An++){var In=Sn[An];if(In===0||In===vn)break;if(Y0(In,vn,fn.zb+16))return m0=In,Qt}return m0=vn,Qt},g:function(){var Qt=A0;if(!Qt)return m0=0;var fn=new _i(Qt);fn.Fb(Qt);var vn=fn.Eb();if(!vn)return m0=0,Qt;for(var Sn=Array.prototype.slice.call(arguments),An=0;An<Sn.length;An++){var In=Sn[An];if(In===0||In===vn)break;if(Y0(In,vn,fn.zb+16))return m0=In,Qt}return m0=vn,Qt},s:x0,L:function(){var Qt=O0.pop();Qt||t0("no exception to throw");var fn=Qt.Db;throw Qt.Lb()||(O0.push(Qt),Qt.Jb(!0),Qt.Ib(!1),v0++),A0=fn,fn},b:function(Qt,fn,vn){throw new _i(Qt).Rb(fn,vn),A0=Qt,v0++,Qt},la:function(){return v0},i:function(Qt){throw A0||(A0=Qt),Qt},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){t0("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){t0("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(Qt,fn){Qt=new Date(1e3*(Ht[Qt>>>2]+4294967296*pn[Qt+4>>>2])),pn[fn>>2>>>0]=Qt.getUTCSeconds(),pn[fn+4>>2>>>0]=Qt.getUTCMinutes(),pn[fn+8>>2>>>0]=Qt.getUTCHours(),pn[fn+12>>2>>>0]=Qt.getUTCDate(),pn[fn+16>>2>>>0]=Qt.getUTCMonth(),pn[fn+20>>2>>>0]=Qt.getUTCFullYear()-1900,pn[fn+24>>2>>>0]=Qt.getUTCDay(),pn[fn+28>>2>>>0]=(Qt.getTime()-Date.UTC(Qt.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(Qt,fn){Qt=new Date(1e3*(Ht[Qt>>>2]+4294967296*pn[Qt+4>>>2])),pn[fn>>2>>>0]=Qt.getSeconds(),pn[fn+4>>2>>>0]=Qt.getMinutes(),pn[fn+8>>2>>>0]=Qt.getHours(),pn[fn+12>>2>>>0]=Qt.getDate(),pn[fn+16>>2>>>0]=Qt.getMonth(),pn[fn+20>>2>>>0]=Qt.getFullYear()-1900,pn[fn+24>>2>>>0]=Qt.getDay();var vn=new Date(Qt.getFullYear(),0,1);pn[fn+28>>2>>>0]=(Qt.getTime()-vn.getTime())/864e5|0,pn[fn+36>>2>>>0]=-60*Qt.getTimezoneOffset();var Sn=new Date(Qt.getFullYear(),6,1).getTimezoneOffset();vn=vn.getTimezoneOffset(),pn[fn+32>>2>>>0]=0|(Sn!=vn&&Qt.getTimezoneOffset()==Math.min(vn,Sn))},Fa:function(Qt){var fn=new Date(pn[Qt+20>>2>>>0]+1900,pn[Qt+16>>2>>>0],pn[Qt+12>>2>>>0],pn[Qt+8>>2>>>0],pn[Qt+4>>2>>>0],pn[Qt>>2>>>0],0),vn=pn[Qt+32>>2>>>0],Sn=fn.getTimezoneOffset(),An=new Date(fn.getFullYear(),0,1),In=new Date(fn.getFullYear(),6,1).getTimezoneOffset(),wr=An.getTimezoneOffset(),Dr=Math.min(wr,In);return 0>vn?pn[Qt+32>>2>>>0]=+(In!=wr&&Dr==Sn):0<vn!=(Dr==Sn)&&(In=Math.max(wr,In),fn.setTime(fn.getTime()+6e4*((0<vn?Dr:In)-Sn))),pn[Qt+24>>2>>>0]=fn.getDay(),pn[Qt+28>>2>>>0]=(fn.getTime()-An.getTime())/864e5|0,pn[Qt>>2>>>0]=fn.getSeconds(),pn[Qt+4>>2>>>0]=fn.getMinutes(),pn[Qt+8>>2>>>0]=fn.getHours(),pn[Qt+12>>2>>>0]=fn.getDate(),pn[Qt+16>>2>>>0]=fn.getMonth(),fn.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function Qt(fn,vn,Sn){Qt.Vb||(Qt.Vb=!0,function(An,In,wr){function Dr(u0){return(u0=u0.toTimeString().match(/\(([A-Za-z ]+)\)$/))?u0[1]:"GMT"}var Tr=new Date().getFullYear(),Wr=new Date(Tr,0,1),r0=new Date(Tr,6,1);Tr=Wr.getTimezoneOffset();var g0=r0.getTimezoneOffset();pn[An>>2>>>0]=60*Math.max(Tr,g0),pn[In>>2>>>0]=+(Tr!=g0),An=Dr(Wr),In=Dr(r0),An=C0(An),In=C0(In),g0<Tr?(Ht[wr>>2>>>0]=An,Ht[wr+4>>2>>>0]=In):(Ht[wr>>2>>>0]=In,Ht[wr+4>>2>>>0]=An)}(fn,vn,Sn))},B:function(){t0("")},ma:function(){return 4294901760},I:bt?()=>{var Qt=process.hrtime();return 1e3*Qt[0]+Qt[1]/1e6}:()=>performance.now(),xa:function(Qt,fn,vn){yn.copyWithin(Qt>>>0,fn>>>0,fn+vn>>>0)},G:function(Qt){var fn=yn.length;if(4294901760<(Qt>>>=0))return!1;for(var vn=1;4>=vn;vn*=2){var Sn=fn*(1+.2/vn);Sn=Math.min(Sn,Qt+100663296);var An=Math;Sn=Math.max(Qt,Sn),An=An.min.call(An,4294901760,Sn+(65536-Sn%65536)%65536);e:{try{Ft.grow(An-ln.byteLength+65535>>>16),En();var In=1;break e}catch{}In=void 0}if(In)return!0}return!1},va:function(Qt,fn){var vn=0;return Z0().forEach(function(Sn,An){var In=fn+vn;for(An=Ht[Qt+4*An>>2>>>0]=In,In=0;In<Sn.length;++In)mn[An++>>0>>>0]=Sn.charCodeAt(In);mn[An>>0>>>0]=0,vn+=Sn.length+1}),0},wa:function(Qt,fn){var vn=Z0();Ht[Qt>>2>>>0]=vn.length;var Sn=0;return vn.forEach(function(An){Sn+=An.length+1}),Ht[fn>>2>>>0]=Sn,0},ba:function(Qt){Ct||0<_f||(Ur(),j0(Vr),ay(0),q0[1].length&&$0(1,10),q0[2].length&&$0(2,10)),Ct||0<_f||(b.onExit&&b.onExit(Qt),Gt=!0),pt(Qt,new T0(Qt))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(Qt,fn,vn,Sn){for(var An=0,In=0;In<vn;In++){var wr=Ht[fn>>2>>>0],Dr=Ht[fn+4>>2>>>0];fn+=8;for(var Tr=0;Tr<Dr;Tr++)$0(Qt,yn[wr+Tr>>>0]);An+=Dr}return Ht[Sn>>2>>>0]=An,0},c:function(){return m0},ja:function Qt(fn,vn){Qt.Mb||(Qt.Mb=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var An=new Uint8Array(1);return()=>(crypto.getRandomValues(An),An[0])}if(bt)try{var In=s(Object(function(){var wr=new Error("Cannot find module 'crypto'");throw wr.code="MODULE_NOT_FOUND",wr}()));return()=>In.randomBytes(1)[0]}catch{}return()=>t0("randomDevice")}());for(var Sn=0;Sn<vn;Sn++)mn[fn+Sn>>0>>>0]=Qt.Mb();return 0},ea:function(Qt,fn,vn){var Sn=qr();try{return Ro(Qt)(fn,vn)}catch(An){if(eo(Sn),An!==An+0)throw An;Yr(1,0)}},fa:function(Qt,fn,vn){var Sn=qr();try{return Ro(Qt)(fn,vn)}catch(An){if(eo(Sn),An!==An+0)throw An;Yr(1,0)}},J:function(Qt){var fn=qr();try{return Ro(Qt)()}catch(vn){if(eo(fn),vn!==vn+0)throw vn;Yr(1,0)}},e:function(Qt,fn){var vn=qr();try{return Ro(Qt)(fn)}catch(Sn){if(eo(vn),Sn!==Sn+0)throw Sn;Yr(1,0)}},N:function(Qt,fn,vn){var Sn=qr();try{return Ro(Qt)(fn,vn)}catch(An){if(eo(Sn),An!==An+0)throw An;Yr(1,0)}},O:function(Qt,fn,vn){var Sn=qr();try{return Ro(Qt)(fn,vn)}catch(An){if(eo(Sn),An!==An+0)throw An;Yr(1,0)}},j:function(Qt,fn,vn){var Sn=qr();try{return Ro(Qt)(fn,vn)}catch(An){if(eo(Sn),An!==An+0)throw An;Yr(1,0)}},o:function(Qt,fn,vn,Sn){var An=qr();try{return Ro(Qt)(fn,vn,Sn)}catch(In){if(eo(An),In!==In+0)throw In;Yr(1,0)}},p:function(Qt,fn,vn,Sn,An){var In=qr();try{return Ro(Qt)(fn,vn,Sn,An)}catch(wr){if(eo(In),wr!==wr+0)throw wr;Yr(1,0)}},M:function(Qt,fn,vn,Sn,An,In){var wr=qr();try{return Ro(Qt)(fn,vn,Sn,An,In)}catch(Dr){if(eo(wr),Dr!==Dr+0)throw Dr;Yr(1,0)}},r:function(Qt,fn,vn,Sn,An,In){var wr=qr();try{return Ro(Qt)(fn,vn,Sn,An,In)}catch(Dr){if(eo(wr),Dr!==Dr+0)throw Dr;Yr(1,0)}},v:function(Qt,fn,vn,Sn,An,In,wr){var Dr=qr();try{return Ro(Qt)(fn,vn,Sn,An,In,wr)}catch(Tr){if(eo(Dr),Tr!==Tr+0)throw Tr;Yr(1,0)}},K:function(Qt,fn,vn,Sn,An,In,wr,Dr){var Tr=qr();try{return Ro(Qt)(fn,vn,Sn,An,In,wr,Dr)}catch(Wr){if(eo(Tr),Wr!==Wr+0)throw Wr;Yr(1,0)}},D:function(Qt,fn,vn,Sn,An,In,wr,Dr,Tr,Wr,r0,g0){var u0=qr();try{return Ro(Qt)(fn,vn,Sn,An,In,wr,Dr,Tr,Wr,r0,g0)}catch(er){if(eo(u0),er!==er+0)throw er;Yr(1,0)}},X:function(Qt,fn,vn,Sn,An,In,wr,Dr){var Tr=qr();try{return ty(Qt,fn,vn,Sn,An,In,wr,Dr)}catch(Wr){if(eo(Tr),Wr!==Wr+0)throw Wr;Yr(1,0)}},V:function(Qt,fn,vn,Sn,An,In,wr){var Dr=qr();try{return G0(Qt,fn,vn,Sn,An,In,wr)}catch(Tr){if(eo(Dr),Tr!==Tr+0)throw Tr;Yr(1,0)}},U:function(Qt,fn,vn,Sn,An){var In=qr();try{return ny(Qt,fn,vn,Sn,An)}catch(wr){if(eo(In),wr!==wr+0)throw wr;Yr(1,0)}},Z:function(Qt,fn,vn,Sn){var An=qr();try{return ey(Qt,fn,vn,Sn)}catch(In){if(eo(An),In!==In+0)throw In;Yr(1,0)}},W:function(Qt){var fn=qr();try{return J0(Qt)}catch(vn){if(eo(fn),vn!==vn+0)throw vn;Yr(1,0)}},Y:function(Qt,fn){var vn=qr();try{return z0(Qt,fn)}catch(Sn){if(eo(vn),Sn!==Sn+0)throw Sn;Yr(1,0)}},T:function(Qt,fn,vn){var Sn=qr();try{return d0(Qt,fn,vn)}catch(An){if(eo(Sn),An!==An+0)throw An;Yr(1,0)}},f:function(Qt){var fn=qr();try{Ro(Qt)()}catch(vn){if(eo(fn),vn!==vn+0)throw vn;Yr(1,0)}},q:function(Qt,fn){var vn=qr();try{Ro(Qt)(fn)}catch(Sn){if(eo(vn),Sn!==Sn+0)throw Sn;Yr(1,0)}},h:function(Qt,fn,vn){var Sn=qr();try{Ro(Qt)(fn,vn)}catch(An){if(eo(Sn),An!==An+0)throw An;Yr(1,0)}},da:function(Qt,fn,vn,Sn){var An=qr();try{Ro(Qt)(fn,vn,Sn)}catch(In){if(eo(An),In!==In+0)throw In;Yr(1,0)}},l:function(Qt,fn,vn,Sn){var An=qr();try{Ro(Qt)(fn,vn,Sn)}catch(In){if(eo(An),In!==In+0)throw In;Yr(1,0)}},t:function(Qt,fn,vn,Sn,An){var In=qr();try{Ro(Qt)(fn,vn,Sn,An)}catch(wr){if(eo(In),wr!==wr+0)throw wr;Yr(1,0)}},u:function(Qt,fn,vn,Sn,An,In){var wr=qr();try{Ro(Qt)(fn,vn,Sn,An,In)}catch(Dr){if(eo(wr),Dr!==Dr+0)throw Dr;Yr(1,0)}},x:function(Qt,fn,vn,Sn,An,In,wr){var Dr=qr();try{Ro(Qt)(fn,vn,Sn,An,In,wr)}catch(Tr){if(eo(Dr),Tr!==Tr+0)throw Tr;Yr(1,0)}},z:function(Qt,fn,vn,Sn,An,In,wr,Dr){var Tr=qr();try{Ro(Qt)(fn,vn,Sn,An,In,wr,Dr)}catch(Wr){if(eo(Tr),Wr!==Wr+0)throw Wr;Yr(1,0)}},ga:function(Qt,fn,vn,Sn,An,In,wr,Dr,Tr){var Wr=qr();try{Ro(Qt)(fn,vn,Sn,An,In,wr,Dr,Tr)}catch(r0){if(eo(Wr),r0!==r0+0)throw r0;Yr(1,0)}},A:function(Qt,fn,vn,Sn,An,In,wr,Dr,Tr,Wr,r0){var g0=qr();try{Ro(Qt)(fn,vn,Sn,An,In,wr,Dr,Tr,Wr,r0)}catch(u0){if(eo(g0),u0!==u0+0)throw u0;Yr(1,0)}},C:function(Qt,fn,vn,Sn,An,In,wr,Dr,Tr,Wr,r0,g0,u0,er,Gr,s0){var I0=qr();try{Ro(Qt)(fn,vn,Sn,An,In,wr,Dr,Tr,Wr,r0,g0,u0,er,Gr,s0)}catch(b0){if(eo(I0),b0!==b0+0)throw b0;Yr(1,0)}},aa:function(Qt,fn,vn,Sn,An,In,wr,Dr){var Tr=qr();try{ly(Qt,fn,vn,Sn,An,In,wr,Dr)}catch(Wr){if(eo(Tr),Wr!==Wr+0)throw Wr;Yr(1,0)}},_:function(Qt,fn,vn,Sn,An,In,wr,Dr,Tr,Wr,r0,g0){var u0=qr();try{E0(Qt,fn,vn,Sn,An,In,wr,Dr,Tr,Wr,r0,g0)}catch(er){if(eo(u0),er!==er+0)throw er;Yr(1,0)}},$:function(Qt,fn,vn,Sn,An,In){var wr=qr();try{N0(Qt,fn,vn,Sn,An,In)}catch(Dr){if(eo(wr),Dr!==Dr+0)throw Dr;Yr(1,0)}},n:function(Qt){return Qt},F:function(Qt){m0=Qt},ha:Wo,y:function(Qt,fn,vn,Sn){return Wo(Qt,fn,vn,Sn)}};(function(){function Qt(An){b.asm=An.exports,Ft=b.asm.Ka,En(),_r=b.asm.ib,xr.unshift(b.asm.La),No--,b.monitorRunDependencies&&b.monitorRunDependencies(No),No==0&&o0&&(An=o0,o0=null,An())}function fn(An){Qt(An.instance)}function vn(An){return function(){if(!$t&&(ft||ht)){if(typeof fetch=="function"&&!Po.startsWith("file://"))return fetch(Po,{credentials:"same-origin"}).then(function(In){if(!In.ok)throw"failed to load wasm binary file at '"+Po+"'";return In.arrayBuffer()}).catch(function(){return k0()});if(it)return new Promise(function(In,wr){it(Po,function(Dr){In(new Uint8Array(Dr))},wr)})}return Promise.resolve().then(function(){return k0()})}().then(function(In){return WebAssembly.instantiate(In,Sn)}).then(function(In){return In}).then(An,function(In){Nt("failed to asynchronously prepare wasm: "+In),t0(In)})}var Sn={a:P0};if(No++,b.monitorRunDependencies&&b.monitorRunDependencies(No),b.instantiateWasm)try{return b.instantiateWasm(Sn,Qt)}catch(An){return Nt("Module.instantiateWasm callback failed with error: "+An),!1}($t||typeof WebAssembly.instantiateStreaming!="function"||xu()||Po.startsWith("file://")||bt||typeof fetch!="function"?vn(fn):fetch(Po,{credentials:"same-origin"}).then(function(An){return WebAssembly.instantiateStreaming(An,Sn).then(fn,function(In){return Nt("wasm streaming compile failed: "+In),Nt("falling back to ArrayBuffer instantiation"),vn(fn)})})).catch(st)})(),b.___wasm_call_ctors=function(){return(b.___wasm_call_ctors=b.asm.La).apply(null,arguments)},b._OrtInit=function(){return(b._OrtInit=b.asm.Ma).apply(null,arguments)},b._OrtCreateSessionOptions=function(){return(b._OrtCreateSessionOptions=b.asm.Na).apply(null,arguments)},b._OrtAppendExecutionProvider=function(){return(b._OrtAppendExecutionProvider=b.asm.Oa).apply(null,arguments)},b._OrtAddSessionConfigEntry=function(){return(b._OrtAddSessionConfigEntry=b.asm.Pa).apply(null,arguments)},b._OrtReleaseSessionOptions=function(){return(b._OrtReleaseSessionOptions=b.asm.Qa).apply(null,arguments)},b._OrtCreateSession=function(){return(b._OrtCreateSession=b.asm.Ra).apply(null,arguments)},b._OrtReleaseSession=function(){return(b._OrtReleaseSession=b.asm.Sa).apply(null,arguments)},b._OrtGetInputCount=function(){return(b._OrtGetInputCount=b.asm.Ta).apply(null,arguments)},b._OrtGetOutputCount=function(){return(b._OrtGetOutputCount=b.asm.Ua).apply(null,arguments)},b._OrtGetInputName=function(){return(b._OrtGetInputName=b.asm.Va).apply(null,arguments)},b._OrtGetOutputName=function(){return(b._OrtGetOutputName=b.asm.Wa).apply(null,arguments)},b._OrtFree=function(){return(b._OrtFree=b.asm.Xa).apply(null,arguments)},b._OrtCreateTensor=function(){return(b._OrtCreateTensor=b.asm.Ya).apply(null,arguments)},b._OrtGetTensorData=function(){return(b._OrtGetTensorData=b.asm.Za).apply(null,arguments)},b._OrtReleaseTensor=function(){return(b._OrtReleaseTensor=b.asm._a).apply(null,arguments)},b._OrtCreateRunOptions=function(){return(b._OrtCreateRunOptions=b.asm.$a).apply(null,arguments)},b._OrtAddRunConfigEntry=function(){return(b._OrtAddRunConfigEntry=b.asm.ab).apply(null,arguments)},b._OrtReleaseRunOptions=function(){return(b._OrtReleaseRunOptions=b.asm.bb).apply(null,arguments)},b._OrtRun=function(){return(b._OrtRun=b.asm.cb).apply(null,arguments)},b._OrtEndProfiling=function(){return(b._OrtEndProfiling=b.asm.db).apply(null,arguments)};var D0,n0=b._malloc=function(){return(n0=b._malloc=b.asm.eb).apply(null,arguments)},K0=b._free=function(){return(K0=b._free=b.asm.fb).apply(null,arguments)},ay=b._fflush=function(){return(ay=b._fflush=b.asm.gb).apply(null,arguments)},Ur=b.___funcs_on_exit=function(){return(Ur=b.___funcs_on_exit=b.asm.hb).apply(null,arguments)},Yr=b._setThrew=function(){return(Yr=b._setThrew=b.asm.jb).apply(null,arguments)},qr=b.stackSave=function(){return(qr=b.stackSave=b.asm.kb).apply(null,arguments)},eo=b.stackRestore=function(){return(eo=b.stackRestore=b.asm.lb).apply(null,arguments)},uy=b.stackAlloc=function(){return(uy=b.stackAlloc=b.asm.mb).apply(null,arguments)},Y0=b.___cxa_can_catch=function(){return(Y0=b.___cxa_can_catch=b.asm.nb).apply(null,arguments)},X0=b.___cxa_is_pointer_type=function(){return(X0=b.___cxa_is_pointer_type=b.asm.ob).apply(null,arguments)},J0=b.dynCall_j=function(){return(J0=b.dynCall_j=b.asm.pb).apply(null,arguments)},G0=b.dynCall_iiiiij=function(){return(G0=b.dynCall_iiiiij=b.asm.qb).apply(null,arguments)},d0=b.dynCall_jii=function(){return(d0=b.dynCall_jii=b.asm.rb).apply(null,arguments)},ly=b.dynCall_viiiiij=function(){return(ly=b.dynCall_viiiiij=b.asm.sb).apply(null,arguments)},N0=b.dynCall_vjji=function(){return(N0=b.dynCall_vjji=b.asm.tb).apply(null,arguments)},E0=b.dynCall_viiijjjii=function(){return(E0=b.dynCall_viiijjjii=b.asm.ub).apply(null,arguments)},ey=b.dynCall_iij=function(){return(ey=b.dynCall_iij=b.asm.vb).apply(null,arguments)},z0=b.dynCall_ji=function(){return(z0=b.dynCall_ji=b.asm.wb).apply(null,arguments)},ty=b.dynCall_iiiiiij=function(){return(ty=b.dynCall_iiiiiij=b.asm.xb).apply(null,arguments)},ny=b.dynCall_iiij=function(){return(ny=b.dynCall_iiij=b.asm.yb).apply(null,arguments)};function cy(){function Qt(){if(!D0&&(D0=!0,b.calledRun=!0,!Gt)){if(j0(xr),et(b),b.onRuntimeInitialized&&b.onRuntimeInitialized(),b.postRun)for(typeof b.postRun=="function"&&(b.postRun=[b.postRun]);b.postRun.length;){var fn=b.postRun.shift();Fr.unshift(fn)}j0(Fr)}}if(!(0<No)){if(b.preRun)for(typeof b.preRun=="function"&&(b.preRun=[b.preRun]);b.preRun.length;)h0();j0(Sr),0<No||(b.setStatus?(b.setStatus("Running..."),setTimeout(function(){setTimeout(function(){b.setStatus("")},1),Qt()},1)):Qt())}}if(b.UTF8ToString=dn,b.stringToUTF8=function(Qt,fn,vn){return wn(Qt,yn,fn,vn)},b.lengthBytesUTF8=gn,b.stackSave=qr,b.stackRestore=eo,b.stackAlloc=uy,o0=function Qt(){D0||cy(),D0||(o0=Qt)},b.preInit)for(typeof b.preInit=="function"&&(b.preInit=[b.preInit]);0<b.preInit.length;)b.preInit.pop()();return cy(),h.ready});o.exports=d},4537:o=>{o.exports=function(e,s){for(var a=new Array(arguments.length-1),d=0,h=2,b=!0;h<arguments.length;)a[d++]=arguments[h++];return new Promise(function(et,st){a[d]=function($){if(b)if(b=!1,$)st($);else{for(var it=new Array(arguments.length-1),g=0;g<it.length;)it[g++]=arguments[g];et.apply(null,it)}};try{e.apply(s||null,a)}catch($){b&&(b=!1,st($))}})}},7419:(o,e)=>{var s=e;s.length=function(et){var st=et.length;if(!st)return 0;for(var $=0;--st%4>1&&et.charAt(st)==="=";)++$;return Math.ceil(3*et.length)/4-$};for(var a=new Array(64),d=new Array(123),h=0;h<64;)d[a[h]=h<26?h+65:h<52?h+71:h<62?h-4:h-59|43]=h++;s.encode=function(et,st,$){for(var it,g=null,c=[],_=0,ot=0;st<$;){var ct=et[st++];switch(ot){case 0:c[_++]=a[ct>>2],it=(3&ct)<<4,ot=1;break;case 1:c[_++]=a[it|ct>>4],it=(15&ct)<<2,ot=2;break;case 2:c[_++]=a[it|ct>>6],c[_++]=a[63&ct],ot=0}_>8191&&((g||(g=[])).push(String.fromCharCode.apply(String,c)),_=0)}return ot&&(c[_++]=a[it],c[_++]=61,ot===1&&(c[_++]=61)),g?(_&&g.push(String.fromCharCode.apply(String,c.slice(0,_))),g.join("")):String.fromCharCode.apply(String,c.slice(0,_))};var b="invalid encoding";s.decode=function(et,st,$){for(var it,g=$,c=0,_=0;_<et.length;){var ot=et.charCodeAt(_++);if(ot===61&&c>1)break;if((ot=d[ot])===void 0)throw Error(b);switch(c){case 0:it=ot,c=1;break;case 1:st[$++]=it<<2|(48&ot)>>4,it=ot,c=2;break;case 2:st[$++]=(15&it)<<4|(60&ot)>>2,it=ot,c=3;break;case 3:st[$++]=(3&it)<<6|ot,c=0}}if(c===1)throw Error(b);return $-g},s.test=function(et){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(et)}},9211:o=>{function e(){this._listeners={}}o.exports=e,e.prototype.on=function(s,a,d){return(this._listeners[s]||(this._listeners[s]=[])).push({fn:a,ctx:d||this}),this},e.prototype.off=function(s,a){if(s===void 0)this._listeners={};else if(a===void 0)this._listeners[s]=[];else for(var d=this._listeners[s],h=0;h<d.length;)d[h].fn===a?d.splice(h,1):++h;return this},e.prototype.emit=function(s){var a=this._listeners[s];if(a){for(var d=[],h=1;h<arguments.length;)d.push(arguments[h++]);for(h=0;h<a.length;)a[h].fn.apply(a[h++].ctx,d)}return this}},945:o=>{function e(b){return typeof Float32Array<"u"?function(){var et=new Float32Array([-0]),st=new Uint8Array(et.buffer),$=st[3]===128;function it(ot,ct,dt){et[0]=ot,ct[dt]=st[0],ct[dt+1]=st[1],ct[dt+2]=st[2],ct[dt+3]=st[3]}function g(ot,ct,dt){et[0]=ot,ct[dt]=st[3],ct[dt+1]=st[2],ct[dt+2]=st[1],ct[dt+3]=st[0]}function c(ot,ct){return st[0]=ot[ct],st[1]=ot[ct+1],st[2]=ot[ct+2],st[3]=ot[ct+3],et[0]}function _(ot,ct){return st[3]=ot[ct],st[2]=ot[ct+1],st[1]=ot[ct+2],st[0]=ot[ct+3],et[0]}b.writeFloatLE=$?it:g,b.writeFloatBE=$?g:it,b.readFloatLE=$?c:_,b.readFloatBE=$?_:c}():function(){function et($,it,g,c){var _=it<0?1:0;if(_&&(it=-it),it===0)$(1/it>0?0:2147483648,g,c);else if(isNaN(it))$(2143289344,g,c);else if(it>34028234663852886e22)$((_<<31|2139095040)>>>0,g,c);else if(it<11754943508222875e-54)$((_<<31|Math.round(it/1401298464324817e-60))>>>0,g,c);else{var ot=Math.floor(Math.log(it)/Math.LN2);$((_<<31|ot+127<<23|8388607&Math.round(it*Math.pow(2,-ot)*8388608))>>>0,g,c)}}function st($,it,g){var c=$(it,g),_=2*(c>>31)+1,ot=c>>>23&255,ct=8388607&c;return ot===255?ct?NaN:_*(1/0):ot===0?1401298464324817e-60*_*ct:_*Math.pow(2,ot-150)*(ct+8388608)}b.writeFloatLE=et.bind(null,s),b.writeFloatBE=et.bind(null,a),b.readFloatLE=st.bind(null,d),b.readFloatBE=st.bind(null,h)}(),typeof Float64Array<"u"?function(){var et=new Float64Array([-0]),st=new Uint8Array(et.buffer),$=st[7]===128;function it(ot,ct,dt){et[0]=ot,ct[dt]=st[0],ct[dt+1]=st[1],ct[dt+2]=st[2],ct[dt+3]=st[3],ct[dt+4]=st[4],ct[dt+5]=st[5],ct[dt+6]=st[6],ct[dt+7]=st[7]}function g(ot,ct,dt){et[0]=ot,ct[dt]=st[7],ct[dt+1]=st[6],ct[dt+2]=st[5],ct[dt+3]=st[4],ct[dt+4]=st[3],ct[dt+5]=st[2],ct[dt+6]=st[1],ct[dt+7]=st[0]}function c(ot,ct){return st[0]=ot[ct],st[1]=ot[ct+1],st[2]=ot[ct+2],st[3]=ot[ct+3],st[4]=ot[ct+4],st[5]=ot[ct+5],st[6]=ot[ct+6],st[7]=ot[ct+7],et[0]}function _(ot,ct){return st[7]=ot[ct],st[6]=ot[ct+1],st[5]=ot[ct+2],st[4]=ot[ct+3],st[3]=ot[ct+4],st[2]=ot[ct+5],st[1]=ot[ct+6],st[0]=ot[ct+7],et[0]}b.writeDoubleLE=$?it:g,b.writeDoubleBE=$?g:it,b.readDoubleLE=$?c:_,b.readDoubleBE=$?_:c}():function(){function et($,it,g,c,_,ot){var ct=c<0?1:0;if(ct&&(c=-c),c===0)$(0,_,ot+it),$(1/c>0?0:2147483648,_,ot+g);else if(isNaN(c))$(0,_,ot+it),$(2146959360,_,ot+g);else if(c>17976931348623157e292)$(0,_,ot+it),$((ct<<31|2146435072)>>>0,_,ot+g);else{var dt;if(c<22250738585072014e-324)$((dt=c/5e-324)>>>0,_,ot+it),$((ct<<31|dt/4294967296)>>>0,_,ot+g);else{var pt=Math.floor(Math.log(c)/Math.LN2);pt===1024&&(pt=1023),$(4503599627370496*(dt=c*Math.pow(2,-pt))>>>0,_,ot+it),$((ct<<31|pt+1023<<20|1048576*dt&1048575)>>>0,_,ot+g)}}}function st($,it,g,c,_){var ot=$(c,_+it),ct=$(c,_+g),dt=2*(ct>>31)+1,pt=ct>>>20&2047,ft=4294967296*(1048575&ct)+ot;return pt===2047?ft?NaN:dt*(1/0):pt===0?5e-324*dt*ft:dt*Math.pow(2,pt-1075)*(ft+4503599627370496)}b.writeDoubleLE=et.bind(null,s,0,4),b.writeDoubleBE=et.bind(null,a,4,0),b.readDoubleLE=st.bind(null,d,0,4),b.readDoubleBE=st.bind(null,h,4,0)}(),b}function s(b,et,st){et[st]=255&b,et[st+1]=b>>>8&255,et[st+2]=b>>>16&255,et[st+3]=b>>>24}function a(b,et,st){et[st]=b>>>24,et[st+1]=b>>>16&255,et[st+2]=b>>>8&255,et[st+3]=255&b}function d(b,et){return(b[et]|b[et+1]<<8|b[et+2]<<16|b[et+3]<<24)>>>0}function h(b,et){return(b[et]<<24|b[et+1]<<16|b[et+2]<<8|b[et+3])>>>0}o.exports=e(e)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(o){}return null}module.exports=inquire},6662:o=>{o.exports=function(e,s,a){var d=a||8192,h=d>>>1,b=null,et=d;return function(st){if(st<1||st>h)return e(st);et+st>d&&(b=e(d),et=0);var $=s.call(b,et,et+=st);return 7&et&&(et=1+(7|et)),$}}},4997:(o,e)=>{var s=e;s.length=function(a){for(var d=0,h=0,b=0;b<a.length;++b)(h=a.charCodeAt(b))<128?d+=1:h<2048?d+=2:(64512&h)==55296&&(64512&a.charCodeAt(b+1))==56320?(++b,d+=4):d+=3;return d},s.read=function(a,d,h){if(h-d<1)return"";for(var b,et=null,st=[],$=0;d<h;)(b=a[d++])<128?st[$++]=b:b>191&&b<224?st[$++]=(31&b)<<6|63&a[d++]:b>239&&b<365?(b=((7&b)<<18|(63&a[d++])<<12|(63&a[d++])<<6|63&a[d++])-65536,st[$++]=55296+(b>>10),st[$++]=56320+(1023&b)):st[$++]=(15&b)<<12|(63&a[d++])<<6|63&a[d++],$>8191&&((et||(et=[])).push(String.fromCharCode.apply(String,st)),$=0);return et?($&&et.push(String.fromCharCode.apply(String,st.slice(0,$))),et.join("")):String.fromCharCode.apply(String,st.slice(0,$))},s.write=function(a,d,h){for(var b,et,st=h,$=0;$<a.length;++$)(b=a.charCodeAt($))<128?d[h++]=b:b<2048?(d[h++]=b>>6|192,d[h++]=63&b|128):(64512&b)==55296&&(64512&(et=a.charCodeAt($+1)))==56320?(b=65536+((1023&b)<<10)+(1023&et),++$,d[h++]=b>>18|240,d[h++]=b>>12&63|128,d[h++]=b>>6&63|128,d[h++]=63&b|128):(d[h++]=b>>12|224,d[h++]=b>>6&63|128,d[h++]=63&b|128);return h-st}},3442:(o,e)=>{e.__esModule=!0;var s=function(){function a(d){if(!d)throw new TypeError("Invalid argument; `value` has no value.");this.value=a.EMPTY,d&&a.isGuid(d)&&(this.value=d)}return a.isGuid=function(d){var h=d.toString();return d&&(d instanceof a||a.validator.test(h))},a.create=function(){return new a([a.gen(2),a.gen(1),a.gen(1),a.gen(1),a.gen(3)].join("-"))},a.createEmpty=function(){return new a("emptyguid")},a.parse=function(d){return new a(d)},a.raw=function(){return[a.gen(2),a.gen(1),a.gen(1),a.gen(1),a.gen(3)].join("-")},a.gen=function(d){for(var h="",b=0;b<d;b++)h+=(65536*(1+Math.random())|0).toString(16).substring(1);return h},a.prototype.equals=function(d){return a.isGuid(d)&&this.value===d.toString()},a.prototype.isEmpty=function(){return this.value===a.EMPTY},a.prototype.toString=function(){return this.value},a.prototype.toJSON=function(){return{value:this.value}},a.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),a.EMPTY="00000000-0000-0000-0000-000000000000",a}();e.Guid=s},3720:o=>{o.exports=s;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function s(Ct,Ft,ln){this.low=0|Ct,this.high=0|Ft,this.unsigned=!!ln}function a(Ct){return(Ct&&Ct.__isLong__)===!0}s.prototype.__isLong__,Object.defineProperty(s.prototype,"__isLong__",{value:!0}),s.isLong=a;var d={},h={};function b(Ct,Ft){var ln,mn,yn;return Ft?(yn=0<=(Ct>>>=0)&&Ct<256)&&(mn=h[Ct])?mn:(ln=st(Ct,(0|Ct)<0?-1:0,!0),yn&&(h[Ct]=ln),ln):(yn=-128<=(Ct|=0)&&Ct<128)&&(mn=d[Ct])?mn:(ln=st(Ct,Ct<0?-1:0,!1),yn&&(d[Ct]=ln),ln)}function et(Ct,Ft){if(isNaN(Ct))return Ft?pt:dt;if(Ft){if(Ct<0)return pt;if(Ct>=_)return $t}else{if(Ct<=-ot)return Tt;if(Ct+1>=ot)return mt}return Ct<0?et(-Ct,Ft).neg():st(Ct%c|0,Ct/c|0,Ft)}function st(Ct,Ft,ln){return new s(Ct,Ft,ln)}s.fromInt=b,s.fromNumber=et,s.fromBits=st;var $=Math.pow;function it(Ct,Ft,ln){if(Ct.length===0)throw Error("empty string");if(Ct==="NaN"||Ct==="Infinity"||Ct==="+Infinity"||Ct==="-Infinity")return dt;if(typeof Ft=="number"?(ln=Ft,Ft=!1):Ft=!!Ft,(ln=ln||10)<2||36<ln)throw RangeError("radix");var mn;if((mn=Ct.indexOf("-"))>0)throw Error("interior hyphen");if(mn===0)return it(Ct.substring(1),Ft,ln).neg();for(var yn=et($(ln,8)),pn=dt,Ht=0;Ht<Ct.length;Ht+=8){var Gt=Math.min(8,Ct.length-Ht),cn=parseInt(Ct.substring(Ht,Ht+Gt),ln);if(Gt<8){var xn=et($(ln,Gt));pn=pn.mul(xn).add(et(cn))}else pn=(pn=pn.mul(yn)).add(et(cn))}return pn.unsigned=Ft,pn}function g(Ct,Ft){return typeof Ct=="number"?et(Ct,Ft):typeof Ct=="string"?it(Ct,Ft):st(Ct.low,Ct.high,typeof Ft=="boolean"?Ft:Ct.unsigned)}s.fromString=it,s.fromValue=g;var c=4294967296,_=c*c,ot=_/2,ct=b(1<<24),dt=b(0);s.ZERO=dt;var pt=b(0,!0);s.UZERO=pt;var ft=b(1);s.ONE=ft;var ht=b(1,!0);s.UONE=ht;var bt=b(-1);s.NEG_ONE=bt;var mt=st(-1,2147483647,!1);s.MAX_VALUE=mt;var $t=st(-1,-1,!0);s.MAX_UNSIGNED_VALUE=$t;var Tt=st(0,-2147483648,!1);s.MIN_VALUE=Tt;var Nt=s.prototype;Nt.toInt=function(){return this.unsigned?this.low>>>0:this.low},Nt.toNumber=function(){return this.unsigned?(this.high>>>0)*c+(this.low>>>0):this.high*c+(this.low>>>0)},Nt.toString=function(Ct){if((Ct=Ct||10)<2||36<Ct)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Tt)){var Ft=et(Ct),ln=this.div(Ft),mn=ln.mul(Ft).sub(this);return ln.toString(Ct)+mn.toInt().toString(Ct)}return"-"+this.neg().toString(Ct)}for(var yn=et($(Ct,6),this.unsigned),pn=this,Ht="";;){var Gt=pn.div(yn),cn=(pn.sub(Gt.mul(yn)).toInt()>>>0).toString(Ct);if((pn=Gt).isZero())return cn+Ht;for(;cn.length<6;)cn="0"+cn;Ht=""+cn+Ht}},Nt.getHighBits=function(){return this.high},Nt.getHighBitsUnsigned=function(){return this.high>>>0},Nt.getLowBits=function(){return this.low},Nt.getLowBitsUnsigned=function(){return this.low>>>0},Nt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Tt)?64:this.neg().getNumBitsAbs();for(var Ct=this.high!=0?this.high:this.low,Ft=31;Ft>0&&!(Ct&1<<Ft);Ft--);return this.high!=0?Ft+33:Ft+1},Nt.isZero=function(){return this.high===0&&this.low===0},Nt.eqz=Nt.isZero,Nt.isNegative=function(){return!this.unsigned&&this.high<0},Nt.isPositive=function(){return this.unsigned||this.high>=0},Nt.isOdd=function(){return(1&this.low)==1},Nt.isEven=function(){return(1&this.low)==0},Nt.equals=function(Ct){return a(Ct)||(Ct=g(Ct)),(this.unsigned===Ct.unsigned||this.high>>>31!=1||Ct.high>>>31!=1)&&this.high===Ct.high&&this.low===Ct.low},Nt.eq=Nt.equals,Nt.notEquals=function(Ct){return!this.eq(Ct)},Nt.neq=Nt.notEquals,Nt.ne=Nt.notEquals,Nt.lessThan=function(Ct){return this.comp(Ct)<0},Nt.lt=Nt.lessThan,Nt.lessThanOrEqual=function(Ct){return this.comp(Ct)<=0},Nt.lte=Nt.lessThanOrEqual,Nt.le=Nt.lessThanOrEqual,Nt.greaterThan=function(Ct){return this.comp(Ct)>0},Nt.gt=Nt.greaterThan,Nt.greaterThanOrEqual=function(Ct){return this.comp(Ct)>=0},Nt.gte=Nt.greaterThanOrEqual,Nt.ge=Nt.greaterThanOrEqual,Nt.compare=function(Ct){if(a(Ct)||(Ct=g(Ct)),this.eq(Ct))return 0;var Ft=this.isNegative(),ln=Ct.isNegative();return Ft&&!ln?-1:!Ft&&ln?1:this.unsigned?Ct.high>>>0>this.high>>>0||Ct.high===this.high&&Ct.low>>>0>this.low>>>0?-1:1:this.sub(Ct).isNegative()?-1:1},Nt.comp=Nt.compare,Nt.negate=function(){return!this.unsigned&&this.eq(Tt)?Tt:this.not().add(ft)},Nt.neg=Nt.negate,Nt.add=function(Ct){a(Ct)||(Ct=g(Ct));var Ft=this.high>>>16,ln=65535&this.high,mn=this.low>>>16,yn=65535&this.low,pn=Ct.high>>>16,Ht=65535&Ct.high,Gt=Ct.low>>>16,cn=0,xn=0,dn=0,wn=0;return dn+=(wn+=yn+(65535&Ct.low))>>>16,xn+=(dn+=mn+Gt)>>>16,cn+=(xn+=ln+Ht)>>>16,cn+=Ft+pn,st((dn&=65535)<<16|(wn&=65535),(cn&=65535)<<16|(xn&=65535),this.unsigned)},Nt.subtract=function(Ct){return a(Ct)||(Ct=g(Ct)),this.add(Ct.neg())},Nt.sub=Nt.subtract,Nt.multiply=function(Ct){if(this.isZero())return dt;if(a(Ct)||(Ct=g(Ct)),e)return st(e.mul(this.low,this.high,Ct.low,Ct.high),e.get_high(),this.unsigned);if(Ct.isZero())return dt;if(this.eq(Tt))return Ct.isOdd()?Tt:dt;if(Ct.eq(Tt))return this.isOdd()?Tt:dt;if(this.isNegative())return Ct.isNegative()?this.neg().mul(Ct.neg()):this.neg().mul(Ct).neg();if(Ct.isNegative())return this.mul(Ct.neg()).neg();if(this.lt(ct)&&Ct.lt(ct))return et(this.toNumber()*Ct.toNumber(),this.unsigned);var Ft=this.high>>>16,ln=65535&this.high,mn=this.low>>>16,yn=65535&this.low,pn=Ct.high>>>16,Ht=65535&Ct.high,Gt=Ct.low>>>16,cn=65535&Ct.low,xn=0,dn=0,wn=0,gn=0;return wn+=(gn+=yn*cn)>>>16,dn+=(wn+=mn*cn)>>>16,wn&=65535,dn+=(wn+=yn*Gt)>>>16,xn+=(dn+=ln*cn)>>>16,dn&=65535,xn+=(dn+=mn*Gt)>>>16,dn&=65535,xn+=(dn+=yn*Ht)>>>16,xn+=Ft*cn+ln*Gt+mn*Ht+yn*pn,st((wn&=65535)<<16|(gn&=65535),(xn&=65535)<<16|(dn&=65535),this.unsigned)},Nt.mul=Nt.multiply,Nt.divide=function(Ct){if(a(Ct)||(Ct=g(Ct)),Ct.isZero())throw Error("division by zero");var Ft,ln,mn;if(e)return this.unsigned||this.high!==-2147483648||Ct.low!==-1||Ct.high!==-1?st((this.unsigned?e.div_u:e.div_s)(this.low,this.high,Ct.low,Ct.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?pt:dt;if(this.unsigned){if(Ct.unsigned||(Ct=Ct.toUnsigned()),Ct.gt(this))return pt;if(Ct.gt(this.shru(1)))return ht;mn=pt}else{if(this.eq(Tt))return Ct.eq(ft)||Ct.eq(bt)?Tt:Ct.eq(Tt)?ft:(Ft=this.shr(1).div(Ct).shl(1)).eq(dt)?Ct.isNegative()?ft:bt:(ln=this.sub(Ct.mul(Ft)),mn=Ft.add(ln.div(Ct)));if(Ct.eq(Tt))return this.unsigned?pt:dt;if(this.isNegative())return Ct.isNegative()?this.neg().div(Ct.neg()):this.neg().div(Ct).neg();if(Ct.isNegative())return this.div(Ct.neg()).neg();mn=dt}for(ln=this;ln.gte(Ct);){Ft=Math.max(1,Math.floor(ln.toNumber()/Ct.toNumber()));for(var yn=Math.ceil(Math.log(Ft)/Math.LN2),pn=yn<=48?1:$(2,yn-48),Ht=et(Ft),Gt=Ht.mul(Ct);Gt.isNegative()||Gt.gt(ln);)Gt=(Ht=et(Ft-=pn,this.unsigned)).mul(Ct);Ht.isZero()&&(Ht=ft),mn=mn.add(Ht),ln=ln.sub(Gt)}return mn},Nt.div=Nt.divide,Nt.modulo=function(Ct){return a(Ct)||(Ct=g(Ct)),e?st((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,Ct.low,Ct.high),e.get_high(),this.unsigned):this.sub(this.div(Ct).mul(Ct))},Nt.mod=Nt.modulo,Nt.rem=Nt.modulo,Nt.not=function(){return st(~this.low,~this.high,this.unsigned)},Nt.and=function(Ct){return a(Ct)||(Ct=g(Ct)),st(this.low&Ct.low,this.high&Ct.high,this.unsigned)},Nt.or=function(Ct){return a(Ct)||(Ct=g(Ct)),st(this.low|Ct.low,this.high|Ct.high,this.unsigned)},Nt.xor=function(Ct){return a(Ct)||(Ct=g(Ct)),st(this.low^Ct.low,this.high^Ct.high,this.unsigned)},Nt.shiftLeft=function(Ct){return a(Ct)&&(Ct=Ct.toInt()),(Ct&=63)==0?this:Ct<32?st(this.low<<Ct,this.high<<Ct|this.low>>>32-Ct,this.unsigned):st(0,this.low<<Ct-32,this.unsigned)},Nt.shl=Nt.shiftLeft,Nt.shiftRight=function(Ct){return a(Ct)&&(Ct=Ct.toInt()),(Ct&=63)==0?this:Ct<32?st(this.low>>>Ct|this.high<<32-Ct,this.high>>Ct,this.unsigned):st(this.high>>Ct-32,this.high>=0?0:-1,this.unsigned)},Nt.shr=Nt.shiftRight,Nt.shiftRightUnsigned=function(Ct){if(a(Ct)&&(Ct=Ct.toInt()),(Ct&=63)==0)return this;var Ft=this.high;return Ct<32?st(this.low>>>Ct|Ft<<32-Ct,Ft>>>Ct,this.unsigned):st(Ct===32?Ft:Ft>>>Ct-32,0,this.unsigned)},Nt.shru=Nt.shiftRightUnsigned,Nt.shr_u=Nt.shiftRightUnsigned,Nt.toSigned=function(){return this.unsigned?st(this.low,this.high,!1):this},Nt.toUnsigned=function(){return this.unsigned?this:st(this.low,this.high,!0)},Nt.toBytes=function(Ct){return Ct?this.toBytesLE():this.toBytesBE()},Nt.toBytesLE=function(){var Ct=this.high,Ft=this.low;return[255&Ft,Ft>>>8&255,Ft>>>16&255,Ft>>>24,255&Ct,Ct>>>8&255,Ct>>>16&255,Ct>>>24]},Nt.toBytesBE=function(){var Ct=this.high,Ft=this.low;return[Ct>>>24,Ct>>>16&255,Ct>>>8&255,255&Ct,Ft>>>24,Ft>>>16&255,Ft>>>8&255,255&Ft]},s.fromBytes=function(Ct,Ft,ln){return ln?s.fromBytesLE(Ct,Ft):s.fromBytesBE(Ct,Ft)},s.fromBytesLE=function(Ct,Ft){return new s(Ct[0]|Ct[1]<<8|Ct[2]<<16|Ct[3]<<24,Ct[4]|Ct[5]<<8|Ct[6]<<16|Ct[7]<<24,Ft)},s.fromBytesBE=function(Ct,Ft){return new s(Ct[4]<<24|Ct[5]<<16|Ct[6]<<8|Ct[7],Ct[0]<<24|Ct[1]<<16|Ct[2]<<8|Ct[3],Ft)}},1446:(o,e,s)=>{var a,d,h,b=s(2100),et=b.Reader,st=b.Writer,$=b.util,it=b.roots.default||(b.roots.default={});it.onnx=((h={}).Version=(a={},(d=Object.create(a))[a[0]="_START_VERSION"]=0,d[a[1]="IR_VERSION_2017_10_10"]=1,d[a[2]="IR_VERSION_2017_10_30"]=2,d[a[3]="IR_VERSION_2017_11_3"]=3,d[a[4]="IR_VERSION_2019_1_22"]=4,d[a[5]="IR_VERSION"]=5,d),h.AttributeProto=function(){function g(c){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],c)for(var _=Object.keys(c),ot=0;ot<_.length;++ot)c[_[ot]]!=null&&(this[_[ot]]=c[_[ot]])}return g.prototype.name="",g.prototype.refAttrName="",g.prototype.docString="",g.prototype.type=0,g.prototype.f=0,g.prototype.i=$.Long?$.Long.fromBits(0,0,!1):0,g.prototype.s=$.newBuffer([]),g.prototype.t=null,g.prototype.g=null,g.prototype.floats=$.emptyArray,g.prototype.ints=$.emptyArray,g.prototype.strings=$.emptyArray,g.prototype.tensors=$.emptyArray,g.prototype.graphs=$.emptyArray,g.create=function(c){return new g(c)},g.encode=function(c,_){if(_||(_=st.create()),c.name!=null&&c.hasOwnProperty("name")&&_.uint32(10).string(c.name),c.f!=null&&c.hasOwnProperty("f")&&_.uint32(21).float(c.f),c.i!=null&&c.hasOwnProperty("i")&&_.uint32(24).int64(c.i),c.s!=null&&c.hasOwnProperty("s")&&_.uint32(34).bytes(c.s),c.t!=null&&c.hasOwnProperty("t")&&it.onnx.TensorProto.encode(c.t,_.uint32(42).fork()).ldelim(),c.g!=null&&c.hasOwnProperty("g")&&it.onnx.GraphProto.encode(c.g,_.uint32(50).fork()).ldelim(),c.floats!=null&&c.floats.length){_.uint32(58).fork();for(var ot=0;ot<c.floats.length;++ot)_.float(c.floats[ot]);_.ldelim()}if(c.ints!=null&&c.ints.length){for(_.uint32(66).fork(),ot=0;ot<c.ints.length;++ot)_.int64(c.ints[ot]);_.ldelim()}if(c.strings!=null&&c.strings.length)for(ot=0;ot<c.strings.length;++ot)_.uint32(74).bytes(c.strings[ot]);if(c.tensors!=null&&c.tensors.length)for(ot=0;ot<c.tensors.length;++ot)it.onnx.TensorProto.encode(c.tensors[ot],_.uint32(82).fork()).ldelim();if(c.graphs!=null&&c.graphs.length)for(ot=0;ot<c.graphs.length;++ot)it.onnx.GraphProto.encode(c.graphs[ot],_.uint32(90).fork()).ldelim();return c.docString!=null&&c.hasOwnProperty("docString")&&_.uint32(106).string(c.docString),c.type!=null&&c.hasOwnProperty("type")&&_.uint32(160).int32(c.type),c.refAttrName!=null&&c.hasOwnProperty("refAttrName")&&_.uint32(170).string(c.refAttrName),_},g.encodeDelimited=function(c,_){return this.encode(c,_).ldelim()},g.decode=function(c,_){c instanceof et||(c=et.create(c));for(var ot=_===void 0?c.len:c.pos+_,ct=new it.onnx.AttributeProto;c.pos<ot;){var dt=c.uint32();switch(dt>>>3){case 1:ct.name=c.string();break;case 21:ct.refAttrName=c.string();break;case 13:ct.docString=c.string();break;case 20:ct.type=c.int32();break;case 2:ct.f=c.float();break;case 3:ct.i=c.int64();break;case 4:ct.s=c.bytes();break;case 5:ct.t=it.onnx.TensorProto.decode(c,c.uint32());break;case 6:ct.g=it.onnx.GraphProto.decode(c,c.uint32());break;case 7:if(ct.floats&&ct.floats.length||(ct.floats=[]),(7&dt)==2)for(var pt=c.uint32()+c.pos;c.pos<pt;)ct.floats.push(c.float());else ct.floats.push(c.float());break;case 8:if(ct.ints&&ct.ints.length||(ct.ints=[]),(7&dt)==2)for(pt=c.uint32()+c.pos;c.pos<pt;)ct.ints.push(c.int64());else ct.ints.push(c.int64());break;case 9:ct.strings&&ct.strings.length||(ct.strings=[]),ct.strings.push(c.bytes());break;case 10:ct.tensors&&ct.tensors.length||(ct.tensors=[]),ct.tensors.push(it.onnx.TensorProto.decode(c,c.uint32()));break;case 11:ct.graphs&&ct.graphs.length||(ct.graphs=[]),ct.graphs.push(it.onnx.GraphProto.decode(c,c.uint32()));break;default:c.skipType(7&dt)}}return ct},g.decodeDelimited=function(c){return c instanceof et||(c=new et(c)),this.decode(c,c.uint32())},g.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.name!=null&&c.hasOwnProperty("name")&&!$.isString(c.name))return"name: string expected";if(c.refAttrName!=null&&c.hasOwnProperty("refAttrName")&&!$.isString(c.refAttrName))return"refAttrName: string expected";if(c.docString!=null&&c.hasOwnProperty("docString")&&!$.isString(c.docString))return"docString: string expected";if(c.type!=null&&c.hasOwnProperty("type"))switch(c.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(c.f!=null&&c.hasOwnProperty("f")&&typeof c.f!="number")return"f: number expected";if(c.i!=null&&c.hasOwnProperty("i")&&!($.isInteger(c.i)||c.i&&$.isInteger(c.i.low)&&$.isInteger(c.i.high)))return"i: integer|Long expected";if(c.s!=null&&c.hasOwnProperty("s")&&!(c.s&&typeof c.s.length=="number"||$.isString(c.s)))return"s: buffer expected";if(c.t!=null&&c.hasOwnProperty("t")&&(ot=it.onnx.TensorProto.verify(c.t)))return"t."+ot;if(c.g!=null&&c.hasOwnProperty("g")&&(ot=it.onnx.GraphProto.verify(c.g)))return"g."+ot;if(c.floats!=null&&c.hasOwnProperty("floats")){if(!Array.isArray(c.floats))return"floats: array expected";for(var _=0;_<c.floats.length;++_)if(typeof c.floats[_]!="number")return"floats: number[] expected"}if(c.ints!=null&&c.hasOwnProperty("ints")){if(!Array.isArray(c.ints))return"ints: array expected";for(_=0;_<c.ints.length;++_)if(!($.isInteger(c.ints[_])||c.ints[_]&&$.isInteger(c.ints[_].low)&&$.isInteger(c.ints[_].high)))return"ints: integer|Long[] expected"}if(c.strings!=null&&c.hasOwnProperty("strings")){if(!Array.isArray(c.strings))return"strings: array expected";for(_=0;_<c.strings.length;++_)if(!(c.strings[_]&&typeof c.strings[_].length=="number"||$.isString(c.strings[_])))return"strings: buffer[] expected"}if(c.tensors!=null&&c.hasOwnProperty("tensors")){if(!Array.isArray(c.tensors))return"tensors: array expected";for(_=0;_<c.tensors.length;++_)if(ot=it.onnx.TensorProto.verify(c.tensors[_]))return"tensors."+ot}if(c.graphs!=null&&c.hasOwnProperty("graphs")){if(!Array.isArray(c.graphs))return"graphs: array expected";for(_=0;_<c.graphs.length;++_){var ot;if(ot=it.onnx.GraphProto.verify(c.graphs[_]))return"graphs."+ot}}return null},g.fromObject=function(c){if(c instanceof it.onnx.AttributeProto)return c;var _=new it.onnx.AttributeProto;switch(c.name!=null&&(_.name=String(c.name)),c.refAttrName!=null&&(_.refAttrName=String(c.refAttrName)),c.docString!=null&&(_.docString=String(c.docString)),c.type){case"UNDEFINED":case 0:_.type=0;break;case"FLOAT":case 1:_.type=1;break;case"INT":case 2:_.type=2;break;case"STRING":case 3:_.type=3;break;case"TENSOR":case 4:_.type=4;break;case"GRAPH":case 5:_.type=5;break;case"FLOATS":case 6:_.type=6;break;case"INTS":case 7:_.type=7;break;case"STRINGS":case 8:_.type=8;break;case"TENSORS":case 9:_.type=9;break;case"GRAPHS":case 10:_.type=10}if(c.f!=null&&(_.f=Number(c.f)),c.i!=null&&($.Long?(_.i=$.Long.fromValue(c.i)).unsigned=!1:typeof c.i=="string"?_.i=parseInt(c.i,10):typeof c.i=="number"?_.i=c.i:typeof c.i=="object"&&(_.i=new $.LongBits(c.i.low>>>0,c.i.high>>>0).toNumber())),c.s!=null&&(typeof c.s=="string"?$.base64.decode(c.s,_.s=$.newBuffer($.base64.length(c.s)),0):c.s.length&&(_.s=c.s)),c.t!=null){if(typeof c.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");_.t=it.onnx.TensorProto.fromObject(c.t)}if(c.g!=null){if(typeof c.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");_.g=it.onnx.GraphProto.fromObject(c.g)}if(c.floats){if(!Array.isArray(c.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");_.floats=[];for(var ot=0;ot<c.floats.length;++ot)_.floats[ot]=Number(c.floats[ot])}if(c.ints){if(!Array.isArray(c.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(_.ints=[],ot=0;ot<c.ints.length;++ot)$.Long?(_.ints[ot]=$.Long.fromValue(c.ints[ot])).unsigned=!1:typeof c.ints[ot]=="string"?_.ints[ot]=parseInt(c.ints[ot],10):typeof c.ints[ot]=="number"?_.ints[ot]=c.ints[ot]:typeof c.ints[ot]=="object"&&(_.ints[ot]=new $.LongBits(c.ints[ot].low>>>0,c.ints[ot].high>>>0).toNumber())}if(c.strings){if(!Array.isArray(c.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(_.strings=[],ot=0;ot<c.strings.length;++ot)typeof c.strings[ot]=="string"?$.base64.decode(c.strings[ot],_.strings[ot]=$.newBuffer($.base64.length(c.strings[ot])),0):c.strings[ot].length&&(_.strings[ot]=c.strings[ot])}if(c.tensors){if(!Array.isArray(c.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(_.tensors=[],ot=0;ot<c.tensors.length;++ot){if(typeof c.tensors[ot]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");_.tensors[ot]=it.onnx.TensorProto.fromObject(c.tensors[ot])}}if(c.graphs){if(!Array.isArray(c.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(_.graphs=[],ot=0;ot<c.graphs.length;++ot){if(typeof c.graphs[ot]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");_.graphs[ot]=it.onnx.GraphProto.fromObject(c.graphs[ot])}}return _},g.toObject=function(c,_){_||(_={});var ot={};if((_.arrays||_.defaults)&&(ot.floats=[],ot.ints=[],ot.strings=[],ot.tensors=[],ot.graphs=[]),_.defaults){if(ot.name="",ot.f=0,$.Long){var ct=new $.Long(0,0,!1);ot.i=_.longs===String?ct.toString():_.longs===Number?ct.toNumber():ct}else ot.i=_.longs===String?"0":0;_.bytes===String?ot.s="":(ot.s=[],_.bytes!==Array&&(ot.s=$.newBuffer(ot.s))),ot.t=null,ot.g=null,ot.docString="",ot.type=_.enums===String?"UNDEFINED":0,ot.refAttrName=""}if(c.name!=null&&c.hasOwnProperty("name")&&(ot.name=c.name),c.f!=null&&c.hasOwnProperty("f")&&(ot.f=_.json&&!isFinite(c.f)?String(c.f):c.f),c.i!=null&&c.hasOwnProperty("i")&&(typeof c.i=="number"?ot.i=_.longs===String?String(c.i):c.i:ot.i=_.longs===String?$.Long.prototype.toString.call(c.i):_.longs===Number?new $.LongBits(c.i.low>>>0,c.i.high>>>0).toNumber():c.i),c.s!=null&&c.hasOwnProperty("s")&&(ot.s=_.bytes===String?$.base64.encode(c.s,0,c.s.length):_.bytes===Array?Array.prototype.slice.call(c.s):c.s),c.t!=null&&c.hasOwnProperty("t")&&(ot.t=it.onnx.TensorProto.toObject(c.t,_)),c.g!=null&&c.hasOwnProperty("g")&&(ot.g=it.onnx.GraphProto.toObject(c.g,_)),c.floats&&c.floats.length){ot.floats=[];for(var dt=0;dt<c.floats.length;++dt)ot.floats[dt]=_.json&&!isFinite(c.floats[dt])?String(c.floats[dt]):c.floats[dt]}if(c.ints&&c.ints.length)for(ot.ints=[],dt=0;dt<c.ints.length;++dt)typeof c.ints[dt]=="number"?ot.ints[dt]=_.longs===String?String(c.ints[dt]):c.ints[dt]:ot.ints[dt]=_.longs===String?$.Long.prototype.toString.call(c.ints[dt]):_.longs===Number?new $.LongBits(c.ints[dt].low>>>0,c.ints[dt].high>>>0).toNumber():c.ints[dt];if(c.strings&&c.strings.length)for(ot.strings=[],dt=0;dt<c.strings.length;++dt)ot.strings[dt]=_.bytes===String?$.base64.encode(c.strings[dt],0,c.strings[dt].length):_.bytes===Array?Array.prototype.slice.call(c.strings[dt]):c.strings[dt];if(c.tensors&&c.tensors.length)for(ot.tensors=[],dt=0;dt<c.tensors.length;++dt)ot.tensors[dt]=it.onnx.TensorProto.toObject(c.tensors[dt],_);if(c.graphs&&c.graphs.length)for(ot.graphs=[],dt=0;dt<c.graphs.length;++dt)ot.graphs[dt]=it.onnx.GraphProto.toObject(c.graphs[dt],_);return c.docString!=null&&c.hasOwnProperty("docString")&&(ot.docString=c.docString),c.type!=null&&c.hasOwnProperty("type")&&(ot.type=_.enums===String?it.onnx.AttributeProto.AttributeType[c.type]:c.type),c.refAttrName!=null&&c.hasOwnProperty("refAttrName")&&(ot.refAttrName=c.refAttrName),ot},g.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},g.AttributeType=function(){var c={},_=Object.create(c);return _[c[0]="UNDEFINED"]=0,_[c[1]="FLOAT"]=1,_[c[2]="INT"]=2,_[c[3]="STRING"]=3,_[c[4]="TENSOR"]=4,_[c[5]="GRAPH"]=5,_[c[6]="FLOATS"]=6,_[c[7]="INTS"]=7,_[c[8]="STRINGS"]=8,_[c[9]="TENSORS"]=9,_[c[10]="GRAPHS"]=10,_}(),g}(),h.ValueInfoProto=function(){function g(c){if(c)for(var _=Object.keys(c),ot=0;ot<_.length;++ot)c[_[ot]]!=null&&(this[_[ot]]=c[_[ot]])}return g.prototype.name="",g.prototype.type=null,g.prototype.docString="",g.create=function(c){return new g(c)},g.encode=function(c,_){return _||(_=st.create()),c.name!=null&&c.hasOwnProperty("name")&&_.uint32(10).string(c.name),c.type!=null&&c.hasOwnProperty("type")&&it.onnx.TypeProto.encode(c.type,_.uint32(18).fork()).ldelim(),c.docString!=null&&c.hasOwnProperty("docString")&&_.uint32(26).string(c.docString),_},g.encodeDelimited=function(c,_){return this.encode(c,_).ldelim()},g.decode=function(c,_){c instanceof et||(c=et.create(c));for(var ot=_===void 0?c.len:c.pos+_,ct=new it.onnx.ValueInfoProto;c.pos<ot;){var dt=c.uint32();switch(dt>>>3){case 1:ct.name=c.string();break;case 2:ct.type=it.onnx.TypeProto.decode(c,c.uint32());break;case 3:ct.docString=c.string();break;default:c.skipType(7&dt)}}return ct},g.decodeDelimited=function(c){return c instanceof et||(c=new et(c)),this.decode(c,c.uint32())},g.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.name!=null&&c.hasOwnProperty("name")&&!$.isString(c.name))return"name: string expected";if(c.type!=null&&c.hasOwnProperty("type")){var _=it.onnx.TypeProto.verify(c.type);if(_)return"type."+_}return c.docString!=null&&c.hasOwnProperty("docString")&&!$.isString(c.docString)?"docString: string expected":null},g.fromObject=function(c){if(c instanceof it.onnx.ValueInfoProto)return c;var _=new it.onnx.ValueInfoProto;if(c.name!=null&&(_.name=String(c.name)),c.type!=null){if(typeof c.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");_.type=it.onnx.TypeProto.fromObject(c.type)}return c.docString!=null&&(_.docString=String(c.docString)),_},g.toObject=function(c,_){_||(_={});var ot={};return _.defaults&&(ot.name="",ot.type=null,ot.docString=""),c.name!=null&&c.hasOwnProperty("name")&&(ot.name=c.name),c.type!=null&&c.hasOwnProperty("type")&&(ot.type=it.onnx.TypeProto.toObject(c.type,_)),c.docString!=null&&c.hasOwnProperty("docString")&&(ot.docString=c.docString),ot},g.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},g}(),h.NodeProto=function(){function g(c){if(this.input=[],this.output=[],this.attribute=[],c)for(var _=Object.keys(c),ot=0;ot<_.length;++ot)c[_[ot]]!=null&&(this[_[ot]]=c[_[ot]])}return g.prototype.input=$.emptyArray,g.prototype.output=$.emptyArray,g.prototype.name="",g.prototype.opType="",g.prototype.domain="",g.prototype.attribute=$.emptyArray,g.prototype.docString="",g.create=function(c){return new g(c)},g.encode=function(c,_){if(_||(_=st.create()),c.input!=null&&c.input.length)for(var ot=0;ot<c.input.length;++ot)_.uint32(10).string(c.input[ot]);if(c.output!=null&&c.output.length)for(ot=0;ot<c.output.length;++ot)_.uint32(18).string(c.output[ot]);if(c.name!=null&&c.hasOwnProperty("name")&&_.uint32(26).string(c.name),c.opType!=null&&c.hasOwnProperty("opType")&&_.uint32(34).string(c.opType),c.attribute!=null&&c.attribute.length)for(ot=0;ot<c.attribute.length;++ot)it.onnx.AttributeProto.encode(c.attribute[ot],_.uint32(42).fork()).ldelim();return c.docString!=null&&c.hasOwnProperty("docString")&&_.uint32(50).string(c.docString),c.domain!=null&&c.hasOwnProperty("domain")&&_.uint32(58).string(c.domain),_},g.encodeDelimited=function(c,_){return this.encode(c,_).ldelim()},g.decode=function(c,_){c instanceof et||(c=et.create(c));for(var ot=_===void 0?c.len:c.pos+_,ct=new it.onnx.NodeProto;c.pos<ot;){var dt=c.uint32();switch(dt>>>3){case 1:ct.input&&ct.input.length||(ct.input=[]),ct.input.push(c.string());break;case 2:ct.output&&ct.output.length||(ct.output=[]),ct.output.push(c.string());break;case 3:ct.name=c.string();break;case 4:ct.opType=c.string();break;case 7:ct.domain=c.string();break;case 5:ct.attribute&&ct.attribute.length||(ct.attribute=[]),ct.attribute.push(it.onnx.AttributeProto.decode(c,c.uint32()));break;case 6:ct.docString=c.string();break;default:c.skipType(7&dt)}}return ct},g.decodeDelimited=function(c){return c instanceof et||(c=new et(c)),this.decode(c,c.uint32())},g.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.input!=null&&c.hasOwnProperty("input")){if(!Array.isArray(c.input))return"input: array expected";for(var _=0;_<c.input.length;++_)if(!$.isString(c.input[_]))return"input: string[] expected"}if(c.output!=null&&c.hasOwnProperty("output")){if(!Array.isArray(c.output))return"output: array expected";for(_=0;_<c.output.length;++_)if(!$.isString(c.output[_]))return"output: string[] expected"}if(c.name!=null&&c.hasOwnProperty("name")&&!$.isString(c.name))return"name: string expected";if(c.opType!=null&&c.hasOwnProperty("opType")&&!$.isString(c.opType))return"opType: string expected";if(c.domain!=null&&c.hasOwnProperty("domain")&&!$.isString(c.domain))return"domain: string expected";if(c.attribute!=null&&c.hasOwnProperty("attribute")){if(!Array.isArray(c.attribute))return"attribute: array expected";for(_=0;_<c.attribute.length;++_){var ot=it.onnx.AttributeProto.verify(c.attribute[_]);if(ot)return"attribute."+ot}}return c.docString!=null&&c.hasOwnProperty("docString")&&!$.isString(c.docString)?"docString: string expected":null},g.fromObject=function(c){if(c instanceof it.onnx.NodeProto)return c;var _=new it.onnx.NodeProto;if(c.input){if(!Array.isArray(c.input))throw TypeError(".onnx.NodeProto.input: array expected");_.input=[];for(var ot=0;ot<c.input.length;++ot)_.input[ot]=String(c.input[ot])}if(c.output){if(!Array.isArray(c.output))throw TypeError(".onnx.NodeProto.output: array expected");for(_.output=[],ot=0;ot<c.output.length;++ot)_.output[ot]=String(c.output[ot])}if(c.name!=null&&(_.name=String(c.name)),c.opType!=null&&(_.opType=String(c.opType)),c.domain!=null&&(_.domain=String(c.domain)),c.attribute){if(!Array.isArray(c.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(_.attribute=[],ot=0;ot<c.attribute.length;++ot){if(typeof c.attribute[ot]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");_.attribute[ot]=it.onnx.AttributeProto.fromObject(c.attribute[ot])}}return c.docString!=null&&(_.docString=String(c.docString)),_},g.toObject=function(c,_){_||(_={});var ot={};if((_.arrays||_.defaults)&&(ot.input=[],ot.output=[],ot.attribute=[]),_.defaults&&(ot.name="",ot.opType="",ot.docString="",ot.domain=""),c.input&&c.input.length){ot.input=[];for(var ct=0;ct<c.input.length;++ct)ot.input[ct]=c.input[ct]}if(c.output&&c.output.length)for(ot.output=[],ct=0;ct<c.output.length;++ct)ot.output[ct]=c.output[ct];if(c.name!=null&&c.hasOwnProperty("name")&&(ot.name=c.name),c.opType!=null&&c.hasOwnProperty("opType")&&(ot.opType=c.opType),c.attribute&&c.attribute.length)for(ot.attribute=[],ct=0;ct<c.attribute.length;++ct)ot.attribute[ct]=it.onnx.AttributeProto.toObject(c.attribute[ct],_);return c.docString!=null&&c.hasOwnProperty("docString")&&(ot.docString=c.docString),c.domain!=null&&c.hasOwnProperty("domain")&&(ot.domain=c.domain),ot},g.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},g}(),h.ModelProto=function(){function g(c){if(this.opsetImport=[],this.metadataProps=[],c)for(var _=Object.keys(c),ot=0;ot<_.length;++ot)c[_[ot]]!=null&&(this[_[ot]]=c[_[ot]])}return g.prototype.irVersion=$.Long?$.Long.fromBits(0,0,!1):0,g.prototype.opsetImport=$.emptyArray,g.prototype.producerName="",g.prototype.producerVersion="",g.prototype.domain="",g.prototype.modelVersion=$.Long?$.Long.fromBits(0,0,!1):0,g.prototype.docString="",g.prototype.graph=null,g.prototype.metadataProps=$.emptyArray,g.create=function(c){return new g(c)},g.encode=function(c,_){if(_||(_=st.create()),c.irVersion!=null&&c.hasOwnProperty("irVersion")&&_.uint32(8).int64(c.irVersion),c.producerName!=null&&c.hasOwnProperty("producerName")&&_.uint32(18).string(c.producerName),c.producerVersion!=null&&c.hasOwnProperty("producerVersion")&&_.uint32(26).string(c.producerVersion),c.domain!=null&&c.hasOwnProperty("domain")&&_.uint32(34).string(c.domain),c.modelVersion!=null&&c.hasOwnProperty("modelVersion")&&_.uint32(40).int64(c.modelVersion),c.docString!=null&&c.hasOwnProperty("docString")&&_.uint32(50).string(c.docString),c.graph!=null&&c.hasOwnProperty("graph")&&it.onnx.GraphProto.encode(c.graph,_.uint32(58).fork()).ldelim(),c.opsetImport!=null&&c.opsetImport.length)for(var ot=0;ot<c.opsetImport.length;++ot)it.onnx.OperatorSetIdProto.encode(c.opsetImport[ot],_.uint32(66).fork()).ldelim();if(c.metadataProps!=null&&c.metadataProps.length)for(ot=0;ot<c.metadataProps.length;++ot)it.onnx.StringStringEntryProto.encode(c.metadataProps[ot],_.uint32(114).fork()).ldelim();return _},g.encodeDelimited=function(c,_){return this.encode(c,_).ldelim()},g.decode=function(c,_){c instanceof et||(c=et.create(c));for(var ot=_===void 0?c.len:c.pos+_,ct=new it.onnx.ModelProto;c.pos<ot;){var dt=c.uint32();switch(dt>>>3){case 1:ct.irVersion=c.int64();break;case 8:ct.opsetImport&&ct.opsetImport.length||(ct.opsetImport=[]),ct.opsetImport.push(it.onnx.OperatorSetIdProto.decode(c,c.uint32()));break;case 2:ct.producerName=c.string();break;case 3:ct.producerVersion=c.string();break;case 4:ct.domain=c.string();break;case 5:ct.modelVersion=c.int64();break;case 6:ct.docString=c.string();break;case 7:ct.graph=it.onnx.GraphProto.decode(c,c.uint32());break;case 14:ct.metadataProps&&ct.metadataProps.length||(ct.metadataProps=[]),ct.metadataProps.push(it.onnx.StringStringEntryProto.decode(c,c.uint32()));break;default:c.skipType(7&dt)}}return ct},g.decodeDelimited=function(c){return c instanceof et||(c=new et(c)),this.decode(c,c.uint32())},g.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.irVersion!=null&&c.hasOwnProperty("irVersion")&&!($.isInteger(c.irVersion)||c.irVersion&&$.isInteger(c.irVersion.low)&&$.isInteger(c.irVersion.high)))return"irVersion: integer|Long expected";if(c.opsetImport!=null&&c.hasOwnProperty("opsetImport")){if(!Array.isArray(c.opsetImport))return"opsetImport: array expected";for(var _=0;_<c.opsetImport.length;++_)if(ot=it.onnx.OperatorSetIdProto.verify(c.opsetImport[_]))return"opsetImport."+ot}if(c.producerName!=null&&c.hasOwnProperty("producerName")&&!$.isString(c.producerName))return"producerName: string expected";if(c.producerVersion!=null&&c.hasOwnProperty("producerVersion")&&!$.isString(c.producerVersion))return"producerVersion: string expected";if(c.domain!=null&&c.hasOwnProperty("domain")&&!$.isString(c.domain))return"domain: string expected";if(c.modelVersion!=null&&c.hasOwnProperty("modelVersion")&&!($.isInteger(c.modelVersion)||c.modelVersion&&$.isInteger(c.modelVersion.low)&&$.isInteger(c.modelVersion.high)))return"modelVersion: integer|Long expected";if(c.docString!=null&&c.hasOwnProperty("docString")&&!$.isString(c.docString))return"docString: string expected";if(c.graph!=null&&c.hasOwnProperty("graph")&&(ot=it.onnx.GraphProto.verify(c.graph)))return"graph."+ot;if(c.metadataProps!=null&&c.hasOwnProperty("metadataProps")){if(!Array.isArray(c.metadataProps))return"metadataProps: array expected";for(_=0;_<c.metadataProps.length;++_){var ot;if(ot=it.onnx.StringStringEntryProto.verify(c.metadataProps[_]))return"metadataProps."+ot}}return null},g.fromObject=function(c){if(c instanceof it.onnx.ModelProto)return c;var _=new it.onnx.ModelProto;if(c.irVersion!=null&&($.Long?(_.irVersion=$.Long.fromValue(c.irVersion)).unsigned=!1:typeof c.irVersion=="string"?_.irVersion=parseInt(c.irVersion,10):typeof c.irVersion=="number"?_.irVersion=c.irVersion:typeof c.irVersion=="object"&&(_.irVersion=new $.LongBits(c.irVersion.low>>>0,c.irVersion.high>>>0).toNumber())),c.opsetImport){if(!Array.isArray(c.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");_.opsetImport=[];for(var ot=0;ot<c.opsetImport.length;++ot){if(typeof c.opsetImport[ot]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");_.opsetImport[ot]=it.onnx.OperatorSetIdProto.fromObject(c.opsetImport[ot])}}if(c.producerName!=null&&(_.producerName=String(c.producerName)),c.producerVersion!=null&&(_.producerVersion=String(c.producerVersion)),c.domain!=null&&(_.domain=String(c.domain)),c.modelVersion!=null&&($.Long?(_.modelVersion=$.Long.fromValue(c.modelVersion)).unsigned=!1:typeof c.modelVersion=="string"?_.modelVersion=parseInt(c.modelVersion,10):typeof c.modelVersion=="number"?_.modelVersion=c.modelVersion:typeof c.modelVersion=="object"&&(_.modelVersion=new $.LongBits(c.modelVersion.low>>>0,c.modelVersion.high>>>0).toNumber())),c.docString!=null&&(_.docString=String(c.docString)),c.graph!=null){if(typeof c.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");_.graph=it.onnx.GraphProto.fromObject(c.graph)}if(c.metadataProps){if(!Array.isArray(c.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(_.metadataProps=[],ot=0;ot<c.metadataProps.length;++ot){if(typeof c.metadataProps[ot]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");_.metadataProps[ot]=it.onnx.StringStringEntryProto.fromObject(c.metadataProps[ot])}}return _},g.toObject=function(c,_){_||(_={});var ot={};if((_.arrays||_.defaults)&&(ot.opsetImport=[],ot.metadataProps=[]),_.defaults){if($.Long){var ct=new $.Long(0,0,!1);ot.irVersion=_.longs===String?ct.toString():_.longs===Number?ct.toNumber():ct}else ot.irVersion=_.longs===String?"0":0;ot.producerName="",ot.producerVersion="",ot.domain="",$.Long?(ct=new $.Long(0,0,!1),ot.modelVersion=_.longs===String?ct.toString():_.longs===Number?ct.toNumber():ct):ot.modelVersion=_.longs===String?"0":0,ot.docString="",ot.graph=null}if(c.irVersion!=null&&c.hasOwnProperty("irVersion")&&(typeof c.irVersion=="number"?ot.irVersion=_.longs===String?String(c.irVersion):c.irVersion:ot.irVersion=_.longs===String?$.Long.prototype.toString.call(c.irVersion):_.longs===Number?new $.LongBits(c.irVersion.low>>>0,c.irVersion.high>>>0).toNumber():c.irVersion),c.producerName!=null&&c.hasOwnProperty("producerName")&&(ot.producerName=c.producerName),c.producerVersion!=null&&c.hasOwnProperty("producerVersion")&&(ot.producerVersion=c.producerVersion),c.domain!=null&&c.hasOwnProperty("domain")&&(ot.domain=c.domain),c.modelVersion!=null&&c.hasOwnProperty("modelVersion")&&(typeof c.modelVersion=="number"?ot.modelVersion=_.longs===String?String(c.modelVersion):c.modelVersion:ot.modelVersion=_.longs===String?$.Long.prototype.toString.call(c.modelVersion):_.longs===Number?new $.LongBits(c.modelVersion.low>>>0,c.modelVersion.high>>>0).toNumber():c.modelVersion),c.docString!=null&&c.hasOwnProperty("docString")&&(ot.docString=c.docString),c.graph!=null&&c.hasOwnProperty("graph")&&(ot.graph=it.onnx.GraphProto.toObject(c.graph,_)),c.opsetImport&&c.opsetImport.length){ot.opsetImport=[];for(var dt=0;dt<c.opsetImport.length;++dt)ot.opsetImport[dt]=it.onnx.OperatorSetIdProto.toObject(c.opsetImport[dt],_)}if(c.metadataProps&&c.metadataProps.length)for(ot.metadataProps=[],dt=0;dt<c.metadataProps.length;++dt)ot.metadataProps[dt]=it.onnx.StringStringEntryProto.toObject(c.metadataProps[dt],_);return ot},g.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},g}(),h.StringStringEntryProto=function(){function g(c){if(c)for(var _=Object.keys(c),ot=0;ot<_.length;++ot)c[_[ot]]!=null&&(this[_[ot]]=c[_[ot]])}return g.prototype.key="",g.prototype.value="",g.create=function(c){return new g(c)},g.encode=function(c,_){return _||(_=st.create()),c.key!=null&&c.hasOwnProperty("key")&&_.uint32(10).string(c.key),c.value!=null&&c.hasOwnProperty("value")&&_.uint32(18).string(c.value),_},g.encodeDelimited=function(c,_){return this.encode(c,_).ldelim()},g.decode=function(c,_){c instanceof et||(c=et.create(c));for(var ot=_===void 0?c.len:c.pos+_,ct=new it.onnx.StringStringEntryProto;c.pos<ot;){var dt=c.uint32();switch(dt>>>3){case 1:ct.key=c.string();break;case 2:ct.value=c.string();break;default:c.skipType(7&dt)}}return ct},g.decodeDelimited=function(c){return c instanceof et||(c=new et(c)),this.decode(c,c.uint32())},g.verify=function(c){return typeof c!="object"||c===null?"object expected":c.key!=null&&c.hasOwnProperty("key")&&!$.isString(c.key)?"key: string expected":c.value!=null&&c.hasOwnProperty("value")&&!$.isString(c.value)?"value: string expected":null},g.fromObject=function(c){if(c instanceof it.onnx.StringStringEntryProto)return c;var _=new it.onnx.StringStringEntryProto;return c.key!=null&&(_.key=String(c.key)),c.value!=null&&(_.value=String(c.value)),_},g.toObject=function(c,_){_||(_={});var ot={};return _.defaults&&(ot.key="",ot.value=""),c.key!=null&&c.hasOwnProperty("key")&&(ot.key=c.key),c.value!=null&&c.hasOwnProperty("value")&&(ot.value=c.value),ot},g.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},g}(),h.TensorAnnotation=function(){function g(c){if(this.quantParameterTensorNames=[],c)for(var _=Object.keys(c),ot=0;ot<_.length;++ot)c[_[ot]]!=null&&(this[_[ot]]=c[_[ot]])}return g.prototype.tensorName="",g.prototype.quantParameterTensorNames=$.emptyArray,g.create=function(c){return new g(c)},g.encode=function(c,_){if(_||(_=st.create()),c.tensorName!=null&&c.hasOwnProperty("tensorName")&&_.uint32(10).string(c.tensorName),c.quantParameterTensorNames!=null&&c.quantParameterTensorNames.length)for(var ot=0;ot<c.quantParameterTensorNames.length;++ot)it.onnx.StringStringEntryProto.encode(c.quantParameterTensorNames[ot],_.uint32(18).fork()).ldelim();return _},g.encodeDelimited=function(c,_){return this.encode(c,_).ldelim()},g.decode=function(c,_){c instanceof et||(c=et.create(c));for(var ot=_===void 0?c.len:c.pos+_,ct=new it.onnx.TensorAnnotation;c.pos<ot;){var dt=c.uint32();switch(dt>>>3){case 1:ct.tensorName=c.string();break;case 2:ct.quantParameterTensorNames&&ct.quantParameterTensorNames.length||(ct.quantParameterTensorNames=[]),ct.quantParameterTensorNames.push(it.onnx.StringStringEntryProto.decode(c,c.uint32()));break;default:c.skipType(7&dt)}}return ct},g.decodeDelimited=function(c){return c instanceof et||(c=new et(c)),this.decode(c,c.uint32())},g.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.tensorName!=null&&c.hasOwnProperty("tensorName")&&!$.isString(c.tensorName))return"tensorName: string expected";if(c.quantParameterTensorNames!=null&&c.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(c.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var _=0;_<c.quantParameterTensorNames.length;++_){var ot=it.onnx.StringStringEntryProto.verify(c.quantParameterTensorNames[_]);if(ot)return"quantParameterTensorNames."+ot}}return null},g.fromObject=function(c){if(c instanceof it.onnx.TensorAnnotation)return c;var _=new it.onnx.TensorAnnotation;if(c.tensorName!=null&&(_.tensorName=String(c.tensorName)),c.quantParameterTensorNames){if(!Array.isArray(c.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");_.quantParameterTensorNames=[];for(var ot=0;ot<c.quantParameterTensorNames.length;++ot){if(typeof c.quantParameterTensorNames[ot]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");_.quantParameterTensorNames[ot]=it.onnx.StringStringEntryProto.fromObject(c.quantParameterTensorNames[ot])}}return _},g.toObject=function(c,_){_||(_={});var ot={};if((_.arrays||_.defaults)&&(ot.quantParameterTensorNames=[]),_.defaults&&(ot.tensorName=""),c.tensorName!=null&&c.hasOwnProperty("tensorName")&&(ot.tensorName=c.tensorName),c.quantParameterTensorNames&&c.quantParameterTensorNames.length){ot.quantParameterTensorNames=[];for(var ct=0;ct<c.quantParameterTensorNames.length;++ct)ot.quantParameterTensorNames[ct]=it.onnx.StringStringEntryProto.toObject(c.quantParameterTensorNames[ct],_)}return ot},g.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},g}(),h.GraphProto=function(){function g(c){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],c)for(var _=Object.keys(c),ot=0;ot<_.length;++ot)c[_[ot]]!=null&&(this[_[ot]]=c[_[ot]])}return g.prototype.node=$.emptyArray,g.prototype.name="",g.prototype.initializer=$.emptyArray,g.prototype.docString="",g.prototype.input=$.emptyArray,g.prototype.output=$.emptyArray,g.prototype.valueInfo=$.emptyArray,g.prototype.quantizationAnnotation=$.emptyArray,g.create=function(c){return new g(c)},g.encode=function(c,_){if(_||(_=st.create()),c.node!=null&&c.node.length)for(var ot=0;ot<c.node.length;++ot)it.onnx.NodeProto.encode(c.node[ot],_.uint32(10).fork()).ldelim();if(c.name!=null&&c.hasOwnProperty("name")&&_.uint32(18).string(c.name),c.initializer!=null&&c.initializer.length)for(ot=0;ot<c.initializer.length;++ot)it.onnx.TensorProto.encode(c.initializer[ot],_.uint32(42).fork()).ldelim();if(c.docString!=null&&c.hasOwnProperty("docString")&&_.uint32(82).string(c.docString),c.input!=null&&c.input.length)for(ot=0;ot<c.input.length;++ot)it.onnx.ValueInfoProto.encode(c.input[ot],_.uint32(90).fork()).ldelim();if(c.output!=null&&c.output.length)for(ot=0;ot<c.output.length;++ot)it.onnx.ValueInfoProto.encode(c.output[ot],_.uint32(98).fork()).ldelim();if(c.valueInfo!=null&&c.valueInfo.length)for(ot=0;ot<c.valueInfo.length;++ot)it.onnx.ValueInfoProto.encode(c.valueInfo[ot],_.uint32(106).fork()).ldelim();if(c.quantizationAnnotation!=null&&c.quantizationAnnotation.length)for(ot=0;ot<c.quantizationAnnotation.length;++ot)it.onnx.TensorAnnotation.encode(c.quantizationAnnotation[ot],_.uint32(114).fork()).ldelim();return _},g.encodeDelimited=function(c,_){return this.encode(c,_).ldelim()},g.decode=function(c,_){c instanceof et||(c=et.create(c));for(var ot=_===void 0?c.len:c.pos+_,ct=new it.onnx.GraphProto;c.pos<ot;){var dt=c.uint32();switch(dt>>>3){case 1:ct.node&&ct.node.length||(ct.node=[]),ct.node.push(it.onnx.NodeProto.decode(c,c.uint32()));break;case 2:ct.name=c.string();break;case 5:ct.initializer&&ct.initializer.length||(ct.initializer=[]),ct.initializer.push(it.onnx.TensorProto.decode(c,c.uint32()));break;case 10:ct.docString=c.string();break;case 11:ct.input&&ct.input.length||(ct.input=[]),ct.input.push(it.onnx.ValueInfoProto.decode(c,c.uint32()));break;case 12:ct.output&&ct.output.length||(ct.output=[]),ct.output.push(it.onnx.ValueInfoProto.decode(c,c.uint32()));break;case 13:ct.valueInfo&&ct.valueInfo.length||(ct.valueInfo=[]),ct.valueInfo.push(it.onnx.ValueInfoProto.decode(c,c.uint32()));break;case 14:ct.quantizationAnnotation&&ct.quantizationAnnotation.length||(ct.quantizationAnnotation=[]),ct.quantizationAnnotation.push(it.onnx.TensorAnnotation.decode(c,c.uint32()));break;default:c.skipType(7&dt)}}return ct},g.decodeDelimited=function(c){return c instanceof et||(c=new et(c)),this.decode(c,c.uint32())},g.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.node!=null&&c.hasOwnProperty("node")){if(!Array.isArray(c.node))return"node: array expected";for(var _=0;_<c.node.length;++_)if(ot=it.onnx.NodeProto.verify(c.node[_]))return"node."+ot}if(c.name!=null&&c.hasOwnProperty("name")&&!$.isString(c.name))return"name: string expected";if(c.initializer!=null&&c.hasOwnProperty("initializer")){if(!Array.isArray(c.initializer))return"initializer: array expected";for(_=0;_<c.initializer.length;++_)if(ot=it.onnx.TensorProto.verify(c.initializer[_]))return"initializer."+ot}if(c.docString!=null&&c.hasOwnProperty("docString")&&!$.isString(c.docString))return"docString: string expected";if(c.input!=null&&c.hasOwnProperty("input")){if(!Array.isArray(c.input))return"input: array expected";for(_=0;_<c.input.length;++_)if(ot=it.onnx.ValueInfoProto.verify(c.input[_]))return"input."+ot}if(c.output!=null&&c.hasOwnProperty("output")){if(!Array.isArray(c.output))return"output: array expected";for(_=0;_<c.output.length;++_)if(ot=it.onnx.ValueInfoProto.verify(c.output[_]))return"output."+ot}if(c.valueInfo!=null&&c.hasOwnProperty("valueInfo")){if(!Array.isArray(c.valueInfo))return"valueInfo: array expected";for(_=0;_<c.valueInfo.length;++_)if(ot=it.onnx.ValueInfoProto.verify(c.valueInfo[_]))return"valueInfo."+ot}if(c.quantizationAnnotation!=null&&c.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(c.quantizationAnnotation))return"quantizationAnnotation: array expected";for(_=0;_<c.quantizationAnnotation.length;++_){var ot;if(ot=it.onnx.TensorAnnotation.verify(c.quantizationAnnotation[_]))return"quantizationAnnotation."+ot}}return null},g.fromObject=function(c){if(c instanceof it.onnx.GraphProto)return c;var _=new it.onnx.GraphProto;if(c.node){if(!Array.isArray(c.node))throw TypeError(".onnx.GraphProto.node: array expected");_.node=[];for(var ot=0;ot<c.node.length;++ot){if(typeof c.node[ot]!="object")throw TypeError(".onnx.GraphProto.node: object expected");_.node[ot]=it.onnx.NodeProto.fromObject(c.node[ot])}}if(c.name!=null&&(_.name=String(c.name)),c.initializer){if(!Array.isArray(c.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(_.initializer=[],ot=0;ot<c.initializer.length;++ot){if(typeof c.initializer[ot]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");_.initializer[ot]=it.onnx.TensorProto.fromObject(c.initializer[ot])}}if(c.docString!=null&&(_.docString=String(c.docString)),c.input){if(!Array.isArray(c.input))throw TypeError(".onnx.GraphProto.input: array expected");for(_.input=[],ot=0;ot<c.input.length;++ot){if(typeof c.input[ot]!="object")throw TypeError(".onnx.GraphProto.input: object expected");_.input[ot]=it.onnx.ValueInfoProto.fromObject(c.input[ot])}}if(c.output){if(!Array.isArray(c.output))throw TypeError(".onnx.GraphProto.output: array expected");for(_.output=[],ot=0;ot<c.output.length;++ot){if(typeof c.output[ot]!="object")throw TypeError(".onnx.GraphProto.output: object expected");_.output[ot]=it.onnx.ValueInfoProto.fromObject(c.output[ot])}}if(c.valueInfo){if(!Array.isArray(c.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(_.valueInfo=[],ot=0;ot<c.valueInfo.length;++ot){if(typeof c.valueInfo[ot]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");_.valueInfo[ot]=it.onnx.ValueInfoProto.fromObject(c.valueInfo[ot])}}if(c.quantizationAnnotation){if(!Array.isArray(c.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(_.quantizationAnnotation=[],ot=0;ot<c.quantizationAnnotation.length;++ot){if(typeof c.quantizationAnnotation[ot]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");_.quantizationAnnotation[ot]=it.onnx.TensorAnnotation.fromObject(c.quantizationAnnotation[ot])}}return _},g.toObject=function(c,_){_||(_={});var ot={};if((_.arrays||_.defaults)&&(ot.node=[],ot.initializer=[],ot.input=[],ot.output=[],ot.valueInfo=[],ot.quantizationAnnotation=[]),_.defaults&&(ot.name="",ot.docString=""),c.node&&c.node.length){ot.node=[];for(var ct=0;ct<c.node.length;++ct)ot.node[ct]=it.onnx.NodeProto.toObject(c.node[ct],_)}if(c.name!=null&&c.hasOwnProperty("name")&&(ot.name=c.name),c.initializer&&c.initializer.length)for(ot.initializer=[],ct=0;ct<c.initializer.length;++ct)ot.initializer[ct]=it.onnx.TensorProto.toObject(c.initializer[ct],_);if(c.docString!=null&&c.hasOwnProperty("docString")&&(ot.docString=c.docString),c.input&&c.input.length)for(ot.input=[],ct=0;ct<c.input.length;++ct)ot.input[ct]=it.onnx.ValueInfoProto.toObject(c.input[ct],_);if(c.output&&c.output.length)for(ot.output=[],ct=0;ct<c.output.length;++ct)ot.output[ct]=it.onnx.ValueInfoProto.toObject(c.output[ct],_);if(c.valueInfo&&c.valueInfo.length)for(ot.valueInfo=[],ct=0;ct<c.valueInfo.length;++ct)ot.valueInfo[ct]=it.onnx.ValueInfoProto.toObject(c.valueInfo[ct],_);if(c.quantizationAnnotation&&c.quantizationAnnotation.length)for(ot.quantizationAnnotation=[],ct=0;ct<c.quantizationAnnotation.length;++ct)ot.quantizationAnnotation[ct]=it.onnx.TensorAnnotation.toObject(c.quantizationAnnotation[ct],_);return ot},g.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},g}(),h.TensorProto=function(){function g(c){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],c)for(var _=Object.keys(c),ot=0;ot<_.length;++ot)c[_[ot]]!=null&&(this[_[ot]]=c[_[ot]])}return g.prototype.dims=$.emptyArray,g.prototype.dataType=0,g.prototype.segment=null,g.prototype.floatData=$.emptyArray,g.prototype.int32Data=$.emptyArray,g.prototype.stringData=$.emptyArray,g.prototype.int64Data=$.emptyArray,g.prototype.name="",g.prototype.docString="",g.prototype.rawData=$.newBuffer([]),g.prototype.externalData=$.emptyArray,g.prototype.dataLocation=0,g.prototype.doubleData=$.emptyArray,g.prototype.uint64Data=$.emptyArray,g.create=function(c){return new g(c)},g.encode=function(c,_){if(_||(_=st.create()),c.dims!=null&&c.dims.length){_.uint32(10).fork();for(var ot=0;ot<c.dims.length;++ot)_.int64(c.dims[ot]);_.ldelim()}if(c.dataType!=null&&c.hasOwnProperty("dataType")&&_.uint32(16).int32(c.dataType),c.segment!=null&&c.hasOwnProperty("segment")&&it.onnx.TensorProto.Segment.encode(c.segment,_.uint32(26).fork()).ldelim(),c.floatData!=null&&c.floatData.length){for(_.uint32(34).fork(),ot=0;ot<c.floatData.length;++ot)_.float(c.floatData[ot]);_.ldelim()}if(c.int32Data!=null&&c.int32Data.length){for(_.uint32(42).fork(),ot=0;ot<c.int32Data.length;++ot)_.int32(c.int32Data[ot]);_.ldelim()}if(c.stringData!=null&&c.stringData.length)for(ot=0;ot<c.stringData.length;++ot)_.uint32(50).bytes(c.stringData[ot]);if(c.int64Data!=null&&c.int64Data.length){for(_.uint32(58).fork(),ot=0;ot<c.int64Data.length;++ot)_.int64(c.int64Data[ot]);_.ldelim()}if(c.name!=null&&c.hasOwnProperty("name")&&_.uint32(66).string(c.name),c.rawData!=null&&c.hasOwnProperty("rawData")&&_.uint32(74).bytes(c.rawData),c.doubleData!=null&&c.doubleData.length){for(_.uint32(82).fork(),ot=0;ot<c.doubleData.length;++ot)_.double(c.doubleData[ot]);_.ldelim()}if(c.uint64Data!=null&&c.uint64Data.length){for(_.uint32(90).fork(),ot=0;ot<c.uint64Data.length;++ot)_.uint64(c.uint64Data[ot]);_.ldelim()}if(c.docString!=null&&c.hasOwnProperty("docString")&&_.uint32(98).string(c.docString),c.externalData!=null&&c.externalData.length)for(ot=0;ot<c.externalData.length;++ot)it.onnx.StringStringEntryProto.encode(c.externalData[ot],_.uint32(106).fork()).ldelim();return c.dataLocation!=null&&c.hasOwnProperty("dataLocation")&&_.uint32(112).int32(c.dataLocation),_},g.encodeDelimited=function(c,_){return this.encode(c,_).ldelim()},g.decode=function(c,_){c instanceof et||(c=et.create(c));for(var ot=_===void 0?c.len:c.pos+_,ct=new it.onnx.TensorProto;c.pos<ot;){var dt=c.uint32();switch(dt>>>3){case 1:if(ct.dims&&ct.dims.length||(ct.dims=[]),(7&dt)==2)for(var pt=c.uint32()+c.pos;c.pos<pt;)ct.dims.push(c.int64());else ct.dims.push(c.int64());break;case 2:ct.dataType=c.int32();break;case 3:ct.segment=it.onnx.TensorProto.Segment.decode(c,c.uint32());break;case 4:if(ct.floatData&&ct.floatData.length||(ct.floatData=[]),(7&dt)==2)for(pt=c.uint32()+c.pos;c.pos<pt;)ct.floatData.push(c.float());else ct.floatData.push(c.float());break;case 5:if(ct.int32Data&&ct.int32Data.length||(ct.int32Data=[]),(7&dt)==2)for(pt=c.uint32()+c.pos;c.pos<pt;)ct.int32Data.push(c.int32());else ct.int32Data.push(c.int32());break;case 6:ct.stringData&&ct.stringData.length||(ct.stringData=[]),ct.stringData.push(c.bytes());break;case 7:if(ct.int64Data&&ct.int64Data.length||(ct.int64Data=[]),(7&dt)==2)for(pt=c.uint32()+c.pos;c.pos<pt;)ct.int64Data.push(c.int64());else ct.int64Data.push(c.int64());break;case 8:ct.name=c.string();break;case 12:ct.docString=c.string();break;case 9:ct.rawData=c.bytes();break;case 13:ct.externalData&&ct.externalData.length||(ct.externalData=[]),ct.externalData.push(it.onnx.StringStringEntryProto.decode(c,c.uint32()));break;case 14:ct.dataLocation=c.int32();break;case 10:if(ct.doubleData&&ct.doubleData.length||(ct.doubleData=[]),(7&dt)==2)for(pt=c.uint32()+c.pos;c.pos<pt;)ct.doubleData.push(c.double());else ct.doubleData.push(c.double());break;case 11:if(ct.uint64Data&&ct.uint64Data.length||(ct.uint64Data=[]),(7&dt)==2)for(pt=c.uint32()+c.pos;c.pos<pt;)ct.uint64Data.push(c.uint64());else ct.uint64Data.push(c.uint64());break;default:c.skipType(7&dt)}}return ct},g.decodeDelimited=function(c){return c instanceof et||(c=new et(c)),this.decode(c,c.uint32())},g.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.dims!=null&&c.hasOwnProperty("dims")){if(!Array.isArray(c.dims))return"dims: array expected";for(var _=0;_<c.dims.length;++_)if(!($.isInteger(c.dims[_])||c.dims[_]&&$.isInteger(c.dims[_].low)&&$.isInteger(c.dims[_].high)))return"dims: integer|Long[] expected"}if(c.dataType!=null&&c.hasOwnProperty("dataType")&&!$.isInteger(c.dataType))return"dataType: integer expected";if(c.segment!=null&&c.hasOwnProperty("segment")&&(ot=it.onnx.TensorProto.Segment.verify(c.segment)))return"segment."+ot;if(c.floatData!=null&&c.hasOwnProperty("floatData")){if(!Array.isArray(c.floatData))return"floatData: array expected";for(_=0;_<c.floatData.length;++_)if(typeof c.floatData[_]!="number")return"floatData: number[] expected"}if(c.int32Data!=null&&c.hasOwnProperty("int32Data")){if(!Array.isArray(c.int32Data))return"int32Data: array expected";for(_=0;_<c.int32Data.length;++_)if(!$.isInteger(c.int32Data[_]))return"int32Data: integer[] expected"}if(c.stringData!=null&&c.hasOwnProperty("stringData")){if(!Array.isArray(c.stringData))return"stringData: array expected";for(_=0;_<c.stringData.length;++_)if(!(c.stringData[_]&&typeof c.stringData[_].length=="number"||$.isString(c.stringData[_])))return"stringData: buffer[] expected"}if(c.int64Data!=null&&c.hasOwnProperty("int64Data")){if(!Array.isArray(c.int64Data))return"int64Data: array expected";for(_=0;_<c.int64Data.length;++_)if(!($.isInteger(c.int64Data[_])||c.int64Data[_]&&$.isInteger(c.int64Data[_].low)&&$.isInteger(c.int64Data[_].high)))return"int64Data: integer|Long[] expected"}if(c.name!=null&&c.hasOwnProperty("name")&&!$.isString(c.name))return"name: string expected";if(c.docString!=null&&c.hasOwnProperty("docString")&&!$.isString(c.docString))return"docString: string expected";if(c.rawData!=null&&c.hasOwnProperty("rawData")&&!(c.rawData&&typeof c.rawData.length=="number"||$.isString(c.rawData)))return"rawData: buffer expected";if(c.externalData!=null&&c.hasOwnProperty("externalData")){if(!Array.isArray(c.externalData))return"externalData: array expected";for(_=0;_<c.externalData.length;++_){var ot;if(ot=it.onnx.StringStringEntryProto.verify(c.externalData[_]))return"externalData."+ot}}if(c.dataLocation!=null&&c.hasOwnProperty("dataLocation"))switch(c.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(c.doubleData!=null&&c.hasOwnProperty("doubleData")){if(!Array.isArray(c.doubleData))return"doubleData: array expected";for(_=0;_<c.doubleData.length;++_)if(typeof c.doubleData[_]!="number")return"doubleData: number[] expected"}if(c.uint64Data!=null&&c.hasOwnProperty("uint64Data")){if(!Array.isArray(c.uint64Data))return"uint64Data: array expected";for(_=0;_<c.uint64Data.length;++_)if(!($.isInteger(c.uint64Data[_])||c.uint64Data[_]&&$.isInteger(c.uint64Data[_].low)&&$.isInteger(c.uint64Data[_].high)))return"uint64Data: integer|Long[] expected"}return null},g.fromObject=function(c){if(c instanceof it.onnx.TensorProto)return c;var _=new it.onnx.TensorProto;if(c.dims){if(!Array.isArray(c.dims))throw TypeError(".onnx.TensorProto.dims: array expected");_.dims=[];for(var ot=0;ot<c.dims.length;++ot)$.Long?(_.dims[ot]=$.Long.fromValue(c.dims[ot])).unsigned=!1:typeof c.dims[ot]=="string"?_.dims[ot]=parseInt(c.dims[ot],10):typeof c.dims[ot]=="number"?_.dims[ot]=c.dims[ot]:typeof c.dims[ot]=="object"&&(_.dims[ot]=new $.LongBits(c.dims[ot].low>>>0,c.dims[ot].high>>>0).toNumber())}if(c.dataType!=null&&(_.dataType=0|c.dataType),c.segment!=null){if(typeof c.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");_.segment=it.onnx.TensorProto.Segment.fromObject(c.segment)}if(c.floatData){if(!Array.isArray(c.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(_.floatData=[],ot=0;ot<c.floatData.length;++ot)_.floatData[ot]=Number(c.floatData[ot])}if(c.int32Data){if(!Array.isArray(c.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(_.int32Data=[],ot=0;ot<c.int32Data.length;++ot)_.int32Data[ot]=0|c.int32Data[ot]}if(c.stringData){if(!Array.isArray(c.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(_.stringData=[],ot=0;ot<c.stringData.length;++ot)typeof c.stringData[ot]=="string"?$.base64.decode(c.stringData[ot],_.stringData[ot]=$.newBuffer($.base64.length(c.stringData[ot])),0):c.stringData[ot].length&&(_.stringData[ot]=c.stringData[ot])}if(c.int64Data){if(!Array.isArray(c.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(_.int64Data=[],ot=0;ot<c.int64Data.length;++ot)$.Long?(_.int64Data[ot]=$.Long.fromValue(c.int64Data[ot])).unsigned=!1:typeof c.int64Data[ot]=="string"?_.int64Data[ot]=parseInt(c.int64Data[ot],10):typeof c.int64Data[ot]=="number"?_.int64Data[ot]=c.int64Data[ot]:typeof c.int64Data[ot]=="object"&&(_.int64Data[ot]=new $.LongBits(c.int64Data[ot].low>>>0,c.int64Data[ot].high>>>0).toNumber())}if(c.name!=null&&(_.name=String(c.name)),c.docString!=null&&(_.docString=String(c.docString)),c.rawData!=null&&(typeof c.rawData=="string"?$.base64.decode(c.rawData,_.rawData=$.newBuffer($.base64.length(c.rawData)),0):c.rawData.length&&(_.rawData=c.rawData)),c.externalData){if(!Array.isArray(c.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(_.externalData=[],ot=0;ot<c.externalData.length;++ot){if(typeof c.externalData[ot]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");_.externalData[ot]=it.onnx.StringStringEntryProto.fromObject(c.externalData[ot])}}switch(c.dataLocation){case"DEFAULT":case 0:_.dataLocation=0;break;case"EXTERNAL":case 1:_.dataLocation=1}if(c.doubleData){if(!Array.isArray(c.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(_.doubleData=[],ot=0;ot<c.doubleData.length;++ot)_.doubleData[ot]=Number(c.doubleData[ot])}if(c.uint64Data){if(!Array.isArray(c.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(_.uint64Data=[],ot=0;ot<c.uint64Data.length;++ot)$.Long?(_.uint64Data[ot]=$.Long.fromValue(c.uint64Data[ot])).unsigned=!0:typeof c.uint64Data[ot]=="string"?_.uint64Data[ot]=parseInt(c.uint64Data[ot],10):typeof c.uint64Data[ot]=="number"?_.uint64Data[ot]=c.uint64Data[ot]:typeof c.uint64Data[ot]=="object"&&(_.uint64Data[ot]=new $.LongBits(c.uint64Data[ot].low>>>0,c.uint64Data[ot].high>>>0).toNumber(!0))}return _},g.toObject=function(c,_){_||(_={});var ot={};if((_.arrays||_.defaults)&&(ot.dims=[],ot.floatData=[],ot.int32Data=[],ot.stringData=[],ot.int64Data=[],ot.doubleData=[],ot.uint64Data=[],ot.externalData=[]),_.defaults&&(ot.dataType=0,ot.segment=null,ot.name="",_.bytes===String?ot.rawData="":(ot.rawData=[],_.bytes!==Array&&(ot.rawData=$.newBuffer(ot.rawData))),ot.docString="",ot.dataLocation=_.enums===String?"DEFAULT":0),c.dims&&c.dims.length){ot.dims=[];for(var ct=0;ct<c.dims.length;++ct)typeof c.dims[ct]=="number"?ot.dims[ct]=_.longs===String?String(c.dims[ct]):c.dims[ct]:ot.dims[ct]=_.longs===String?$.Long.prototype.toString.call(c.dims[ct]):_.longs===Number?new $.LongBits(c.dims[ct].low>>>0,c.dims[ct].high>>>0).toNumber():c.dims[ct]}if(c.dataType!=null&&c.hasOwnProperty("dataType")&&(ot.dataType=c.dataType),c.segment!=null&&c.hasOwnProperty("segment")&&(ot.segment=it.onnx.TensorProto.Segment.toObject(c.segment,_)),c.floatData&&c.floatData.length)for(ot.floatData=[],ct=0;ct<c.floatData.length;++ct)ot.floatData[ct]=_.json&&!isFinite(c.floatData[ct])?String(c.floatData[ct]):c.floatData[ct];if(c.int32Data&&c.int32Data.length)for(ot.int32Data=[],ct=0;ct<c.int32Data.length;++ct)ot.int32Data[ct]=c.int32Data[ct];if(c.stringData&&c.stringData.length)for(ot.stringData=[],ct=0;ct<c.stringData.length;++ct)ot.stringData[ct]=_.bytes===String?$.base64.encode(c.stringData[ct],0,c.stringData[ct].length):_.bytes===Array?Array.prototype.slice.call(c.stringData[ct]):c.stringData[ct];if(c.int64Data&&c.int64Data.length)for(ot.int64Data=[],ct=0;ct<c.int64Data.length;++ct)typeof c.int64Data[ct]=="number"?ot.int64Data[ct]=_.longs===String?String(c.int64Data[ct]):c.int64Data[ct]:ot.int64Data[ct]=_.longs===String?$.Long.prototype.toString.call(c.int64Data[ct]):_.longs===Number?new $.LongBits(c.int64Data[ct].low>>>0,c.int64Data[ct].high>>>0).toNumber():c.int64Data[ct];if(c.name!=null&&c.hasOwnProperty("name")&&(ot.name=c.name),c.rawData!=null&&c.hasOwnProperty("rawData")&&(ot.rawData=_.bytes===String?$.base64.encode(c.rawData,0,c.rawData.length):_.bytes===Array?Array.prototype.slice.call(c.rawData):c.rawData),c.doubleData&&c.doubleData.length)for(ot.doubleData=[],ct=0;ct<c.doubleData.length;++ct)ot.doubleData[ct]=_.json&&!isFinite(c.doubleData[ct])?String(c.doubleData[ct]):c.doubleData[ct];if(c.uint64Data&&c.uint64Data.length)for(ot.uint64Data=[],ct=0;ct<c.uint64Data.length;++ct)typeof c.uint64Data[ct]=="number"?ot.uint64Data[ct]=_.longs===String?String(c.uint64Data[ct]):c.uint64Data[ct]:ot.uint64Data[ct]=_.longs===String?$.Long.prototype.toString.call(c.uint64Data[ct]):_.longs===Number?new $.LongBits(c.uint64Data[ct].low>>>0,c.uint64Data[ct].high>>>0).toNumber(!0):c.uint64Data[ct];if(c.docString!=null&&c.hasOwnProperty("docString")&&(ot.docString=c.docString),c.externalData&&c.externalData.length)for(ot.externalData=[],ct=0;ct<c.externalData.length;++ct)ot.externalData[ct]=it.onnx.StringStringEntryProto.toObject(c.externalData[ct],_);return c.dataLocation!=null&&c.hasOwnProperty("dataLocation")&&(ot.dataLocation=_.enums===String?it.onnx.TensorProto.DataLocation[c.dataLocation]:c.dataLocation),ot},g.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},g.DataType=function(){var c={},_=Object.create(c);return _[c[0]="UNDEFINED"]=0,_[c[1]="FLOAT"]=1,_[c[2]="UINT8"]=2,_[c[3]="INT8"]=3,_[c[4]="UINT16"]=4,_[c[5]="INT16"]=5,_[c[6]="INT32"]=6,_[c[7]="INT64"]=7,_[c[8]="STRING"]=8,_[c[9]="BOOL"]=9,_[c[10]="FLOAT16"]=10,_[c[11]="DOUBLE"]=11,_[c[12]="UINT32"]=12,_[c[13]="UINT64"]=13,_[c[14]="COMPLEX64"]=14,_[c[15]="COMPLEX128"]=15,_[c[16]="BFLOAT16"]=16,_}(),g.Segment=function(){function c(_){if(_)for(var ot=Object.keys(_),ct=0;ct<ot.length;++ct)_[ot[ct]]!=null&&(this[ot[ct]]=_[ot[ct]])}return c.prototype.begin=$.Long?$.Long.fromBits(0,0,!1):0,c.prototype.end=$.Long?$.Long.fromBits(0,0,!1):0,c.create=function(_){return new c(_)},c.encode=function(_,ot){return ot||(ot=st.create()),_.begin!=null&&_.hasOwnProperty("begin")&&ot.uint32(8).int64(_.begin),_.end!=null&&_.hasOwnProperty("end")&&ot.uint32(16).int64(_.end),ot},c.encodeDelimited=function(_,ot){return this.encode(_,ot).ldelim()},c.decode=function(_,ot){_ instanceof et||(_=et.create(_));for(var ct=ot===void 0?_.len:_.pos+ot,dt=new it.onnx.TensorProto.Segment;_.pos<ct;){var pt=_.uint32();switch(pt>>>3){case 1:dt.begin=_.int64();break;case 2:dt.end=_.int64();break;default:_.skipType(7&pt)}}return dt},c.decodeDelimited=function(_){return _ instanceof et||(_=new et(_)),this.decode(_,_.uint32())},c.verify=function(_){return typeof _!="object"||_===null?"object expected":_.begin!=null&&_.hasOwnProperty("begin")&&!($.isInteger(_.begin)||_.begin&&$.isInteger(_.begin.low)&&$.isInteger(_.begin.high))?"begin: integer|Long expected":_.end!=null&&_.hasOwnProperty("end")&&!($.isInteger(_.end)||_.end&&$.isInteger(_.end.low)&&$.isInteger(_.end.high))?"end: integer|Long expected":null},c.fromObject=function(_){if(_ instanceof it.onnx.TensorProto.Segment)return _;var ot=new it.onnx.TensorProto.Segment;return _.begin!=null&&($.Long?(ot.begin=$.Long.fromValue(_.begin)).unsigned=!1:typeof _.begin=="string"?ot.begin=parseInt(_.begin,10):typeof _.begin=="number"?ot.begin=_.begin:typeof _.begin=="object"&&(ot.begin=new $.LongBits(_.begin.low>>>0,_.begin.high>>>0).toNumber())),_.end!=null&&($.Long?(ot.end=$.Long.fromValue(_.end)).unsigned=!1:typeof _.end=="string"?ot.end=parseInt(_.end,10):typeof _.end=="number"?ot.end=_.end:typeof _.end=="object"&&(ot.end=new $.LongBits(_.end.low>>>0,_.end.high>>>0).toNumber())),ot},c.toObject=function(_,ot){ot||(ot={});var ct={};if(ot.defaults){if($.Long){var dt=new $.Long(0,0,!1);ct.begin=ot.longs===String?dt.toString():ot.longs===Number?dt.toNumber():dt}else ct.begin=ot.longs===String?"0":0;$.Long?(dt=new $.Long(0,0,!1),ct.end=ot.longs===String?dt.toString():ot.longs===Number?dt.toNumber():dt):ct.end=ot.longs===String?"0":0}return _.begin!=null&&_.hasOwnProperty("begin")&&(typeof _.begin=="number"?ct.begin=ot.longs===String?String(_.begin):_.begin:ct.begin=ot.longs===String?$.Long.prototype.toString.call(_.begin):ot.longs===Number?new $.LongBits(_.begin.low>>>0,_.begin.high>>>0).toNumber():_.begin),_.end!=null&&_.hasOwnProperty("end")&&(typeof _.end=="number"?ct.end=ot.longs===String?String(_.end):_.end:ct.end=ot.longs===String?$.Long.prototype.toString.call(_.end):ot.longs===Number?new $.LongBits(_.end.low>>>0,_.end.high>>>0).toNumber():_.end),ct},c.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},c}(),g.DataLocation=function(){var c={},_=Object.create(c);return _[c[0]="DEFAULT"]=0,_[c[1]="EXTERNAL"]=1,_}(),g}(),h.TensorShapeProto=function(){function g(c){if(this.dim=[],c)for(var _=Object.keys(c),ot=0;ot<_.length;++ot)c[_[ot]]!=null&&(this[_[ot]]=c[_[ot]])}return g.prototype.dim=$.emptyArray,g.create=function(c){return new g(c)},g.encode=function(c,_){if(_||(_=st.create()),c.dim!=null&&c.dim.length)for(var ot=0;ot<c.dim.length;++ot)it.onnx.TensorShapeProto.Dimension.encode(c.dim[ot],_.uint32(10).fork()).ldelim();return _},g.encodeDelimited=function(c,_){return this.encode(c,_).ldelim()},g.decode=function(c,_){c instanceof et||(c=et.create(c));for(var ot=_===void 0?c.len:c.pos+_,ct=new it.onnx.TensorShapeProto;c.pos<ot;){var dt=c.uint32();dt>>>3==1?(ct.dim&&ct.dim.length||(ct.dim=[]),ct.dim.push(it.onnx.TensorShapeProto.Dimension.decode(c,c.uint32()))):c.skipType(7&dt)}return ct},g.decodeDelimited=function(c){return c instanceof et||(c=new et(c)),this.decode(c,c.uint32())},g.verify=function(c){if(typeof c!="object"||c===null)return"object expected";if(c.dim!=null&&c.hasOwnProperty("dim")){if(!Array.isArray(c.dim))return"dim: array expected";for(var _=0;_<c.dim.length;++_){var ot=it.onnx.TensorShapeProto.Dimension.verify(c.dim[_]);if(ot)return"dim."+ot}}return null},g.fromObject=function(c){if(c instanceof it.onnx.TensorShapeProto)return c;var _=new it.onnx.TensorShapeProto;if(c.dim){if(!Array.isArray(c.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");_.dim=[];for(var ot=0;ot<c.dim.length;++ot){if(typeof c.dim[ot]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");_.dim[ot]=it.onnx.TensorShapeProto.Dimension.fromObject(c.dim[ot])}}return _},g.toObject=function(c,_){_||(_={});var ot={};if((_.arrays||_.defaults)&&(ot.dim=[]),c.dim&&c.dim.length){ot.dim=[];for(var ct=0;ct<c.dim.length;++ct)ot.dim[ct]=it.onnx.TensorShapeProto.Dimension.toObject(c.dim[ct],_)}return ot},g.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},g.Dimension=function(){function c(ot){if(ot)for(var ct=Object.keys(ot),dt=0;dt<ct.length;++dt)ot[ct[dt]]!=null&&(this[ct[dt]]=ot[ct[dt]])}var _;return c.prototype.dimValue=$.Long?$.Long.fromBits(0,0,!1):0,c.prototype.dimParam="",c.prototype.denotation="",Object.defineProperty(c.prototype,"value",{get:$.oneOfGetter(_=["dimValue","dimParam"]),set:$.oneOfSetter(_)}),c.create=function(ot){return new c(ot)},c.encode=function(ot,ct){return ct||(ct=st.create()),ot.dimValue!=null&&ot.hasOwnProperty("dimValue")&&ct.uint32(8).int64(ot.dimValue),ot.dimParam!=null&&ot.hasOwnProperty("dimParam")&&ct.uint32(18).string(ot.dimParam),ot.denotation!=null&&ot.hasOwnProperty("denotation")&&ct.uint32(26).string(ot.denotation),ct},c.encodeDelimited=function(ot,ct){return this.encode(ot,ct).ldelim()},c.decode=function(ot,ct){ot instanceof et||(ot=et.create(ot));for(var dt=ct===void 0?ot.len:ot.pos+ct,pt=new it.onnx.TensorShapeProto.Dimension;ot.pos<dt;){var ft=ot.uint32();switch(ft>>>3){case 1:pt.dimValue=ot.int64();break;case 2:pt.dimParam=ot.string();break;case 3:pt.denotation=ot.string();break;default:ot.skipType(7&ft)}}return pt},c.decodeDelimited=function(ot){return ot instanceof et||(ot=new et(ot)),this.decode(ot,ot.uint32())},c.verify=function(ot){if(typeof ot!="object"||ot===null)return"object expected";var ct={};if(ot.dimValue!=null&&ot.hasOwnProperty("dimValue")&&(ct.value=1,!($.isInteger(ot.dimValue)||ot.dimValue&&$.isInteger(ot.dimValue.low)&&$.isInteger(ot.dimValue.high))))return"dimValue: integer|Long expected";if(ot.dimParam!=null&&ot.hasOwnProperty("dimParam")){if(ct.value===1)return"value: multiple values";if(ct.value=1,!$.isString(ot.dimParam))return"dimParam: string expected"}return ot.denotation!=null&&ot.hasOwnProperty("denotation")&&!$.isString(ot.denotation)?"denotation: string expected":null},c.fromObject=function(ot){if(ot instanceof it.onnx.TensorShapeProto.Dimension)return ot;var ct=new it.onnx.TensorShapeProto.Dimension;return ot.dimValue!=null&&($.Long?(ct.dimValue=$.Long.fromValue(ot.dimValue)).unsigned=!1:typeof ot.dimValue=="string"?ct.dimValue=parseInt(ot.dimValue,10):typeof ot.dimValue=="number"?ct.dimValue=ot.dimValue:typeof ot.dimValue=="object"&&(ct.dimValue=new $.LongBits(ot.dimValue.low>>>0,ot.dimValue.high>>>0).toNumber())),ot.dimParam!=null&&(ct.dimParam=String(ot.dimParam)),ot.denotation!=null&&(ct.denotation=String(ot.denotation)),ct},c.toObject=function(ot,ct){ct||(ct={});var dt={};return ct.defaults&&(dt.denotation=""),ot.dimValue!=null&&ot.hasOwnProperty("dimValue")&&(typeof ot.dimValue=="number"?dt.dimValue=ct.longs===String?String(ot.dimValue):ot.dimValue:dt.dimValue=ct.longs===String?$.Long.prototype.toString.call(ot.dimValue):ct.longs===Number?new $.LongBits(ot.dimValue.low>>>0,ot.dimValue.high>>>0).toNumber():ot.dimValue,ct.oneofs&&(dt.value="dimValue")),ot.dimParam!=null&&ot.hasOwnProperty("dimParam")&&(dt.dimParam=ot.dimParam,ct.oneofs&&(dt.value="dimParam")),ot.denotation!=null&&ot.hasOwnProperty("denotation")&&(dt.denotation=ot.denotation),dt},c.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},c}(),g}(),h.TypeProto=function(){function g(_){if(_)for(var ot=Object.keys(_),ct=0;ct<ot.length;++ct)_[ot[ct]]!=null&&(this[ot[ct]]=_[ot[ct]])}var c;return g.prototype.tensorType=null,g.prototype.denotation="",Object.defineProperty(g.prototype,"value",{get:$.oneOfGetter(c=["tensorType"]),set:$.oneOfSetter(c)}),g.create=function(_){return new g(_)},g.encode=function(_,ot){return ot||(ot=st.create()),_.tensorType!=null&&_.hasOwnProperty("tensorType")&&it.onnx.TypeProto.Tensor.encode(_.tensorType,ot.uint32(10).fork()).ldelim(),_.denotation!=null&&_.hasOwnProperty("denotation")&&ot.uint32(50).string(_.denotation),ot},g.encodeDelimited=function(_,ot){return this.encode(_,ot).ldelim()},g.decode=function(_,ot){_ instanceof et||(_=et.create(_));for(var ct=ot===void 0?_.len:_.pos+ot,dt=new it.onnx.TypeProto;_.pos<ct;){var pt=_.uint32();switch(pt>>>3){case 1:dt.tensorType=it.onnx.TypeProto.Tensor.decode(_,_.uint32());break;case 6:dt.denotation=_.string();break;default:_.skipType(7&pt)}}return dt},g.decodeDelimited=function(_){return _ instanceof et||(_=new et(_)),this.decode(_,_.uint32())},g.verify=function(_){if(typeof _!="object"||_===null)return"object expected";if(_.tensorType!=null&&_.hasOwnProperty("tensorType")){var ot=it.onnx.TypeProto.Tensor.verify(_.tensorType);if(ot)return"tensorType."+ot}return _.denotation!=null&&_.hasOwnProperty("denotation")&&!$.isString(_.denotation)?"denotation: string expected":null},g.fromObject=function(_){if(_ instanceof it.onnx.TypeProto)return _;var ot=new it.onnx.TypeProto;if(_.tensorType!=null){if(typeof _.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");ot.tensorType=it.onnx.TypeProto.Tensor.fromObject(_.tensorType)}return _.denotation!=null&&(ot.denotation=String(_.denotation)),ot},g.toObject=function(_,ot){ot||(ot={});var ct={};return ot.defaults&&(ct.denotation=""),_.tensorType!=null&&_.hasOwnProperty("tensorType")&&(ct.tensorType=it.onnx.TypeProto.Tensor.toObject(_.tensorType,ot),ot.oneofs&&(ct.value="tensorType")),_.denotation!=null&&_.hasOwnProperty("denotation")&&(ct.denotation=_.denotation),ct},g.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},g.Tensor=function(){function _(ot){if(ot)for(var ct=Object.keys(ot),dt=0;dt<ct.length;++dt)ot[ct[dt]]!=null&&(this[ct[dt]]=ot[ct[dt]])}return _.prototype.elemType=0,_.prototype.shape=null,_.create=function(ot){return new _(ot)},_.encode=function(ot,ct){return ct||(ct=st.create()),ot.elemType!=null&&ot.hasOwnProperty("elemType")&&ct.uint32(8).int32(ot.elemType),ot.shape!=null&&ot.hasOwnProperty("shape")&&it.onnx.TensorShapeProto.encode(ot.shape,ct.uint32(18).fork()).ldelim(),ct},_.encodeDelimited=function(ot,ct){return this.encode(ot,ct).ldelim()},_.decode=function(ot,ct){ot instanceof et||(ot=et.create(ot));for(var dt=ct===void 0?ot.len:ot.pos+ct,pt=new it.onnx.TypeProto.Tensor;ot.pos<dt;){var ft=ot.uint32();switch(ft>>>3){case 1:pt.elemType=ot.int32();break;case 2:pt.shape=it.onnx.TensorShapeProto.decode(ot,ot.uint32());break;default:ot.skipType(7&ft)}}return pt},_.decodeDelimited=function(ot){return ot instanceof et||(ot=new et(ot)),this.decode(ot,ot.uint32())},_.verify=function(ot){if(typeof ot!="object"||ot===null)return"object expected";if(ot.elemType!=null&&ot.hasOwnProperty("elemType")&&!$.isInteger(ot.elemType))return"elemType: integer expected";if(ot.shape!=null&&ot.hasOwnProperty("shape")){var ct=it.onnx.TensorShapeProto.verify(ot.shape);if(ct)return"shape."+ct}return null},_.fromObject=function(ot){if(ot instanceof it.onnx.TypeProto.Tensor)return ot;var ct=new it.onnx.TypeProto.Tensor;if(ot.elemType!=null&&(ct.elemType=0|ot.elemType),ot.shape!=null){if(typeof ot.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");ct.shape=it.onnx.TensorShapeProto.fromObject(ot.shape)}return ct},_.toObject=function(ot,ct){ct||(ct={});var dt={};return ct.defaults&&(dt.elemType=0,dt.shape=null),ot.elemType!=null&&ot.hasOwnProperty("elemType")&&(dt.elemType=ot.elemType),ot.shape!=null&&ot.hasOwnProperty("shape")&&(dt.shape=it.onnx.TensorShapeProto.toObject(ot.shape,ct)),dt},_.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},_}(),g}(),h.OperatorSetIdProto=function(){function g(c){if(c)for(var _=Object.keys(c),ot=0;ot<_.length;++ot)c[_[ot]]!=null&&(this[_[ot]]=c[_[ot]])}return g.prototype.domain="",g.prototype.version=$.Long?$.Long.fromBits(0,0,!1):0,g.create=function(c){return new g(c)},g.encode=function(c,_){return _||(_=st.create()),c.domain!=null&&c.hasOwnProperty("domain")&&_.uint32(10).string(c.domain),c.version!=null&&c.hasOwnProperty("version")&&_.uint32(16).int64(c.version),_},g.encodeDelimited=function(c,_){return this.encode(c,_).ldelim()},g.decode=function(c,_){c instanceof et||(c=et.create(c));for(var ot=_===void 0?c.len:c.pos+_,ct=new it.onnx.OperatorSetIdProto;c.pos<ot;){var dt=c.uint32();switch(dt>>>3){case 1:ct.domain=c.string();break;case 2:ct.version=c.int64();break;default:c.skipType(7&dt)}}return ct},g.decodeDelimited=function(c){return c instanceof et||(c=new et(c)),this.decode(c,c.uint32())},g.verify=function(c){return typeof c!="object"||c===null?"object expected":c.domain!=null&&c.hasOwnProperty("domain")&&!$.isString(c.domain)?"domain: string expected":c.version!=null&&c.hasOwnProperty("version")&&!($.isInteger(c.version)||c.version&&$.isInteger(c.version.low)&&$.isInteger(c.version.high))?"version: integer|Long expected":null},g.fromObject=function(c){if(c instanceof it.onnx.OperatorSetIdProto)return c;var _=new it.onnx.OperatorSetIdProto;return c.domain!=null&&(_.domain=String(c.domain)),c.version!=null&&($.Long?(_.version=$.Long.fromValue(c.version)).unsigned=!1:typeof c.version=="string"?_.version=parseInt(c.version,10):typeof c.version=="number"?_.version=c.version:typeof c.version=="object"&&(_.version=new $.LongBits(c.version.low>>>0,c.version.high>>>0).toNumber())),_},g.toObject=function(c,_){_||(_={});var ot={};if(_.defaults)if(ot.domain="",$.Long){var ct=new $.Long(0,0,!1);ot.version=_.longs===String?ct.toString():_.longs===Number?ct.toNumber():ct}else ot.version=_.longs===String?"0":0;return c.domain!=null&&c.hasOwnProperty("domain")&&(ot.domain=c.domain),c.version!=null&&c.hasOwnProperty("version")&&(typeof c.version=="number"?ot.version=_.longs===String?String(c.version):c.version:ot.version=_.longs===String?$.Long.prototype.toString.call(c.version):_.longs===Number?new $.LongBits(c.version.low>>>0,c.version.high>>>0).toNumber():c.version),ot},g.prototype.toJSON=function(){return this.constructor.toObject(this,b.util.toJSONOptions)},g}(),h),o.exports=it},2100:(o,e,s)=>{o.exports=s(9482)},9482:(o,e,s)=>{var a=e;function d(){a.util._configure(),a.Writer._configure(a.BufferWriter),a.Reader._configure(a.BufferReader)}a.build="minimal",a.Writer=s(1173),a.BufferWriter=s(3155),a.Reader=s(1408),a.BufferReader=s(593),a.util=s(9693),a.rpc=s(5994),a.roots=s(5054),a.configure=d,d()},1408:(o,e,s)=>{o.exports=st;var a,d=s(9693),h=d.LongBits,b=d.utf8;function et(ct,dt){return RangeError("index out of range: "+ct.pos+" + "+(dt||1)+" > "+ct.len)}function st(ct){this.buf=ct,this.pos=0,this.len=ct.length}var $,it=typeof Uint8Array<"u"?function(ct){if(ct instanceof Uint8Array||Array.isArray(ct))return new st(ct);throw Error("illegal buffer")}:function(ct){if(Array.isArray(ct))return new st(ct);throw Error("illegal buffer")},g=function(){return d.Buffer?function(ct){return(st.create=function(dt){return d.Buffer.isBuffer(dt)?new a(dt):it(dt)})(ct)}:it};function c(){var ct=new h(0,0),dt=0;if(!(this.len-this.pos>4)){for(;dt<3;++dt){if(this.pos>=this.len)throw et(this);if(ct.lo=(ct.lo|(127&this.buf[this.pos])<<7*dt)>>>0,this.buf[this.pos++]<128)return ct}return ct.lo=(ct.lo|(127&this.buf[this.pos++])<<7*dt)>>>0,ct}for(;dt<4;++dt)if(ct.lo=(ct.lo|(127&this.buf[this.pos])<<7*dt)>>>0,this.buf[this.pos++]<128)return ct;if(ct.lo=(ct.lo|(127&this.buf[this.pos])<<28)>>>0,ct.hi=(ct.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return ct;if(dt=0,this.len-this.pos>4){for(;dt<5;++dt)if(ct.hi=(ct.hi|(127&this.buf[this.pos])<<7*dt+3)>>>0,this.buf[this.pos++]<128)return ct}else for(;dt<5;++dt){if(this.pos>=this.len)throw et(this);if(ct.hi=(ct.hi|(127&this.buf[this.pos])<<7*dt+3)>>>0,this.buf[this.pos++]<128)return ct}throw Error("invalid varint encoding")}function _(ct,dt){return(ct[dt-4]|ct[dt-3]<<8|ct[dt-2]<<16|ct[dt-1]<<24)>>>0}function ot(){if(this.pos+8>this.len)throw et(this,8);return new h(_(this.buf,this.pos+=4),_(this.buf,this.pos+=4))}st.create=g(),st.prototype._slice=d.Array.prototype.subarray||d.Array.prototype.slice,st.prototype.uint32=($=4294967295,function(){if($=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||($=($|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||($=($|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||($=($|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||($=($|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return $;if((this.pos+=5)>this.len)throw this.pos=this.len,et(this,10);return $}),st.prototype.int32=function(){return 0|this.uint32()},st.prototype.sint32=function(){var ct=this.uint32();return ct>>>1^-(1&ct)|0},st.prototype.bool=function(){return this.uint32()!==0},st.prototype.fixed32=function(){if(this.pos+4>this.len)throw et(this,4);return _(this.buf,this.pos+=4)},st.prototype.sfixed32=function(){if(this.pos+4>this.len)throw et(this,4);return 0|_(this.buf,this.pos+=4)},st.prototype.float=function(){if(this.pos+4>this.len)throw et(this,4);var ct=d.float.readFloatLE(this.buf,this.pos);return this.pos+=4,ct},st.prototype.double=function(){if(this.pos+8>this.len)throw et(this,4);var ct=d.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,ct},st.prototype.bytes=function(){var ct=this.uint32(),dt=this.pos,pt=this.pos+ct;if(pt>this.len)throw et(this,ct);return this.pos+=ct,Array.isArray(this.buf)?this.buf.slice(dt,pt):dt===pt?new this.buf.constructor(0):this._slice.call(this.buf,dt,pt)},st.prototype.string=function(){var ct=this.bytes();return b.read(ct,0,ct.length)},st.prototype.skip=function(ct){if(typeof ct=="number"){if(this.pos+ct>this.len)throw et(this,ct);this.pos+=ct}else do if(this.pos>=this.len)throw et(this);while(128&this.buf[this.pos++]);return this},st.prototype.skipType=function(ct){switch(ct){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(ct=7&this.uint32())!=4;)this.skipType(ct);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+ct+" at offset "+this.pos)}return this},st._configure=function(ct){a=ct,st.create=g(),a._configure();var dt=d.Long?"toLong":"toNumber";d.merge(st.prototype,{int64:function(){return c.call(this)[dt](!1)},uint64:function(){return c.call(this)[dt](!0)},sint64:function(){return c.call(this).zzDecode()[dt](!1)},fixed64:function(){return ot.call(this)[dt](!0)},sfixed64:function(){return ot.call(this)[dt](!1)}})}},593:(o,e,s)=>{o.exports=h;var a=s(1408);(h.prototype=Object.create(a.prototype)).constructor=h;var d=s(9693);function h(b){a.call(this,b)}h._configure=function(){d.Buffer&&(h.prototype._slice=d.Buffer.prototype.slice)},h.prototype.string=function(){var b=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+b,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+b,this.len))},h._configure()},5054:o=>{o.exports={}},5994:(o,e,s)=>{e.Service=s(7948)},7948:(o,e,s)=>{o.exports=d;var a=s(9693);function d(h,b,et){if(typeof h!="function")throw TypeError("rpcImpl must be a function");a.EventEmitter.call(this),this.rpcImpl=h,this.requestDelimited=!!b,this.responseDelimited=!!et}(d.prototype=Object.create(a.EventEmitter.prototype)).constructor=d,d.prototype.rpcCall=function h(b,et,st,$,it){if(!$)throw TypeError("request must be specified");var g=this;if(!it)return a.asPromise(h,g,b,et,st,$);if(g.rpcImpl)try{return g.rpcImpl(b,et[g.requestDelimited?"encodeDelimited":"encode"]($).finish(),function(c,_){if(c)return g.emit("error",c,b),it(c);if(_!==null){if(!(_ instanceof st))try{_=st[g.responseDelimited?"decodeDelimited":"decode"](_)}catch(ot){return g.emit("error",ot,b),it(ot)}return g.emit("data",_,b),it(null,_)}g.end(!0)})}catch(c){return g.emit("error",c,b),void setTimeout(function(){it(c)},0)}else setTimeout(function(){it(Error("already ended"))},0)},d.prototype.end=function(h){return this.rpcImpl&&(h||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(o,e,s)=>{o.exports=d;var a=s(9693);function d(st,$){this.lo=st>>>0,this.hi=$>>>0}var h=d.zero=new d(0,0);h.toNumber=function(){return 0},h.zzEncode=h.zzDecode=function(){return this},h.length=function(){return 1};var b=d.zeroHash="\0\0\0\0\0\0\0\0";d.fromNumber=function(st){if(st===0)return h;var $=st<0;$&&(st=-st);var it=st>>>0,g=(st-it)/4294967296>>>0;return $&&(g=~g>>>0,it=~it>>>0,++it>4294967295&&(it=0,++g>4294967295&&(g=0))),new d(it,g)},d.from=function(st){if(typeof st=="number")return d.fromNumber(st);if(a.isString(st)){if(!a.Long)return d.fromNumber(parseInt(st,10));st=a.Long.fromString(st)}return st.low||st.high?new d(st.low>>>0,st.high>>>0):h},d.prototype.toNumber=function(st){if(!st&&this.hi>>>31){var $=1+~this.lo>>>0,it=~this.hi>>>0;return $||(it=it+1>>>0),-($+4294967296*it)}return this.lo+4294967296*this.hi},d.prototype.toLong=function(st){return a.Long?new a.Long(0|this.lo,0|this.hi,!!st):{low:0|this.lo,high:0|this.hi,unsigned:!!st}};var et=String.prototype.charCodeAt;d.fromHash=function(st){return st===b?h:new d((et.call(st,0)|et.call(st,1)<<8|et.call(st,2)<<16|et.call(st,3)<<24)>>>0,(et.call(st,4)|et.call(st,5)<<8|et.call(st,6)<<16|et.call(st,7)<<24)>>>0)},d.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},d.prototype.zzEncode=function(){var st=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^st)>>>0,this.lo=(this.lo<<1^st)>>>0,this},d.prototype.zzDecode=function(){var st=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^st)>>>0,this.hi=(this.hi>>>1^st)>>>0,this},d.prototype.length=function(){var st=this.lo,$=(this.lo>>>28|this.hi<<4)>>>0,it=this.hi>>>24;return it===0?$===0?st<16384?st<128?1:2:st<2097152?3:4:$<16384?$<128?5:6:$<2097152?7:8:it<128?9:10}},9693:function(o,e,s){var a=e;function d(b,et,st){for(var $=Object.keys(et),it=0;it<$.length;++it)b[$[it]]!==void 0&&st||(b[$[it]]=et[$[it]]);return b}function h(b){function et(st,$){if(!(this instanceof et))return new et(st,$);Object.defineProperty(this,"message",{get:function(){return st}}),Error.captureStackTrace?Error.captureStackTrace(this,et):Object.defineProperty(this,"stack",{value:new Error().stack||""}),$&&d(this,$)}return(et.prototype=Object.create(Error.prototype)).constructor=et,Object.defineProperty(et.prototype,"name",{get:function(){return b}}),et.prototype.toString=function(){return this.name+": "+this.message},et}a.asPromise=s(4537),a.base64=s(7419),a.EventEmitter=s(9211),a.float=s(945),a.inquire=s(7199),a.utf8=s(4997),a.pool=s(6662),a.LongBits=s(1945),a.isNode=!!(s.g!==void 0&&s.g&&s.g.process&&s.g.process.versions&&s.g.process.versions.node),a.global=a.isNode&&s.g||typeof window<"u"&&window||typeof self<"u"&&self||this,a.emptyArray=Object.freeze?Object.freeze([]):[],a.emptyObject=Object.freeze?Object.freeze({}):{},a.isInteger=Number.isInteger||function(b){return typeof b=="number"&&isFinite(b)&&Math.floor(b)===b},a.isString=function(b){return typeof b=="string"||b instanceof String},a.isObject=function(b){return b&&typeof b=="object"},a.isset=a.isSet=function(b,et){var st=b[et];return!(st==null||!b.hasOwnProperty(et))&&(typeof st!="object"||(Array.isArray(st)?st.length:Object.keys(st).length)>0)},a.Buffer=function(){try{var b=a.inquire("buffer").Buffer;return b.prototype.utf8Write?b:null}catch{return null}}(),a._Buffer_from=null,a._Buffer_allocUnsafe=null,a.newBuffer=function(b){return typeof b=="number"?a.Buffer?a._Buffer_allocUnsafe(b):new a.Array(b):a.Buffer?a._Buffer_from(b):typeof Uint8Array>"u"?b:new Uint8Array(b)},a.Array=typeof Uint8Array<"u"?Uint8Array:Array,a.Long=a.global.dcodeIO&&a.global.dcodeIO.Long||a.global.Long||a.inquire("long"),a.key2Re=/^true|false|0|1$/,a.key32Re=/^-?(?:0|[1-9][0-9]*)$/,a.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,a.longToHash=function(b){return b?a.LongBits.from(b).toHash():a.LongBits.zeroHash},a.longFromHash=function(b,et){var st=a.LongBits.fromHash(b);return a.Long?a.Long.fromBits(st.lo,st.hi,et):st.toNumber(!!et)},a.merge=d,a.lcFirst=function(b){return b.charAt(0).toLowerCase()+b.substring(1)},a.newError=h,a.ProtocolError=h("ProtocolError"),a.oneOfGetter=function(b){for(var et={},st=0;st<b.length;++st)et[b[st]]=1;return function(){for(var $=Object.keys(this),it=$.length-1;it>-1;--it)if(et[$[it]]===1&&this[$[it]]!==void 0&&this[$[it]]!==null)return $[it]}},a.oneOfSetter=function(b){return function(et){for(var st=0;st<b.length;++st)b[st]!==et&&delete this[b[st]]}},a.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},a._configure=function(){var b=a.Buffer;b?(a._Buffer_from=b.from!==Uint8Array.from&&b.from||function(et,st){return new b(et,st)},a._Buffer_allocUnsafe=b.allocUnsafe||function(et){return new b(et)}):a._Buffer_from=a._Buffer_allocUnsafe=null}},1173:(o,e,s)=>{o.exports=g;var a,d=s(9693),h=d.LongBits,b=d.base64,et=d.utf8;function st(ft,ht,bt){this.fn=ft,this.len=ht,this.next=void 0,this.val=bt}function $(){}function it(ft){this.head=ft.head,this.tail=ft.tail,this.len=ft.len,this.next=ft.states}function g(){this.len=0,this.head=new st($,0,0),this.tail=this.head,this.states=null}var c=function(){return d.Buffer?function(){return(g.create=function(){return new a})()}:function(){return new g}};function _(ft,ht,bt){ht[bt]=255&ft}function ot(ft,ht){this.len=ft,this.next=void 0,this.val=ht}function ct(ft,ht,bt){for(;ft.hi;)ht[bt++]=127&ft.lo|128,ft.lo=(ft.lo>>>7|ft.hi<<25)>>>0,ft.hi>>>=7;for(;ft.lo>127;)ht[bt++]=127&ft.lo|128,ft.lo=ft.lo>>>7;ht[bt++]=ft.lo}function dt(ft,ht,bt){ht[bt]=255&ft,ht[bt+1]=ft>>>8&255,ht[bt+2]=ft>>>16&255,ht[bt+3]=ft>>>24}g.create=c(),g.alloc=function(ft){return new d.Array(ft)},d.Array!==Array&&(g.alloc=d.pool(g.alloc,d.Array.prototype.subarray)),g.prototype._push=function(ft,ht,bt){return this.tail=this.tail.next=new st(ft,ht,bt),this.len+=ht,this},ot.prototype=Object.create(st.prototype),ot.prototype.fn=function(ft,ht,bt){for(;ft>127;)ht[bt++]=127&ft|128,ft>>>=7;ht[bt]=ft},g.prototype.uint32=function(ft){return this.len+=(this.tail=this.tail.next=new ot((ft>>>=0)<128?1:ft<16384?2:ft<2097152?3:ft<268435456?4:5,ft)).len,this},g.prototype.int32=function(ft){return ft<0?this._push(ct,10,h.fromNumber(ft)):this.uint32(ft)},g.prototype.sint32=function(ft){return this.uint32((ft<<1^ft>>31)>>>0)},g.prototype.uint64=function(ft){var ht=h.from(ft);return this._push(ct,ht.length(),ht)},g.prototype.int64=g.prototype.uint64,g.prototype.sint64=function(ft){var ht=h.from(ft).zzEncode();return this._push(ct,ht.length(),ht)},g.prototype.bool=function(ft){return this._push(_,1,ft?1:0)},g.prototype.fixed32=function(ft){return this._push(dt,4,ft>>>0)},g.prototype.sfixed32=g.prototype.fixed32,g.prototype.fixed64=function(ft){var ht=h.from(ft);return this._push(dt,4,ht.lo)._push(dt,4,ht.hi)},g.prototype.sfixed64=g.prototype.fixed64,g.prototype.float=function(ft){return this._push(d.float.writeFloatLE,4,ft)},g.prototype.double=function(ft){return this._push(d.float.writeDoubleLE,8,ft)};var pt=d.Array.prototype.set?function(ft,ht,bt){ht.set(ft,bt)}:function(ft,ht,bt){for(var mt=0;mt<ft.length;++mt)ht[bt+mt]=ft[mt]};g.prototype.bytes=function(ft){var ht=ft.length>>>0;if(!ht)return this._push(_,1,0);if(d.isString(ft)){var bt=g.alloc(ht=b.length(ft));b.decode(ft,bt,0),ft=bt}return this.uint32(ht)._push(pt,ht,ft)},g.prototype.string=function(ft){var ht=et.length(ft);return ht?this.uint32(ht)._push(et.write,ht,ft):this._push(_,1,0)},g.prototype.fork=function(){return this.states=new it(this),this.head=this.tail=new st($,0,0),this.len=0,this},g.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new st($,0,0),this.len=0),this},g.prototype.ldelim=function(){var ft=this.head,ht=this.tail,bt=this.len;return this.reset().uint32(bt),bt&&(this.tail.next=ft.next,this.tail=ht,this.len+=bt),this},g.prototype.finish=function(){for(var ft=this.head.next,ht=this.constructor.alloc(this.len),bt=0;ft;)ft.fn(ft.val,ht,bt),bt+=ft.len,ft=ft.next;return ht},g._configure=function(ft){a=ft,g.create=c(),a._configure()}},3155:(o,e,s)=>{o.exports=h;var a=s(1173);(h.prototype=Object.create(a.prototype)).constructor=h;var d=s(9693);function h(){a.call(this)}function b(et,st,$){et.length<40?d.utf8.write(et,st,$):st.utf8Write?st.utf8Write(et,$):st.write(et,$)}h._configure=function(){h.alloc=d._Buffer_allocUnsafe,h.writeBytesBuffer=d.Buffer&&d.Buffer.prototype instanceof Uint8Array&&d.Buffer.prototype.set.name==="set"?function(et,st,$){st.set(et,$)}:function(et,st,$){if(et.copy)et.copy(st,$,0,et.length);else for(var it=0;it<et.length;)st[$++]=et[it++]}},h.prototype.bytes=function(et){d.isString(et)&&(et=d._Buffer_from(et,"base64"));var st=et.length>>>0;return this.uint32(st),st&&this._push(h.writeBytesBuffer,st,et),this},h.prototype.string=function(et){var st=d.Buffer.byteLength(et);return this.uint32(st),st&&this._push(b,st,et),this},h._configure()},7714:(o,e,s)=>{e.R=void 0;const a=s(6919),d=s(7448);e.R=new class{async init(){}async createSessionHandler(h,b){const et=new a.Session(b);return await et.loadModel(h),new d.OnnxjsSessionHandler(et)}}},4200:(o,e,s)=>{e.c8=e.rX=void 0;const a=s(1670),d=s(5381),h=s(2157),b=s(2306);e.rX=()=>{if((typeof a.env.wasm.initTimeout!="number"||a.env.wasm.initTimeout<0)&&(a.env.wasm.initTimeout=0),typeof a.env.wasm.simd!="boolean"&&(a.env.wasm.simd=!0),typeof a.env.wasm.proxy!="boolean"&&(a.env.wasm.proxy=!1),typeof a.env.wasm.numThreads!="number"||!Number.isInteger(a.env.wasm.numThreads)||a.env.wasm.numThreads<=0){const et=typeof navigator>"u"?(0,d.cpus)().length:navigator.hardwareConcurrency;a.env.wasm.numThreads=Math.min(4,Math.ceil((et||1)/2))}},e.c8=new class{async init(){(0,e.rX)(),await(0,h.initWasm)()}async createSessionHandler(et,st){const $=new b.OnnxruntimeWebAssemblySessionHandler;return await $.loadModel(et,st),Promise.resolve($)}}},6018:function(o,e,s){var a=this&&this.__createBinding||(Object.create?function(b,et,st,$){$===void 0&&($=st);var it=Object.getOwnPropertyDescriptor(et,st);it&&!("get"in it?!et.__esModule:it.writable||it.configurable)||(it={enumerable:!0,get:function(){return et[st]}}),Object.defineProperty(b,$,it)}:function(b,et,st,$){$===void 0&&($=st),b[$]=et[st]}),d=this&&this.__exportStar||function(b,et){for(var st in b)st==="default"||Object.prototype.hasOwnProperty.call(et,st)||a(et,b,st)};Object.defineProperty(e,"__esModule",{value:!0}),d(s(1670),e);const h=s(1670);{const b=s(7714).R;(0,h.registerBackend)("webgl",b,-10)}{const b=s(4200).c8;(0,h.registerBackend)("cpu",b,10),(0,h.registerBackend)("wasm",b,10),(0,h.registerBackend)("xnnpack",b,9)}},246:(o,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createAttributeWithCacheKey=void 0;class s{constructor(d){Object.assign(this,d)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(d=>`${this[d]}`).join(";")),this._cacheKey}}e.createAttributeWithCacheKey=a=>new s(a)},7778:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Attribute=void 0;const a=s(1446),d=s(9395),h=s(9162),b=s(2517);var et=d.onnxruntime.experimental.fbs;class st{constructor(it){if(this._attributes=new Map,it!=null){for(const g of it)g instanceof a.onnx.AttributeProto?this._attributes.set(g.name,[st.getValue(g),st.getType(g)]):g instanceof et.Attribute&&this._attributes.set(g.name(),[st.getValue(g),st.getType(g)]);if(this._attributes.size<it.length)throw new Error("duplicated attribute names")}}set(it,g,c){this._attributes.set(it,[c,g])}delete(it){this._attributes.delete(it)}getFloat(it,g){return this.get(it,"float",g)}getInt(it,g){return this.get(it,"int",g)}getString(it,g){return this.get(it,"string",g)}getTensor(it,g){return this.get(it,"tensor",g)}getFloats(it,g){return this.get(it,"floats",g)}getInts(it,g){return this.get(it,"ints",g)}getStrings(it,g){return this.get(it,"strings",g)}getTensors(it,g){return this.get(it,"tensors",g)}get(it,g,c){const _=this._attributes.get(it);if(_===void 0){if(c!==void 0)return c;throw new Error(`required attribute not found: ${it}`)}if(_[1]!==g)throw new Error(`type mismatch: expected ${g} but got ${_[1]}`);return _[0]}static getType(it){const g=it instanceof a.onnx.AttributeProto?it.type:it.type();switch(g){case a.onnx.AttributeProto.AttributeType.FLOAT:return"float";case a.onnx.AttributeProto.AttributeType.INT:return"int";case a.onnx.AttributeProto.AttributeType.STRING:return"string";case a.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case a.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case a.onnx.AttributeProto.AttributeType.INTS:return"ints";case a.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case a.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${a.onnx.AttributeProto.AttributeType[g]}`)}}static getValue(it){const g=it instanceof a.onnx.AttributeProto?it.type:it.type();if(g===a.onnx.AttributeProto.AttributeType.GRAPH||g===a.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const c=this.getValueNoCheck(it);if(g===a.onnx.AttributeProto.AttributeType.INT&&b.LongUtil.isLong(c))return b.LongUtil.longToNumber(c);if(g===a.onnx.AttributeProto.AttributeType.INTS){const _=c,ot=new Array(_.length);for(let ct=0;ct<_.length;ct++){const dt=_[ct];ot[ct]=b.LongUtil.longToNumber(dt)}return ot}if(g===a.onnx.AttributeProto.AttributeType.TENSOR)return it instanceof a.onnx.AttributeProto?h.Tensor.fromProto(c):h.Tensor.fromOrtTensor(c);if(g===a.onnx.AttributeProto.AttributeType.TENSORS){if(it instanceof a.onnx.AttributeProto)return c.map(_=>h.Tensor.fromProto(_));if(it instanceof et.Attribute)return c.map(_=>h.Tensor.fromOrtTensor(_))}if(g===a.onnx.AttributeProto.AttributeType.STRING&&it instanceof a.onnx.AttributeProto){const _=c;return(0,b.decodeUtf8String)(_)}return g===a.onnx.AttributeProto.AttributeType.STRINGS&&it instanceof a.onnx.AttributeProto?c.map(b.decodeUtf8String):c}static getValueNoCheck(it){return it instanceof a.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(it):this.getValueNoCheckFromOrtFormat(it)}static getValueNoCheckFromOnnxFormat(it){switch(it.type){case a.onnx.AttributeProto.AttributeType.FLOAT:return it.f;case a.onnx.AttributeProto.AttributeType.INT:return it.i;case a.onnx.AttributeProto.AttributeType.STRING:return it.s;case a.onnx.AttributeProto.AttributeType.TENSOR:return it.t;case a.onnx.AttributeProto.AttributeType.GRAPH:return it.g;case a.onnx.AttributeProto.AttributeType.FLOATS:return it.floats;case a.onnx.AttributeProto.AttributeType.INTS:return it.ints;case a.onnx.AttributeProto.AttributeType.STRINGS:return it.strings;case a.onnx.AttributeProto.AttributeType.TENSORS:return it.tensors;case a.onnx.AttributeProto.AttributeType.GRAPHS:return it.graphs;default:throw new Error(`unsupported attribute type: ${a.onnx.AttributeProto.AttributeType[it.type]}`)}}static getValueNoCheckFromOrtFormat(it){switch(it.type()){case et.AttributeType.FLOAT:return it.f();case et.AttributeType.INT:return it.i();case et.AttributeType.STRING:return it.s();case et.AttributeType.TENSOR:return it.t();case et.AttributeType.GRAPH:return it.g();case et.AttributeType.FLOATS:return it.floatsArray();case et.AttributeType.INTS:{const g=[];for(let c=0;c<it.intsLength();c++)g.push(it.ints(c));return g}case et.AttributeType.STRINGS:{const g=[];for(let c=0;c<it.stringsLength();c++)g.push(it.strings(c));return g}case et.AttributeType.TENSORS:{const g=[];for(let c=0;c<it.tensorsLength();c++)g.push(it.tensors(c));return g}default:throw new Error(`unsupported attribute type: ${et.AttributeType[it.type()]}`)}}}e.Attribute=st},7091:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.resolveBackend=e.backend=void 0;const a=s(5038),d=new Map;async function h(b){const et=e.backend;if(et[b]!==void 0&&function(st){const $=st;return"initialize"in $&&typeof $.initialize=="function"&&"createSessionHandler"in $&&typeof $.createSessionHandler=="function"&&"dispose"in $&&typeof $.dispose=="function"}(et[b])){const st=et[b];let $=st.initialize();if(typeof $=="object"&&"then"in $&&($=await $),$)return d.set(b,st),st}}e.backend={webgl:new a.WebGLBackend},e.resolveBackend=async function b(et){if(!et)return b(["webgl"]);{const st=typeof et=="string"?[et]:et;for(const $ of st){const it=d.get($);if(it)return it;const g=await h($);if(g)return g}}throw new Error("no available backend to use")}},5038:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLBackend=void 0;const a=s(1670),d=s(6231),h=s(6416),b=s(7305);e.WebGLBackend=class{get contextId(){return a.env.webgl.contextId}set contextId(et){a.env.webgl.contextId=et}get matmulMaxBatchSize(){return a.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(et){a.env.webgl.matmulMaxBatchSize=et}get textureCacheMode(){return a.env.webgl.textureCacheMode}set textureCacheMode(et){a.env.webgl.textureCacheMode=et}get pack(){return a.env.webgl.pack}set pack(et){a.env.webgl.pack=et}get async(){return a.env.webgl.async}set async(et){a.env.webgl.async=et}initialize(){try{return this.glContext=(0,b.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),d.Logger.setWithEnv(a.env),d.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(et){return d.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${et}`),!1}}createSessionHandler(et){return new h.WebGLSessionHandler(this,et)}dispose(){this.glContext.dispose()}}},5107:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.CoordsGlslLib=void 0;const a=s(2517),d=s(8520),h=s(5060),b=s(7859),et=s(9390);class st extends d.GlslLib{constructor(it){super(it)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new d.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new d.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const it=this.context.outputTextureLayout;return it.isPacked?this.getPackedOutputSamplingSnippet(it):this.getUnpackedOutputSamplingSnippet(it)}getPackedOutputSamplingSnippet(it){const g=it.unpackedShape,c=[it.width,it.height],_={},ot="getOutputCoords";switch(g.length){case 0:_[ot]=this.getOutputScalarCoords();break;case 1:_[ot]=this.getOutputPacked1DCoords(g,c);break;case 2:_[ot]=this.getOutputPacked2DCoords(g,c);break;case 3:_[ot]=this.getOutputPacked3DCoords(g,c);break;default:_[ot]=this.getOutputPackedNDCoords(g,c)}const ct=`
      void setOutput(vec4 val) {
        ${(0,h.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return _.floatTextureSetRGBA=new d.GlslLibRoutine(ct),_}getUnpackedOutputSamplingSnippet(it){const g=it.unpackedShape,c=[it.width,it.height],_={},ot="getOutputCoords";switch(g.length){case 0:_[ot]=this.getOutputScalarCoords();break;case 1:_[ot]=this.getOutputUnpacked1DCoords(g,c);break;case 2:_[ot]=this.getOutputUnpacked2DCoords(g,c);break;case 3:_[ot]=this.getOutputUnpacked3DCoords(g,c);break;case 4:_[ot]=this.getOutputUnpacked4DCoords(g,c);break;case 5:_[ot]=this.getOutputUnpacked5DCoords(g,c);break;case 6:_[ot]=this.getOutputUnpacked6DCoords(g,c);break;default:throw new Error(`Unsupported output dimensionality: ${g.length}`)}const ct=`
        void setOutput(float val) {
          ${(0,h.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return _.floatTextureSetR=new d.GlslLibRoutine(ct),_}getOutputScalarCoords(){return new d.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(it,g){const c=g;let _="";return c[0]===1?(_=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${c[1]}.0);
          }
        `,new d.GlslLibRoutine(_)):c[1]===1?(_=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${c[0]}.0);
          }
        `,new d.GlslLibRoutine(_)):(_=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${c[0]}, ${c[1]}));
          return 2 * (resTexRC.y * ${c[0]} + resTexRC.x);
        }
      `,new d.GlslLibRoutine(_))}getOutputPacked2DCoords(it,g){let c="";if(a.ArrayUtil.arraysEqual(it,g))return c=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${g[0]}, ${g[1]}));
        }
      `,new d.GlslLibRoutine(c);const _=g,ot=Math.ceil(it[1]/2);return c=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${_[0]}, ${_[1]}));

          int index = resTexRC.y * ${_[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${ot}) * 2;
          int c = 2 * (index / ${ot});

          return ivec2(r, c);
        }
      `,new d.GlslLibRoutine(c)}getOutputPacked3DCoords(it,g){const c=[g[0],g[1]],_=Math.ceil(it[2]/2),ot=_*Math.ceil(it[1]/2),ct=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${c[0]}, ${c[1]}));
          int index = resTexRC.y * ${c[0]} + resTexRC.x;

          int b = index / ${ot};
          index -= b * ${ot};

          // reverse r and c order for packed texture
          int r = imod(index, ${_}) * 2;
          int c = 2 * (index / ${_});

          return ivec3(b, r, c);
        }
      `;return new d.GlslLibRoutine(ct)}getOutputPackedNDCoords(it,g){const c=[g[0],g[1]],_=Math.ceil(it[it.length-1]/2),ot=_*Math.ceil(it[it.length-2]/2);let ct=ot,dt="",pt="b, r, c";for(let ht=2;ht<it.length-1;ht++)ct*=it[it.length-ht-1],dt=`
      int b${ht} = index / ${ct};
      index -= b${ht} * ${ct};
    `+dt,pt=`b${ht}, `+pt;const ft=`
      ivec${it.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${c[0]}, ${c[1]}));
        int index = resTexRC.y * ${c[0]} + resTexRC.x;

        ${dt}

        int b = index / ${ot};
        index -= b * ${ot};

        // reverse r and c order for packed texture
        int r = imod(index, ${_}) * 2;
        int c = 2 * (index / ${_});

        return ivec${it.length}(${pt});
      }
    `;return new d.GlslLibRoutine(ft)}getOutputUnpacked1DCoords(it,g){const c=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${g[0]}, ${g[1]}));
          return resTexRC.y * ${g[0]} + resTexRC.x;
        }
      `;return new d.GlslLibRoutine(c)}getOutputUnpacked2DCoords(it,g){const c=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${g[0]}, ${g[1]}));
          int index = resTexRC.y * ${g[0]} + resTexRC.x;
          int r = index / ${it[1]};
          int c = index - r * ${it[1]};
          return ivec2(r, c);
        }
      `;return new d.GlslLibRoutine(c)}getOutputUnpacked3DCoords(it,g){let c="";const _=it.length;let ot=null;_<2&&(ot=[]),ot=new Array(_-1),ot[_-2]=it[_-1];for(let pt=_-3;pt>=0;--pt)ot[pt]=ot[pt+1]*it[pt+1];const ct=["r","c","d"],dt=ot.map((pt,ft)=>`int ${ct[ft]} = index / ${pt}; ${ft===ot.length-1?`int ${ct[ft+1]} = index - ${ct[ft]} * ${pt}`:`index -= ${ct[ft]} * ${pt}`};`).join("");return c=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${g[0]}, ${g[1]}));
          int index = resTexRC.y * ${g[0]} + resTexRC.x;
          ${dt}
          return ivec3(r, c, d);
        }
      `,new d.GlslLibRoutine(c)}getOutputUnpacked4DCoords(it,g){let c="";const _=it.length;let ot=null;_<2&&(ot=[]),ot=new Array(_-1),ot[_-2]=it[_-1];for(let pt=_-3;pt>=0;--pt)ot[pt]=ot[pt+1]*it[pt+1];const ct=["r","c","d","d2"],dt=ot.map((pt,ft)=>`int ${ct[ft]} = index / ${pt}; ${ft===ot.length-1?`int ${ct[ft+1]} = index - ${ct[ft]} * ${pt}`:`index -= ${ct[ft]} * ${pt}`};`).join("");return c=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${g[0]}, ${g[1]}));
          int index = resTexRC.y * ${g[0]} + resTexRC.x;
          ${dt}
          return ivec4(r, c, d, d2);
        }
      `,new d.GlslLibRoutine(c)}getOutputUnpacked5DCoords(it,g){let c="";const _=it.length;let ot=null;_<2&&(ot=[]),ot=new Array(_-1),ot[_-2]=it[_-1];for(let pt=_-3;pt>=0;--pt)ot[pt]=ot[pt+1]*it[pt+1];const ct=["r","c","d","d2","d3"],dt=ot.map((pt,ft)=>`int ${ct[ft]} = index / ${pt}; ${ft===ot.length-1?`int ${ct[ft+1]} = index - ${ct[ft]} * ${pt}`:`index -= ${ct[ft]} * ${pt}`};`).join("");return c=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${g[0]}, ${g[1]}));
          int index = resTexRC.y * ${g[0]} + resTexRC.x;
          ${dt}
          return ivec5(r, c, d, d2, d3);
        }
      `,new d.GlslLibRoutine(c)}getOutputUnpacked6DCoords(it,g){let c="";const _=it.length;let ot=null;_<2&&(ot=[]),ot=new Array(_-1),ot[_-2]=it[_-1];for(let pt=_-3;pt>=0;--pt)ot[pt]=ot[pt+1]*it[pt+1];const ct=["r","c","d","d2","d3","d4"],dt=ot.map((pt,ft)=>`int ${ct[ft]} = index / ${pt}; ${ft===ot.length-1?`int ${ct[ft+1]} = index - ${ct[ft]} * ${pt}`:`index -= ${ct[ft]} * ${pt}`};`).join("");return c=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${g[0]}, ${g[1]}));
         int index = resTexRC.y * ${g[0]} + resTexRC.x;
         ${dt}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new d.GlslLibRoutine(c)}getCommonUtilFuncs(){const it={};let g="uvFromFlat";it[g]=new d.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),g="packedUVfrom1D",it[g]=new d.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),g="packedUVfrom2D",it[g]=new d.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),g="packedUVfrom3D",it[g]=new d.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),g="sampleTexture";const c=(0,h.getGlsl)(this.context.glContext.version);return it[g]=new d.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${c.texture2D}(textureSampler, uv).r;
        }`),it}getInputsSamplingSnippets(){const it={},g=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((c,_)=>{const ot=this.context.inputTextureLayouts[_],ct=(0,et.generateShaderFuncNameFromInputSamplerName)(c);ot.isPacked?it[ct]=this.getPackedSamplerFromInput(ct,c,ot):it[ct]=this.getUnpackedSamplerFromInput(ct,c,ot);const dt=(0,et.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(c);ot.unpackedShape.length<=g.unpackedShape.length&&(ot.isPacked?it[dt]=this.getPackedSamplerAtOutputCoords(dt,ot,g,c):it[dt]=this.getUnpackedSamplerAtOutputCoords(dt,ot,g,c))}),it}getPackedSamplerAtOutputCoords(it,g,c,_){const ot=g.unpackedShape,ct=c.unpackedShape,dt=_,pt=(0,et.generateShaderFuncNameFromInputSamplerName)(dt),ft=ot.length,ht=ct.length,bt=a.BroadcastUtil.getBroadcastDims(ot,ct),mt=(0,et.getCoordsDataType)(ht),$t=ht-ft;let Tt;const Nt=(0,et.getGlChannels)();Tt=ft===0?"":ht<2&&bt.length>=1?"coords = 0;":bt.map(pn=>`coords.${Nt[pn+$t]} = 0;`).join(`
`);let Ct="";Ct=ht<2&&ft>0?"coords":ot.map((pn,Ht)=>`coords.${Nt[Ht+$t]}`).join(", ");let Ft="return outputValue;";const ln=a.ShapeUtil.size(ot)===1,mn=a.ShapeUtil.size(ct)===1;if(ft!==1||ln||mn){if(ln&&!mn)Ft=ht===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(bt.length){const pn=ft-2,Ht=ft-1;bt.indexOf(pn)>-1&&bt.indexOf(Ht)>-1?Ft="return vec4(outputValue.x);":bt.indexOf(pn)>-1?Ft="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":bt.indexOf(Ht)>-1&&(Ft="return vec4(outputValue.xx, outputValue.zz);")}}else Ft=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const yn=`
      vec4 ${it}() {
        ${mt} coords = getOutputCoords();
        
        int lastDim = coords.${Nt[ht-1]};
        coords.${Nt[ht-1]} = coords.${Nt[ht-2]};
        coords.${Nt[ht-2]} = lastDim;
      
        ${Tt}
        vec4 outputValue = ${pt}(${Ct});
        ${Ft}
      }
    `;return new d.GlslLibRoutine(yn,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(it,g,c,_){const ot=[c.width,c.height],ct=[g.width,g.height],dt=g.unpackedShape.length,pt=c.unpackedShape.length,ft=g.unpackedShape,ht=c.unpackedShape,bt=(0,et.generateShaderFuncNameFromInputSamplerName)(_);if(dt===pt&&a.ArrayUtil.arraysEqual(ct,ot)){const mn=`
          float ${it}() {
            return sampleTexture(${_}, TexCoords);
          }
        `;return new d.GlslLibRoutine(mn,["coordinates.sampleTexture"])}const mt=(0,et.getCoordsDataType)(pt),$t=a.BroadcastUtil.getBroadcastDims(ft,ht),Tt=pt-dt;let Nt;const Ct=(0,et.getGlChannels)();Nt=dt===0?"":pt<2&&$t.length>=1?"coords = 0;":$t.map(mn=>`coords.${Ct[mn+Tt]} = 0;`).join(`
`);let Ft="";Ft=pt<2&&dt>0?"coords":g.unpackedShape.map((mn,yn)=>`coords.${Ct[yn+Tt]}`).join(", ");const ln=`
        float ${it}() {
          ${mt} coords = getOutputCoords();
          ${Nt}
          return ${bt}(${Ft});
        }
      `;return new d.GlslLibRoutine(ln,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(it,g,c){switch(c.unpackedShape.length){case 0:return this.getPackedSamplerScalar(it,g);case 1:return this.getPackedSampler1D(it,g,c);case 2:return this.getPackedSampler2D(it,g,c);case 3:return this.getPackedSampler3D(it,g,c);default:return this.getPackedSamplerND(it,g,c)}}getUnpackedSamplerFromInput(it,g,c){const _=c.unpackedShape;switch(_.length){case 0:return this.getUnpackedSamplerScalar(it,g,c);case 1:return this.getUnpackedSampler1D(it,g,c);case 2:return this.getUnpackedSampler2D(it,g,c);case 3:return this.getUnpackedSampler3D(it,g,c);case 4:return this.getUnpackedSampler4D(it,g,c);case 5:return this.getUnpackedSampler5D(it,g,c);case 6:return this.getUnpackedSampler6D(it,g,c);default:throw new Error(`Unsupported dimension ${_.length}-D`)}}getPackedSamplerScalar(it,g){const c=`
          vec4 ${it}() {
            return ${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${g}, halfCR);
          }
        `;return new d.GlslLibRoutine(c)}getPackedSampler1D(it,g,c){const _=[c.width,c.height],ot=[_[1],_[0]],ct=(0,h.getGlsl)(this.context.glContext.version),dt=`vec4 ${it}(int index) {
      vec2 uv = packedUVfrom1D(
      ${ot[0]}, ${ot[1]}, index);
      return ${ct.texture2D}(${g}, uv);
    }`;return new d.GlslLibRoutine(dt,["coordinates.packedUVfrom1D"])}getPackedSampler2D(it,g,c){const _=c.unpackedShape,ot=[c.width,c.height],ct=(0,h.getGlsl)(this.context.glContext.version),dt=ot[0],pt=ot[1];if(ot!=null&&a.ArrayUtil.arraysEqual(_,ot)){const mt=`vec4 ${it}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${pt}.0, ${dt}.0);
        return ${ct.texture2D}(${g}, uv);
      }`;return new d.GlslLibRoutine(mt)}const ft=ot,ht=Math.ceil(_[1]/2),bt=`vec4 ${it}(int row, int col) {
      vec2 uv = packedUVfrom2D(${ft[1]}, ${ft[0]}, ${ht}, row, col);
      return ${ct.texture2D}(${g}, uv);
    }`;return new d.GlslLibRoutine(bt,["coordinates.packedUVfrom2D"])}getPackedSampler3D(it,g,c){const _=c.unpackedShape,ot=[c.width,c.height],ct=[ot[0],ot[1]],dt=(0,h.getGlsl)(this.context.glContext.version);if(_[0]===1){const mt=_.slice(1),$t=[1,2],Tt=(0,et.squeezeInputShape)(_,mt),Nt=["b","row","col"],Ct=JSON.parse(JSON.stringify(c));Ct.unpackedShape=Tt;const Ft=this.getPackedSamplerFromInput(it,g,Ct),ln=`${Ft.routineBody}
      vec4 ${it}(int b, int row, int col) {
        return ${it}(${(0,et.getSqueezedParams)(Nt,$t)});
      } `;return new d.GlslLibRoutine(ln,Ft.dependencies)}const pt=ct[0],ft=ct[1],ht=Math.ceil(_[2]/2),bt=`vec4 ${it}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${ft}, ${pt}, ${ht*Math.ceil(_[1]/2)}, ${ht}, b, row, col);
      return ${dt.texture2D}(${g}, uv);}`;return new d.GlslLibRoutine(bt,["coordinates.packedUVfrom3D"])}getPackedSamplerND(it,g,c){const _=c.unpackedShape,ot=_.length,ct=[c.width,c.height],dt=(0,h.getGlsl)(this.context.glContext.version),pt=[ct[0],ct[1]],ft=pt[1],ht=pt[0],bt=Math.ceil(_[ot-1]/2);let mt=bt*Math.ceil(_[ot-2]/2),$t="int b, int row, int col",Tt=`b * ${mt} + (row / 2) * ${bt} + (col / 2)`;for(let Ct=2;Ct<ot-1;Ct++)$t=`int b${Ct}, `+$t,mt*=_[ot-Ct-1],Tt=`b${Ct} * ${mt} + `+Tt;const Nt=`vec4 ${it}(${$t}) {
      int index = ${Tt};
      int texR = index / ${ht};
      int texC = index - texR * ${ht};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${ht}, ${ft});
      return ${dt.texture2D}(${g}, uv);
    }`;return new d.GlslLibRoutine(Nt)}getUnpackedSamplerScalar(it,g,c){const[_,ot]=[c.width,c.height];if(_===1&&ot===1){const dt=`
          float ${it}() {
            return sampleTexture(${g}, halfCR);
          }
        `;return new d.GlslLibRoutine(dt,["coordinates.sampleTexture"])}const ct=`
        float ${it}() {
          int offset_${g} = coordsToOffset(TexCoords, ${_}, ${ot});
          vec2 uv = uvFromFlat(${_}, ${ot}, offset_${g});
          return sampleTexture(${g}, uv);
        }
      `;return new d.GlslLibRoutine(ct,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(it,g,c){const _=c.width,ot=c.height;if(ot===1&&_===1){const dt=`
        float ${it}(int index) {
          return sampleTexture(${g}, halfCR);
        }
      `;return new d.GlslLibRoutine(dt,["coordinates.sampleTexture"])}if(ot===1){const dt=`
          float ${it}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${_}.0, 0.5);
            return sampleTexture(${g}, uv);
          }
        `;return new d.GlslLibRoutine(dt,["coordinates.sampleTexture"])}if(_===1){const dt=`
          float ${it}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${ot}.0);
            return sampleTexture(${g}, uv);
          }
        `;return new d.GlslLibRoutine(dt,["coordinates.sampleTexture"])}const ct=`
        float ${it}(int index) {
          vec2 uv = uvFromFlat(${_}, ${ot}, index);
          return sampleTexture(${g}, uv);
        }
      `;return new d.GlslLibRoutine(ct,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(it,g,c){const _=c.unpackedShape,ot=[c.height,c.width];if(ot!=null&&a.ArrayUtil.arraysEqual(_,ot)){const mt=`
          float ${it}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${ot[1]}.0, ${ot[0]}.0);
            return sampleTexture(${g}, uv);
          }
        `;return new d.GlslLibRoutine(mt,["coordinates.sampleTexture"])}const{newShape:ct,keptDims:dt}=(0,b.squeezeShape)(_),pt=ct;if(pt.length<_.length){const mt=(0,et.squeezeInputShape)(_,pt),$t=JSON.parse(JSON.stringify(c));$t.unpackedShape=mt;const Tt=["col","row"],Nt=`
          ${this.getUnpackedSamplerFromInput(it,g,$t).routineBody}
          float ${it}(int row, int col) {
            return ${it}(${(0,et.getSqueezedParams)(Tt,dt)});
          }
        `;return new d.GlslLibRoutine(Nt,["coordinates.sampleTexture"])}const ft=ot[1],ht=ot[0];if(ht===1){const mt=`
          float ${it}(int row, int col) {
            int offset_${g} = coordsToOffset(TexCoords, ${ft}, ${ht});
            float index = dot(vec3(row, col, offset_${g}), vec3(${_[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${ft}.0);
            return sampleTexture(${g}, uv);
          }
        `;return new d.GlslLibRoutine(mt,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(ft===1){const mt=`
          float ${it}(int row, int col) {
            int offset_${g} = coordsToOffset(TexCoords, ${ft}, ${ht});
            float index = dot(vec3(row, col, offset_${g}), vec3(${_[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${ht}.0, 0.5);
            return sampleTexture(${g}, uv);
          }
        `;return new d.GlslLibRoutine(mt,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const bt=`
        float ${it}(int row, int col) {
          int index = col * ${_[1]} + row;
          vec2 uv = uvFromFlat(${ft}, ${ht}, index);
          return sampleTexture(${g}, uv);
        }
      `;return new d.GlslLibRoutine(bt,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(it,g,c){const _=c.unpackedShape,ot=_[1]*_[2],ct=_[2],{newShape:dt,keptDims:pt}=(0,b.squeezeShape)(_),ft=dt;if(ft.length<_.length){const bt=(0,et.squeezeInputShape)(_,ft),mt=["batch","col","row"],$t=JSON.parse(JSON.stringify(c));$t.unpackedShape=bt;const Tt=this.getUnpackedSamplerFromInput(it,g,$t),Nt=pt.reverse(),Ct=`
          ${Tt.routineBody}
          float ${it}(int batch, int row, int col) {
            return ${it}(${(0,et.getSqueezedParams)(mt,Nt)});
          }
        `;return new d.GlslLibRoutine(Ct,Tt.dependencies)}const ht=`
          float ${it}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${ot} + col * ${ct} + row;
            vec2 uv = uvFromFlat(${c.width}, ${c.height}, index);
            return sampleTexture(${g}, uv);
          }
      `;return new d.GlslLibRoutine(ht,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(it,g,c){const _=c.unpackedShape,ot=_[3],ct=_[2]*ot,dt=`
        float ${it}(int row, int col, int depth, int depth2) {
          int index = row * ${_[1]*ct} + col * ${ct} +
              depth2 * ${ot} + depth;
          vec2 uv = uvFromFlat(${c.width}, ${c.height}, index);
          return sampleTexture(${g}, uv);
        }
      `;return new d.GlslLibRoutine(dt,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(it,g,c){const _=c.unpackedShape,ot=_[4],ct=_[3]*ot,dt=_[2]*ct,pt=_[1]*dt,{newShape:ft,keptDims:ht}=(0,b.squeezeShape)(_);if(ft.length<_.length){const mt=(0,et.squeezeInputShape)(_,ft),$t=["row","col","depth","depth2","depth3"],Tt=JSON.parse(JSON.stringify(c));Tt.unpackedShape=mt;const Nt=`
          ${this.getUnpackedSamplerFromInput(it,g,Tt).routineBody}
          float ${it}(int row, int col, int depth, int depth2, int depth3) {
            return ${it}(${(0,et.getSqueezedParams)($t,ht)});
          }
        `;return new d.GlslLibRoutine(Nt,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const bt=`
        float ${it}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${pt} + col * ${dt} + depth * ${ct} +
          depth3 * ${ot} + depth2;
          vec2 uv = uvFromFlat(${c.width}, ${c.height}, index);
          return sampleTexture(${g}, uv);
        }
      `;return new d.GlslLibRoutine(bt,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(it,g,c){const _=c.unpackedShape,ot=_[5],ct=_[4]*ot,dt=_[3]*ct,pt=_[2]*dt,ft=_[1]*pt,{newShape:ht,keptDims:bt}=(0,b.squeezeShape)(_);if(ht.length<_.length){const $t=(0,et.squeezeInputShape)(_,ht),Tt=["row","col","depth","depth2","depth3","depth4"],Nt=JSON.parse(JSON.stringify(c));Nt.unpackedShape=$t;const Ct=`
            ${this.getUnpackedSamplerFromInput(it,g,Nt).routineBody}
            float ${it}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${it}(${(0,et.getSqueezedParams)(Tt,bt)});
            }
          `;return new d.GlslLibRoutine(Ct,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const mt=`
          float ${it}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${ft} + col * ${pt} + depth * ${dt} +
            depth2 * ${ct} + depth3 * ${ot} + depth4;
            vec2 uv = uvFromFlat(${c.width}, ${c.height}, index);
            return sampleTexture(${g}, uv);
          }
        `;return new d.GlslLibRoutine(mt,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const it=this.context.outputTextureLayout,g=it.shape.length,c=it.strides,_=it.width,ot=it.height,ct=[];for(let pt=0;pt<g-1;++pt)ct.push(`
        c[${pt}] = offset / ${c[pt]};`),ct.push(`
        offset -= c[${pt}] * ${c[pt]};`);ct.push(`
        c[${g-1}] = offset;`);const dt=`
      void toVec(vec2 texCoords, out int c[${g}]) {
        int offset = coordsToOffset(texCoords, ${_}, ${ot});
        ${ct.join("")}
      }
      void toVec(int offset, out int c[${g}]) {
        ${ct.join("")}
      }
    `;return{toVec:new d.GlslLibRoutine(dt,["coordinates.coordsToOffset"])}}valueFrom(){const it={};return this.context.programInfo.inputNames.forEach((g,c)=>{const _=this.context.inputTextureLayouts[c],ot=(_.unpackedShape.length>0?_.unpackedShape:_.shape).length;let ct=`_${g}`;it[ct]=new d.GlslLibRoutine(this.getValueFromSingle(g,ot,_.width,_.height,!1),[`shapeUtils.indicesToOffset${ct}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),ct+="_T",it[ct]=new d.GlslLibRoutine(this.getValueFromSingle(g,ot,_.width,_.height,!0),[`shapeUtils.indicesToOffset${ct}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),it}getValueFromSingle(it,g,c,_,ot){let ct=`_${it}`;return ot&&(ct+="_T"),`
        float ${ct}(int m[${g}]) {
          int offset = indicesToOffset${ct}(m);
          vec2 coords = offsetToCoords(offset, ${c}, ${_});
          float value = getColorAsFloat(${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${it}, coords));
          return value;
        }
        `}getPackedValueFrom(it,g,c,_,ot){let ct=`_${it}_Pack`;return ot&&(ct+="_T"),`
        vec4 ${ct}(int m[${g}]) {
          int offset = indicesToOffset_${it}(m);
          vec2 coords = offsetToCoords(offset, ${c}, ${_});
          return ${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${it}, coords);
        }
        `}}e.CoordsGlslLib=st},8520:(o,e)=>{var s;Object.defineProperty(e,"__esModule",{value:!0}),e.TopologicalSortGlslRoutines=e.GlslLibRoutineNode=e.GlslLibRoutine=e.GlslLib=e.GlslContext=e.FunctionType=void 0,(s=e.FunctionType||(e.FunctionType={}))[s.ValueBased=0]="ValueBased",s[s.Positional=1]="Positional",e.GlslContext=class{constructor(a,d,h,b){this.glContext=a,this.programInfo=d,this.inputTextureLayouts=h,this.outputTextureLayout=b}},e.GlslLib=class{constructor(a){this.context=a}},e.GlslLibRoutine=class{constructor(a,d){this.routineBody=a,this.dependencies=d}},e.GlslLibRoutineNode=class{constructor(a,d,h){this.name=a,this.dependencies=h||[],d&&(this.routineBody=d)}addDependency(a){a&&this.dependencies.push(a)}},e.TopologicalSortGlslRoutines=class{static returnOrderedNodes(a){if(!a||a.length===0)return[];if(a.length===1)return a;const d=new Set,h=new Set,b=new Array;return this.createOrderedNodes(a,d,h,b),b}static createOrderedNodes(a,d,h,b){for(let et=0;et<a.length;++et)this.dfsTraverse(a[et],d,h,b)}static dfsTraverse(a,d,h,b){if(!a||h.has(a.name))return;if(d.has(a.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");d.add(a.name);const et=a.dependencies;if(et&&et.length>0)for(let st=0;st<et.length;++st)this.dfsTraverse(et[st],d,h,b);b.push(a),h.add(a.name),d.delete(a.name)}}},7341:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.EncodingGlslLib=void 0;const a=s(8520);class d extends a.GlslLib{constructor(b){super(b)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new a.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new a.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const b=d.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new a.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${b}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const b=d.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new a.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${b}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const b=new ArrayBuffer(4),et=new Uint32Array(b),st=new Uint8Array(b);if(et[0]=3735928559,st[0]===239)return!0;if(st[0]===222)return!1;throw new Error("unknown endianness")}}e.EncodingGlslLib=d},9894:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.FragColorGlslLib=void 0;const a=s(8520),d=s(5060);class h extends a.GlslLib{constructor(et){super(et)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const et=(0,d.getGlsl)(this.context.glContext.version);return{setFragColor:new a.GlslLibRoutine(`
        void setFragColor(float value) {
            ${et.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new a.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}e.FragColorGlslLib=h},2848:(o,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.replaceInlines=void 0;const s=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;e.replaceInlines=function(a){const d={};let h;for(;(h=s.exec(a))!==null;){const b=h[3].split(",").map(et=>{const st=et.trim().split(" ");return st&&st.length===2?{type:st[0],name:st[1]}:null}).filter(et=>et!==null);d[h[2]]={params:b,body:h[4]}}for(const b in d){const et="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",b),st=new RegExp(et,"gm");for(;(h=st.exec(a))!==null;){const $=h[1],it=h[2],g=h[3].split(","),c=$?`${$} ${it};`:"";let _=d[b].body,ot="";d[b].params.forEach((dt,pt)=>{dt&&(ot+=`${dt.type} ${dt.name} = ${g[pt]};
`)}),_=`${ot}
 ${_}`,_=_.replace("return",`${it} = `);const ct=`
      ${c}
      {
        ${_}
      }
      `;a=a.replace(h[0],ct)}}return a.replace(s,"")}},8879:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.GlslPreprocessor=void 0;const a=s(8520),d=s(2848),h=s(5483),b=s(5060);e.GlslPreprocessor=class{constructor(et,st,$,it){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new a.GlslContext(et,st,$,it),Object.keys(h.glslRegistry).forEach(c=>{const _=new h.glslRegistry[c](this.context);this.libs[c]=_});const g=this.glslLibRoutineDependencyGraph;for(const c in this.libs){const _=this.libs[c].getFunctions();for(const ot in _){const ct=c+"."+ot;let dt;g[ct]?(dt=g[ct],dt.routineBody=_[ot].routineBody):(dt=new a.GlslLibRoutineNode(ct,_[ot].routineBody),g[ct]=dt);const pt=_[ot].dependencies;if(pt)for(let ft=0;ft<pt.length;++ft)if(g[pt[ft]])dt.addDependency(g[pt[ft]]);else{const ht=new a.GlslLibRoutineNode(pt[ft]);g[pt[ft]]=ht,dt.addDependency(ht)}}}}preprocess(){const et=this.context.programInfo;let st=et.shaderSource;return this.context.programInfo.hasMain||(st=`${st}
      ${(0,b.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),st=(0,d.replaceInlines)(st),`${(0,b.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(et.inputNames,et.variables)}
    ${this.getImports(st)}
    ${st}`}getImports(et){const st=this.selectGlslLibRoutinesToBeIncluded(et);if(st.length===0)return"";let $="";for(let it=0;it<st.length;++it){if(!st[it].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${st[it].name}`);$+=st[it].routineBody+`
`}return $}selectGlslLibRoutinesToBeIncluded(et){const st=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach($=>{const it=$.split(".")[1];et.indexOf(it)!==-1&&st.push(this.glslLibRoutineDependencyGraph[$])}),a.TopologicalSortGlslRoutines.returnOrderedNodes(st)}getUniforms(et,st){const $=[];if(et)for(const it of et)$.push(`uniform sampler2D ${it};`);if(st)for(const it of st)$.push(`uniform ${it.type} ${it.name}${it.arrayLength?`[${it.arrayLength}]`:""};`);return $.join(`
`)}}},5483:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.glslRegistry=void 0;const a=s(5107),d=s(7341),h=s(9894),b=s(2655),et=s(3891);e.glslRegistry={encoding:d.EncodingGlslLib,fragcolor:h.FragColorGlslLib,vec:et.VecGlslLib,shapeUtils:b.ShapeUtilsGlslLib,coordinates:a.CoordsGlslLib}},2655:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ShapeUtilsGlslLib=void 0;const a=s(8520);class d extends a.GlslLib{constructor(b){super(b)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const b=this.context.outputTextureLayout.shape.length,et={};return this.context.programInfo.inputNames.forEach((st,$)=>{const it=this.context.inputTextureLayouts[$].unpackedShape;if(it.length<=b){const g=it.length,c=b-g,_=`bcastIndices_${st}`;let ot="";for(let dt=0;dt<g;++dt)ot+=`
          realIndices[${dt}] = int( mod(float(bcastedIndices[${c+dt}]), ${it[dt]}.0) );
          `;const ct=`
        void ${_} (int bcastedIndices[${b}], out int realIndices[${g}]) {
          ${ot}
        }
        `;et[_]=new a.GlslLibRoutine(ct)}}),et}bcastMatmulIndex(){const b=this.context.outputTextureLayout.shape.length,et={};return this.context.programInfo.inputNames.forEach((st,$)=>{const it=this.context.inputTextureLayouts[$].shape;if(!(it.length<2||it.length>b)){const g=it.length,c=b-g,_=`bcastMatmulIndices_${st}`;let ot="";for(let dt=0;dt<g-2;++dt)ot+=`
          realIndices[${dt}] = int( mod(float(bcastedIndices[${c+dt}]), ${it[dt]}.0) );
          `;const ct=`
        void ${_}(int bcastedIndices[${b}], out int realIndices[${g}]) {
          ${ot}
          realIndices[${g-1}] = bcastedIndices[${b-1}];
          realIndices[${g-2}] = bcastedIndices[${b-2}];
        }
        `;et[_]=new a.GlslLibRoutine(ct)}}),et}indicesToOffset(){const b={};return this.context.programInfo.inputNames.forEach((et,st)=>{const $=this.context.inputTextureLayouts[st].shape,it=this.context.inputTextureLayouts[st].strides,g=$.length;let c=`indicesToOffset_${et}`;b[c]=new a.GlslLibRoutine(d.indexToOffsetSingle(c,g,it)),c=`indicesToOffset_${et}_T`,b[c]=new a.GlslLibRoutine(d.indexToOffsetSingle(c,g,it.slice().reverse()))}),b}static indexToOffsetSingle(b,et,st){let $="";for(let it=et-1;it>=0;--it)$+=`
        offset += indices[${it}] * ${st[it]};
        `;return`
      int ${b}(int indices[${et}]) {
        int offset = 0;
        ${$}
        return offset;
      }
      `}offsetToIndices(){const b={};return this.context.programInfo.inputNames.forEach((et,st)=>{const $=this.context.inputTextureLayouts[st].shape,it=this.context.inputTextureLayouts[st].strides,g=$.length;let c=`offsetToIndices_${et}`;b[c]=new a.GlslLibRoutine(d.offsetToIndicesSingle(c,g,it)),c=`offsetToIndices_${et}_T`,b[c]=new a.GlslLibRoutine(d.offsetToIndicesSingle(c,g,it.slice().reverse()))}),b}static offsetToIndicesSingle(b,et,st){const $=[];for(let it=0;it<et-1;++it)$.push(`
      indices[${it}] = offset / ${st[it]};`),$.push(`
        offset -= indices[${it}] * ${st[it]};`);return $.push(`
      indices[${et-1}] = offset;`),`
      void ${b}(int offset, out int indices[${et}]) {
        ${$.join("")}
      }
      `}incrementIndices(){const b={};return this.context.programInfo.inputNames.forEach((et,st)=>{const $=this.context.inputTextureLayouts[st].shape,it=$.length,g=`incrementIndices_${et}`;let c="";for(let ot=0;ot<it;++ot)c+=`
        shape[${ot}] = ${$[ot]};`;const _=`
        void ${g}(int axis, out int indices[${it}]) {
          int shape[${it}];
          ${c};
          for(int i = ${it} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;b[g]=new a.GlslLibRoutine(_)}),b}}e.ShapeUtilsGlslLib=d},5060:(o,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getDefaultFragShaderMain=e.getFragShaderPreamble=e.getVertexShaderSource=e.getGlsl=void 0;const s={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},a={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function d(h){return h===1?s:a}e.getGlsl=d,e.getVertexShaderSource=function(h){const b=d(h);return`${b.version}
      precision highp float;
      ${b.attribute} vec3 position;
      ${b.attribute} vec2 textureCoord;

      ${b.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},e.getFragShaderPreamble=function(h){const b=d(h);return`${b.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${b.varyingFrag} vec2 TexCoords;
    ${b.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},e.getDefaultFragShaderMain=function(h,b){return`
  void main() {
    int indices[${b}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${d(h).output} = result;
  }
  `}},3891:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.VecGlslLib=void 0;const a=s(8520);class d extends a.GlslLib{constructor(b){super(b)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const b=this.context.outputTextureLayout.shape.length,et={add:"+=",sub:"-=",mul:"*=",div:"/="},st={};for(const $ in et){const it=`${$}Vec`;let g="";for(let _=0;_<b;++_)g+=`
          dest[${_}] ${et[$]} src[${_}];
          `;const c=`
        void ${it}(int src[${b}], out int dest[${b}]) {
          ${g}
        }
        `;st[it]=new a.GlslLibRoutine(c)}return st}copyVec(){const b=this.context.outputTextureLayout.shape.length;let et="";for(let $=0;$<b;++$)et+=`
        dest[${$}] = src[${$}];
        `;const st=`
      void copyVec(int src[${b}], out int dest[${b}]) {
        ${et}
      }
      `;return{copyVec:new a.GlslLibRoutine(st)}}setVecItem(){const b=this.context.outputTextureLayout.shape.length;let et=`
        if(index < 0)
            index =${b} + index;
        if (index == 0)
            m[0] = value;
        `;for(let $=1;$<b-1;++$)et+=`
        else if (index == ${$})
            m[${$}] = value;
            `;et+=`
        else
            m[${b-1}] = value;
        `;const st=`
      void setVecItem(out int m[${b}], int index, int value) {
        ${et}
      }
        `;return{setVecItem:new a.GlslLibRoutine(st)}}getVecItem(){const b=this.context.outputTextureLayout.shape.length;let et=`
        if(index < 0)
            index = ${b} + index;
        if (index == 0)
            return m[0];
      `;for(let $=1;$<b-1;++$)et+=`
        else if (index == ${$})
            return m[${$}];
      `;et+=`
        else
            return m[${b-1}];
        `;const st=`
      int getVecItem(int m[${b}], int index) {
        ${et}
      }
    `;return{getVecItem:new a.GlslLibRoutine(st)}}}e.VecGlslLib=d},8316:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLInferenceHandler=void 0;const a=s(6231),d=s(9162),h=s(2517),b=s(2403),et=s(7019),st=s(8710),$=s(5611),it=s(4057),g=s(2039);e.WebGLInferenceHandler=class{constructor(c){this.session=c,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(c,_){return(0,it.calculateTextureWidthAndHeight)(this.session.layoutStrategy,c,_)}executeProgram(c,_){if(_.length<c.inputNames.length)throw new Error(`Input size mustn't be less than ${c.inputNames.length}.`);if(c.inputNames.length!==c.inputTypes.length)throw new Error("input names size does not match input types");const ot=[];for(let bt=0;bt<c.inputNames.length;++bt)ot[bt]=this.getOrCreateTextureData(_[bt],c.inputTypes[bt]);const ct=((bt,mt)=>{const $t=mt.map(Nt=>`${Nt.unpackedShape.join(",")};${Nt.width}x${Nt.height}`).join("_");let Tt=bt.name;return bt.cacheHint&&(Tt+="["+bt.cacheHint+"]"),Tt+=":"+$t,Tt})(c,ot);let dt=this.session.programManager.getArtifact(ct);const pt=dt?dt.programInfo:typeof c.get=="function"?c.get():c,ft=(0,it.createTextureLayoutFromTextureType)(this.session.layoutStrategy,pt.output.dims,pt.output.textureType),ht=this.createTextureData(ft,pt.output.type);return dt||(dt=this.session.programManager.build(pt,ot,ht),this.session.programManager.setArtifact(ct,dt)),this.runProgram(dt,ot,ht),ht}run(c,_){return this.executeProgram(c,_).tensor}runProgram(c,_,ot){for(let ct=0;ct<_.length;++ct)if(!!_[ct].isPacked!=(c.programInfo.inputTypes[ct]===g.TextureType.packed))throw new Error(`input[${ct}] property packed inconsistent`);if(!!ot.isPacked!=(c.programInfo.output.textureType===g.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(c,_,ot)}getOrCreateTextureData(c,_){let ot=this.getTextureData(c.dataId,_===g.TextureType.packed);if(!ot&&(ot=this.getTextureData(c.dataId,_!==g.TextureType.packed),ot))return _===g.TextureType.packed?this.pack(ot):this.unpack(ot);if(!ot){const ct=(0,it.createTextureLayoutFromTextureType)(this.session.layoutStrategy,c.dims,_);if(_===g.TextureType.packedLastDimension){const ft=c.dims;if(ft.length===4){const ht=[ft[0],Math.ceil(ft[1]*ft[2]*ft[3]/4)],bt=(0,it.createTextureLayoutFromTextureType)(this.session.layoutStrategy,ht,_);let mt=c.numberData;if(ft[1]*ft[2]*ft[3]%4!=0){const $t=ft[0],Tt=ft[1]*ft[2]*ft[3],Nt=Math.ceil(Tt*1/4)*4;mt=new Float32Array($t*Nt);for(let Ct=0;Ct<$t;++Ct){const Ft=Ct*Tt,ln=Ct*Nt+Ct%1*Tt;mt.set(c.numberData.subarray(Ft,Ft+Tt),ln)}}return this.createTextureData(bt,c.type,mt,c,1)}}if(_===g.TextureType.packed){const dt=(0,it.createTextureLayoutFromShape)(this.session.layoutStrategy,c.dims,1,[],{reverseWH:!0}),pt=this.createTextureData(dt,c.type,c.numberData,c,1);ot=this.pack(pt)}else ot=this.createTextureData(ct,c.type,c.numberData,c,1)}return ot}createTextureDataFromLayoutBindTensor(c,_,ot,ct){return this.createTextureData(c,_,ot,ct,1)}createTextureData(c,_,ot,ct,dt){a.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(c)}]`);const pt=this.session.textureManager.createTextureFromLayout(_,c,ot,dt);return this.createTextureDataFromTexture(c,_,pt,ct)}reshapeUnpacked(c,_){const ot=this.getOrCreateTextureData(c,g.TextureType.unpacked),ct={channels:ot.channels,height:ot.height,width:ot.width,shape:_.length!==0?_:[1],strides:h.ShapeUtil.computeStrides(_),unpackedShape:_};return this.createTextureDataFromTexture(ct,c.type,ot.texture).tensor}reshapePacked(c,_){const ot=this.getOrCreateTextureData(c,g.TextureType.packed);if((0,et.isReshapeCheap)(c.dims,_)){const ht={channels:ot.channels,height:ot.height,width:ot.width,shape:_.length!==0?_:[1],strides:h.ShapeUtil.computeStrides(_),unpackedShape:_,isPacked:!0};return this.createTextureDataFromTexture(ht,c.type,ot.texture).tensor}const ct=(0,et.processDims3D)(c.dims),dt=(0,et.processDims3D)(_),pt=this.reshapePacked(c,ct),ft=this.run((0,et.createPackedReshape3DProgramInfoLoader)(this,pt,dt),[pt]);return this.reshapePacked(ft,_)}cast(c,_){const ot=this.getOrCreateTextureData(c,g.TextureType.unpacked);return this.createTextureDataFromTexture(ot,_,ot.texture).tensor}createTextureDataFromTexture(c,_,ot,ct,dt){const pt=Object.assign(Object.assign({},c),{tensor:ct||new d.Tensor(c.unpackedShape,_,ft=>this.readTexture(pt),async ft=>this.readTextureAsync(pt),void 0,dt),texture:ot});return this.setTextureData(pt.tensor.dataId,pt,c.isPacked),pt}getTextureData(c,_=!1){return this.session.isInitializer(c)?this.session.getTextureData(c,_):_?this.packedTextureDataCache.get(c):this.unpackedTextureDataCache.get(c)}setTextureData(c,_,ot=!1){this.session.isInitializer(c)?this.session.setTextureData(c,_,ot):(ot?this.packedTextureDataCache:this.unpackedTextureDataCache).set(c,_)}isTextureLayoutCached(c,_=!1){return!!this.getTextureData(c.dataId,_)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(c=>this.session.textureManager.releaseTexture(c)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(c=>this.session.textureManager.releaseTexture(c)),this.unpackedTextureDataCache=new Map}readTexture(c){return c.isPacked?this.readTexture(this.unpack(c)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(c,c.tensor.type,c.channels):this.session.textureManager.readUint8TextureAsFloat((0,st.encodeAsUint8)(this,c))}async readTextureAsync(c){return c.isPacked?this.readTextureAsync(this.unpack(c)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(c,c.tensor.type,c.channels):this.session.textureManager.readUint8TextureAsFloat((0,st.encodeAsUint8)(this,c))}pack(c){return this.executeProgram((0,b.createPackProgramInfoLoader)(this,c.tensor),[c.tensor])}unpack(c){return this.executeProgram((0,$.createUnpackProgramInfoLoader)(this,c.tensor),[c.tensor])}}},1640:function(o,e,s){var a=this&&this.__createBinding||(Object.create?function(dn,wn,gn,En){En===void 0&&(En=gn);var _r=Object.getOwnPropertyDescriptor(wn,gn);_r&&!("get"in _r?!wn.__esModule:_r.writable||_r.configurable)||(_r={enumerable:!0,get:function(){return wn[gn]}}),Object.defineProperty(dn,En,_r)}:function(dn,wn,gn,En){En===void 0&&(En=gn),dn[En]=wn[gn]}),d=this&&this.__setModuleDefault||(Object.create?function(dn,wn){Object.defineProperty(dn,"default",{enumerable:!0,value:wn})}:function(dn,wn){dn.default=wn}),h=this&&this.__importStar||function(dn){if(dn&&dn.__esModule)return dn;var wn={};if(dn!=null)for(var gn in dn)gn!=="default"&&Object.prototype.hasOwnProperty.call(dn,gn)&&a(wn,dn,gn);return d(wn,dn),wn};Object.defineProperty(e,"__esModule",{value:!0}),e.WEBGL_OP_RESOLVE_RULES=void 0;const b=s(2898),et=h(s(7839)),st=s(4196),$=s(2069),it=s(8138),g=s(9663),c=s(5193),_=s(7992),ot=s(1253),ct=s(4776),dt=s(6572),pt=s(3346),ft=s(5623),ht=s(2870),bt=s(2143),mt=s(4939),$t=s(718),Tt=s(2268),Nt=s(8117),Ct=s(2278),Ft=s(5524),ln=s(5975),mn=s(3933),yn=s(6558),pn=s(5723),Ht=s(3738),Gt=h(s(4909)),cn=s(8428),xn=s(9793);e.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",Gt.abs],["Acos","","7+",Gt.acos],["Add","","7+",et.add],["And","","7+",et.and],["Asin","","7+",Gt.asin],["Atan","","7+",Gt.atan],["AveragePool","","7+",bt.averagePool,bt.parseAveragePoolAttributes],["BatchNormalization","","7+",b.batchNormalization,b.parseBatchNormalizationAttributes],["Cast","","6+",st.cast,st.parseCastAttributes],["Ceil","","6+",Gt.ceil],["Clip","","6-10",Gt.clip,Gt.parseClipAttributes],["Clip","","11+",Gt.clipV11],["Concat","","4+",$.concat,$.parseConcatAttributes],["Conv","","1+",it.conv,it.parseConvAttributes],["ConvTranspose","","1+",g.convTranspose,g.parseConvTransposeAttributes],["Cos","","7+",Gt.cos],["Div","","7+",et.div],["Dropout","","7+",Gt.identity],["DepthToSpace","","1+",c.depthToSpace,c.parseDepthToSpaceAttributes],["Equal","","7+",et.equal],["Elu","","6+",Gt.elu,Gt.parseEluAttributes],["Exp","","6+",Gt.exp],["Flatten","","1+",_.flatten,_.parseFlattenAttributes],["Floor","","6+",Gt.floor],["FusedConv","com.microsoft","1+",it.conv,it.parseConvAttributes],["Gather","","1+",ot.gather,ot.parseGatherAttributes],["Gemm","","7-10",ct.gemm,ct.parseGemmAttributesV7],["Gemm","","11+",ct.gemm,ct.parseGemmAttributesV11],["GlobalAveragePool","","1+",bt.globalAveragePool,bt.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",bt.globalMaxPool],["Greater","","7+",et.greater],["Identity","","1+",Gt.identity],["ImageScaler","","1+",dt.imageScaler,dt.parseImageScalerAttributes],["InstanceNormalization","","6+",pt.instanceNormalization,pt.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",Gt.leakyRelu,Gt.parseLeakyReluAttributes],["Less","","7+",et.less],["Log","","6+",Gt.log],["MatMul","","1+",ft.matMul,ft.parseMatMulAttributes],["MaxPool","","1+",bt.maxPool,bt.parseMaxPoolAttributes],["Mul","","7+",et.mul],["Neg","","6+",Gt.neg],["Not","","1+",Gt.not],["Or","","7+",et.or],["Pad","","2-10",ht.padV2,ht.parsePadAttributesV2],["Pad","","11+",ht.padV11,ht.parsePadAttributesV11],["Pow","","7+",et.pow],["PRelu","","7+",et.pRelu],["ReduceLogSum","","1+",mt.reduceLogSum,mt.parseReduceAttributes],["ReduceMax","","1+",mt.reduceMax,mt.parseReduceAttributes],["ReduceMean","","1+",mt.reduceMean,mt.parseReduceAttributes],["ReduceMin","","1+",mt.reduceMin,mt.parseReduceAttributes],["ReduceProd","","1+",mt.reduceProd,mt.parseReduceAttributes],["ReduceSum","","1-12",mt.reduceSum,mt.parseReduceAttributes],["ReduceSumSquare","","1+",mt.reduceLogSumSquare,mt.parseReduceAttributes],["Relu","","6+",Gt.relu],["Reshape","","5+",$t.reshape],["Resize","","10",Tt.resize,Tt.parseResizeAttributesV10],["Resize","","11+",Tt.resize,Tt.parseResizeAttributesV11],["Shape","","1+",Nt.shape],["Sigmoid","","6+",Gt.sigmoid],["Sin","","7+",Gt.sin],["Slice","","10+",Ct.sliceV10],["Slice","","1-9",Ct.slice,Ct.parseSliceAttributes],["Softmax","","1-12",Ft.softmax,Ft.parseSoftmaxAttributes],["Softmax","","13+",Ft.softmaxV13,Ft.parseSoftmaxAttributesV13],["Split","","2-12",ln.split,ln.parseSplitAttributes],["Sqrt","","6+",Gt.sqrt],["Squeeze","","1-12",mn.squeeze,mn.parseSqueezeAttributes],["Squeeze","","13+",mn.squeezeV13],["Sub","","7+",et.sub],["Sum","","6+",yn.sum],["Tan","","7+",Gt.tan],["Tanh","","6+",Gt.tanh],["Tile","","6+",pn.tile],["Transpose","","1+",Ht.transpose,Ht.parseTransposeAttributes],["Upsample","","7-8",xn.upsample,xn.parseUpsampleAttributesV7],["Upsample","","9",xn.upsample,xn.parseUpsampleAttributesV9],["Unsqueeze","","1-12",cn.unsqueeze,cn.parseUnsqueezeAttributes],["Unsqueeze","","13+",cn.unsqueezeV13],["Xor","","7+",et.xor]]},2898:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseBatchNormalizationAttributes=e.batchNormalization=void 0;const a=s(246),d=s(5060),h=s(2039),b={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]};e.batchNormalization=($,it,g)=>(st(it),[$.run(Object.assign(Object.assign({},b),{cacheHint:g.cacheKey,get:()=>et($,it,g)}),it)]),e.parseBatchNormalizationAttributes=$=>{const it=$.attributes.getFloat("epsilon",1e-5),g=$.attributes.getFloat("momentum",.9),c=$.attributes.getInt("spatial",1);return(0,a.createAttributeWithCacheKey)({epsilon:it,momentum:g,spatial:c})};const et=($,it,g)=>{const c=(0,d.getGlsl)($.session.backend.glContext.version),_=it[0].dims.length,[ot,ct]=$.calculateTextureWidthAndHeight(it[1].dims,h.TextureType.unpacked),dt=`
  float process(int[${_}] indices) {
    vec2 position = offsetToCoords(indices[1], ${ot}, ${ct});
    float scale = getColorAsFloat(${c.texture2D}(Scale, position));
    float mean = getColorAsFloat(${c.texture2D}(Mean, position));
    float variance = getColorAsFloat(${c.texture2D}(Variance, position));
    float b = getColorAsFloat(${c.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${g.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},b),{output:{dims:it[0].dims,type:it[0].type,textureType:h.TextureType.unpacked},shaderSource:dt})},st=$=>{if(!$||$.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const it=$[0],g=$[1],c=$[2],_=$[3],ot=$[4];if(it.dims.length<3||g.dims.length!==1||c.dims.length!==1||_.dims.length!==1||ot.dims.length!==1)throw new Error("invalid input shape.");if(g.dims[0]!==it.dims[1]||c.dims[0]!==it.dims[1]||_.dims[0]!==it.dims[1]||ot.dims[0]!==it.dims[1])throw new Error("invalid input shape.");if(it.type!=="float32"&&it.type!=="float64"||g.type!=="float32"&&g.type!=="float64"||c.type!=="float32"&&c.type!=="float64"||_.type!=="float32"&&_.type!=="float64"||ot.type!=="float32"&&ot.type!=="float64")throw new Error("invalid input tensor types.")}},7839:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.xor=e.sub=e.pRelu=e.pow=e.or=e.mul=e.less=e.greater=e.equal=e.div=e.and=e.add=e.glslPRelu=e.glslPow=e.glslXor=e.glslOr=e.glslAnd=e.glslLess=e.glslGreater=e.glslEqual=e.glslSub=e.glslMul=e.glslDiv=e.glslAdd=void 0;const a=s(2517),d=s(8520),h=s(5060),b=s(2039);function et(){const mt="add_";return{body:`
  float ${mt}(float a, float b) {
    return a + b;
  }
  vec4 ${mt}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:mt,type:d.FunctionType.ValueBased}}function st(){const mt="div_";return{body:`
  float ${mt}(float a, float b) {
    return a / b;
  }
  vec4 ${mt}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:mt,type:d.FunctionType.ValueBased}}function $(){const mt="mul_";return{body:`
  float ${mt}(float a, float b) {
    return a * b;
  }
  vec4 ${mt}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:mt,type:d.FunctionType.ValueBased}}function it(){const mt="sub_";return{body:`
  float ${mt}(float a, float b) {
    return a - b;
  }
  vec4 ${mt}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:mt,type:d.FunctionType.ValueBased}}function g(){const mt="equal_";return{body:`
  float ${mt}(float a, float b) {
    return float(a == b);
  }
  vec4 ${mt}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:mt,type:d.FunctionType.ValueBased}}function c(){const mt="greater_";return{body:`
  float ${mt}(float a, float b) {
    return float(a > b);
  }
  vec4 ${mt}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:mt,type:d.FunctionType.ValueBased}}function _(){const mt="less_";return{body:`
  float ${mt}(float a, float b) {
    return float(a < b);
  }
  vec4 ${mt}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:mt,type:d.FunctionType.ValueBased}}function ot(){const mt="and_";return{body:`
  float ${mt}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${mt}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:mt,type:d.FunctionType.ValueBased}}function ct(){const mt="or_";return{body:`
  float ${mt}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${mt}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:mt,type:d.FunctionType.ValueBased}}function dt(){const mt="xor_";return{body:`
  float ${mt}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${mt}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:mt,type:d.FunctionType.ValueBased}}function pt(){return function(mt){const $t=`${mt}_`;return{body:`
  float ${$t}(float a, float b) {
    return ${mt}(a, b);
  }
  vec4 ${$t}(vec4 v1, vec4 v2) {
    return ${mt}(v1, v2);
  }
  `,name:$t,type:d.FunctionType.ValueBased}}("pow")}function ft(){const mt="prelu_";return{body:`
  float ${mt}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${mt}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:mt,type:d.FunctionType.ValueBased}}e.glslAdd=et,e.glslDiv=st,e.glslMul=$,e.glslSub=it,e.glslEqual=g,e.glslGreater=c,e.glslLess=_,e.glslAnd=ot,e.glslOr=ct,e.glslXor=dt,e.glslPow=pt,e.glslPRelu=ft;const ht=(mt,$t,Tt,Nt=$t[0].type,Ct)=>{const Ft=mt.session.pack?b.TextureType.packed:b.TextureType.unpacked;return{name:Tt.name,inputNames:["A","B"],inputTypes:[Ft,Ft],cacheHint:Ct,get:()=>bt(mt,$t,Tt,Nt)}},bt=(mt,$t,Tt,Nt=$t[0].type)=>{const Ct=mt.session.pack?b.TextureType.packed:b.TextureType.unpacked,Ft=!a.ShapeUtil.areEqual($t[0].dims,$t[1].dims);let ln=$t[0].dims;const mn=mt.session.pack;if(Ft){const Ht=a.BroadcastUtil.calcShape($t[0].dims,$t[1].dims,!1);if(!Ht)throw new Error("Can't perform binary op on the given tensors");ln=Ht;const Gt=ln.length,cn=$t[0].dims.length!==0?$t[0].dims.length:1,xn=$t[1].dims.length!==0?$t[1].dims.length:1,dn=$t[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",wn=$t[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",gn=(0,h.getGlsl)(mt.session.backend.glContext.version),En=mn?`
      ${Tt.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${Tt.name}(a, b);
        ${gn.output} = result;
      }`:`
      ${Tt.body}
      float process(int indices[${Gt}]) {
        int aindices[${cn}];
        int bindices[${xn}];
        ${dn}
        ${wn}
        return ${Tt.name}(_A(aindices), _B(bindices));
      }`;return{name:Tt.name,inputNames:["A","B"],inputTypes:[Ct,Ct],output:{dims:ln,type:Nt,textureType:Ct},shaderSource:En,hasMain:mn}}const yn=(0,h.getGlsl)(mt.session.backend.glContext.version),pn=`
    ${Tt.body}
    void main() {
      vec4 v1 = ${yn.texture2D}(A, TexCoords);
      vec4 v2 = ${yn.texture2D}(B, TexCoords);
      vec4 result = ${Tt.name}(v1, v2);
      ${yn.output} = result;
    }
    `;return{name:Tt.name,inputNames:["A","B"],inputTypes:[Ct,Ct],output:{dims:$t[0].dims,type:Nt,textureType:Ct},shaderSource:pn,hasMain:!0}};e.add=(mt,$t)=>[mt.run(ht(mt,$t,et()),$t)],e.and=(mt,$t)=>[mt.run(ht(mt,$t,ot(),"bool"),$t)],e.div=(mt,$t)=>[mt.run(ht(mt,$t,st()),$t)],e.equal=(mt,$t)=>[mt.run(ht(mt,$t,g(),"bool"),$t)],e.greater=(mt,$t)=>[mt.run(ht(mt,$t,c(),"bool"),$t)],e.less=(mt,$t)=>[mt.run(ht(mt,$t,_(),"bool"),$t)],e.mul=(mt,$t)=>[mt.run(ht(mt,$t,$()),$t)],e.or=(mt,$t)=>[mt.run(ht(mt,$t,ct(),"bool"),$t)],e.pow=(mt,$t)=>[mt.run(ht(mt,$t,pt()),$t)],e.pRelu=(mt,$t)=>[mt.run(ht(mt,$t,ft()),$t)],e.sub=(mt,$t)=>[mt.run(ht(mt,$t,it()),$t)],e.xor=(mt,$t)=>[mt.run(ht(mt,$t,dt(),"bool"),$t)]},4196:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseCastAttributes=e.cast=void 0;const a=s(2517);e.cast=(h,b,et)=>(d(b),[h.cast(b[0],et)]),e.parseCastAttributes=h=>a.ProtoUtil.tensorDataTypeFromProto(h.attributes.getInt("to"));const d=h=>{if(!h||h.length!==1)throw new Error("Cast requires 1 input.");if(h[0].type==="string")throw new Error("Invalid input type.")}},1163:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedConcatProgramInfoLoader=void 0;const a=s(5060),d=s(2039),h=s(9390),b=s(2827);e.createPackedConcatProgramInfoLoader=(st,$,it)=>{const g=(c=$.length,_=it.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:c},(ot,ct)=>`X${ct}`),inputTypes:Array(c).fill(d.TextureType.packed),cacheHint:_});var c,_;return Object.assign(Object.assign({},g),{get:()=>((ot,ct,dt,pt)=>{const ft=dt[0].dims.slice();if(pt>=ft.length||pt<-1*ft.length)throw new Error("axis specified for concat doesn't match input dimensionality");pt<0&&(pt=ft.length+pt);const ht=ft.slice(0);for(let dn=1;dn<dt.length;dn++){const wn=dt[dn].dims.slice();for(let gn=0;gn<ft.length;gn++)if(gn===pt)ht[pt]+=wn[gn];else if(ft[gn]!==wn[gn])throw new Error("non concat dimensions must match")}const bt=ht.length,mt=(0,b.getChannels)("coords",bt),$t=(0,h.getCoordsDataType)(bt),Tt=(0,b.unpackFromChannel)(),Nt=dt.map(dn=>dn.dims),Ct=(0,h.getGlChannels)(bt),Ft=new Array(Nt.length-1);Ft[0]=Nt[0][pt];for(let dn=1;dn<Ft.length;dn++)Ft[dn]=Ft[dn-1]+Nt[dn][pt];const ln=Ct[pt],mn=Ct.slice(-2),yn=Ct.join();let pn=`if (${ln} < ${Ft[0]}) {
        return getChannel(
            getX0(${yn}), vec2(${mn.join()}));
        }`;for(let dn=1;dn<Ft.length;dn++){const wn=Ft[dn-1];pn+=`
            if (${ln} < ${Ft[dn]}  && ${ln} >= ${Ft[dn-1]}) {
              return getChannel(
                getX${dn}(${et(Ct,ln,wn)}),
                vec2(${et(mn,ln,wn)}));
            }`}const Ht=Ft.length,Gt=Ft[Ft.length-1];pn+=`
            return getChannel(
              getX${Ht}(${et(Ct,ln,Gt)}),
              vec2(${et(mn,ln,Gt)}));`;const cn=(0,a.getGlsl)(ot.session.backend.glContext.version),xn=`
          ${Tt}
          float getValue(${Ct.map(dn=>"int "+dn)}) {
            ${pn}
          }

          void main() {
            ${$t} coords = getOutputCoords();
            int lastDim = coords.${Ct[bt-1]};
            coords.${Ct[bt-1]} = coords.${Ct[bt-2]};
            coords.${Ct[bt-2]} = lastDim;

            vec4 result = vec4(getValue(${mt}), 0., 0., 0.);

            ${mt[bt-1]} = ${mt[bt-1]} + 1;
            if (${mt[bt-1]} < ${ht[bt-1]}) {
              result.g = getValue(${mt});
            }

            ${mt[bt-2]} = ${mt[bt-2]} + 1;
            if (${mt[bt-2]} < ${ht[bt-2]}) {
              result.a = getValue(${mt});
            }

            ${mt[bt-1]} = ${mt[bt-1]} - 1;
            if (${mt[bt-2]} < ${ht[bt-2]} &&
                ${mt[bt-1]} < ${ht[bt-1]}) {
              result.b = getValue(${mt});
            }
            ${cn.output} = result;
          }
        `;return Object.assign(Object.assign({},ct),{output:{dims:ht,type:dt[0].type,textureType:d.TextureType.packed},shaderSource:xn,hasMain:!0})})(st,g,$,it.axis)})};const et=(st,$,it)=>{const g=st.indexOf($);return st.map((c,_)=>_===g?`${c} - ${it}`:c).join()}},2069:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseConcatAttributes=e.concat=void 0;const a=s(246),d=s(2039),h=s(1163);e.concat=(c,_,ot)=>(g(_),c.session.pack&&_[0].dims.length>1?[c.run((0,h.createPackedConcatProgramInfoLoader)(c,_,ot),_)]:[c.run(b(c,_,ot),_)]);const b=(c,_,ot)=>{const ct=(dt=_.length,pt=ot.cacheKey,{name:"Concat",inputNames:Array.from({length:dt},(ft,ht)=>`X${ht}`),inputTypes:Array(dt).fill(d.TextureType.unpacked),cacheHint:pt});var dt,pt;return Object.assign(Object.assign({},ct),{get:()=>((ft,ht,bt,mt)=>{const $t=bt[0].dims.slice();if(mt>=$t.length||mt<-1*$t.length)throw new Error("axis specified for concat doesn't match input dimensionality");mt<0&&(mt=$t.length+mt);const Tt=$t.slice(0);for(let yn=1;yn<bt.length;yn++){const pn=bt[yn].dims.slice();for(let Ht=0;Ht<$t.length;Ht++)if(Ht===mt)Tt[mt]+=pn[Ht];else if($t[Ht]!==pn[Ht])throw new Error("non concat dimensions must match")}const Nt=Tt.length,Ct=new Array(bt.length);let Ft=0;for(let yn=0;yn<Ct.length;++yn)Ft+=bt[yn].dims[mt],Ct[yn]=Ft;let ln="";ln=bt.length<5?et(Ct):st(Ct);const mn=`
        ${$(bt.length,Nt)}
        ${it(Ct)}
        ${ln}
        float process(int indices[${Nt}]) {
          int textureIndex = getTextureWhereDataResides (indices[${mt}]);

          if(textureIndex != 0) {
            indices[${mt}] = indices[${mt}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},ht),{output:{dims:Tt,type:bt[0].type,textureType:d.TextureType.unpacked},shaderSource:mn})})(0,ct,_,ot.axis)})},et=c=>`int getTextureWhereDataResides(int index) {
      ${c.map((_,ot)=>`if(index<${_}) {return ${ot};}
`).join("")}
    }`,st=c=>et(c),$=(c,_)=>{const ot=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${_}]) {`];for(let ct=0;ct<c;++ct)ct===0?ot.push(`	if (textureIndex == ${ct}) { return _X${ct}(indices); }`):ct===c-1?ot.push(`	else { return _X${ct}(indices); }`):ot.push(`	else if (textureIndex == ${ct}) { return _X${ct}(indices); }`);return ot.push("	}"),ot.join(`
`)},it=c=>{const _=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let ot=0;ot<c.length;++ot)ot===0?_.push(`	if (index == ${ot}) { return ${c[ot]}; }`):ot===c.length-1?_.push(`	else { return ${c[ot]}; }`):_.push(`	else if (index == ${ot}) { return ${c[ot]}; }`);return _.push("	}"),_.join(`
`)};e.parseConcatAttributes=c=>(0,a.createAttributeWithCacheKey)({axis:c.attributes.getInt("axis")});const g=c=>{if(!c||c.length<1)throw new Error("too few inputs");const _=c[0].type,ot=c[0].dims.length;if(_==="string")throw new Error("string tensor is not supported yet");for(const ct of c){if(ct.type!==_)throw new Error("input tensors should be one type");if(ct.dims.length!==ot)throw new Error("input tensors should have the same shape")}}},4770:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createUnpackedGroupedConvProgramInfoLoader=void 0;const a=s(6231),d=s(5060),h=s(2039),b=s(8138),et=s(2823);e.createUnpackedGroupedConvProgramInfoLoader=(st,$,it)=>{const g=(c=$.length>2,_=it.cacheKey,{name:"GroupedConv",inputNames:c?["X","W","Bias"]:["X","W"],inputTypes:c?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],cacheHint:_});var c,_;return Object.assign(Object.assign({},g),{get:()=>((ot,ct,dt,pt)=>{const ft=ct.length>2?"value += getBias(output_channel);":"",ht=ct[0].dims.slice(),bt=ct[1].dims.slice(),mt=bt[0]/pt.group;a.Logger.verbose("GroupedConv",`autpPad:${pt.autoPad}, dilations:${pt.dilations}, group:${pt.group}, kernelShape:${pt.kernelShape}, pads:${pt.pads}, strides:${pt.strides}`);const $t=(0,b.calculateOutputShape)(ht,bt,pt.dilations,pt.pads,pt.strides),Tt=(0,d.getGlsl)(ot.session.backend.glContext.version),{activationFunction:Nt,applyActivation:Ct}=(0,et.getActivationSnippet)(pt),Ft=`
  const ivec2 strides = ivec2(${pt.strides[0]}, ${pt.strides[1]});
  const ivec2 pads = ivec2(${pt.pads[0]}, ${pt.pads[1]});
  ${Nt}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${mt};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${bt[1]}; wInChannel++) {
      int input_channel = group_id * ${bt[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${bt[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${pt.dilations[0]};

        if (xHeight < 0 || xHeight >= ${ht[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${bt[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${pt.dilations[1]};
          if (xWidth < 0 || xWidth >= ${ht[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${ft}
    ${Ct}
    ${Tt.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},dt),{output:{dims:$t,type:ct[0].type,textureType:h.TextureType.unpacked},shaderSource:Ft,hasMain:!0})})(st,$,g,it)})}},1386:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.conv2DPacked=e.conv2DPackedPointwise=void 0;const a=s(8138),d=s(8555),h=s(708);e.conv2DPackedPointwise=(b,et,st)=>{const $=et[0].dims,it=et[1].dims,g=(0,a.calculateOutputShape)($,it,st.dilations,st.pads,st.strides),c=b.reshapePacked(et[0],[$[1],$[2]*$[3]]),_=b.reshapePacked(et[1],[it[0],it[1]]),ot=et.length>2?[_,c,et[2]]:[_,c],ct=b.run((0,h.createPackedMatmulProgramInfoLoader)(b,ot,st),ot);return b.reshapePacked(ct,g)},e.conv2DPacked=(b,et,st)=>{const $=et[0].dims,it=et[1].dims,g=(0,a.calculateOutputShape)($,it,st.dilations,st.pads,st.strides),c=b.run((0,d.createPackedIm2ColProgramInfoLoader)(b,et[0],et[1],g,st),[et[0]]),_=b.reshapePacked(et[1],[it[0],it[1]*it[2]*it[3]]),ot=et.length===3?[_,c,et[2]]:[_,c],ct=b.run((0,h.createPackedMatmulProgramInfoLoader)(b,ot,st),ot);return b.reshapePacked(ct,g)}},9663:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseConvTransposeAttributes=e.convTranspose=void 0;const a=s(246),d=s(5060),h=s(2039),b=s(2823),et=(_,ot,ct,dt,pt,ft)=>(_-1)*ot+ct+(dt-1)*pt+1-ft,st=(_,ot,ct,dt,pt)=>{const ft=Math.floor(_/2);ot==="SAME_UPPER"?(ct[dt]=ft,ct[pt]=_-ft):ot==="SAME_LOWER"&&(ct[dt]=_-ft,ct[pt]=ft)};e.convTranspose=(_,ot,ct)=>(c(ot,ct),$(_,ot,ct));const $=(_,ot,ct)=>{const dt=g(ct,ot);return[it(_,ot,dt)]},it=(_,ot,ct)=>_.run(((dt,pt,ft)=>{const ht=(bt=pt.length>2,mt=ft.cacheKey,{name:"ConvTranspose",inputNames:bt?["X","W","B"]:["X","W"],inputTypes:bt?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],cacheHint:mt});var bt,mt;return Object.assign(Object.assign({},ht),{get:()=>(($t,Tt,Nt,Ct)=>{const Ft=Tt.length>2?"getB(output_channel)":"0.0",ln=Tt[0].dims,mn=Tt[1].dims,yn=mn[1],pn=mn[0]/Ct.group,Ht=[Tt[0].dims[0],Tt[1].dims[1]*Ct.group,...Ct.outputShape],Gt=(0,d.getGlsl)($t.session.backend.glContext.version),{activationFunction:cn,applyActivation:xn}=(0,b.getActivationSnippet)(Ct),dn=`
  const ivec2 strides = ivec2(${Ct.strides[0]}, ${Ct.strides[1]});
  const ivec2 pads = ivec2(${Ct.pads[0]}, ${Ct.pads[1]});
  ${cn}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${yn};
    int wOutChannel = output_channel - group_id * ${yn};

    float value = ${Ft};
    for (int inChannelOffset = 0; inChannelOffset < ${pn}; inChannelOffset++) {
      int input_channel = group_id * ${pn} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${mn[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${mn[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${Ct.dilations[0]}, wHOff * ${Ct.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${ln[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${ln[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${xn}
    ${Gt.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},Nt),{output:{dims:Ht,type:Tt[0].type,textureType:h.TextureType.unpacked},shaderSource:dn,hasMain:!0})})(dt,pt,ht,ft)})})(_,ot,ct),ot),g=(_,ot)=>{const ct=_.kernelShape.slice();if(_.kernelShape.length===0)for(let ht=2;ht<ot[1].dims.length;++ht)ct.push(ot[1].dims[ht]);const dt=_.pads.slice(),pt=_.outputShape.slice();((ht,bt,mt,$t,Tt,Nt,Ct,Ft)=>{const ln=ht.length-2,mn=Ft.length===0;for(let yn=0;yn<ln;++yn){const pn=mn?ht[yn+2]*Nt[yn]:Ft[yn],Ht=et(ht[yn+2],Nt[yn],Tt[yn],bt[yn],mt[yn],pn);st(Ht,$t,Tt,yn,yn+ln),mn&&Ft.push(Nt[yn]*(ht[yn+2]-1)+Ct[yn]+(bt[yn]-1)*mt[yn]+1-Tt[yn]-Tt[yn+ln])}})(ot[0].dims,ct,_.dilations,_.autoPad,dt,_.strides,_.outputPadding,pt);const ft=Object.assign({},_);return Object.assign(ft,{kernelShape:ct,pads:dt,outputShape:pt,cacheKey:_.cacheKey}),ft};e.parseConvTransposeAttributes=_=>{const ot=_.attributes,ct=(0,b.parseInternalActivationAttributes)(ot),dt=ot.getString("auto_pad","NOTSET"),pt=ot.getInts("dilations",[1,1]),ft=ot.getInt("group",1),ht=ot.getInts("kernel_shape",[]),bt=ot.getInts("output_padding",[0,0]),mt=ot.getInts("output_shape",[]),$t=ot.getInts("pads",[0,0,0,0]),Tt=ot.getInts("strides",[1,1]);return(0,a.createAttributeWithCacheKey)(Object.assign({autoPad:dt,dilations:pt,group:ft,kernelShape:ht,outputPadding:bt,outputShape:mt,pads:$t,strides:Tt},ct))};const c=(_,ot)=>{if(!_||_.length!==2&&_.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(_[0].dims.length!==4||_[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(_[0].dims[1]!==_[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const ct=_[1].dims[1]*ot.group;if(_.length===3&&(_[2].dims.length!==1||_[2].dims[0]!==ct))throw new Error("invalid bias");const dt=_[0].dims.length-2;if(ot.dilations.length!==dt)throw new Error(`dilations should be ${dt}D`);if(ot.strides.length!==dt)throw new Error(`strides should be ${dt}D`);if(ot.pads.length!==2*dt)throw new Error(`pads should be ${2*dt}D`);if(ot.outputPadding.length!==dt)throw new Error(`output_padding should be ${dt}D`);if(ot.kernelShape.length!==0&&ot.kernelShape.length!==_[1].dims.length-2)throw new Error("invalid kernel shape");if(ot.outputShape.length!==0&&ot.outputShape.length!==_[0].dims.length-2)throw new Error("invalid output shape");if(_[0].type!=="float32"||_[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(_.length===3&&_[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},8138:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseConvAttributes=e.conv=e.calculateOutputShape=void 0;const a=s(246),d=s(2517),h=s(4770),b=s(1386),et=s(9828),st=s(2823),$=s(3248),it=s(5623);e.calculateOutputShape=(dt,pt,ft,ht,bt)=>{const mt=dt[0],$t=dt.slice(2),Tt=$t.length,Nt=pt[0],Ct=pt.slice(2).map((ln,mn)=>ln+(ln-1)*(ft[mn]-1)),Ft=$t.map((ln,mn)=>ln+ht[mn]+ht[mn+Tt]).map((ln,mn)=>Math.floor((ln-Ct[mn]+bt[mn])/bt[mn]));return[mt,Nt].concat(...Ft)},e.conv=(dt,pt,ft)=>(ct(pt,ft),g(dt,pt,ft));const g=(dt,pt,ft)=>{const ht=ot(ft,pt),bt=dt.session.pack,mt=ht.kernelShape[0]===1&&ht.kernelShape[1]===1;return ht.group>1?[dt.run((0,h.createUnpackedGroupedConvProgramInfoLoader)(dt,pt,ht),pt)]:mt&&bt?[c(dt,pt,ht)]:bt&&pt[0].dims.length===4&&pt[0].dims[0]===1&&!mt?[(0,b.conv2DPacked)(dt,pt,ht)]:[_(dt,pt,ht)]},c=(dt,pt,ft)=>{const ht=pt[0].dims,bt=pt[1].dims,mt=(0,e.calculateOutputShape)(ht,bt,ft.dilations,ft.pads,ft.strides),$t=dt.reshapeUnpacked(pt[0],[ht[1],ht[2]*ht[3]]),Tt=dt.reshapeUnpacked(pt[1],[bt[0],bt[1]]),Nt=pt.length>2?[Tt,$t,pt[2]]:[Tt,$t],Ct=dt.run((0,it.createMatmulProgramInfoLoader)(Nt,ft),Nt);return dt.reshapeUnpacked(Ct,mt)},_=(dt,pt,ft)=>{const ht=pt[0].dims,bt=pt[1].dims,mt=(0,e.calculateOutputShape)(ht,bt,ft.dilations,ft.pads,ft.strides),$t=dt.run((0,$.createIm2ColProgramInfoLoader)(dt,pt[0],pt[1],mt,ft),[pt[0]]),Tt=pt.length===3?[$t,pt[1],pt[2]]:[$t,pt[1]];return dt.run((0,et.createDotProductProgramInfoLoader)(dt,pt,mt,ft),Tt)},ot=(dt,pt)=>{const ft=dt.kernelShape.slice();if(dt.kernelShape.length===0)for(let mt=2;mt<pt[1].dims.length;++mt)ft.push(pt[1].dims[mt]);const ht=dt.pads.slice();d.PoolConvUtil.adjustPadsBasedOnAutoPad(pt[0].dims,dt.strides,dt.dilations,ft,ht,dt.autoPad);const bt=Object.assign({},dt);return Object.assign(bt,{kernelShape:ft,pads:ht,cacheKey:dt.cacheKey}),bt};e.parseConvAttributes=dt=>{const pt=dt.attributes,ft=(0,st.parseInternalActivationAttributes)(pt),ht=pt.getString("auto_pad","NOTSET"),bt=pt.getInts("dilations",[1,1]),mt=pt.getInt("group",1),$t=pt.getInts("kernel_shape",[]),Tt=pt.getInts("pads",[0,0,0,0]),Nt=pt.getInts("strides",[1,1]);return(0,a.createAttributeWithCacheKey)(Object.assign({autoPad:ht,dilations:bt,group:mt,kernelShape:$t,pads:Tt,strides:Nt},ft))};const ct=(dt,pt)=>{if(!dt||dt.length!==2&&dt.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(dt[0].dims.length!==4||dt[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(dt[0].dims[1]!==dt[1].dims[1]*pt.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(dt.length===3&&(dt[2].dims.length!==1||dt[1].dims[0]!==dt[2].dims[0]))throw new Error("invalid bias");const ft=dt[0].dims.length-2;if(pt.dilations.length!==ft)throw new Error(`dilations should be ${ft}D`);if(pt.strides.length!==ft)throw new Error(`strides should be ${ft}D`);if(pt.pads.length!==2*ft)throw new Error(`pads should be ${2*ft}D`);if(pt.kernelShape.length!==0&&pt.kernelShape.length!==dt[1].dims.length-2)throw new Error("invalid kernel shape");if(dt[0].type!=="float32"||dt[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(dt.length===3&&dt[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},5193:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseDepthToSpaceAttributes=e.depthToSpace=void 0;const a=s(3738);e.depthToSpace=(h,b,et)=>{d(b);const st=et.blocksize,$=st*st,it=et.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],g=et.mode==="DCR"?[b[0].dims[0],st,st,b[0].dims[1]/$,b[0].dims[2],b[0].dims[3]]:[b[0].dims[0],b[0].dims[1]/$,st,st,b[0].dims[2],b[0].dims[3]],c=h.reshapeUnpacked(b[0],g),_={perm:it,cacheKey:`${it}`},[ot]=(0,a.transpose)(h,[c],_),ct=[b[0].dims[0],b[0].dims[1]/$,b[0].dims[2]*st,b[0].dims[3]*st];return[h.reshapeUnpacked(ot,ct)]},e.parseDepthToSpaceAttributes=h=>{const b=h.attributes.getInt("blocksize");if(b<1)throw new Error(`blocksize must be >= 1, but got : ${b} for DepthToSpace`);const et=h.attributes.getString("mode","DCR");if(et!=="DCR"&&et!=="CRD")throw new Error(`unrecognized mode: ${et} for DepthToSpace`);return{mode:et,blocksize:b}};const d=h=>{if(h.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${h.length}`);if(h[0].type==="string"||h[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createDotProductProgramInfoLoader=void 0;const a=s(2517),d=s(5060),h=s(2039),b=s(2823),et=s(3248);e.createDotProductProgramInfoLoader=(st,$,it,g)=>{const c=((_,ot)=>({name:"ConvDotProduct",inputNames:_?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:_?[h.TextureType.unpacked,h.TextureType.packedLastDimension,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.packedLastDimension],cacheKey:ot.activationCacheKey}))($.length>2,g);return Object.assign(Object.assign({},c),{get:()=>((_,ot,ct,dt,pt)=>{const ft=ct[0].dims,ht=ct[1].dims,bt=[ht[0],Math.ceil(ft[1]*ht[2]*ht[3]/4)],mt=(0,et.calculateIm2ColDims)(ft,ht,dt),[$t,Tt]=_.calculateTextureWidthAndHeight(bt,h.TextureType.packedLastDimension),Nt=a.ShapeUtil.computeStrides(mt),[Ct,Ft]=_.calculateTextureWidthAndHeight(mt,h.TextureType.packedLastDimension),ln=dt.length,mn=ct.length<3?"0.0":"_B(b)",yn=Math.ceil(ft[1]*ht[2]*ht[3]/4),{activationFunction:pn,applyActivation:Ht}=(0,b.getActivationSnippet)(pt),Gt=(0,d.getGlsl)(_.session.backend.glContext.version),cn=`
${pn}
float process(int indices[${ln}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${Nt[0]} + im2col[1] * ${Nt[1]} + im2col[2] * ${Nt[2]};
  int kernelOffset = indices[1] * ${bt[1]};
  float value = ${mn};
  for (int i = 0; i < ${yn}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${Ct}, ${Ft});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${$t}, ${Tt});
    value += dot(${Gt.texture2D}(Im2Col, im2colCoords), ${Gt.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${Ht}
  return value;
}`;return Object.assign(Object.assign({},ot),{output:{dims:dt,type:ct[0].type,textureType:h.TextureType.unpacked},shaderSource:cn})})(st,c,$,it,g)})}},7992:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseFlattenAttributes=e.flatten=void 0;const a=s(2517);e.flatten=(h,b,et)=>{d(b,et);const st=a.ShapeUtil.flattenShape(b[0].dims,et);return[h.reshapeUnpacked(b[0],st)]},e.parseFlattenAttributes=h=>h.attributes.getInt("axis",1);const d=(h,b)=>{if(!h||h.length!==1)throw new Error("Flatten requires 1 input.");const et=h[0].dims.length;if(et===0)throw new Error("scalar tensor is not supported.");if(b<-et||b>et)throw new Error("Invalid axis");if(h[0].type==="string")throw new Error("string tensor is not supported.")}},2823:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseInternalActivationAttributes=e.getActivationSnippet=void 0;const a=s(2517),d=s(4909);e.getActivationSnippet=function(h){let b;switch(h.activation){case"Relu":b=(0,d.glslRelu)();break;case"Sigmoid":b=(0,d.glslSigmoid)();break;case"Clip":b=(0,d.glslClip)(h.clipMin,h.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const et=b.name;return{activationFunction:b.body,applyActivation:`value = ${et}_(value);`}},e.parseInternalActivationAttributes=h=>{const b=h.getString("activation","");if(b==="Clip"){const[et,st]=h.getFloats("activation_params",[a.MIN_CLIP,a.MAX_CLIP]);return{activation:b,clipMax:st,clipMin:et,activationCacheKey:`${b}:${et},${st}`}}return{activation:b,activationCacheKey:b}}},1253:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseGatherAttributes=e.gather=void 0;const a=s(246),d=s(782),h=s(2517),b=s(2039);e.gather=(it,g,c)=>($(g,c.axis),[it.run(st(it,g,c),g)]),e.parseGatherAttributes=it=>(0,a.createAttributeWithCacheKey)({axis:it.attributes.getInt("axis",0)});const et={name:"Gather",inputNames:["A","B"],inputTypes:[b.TextureType.unpacked,b.TextureType.unpacked]},st=(it,g,c)=>{const _=Object.assign(Object.assign({},et),{cacheHint:c.cacheKey});return Object.assign(Object.assign({},_),{get:()=>((ot,ct,dt,pt)=>{const ft=dt[0].dims.slice(),ht=dt[1].dims.slice(),bt=new Array(ft.length+ht.length-1);pt=h.ShapeUtil.normalizeAxis(pt,ft.length);const mt=[];for(let Tt=0;Tt<bt.length;Tt++)Tt<pt?(bt[Tt]=ft[Tt],mt.push(`inputIdx[${Tt}] = outputIdx[${Tt}];`)):Tt<pt+ht.length?(bt[Tt]=ht[Tt-pt],mt.push(`indexDataIdx[${Tt-pt}] = outputIdx[${Tt}];`)):(bt[Tt]=ft[Tt-ht.length+1],mt.push(`inputIdx[${Tt-ht.length+1}] = outputIdx[${Tt}];`));const $t=`
      float process(int outputIdx[${bt.length||1}]) {
        int inputIdx[${ft.length}];
        int indexDataIdx[${ht.length||1}];
        indexDataIdx[0] = 0;
        ${mt.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${pt}] = idx < 0 ? idx + ${ft[pt]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},ct),{output:{dims:bt,type:dt[0].type,textureType:b.TextureType.unpacked},shaderSource:$t})})(0,_,g,c.axis)})},$=(it,g)=>{if(!it||it.length!==2)throw new Error("Gather requires 2 inputs.");const c=it[0].dims.length;if(c<1)throw new Error("Invalid input shape.");if(g<-c||g>c-1)throw new Error("Invalid axis.");if(d.NUMBER_TYPES.indexOf(it[0].type)===-1)throw new Error("Invaid input type.");if(it[1].type!=="int32"&&it[1].type!=="int16")throw new Error("Invaid input type.")}},4776:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseGemmAttributesV11=e.parseGemmAttributesV7=e.gemm=void 0;const a=s(246),d=s(2517),h=s(2039);e.gemm=(it,g,c)=>($(g,c),[it.run(et(g,c),g)]);const b=(it,g)=>{const c=it.attributes.getInt("transA",0)!==0,_=it.attributes.getInt("transB",0)!==0,ot=it.attributes.getFloat("alpha",1),ct=it.attributes.getFloat("beta",1);return(0,a.createAttributeWithCacheKey)({transA:c,transB:_,alpha:ot,beta:ct,isOptionalC:g})};e.parseGemmAttributesV7=it=>b(it,!1),e.parseGemmAttributesV11=it=>b(it,!0);const et=(it,g)=>{const c={name:"Gemm",inputNames:it.length===3?["A","B","C"]:["A","B"],inputTypes:it.length===3?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],key:g.cacheKey};return Object.assign(Object.assign({},c),{get:()=>st(c,it,g)})},st=(it,g,c)=>{const _=g[0].dims.slice(),ot=g[1].dims.slice(),[ct,dt]=d.GemmUtil.getShapeOfGemmResult(_,c.transA,ot,c.transB,g.length===3?g[2].dims:void 0),pt=[ct,dt];if(!pt)throw new Error("Can't use gemm on the given tensors");let ft=_[_.length-1],ht="";c.transA&&(ft=_[0]),c.transA&&c.transB?ht="value += _A_T(a) * _B_T(b);":c.transA&&!c.transB?ht="value += _A_T(a) * _B(b);":!c.transA&&c.transB?ht="value += _A(a) * _B_T(b);":c.transA||c.transB||(ht="value += _A(a) * _B(b);");const bt=pt.length,mt=`
      float process(int indices[${bt}]) {
          int a[${bt}];
          int b[${bt}];
          ${g.length===3?`int c[${g[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${g.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${ft}; ++k) {
              a[${bt-1}] = k;
              b[${bt-2}] = k;
              ${ht}
          }

          value = value * alpha;
          ${g.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},it),{output:{dims:pt,type:g[0].type,textureType:h.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:c.alpha},{name:"beta",type:"float",data:c.beta}],shaderSource:mt})},$=(it,g)=>{if(!it)throw new Error("Input is missing");if(g.isOptionalC&&(it.length<2||it.length>3))throw new Error("Invaid input shape.");if(!g.isOptionalC&&it.length!==3)throw new Error("Gemm requires 3 inputs");if(it.length===3&&it[2].dims.length!==1&&it[2].dims.length!==2)throw new Error("Invalid input shape of C");if(it[0].type!=="float32"&&it[0].type!=="float64"||it[1].type!=="float32"&&it[1].type!=="float64"||it.length===3&&it[2].type!=="float32"&&it[2].type!=="float64")throw new Error("Invalid input type.");if(it[0].type!==it[1].type||it.length===3&&it[0].type!==it[2].type)throw new Error("Input types are mismatched")}},8555:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedIm2ColProgramInfoLoader=void 0;const a=s(5060),d=s(2039),h=s(2827);e.createPackedIm2ColProgramInfoLoader=(b,et,st,$,it)=>{const g=(c=it.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[d.TextureType.packed],cacheHint:c});var c;return Object.assign(Object.assign({},g),{get:()=>((_,ot,ct,dt,pt,ft)=>{const ht=ct.dims,bt=dt.dims,mt=pt.length,$t=[bt[1]*bt[2]*bt[3],pt[2]*pt[3]],Tt=bt[2]*bt[3],Nt=(0,h.unpackFromChannel)(),Ct=(0,a.getGlsl)(_.session.backend.glContext.version);let Ft="";for(let mn=0;mn<=1;mn++)for(let yn=0;yn<=1;yn++)Ft+=`
            blockIndex = rc.x + ${yn};
            pos = rc.y + ${mn};

            if(blockIndex < ${$t[1]} && pos < ${$t[0]}) {
              offsetY = int(blockIndex / (${pt[mt-1]})) * ${ft.strides[0]} -
                ${ft.pads[0]};
              d0 = offsetY + ${ft.dilations[0]} * (imod(pos, ${Tt}) / ${bt[2]});

              if(d0 < ${ht[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${pt[mt-1]}) * ${ft.strides[1]} -
                  ${ft.pads[1]};
                d1 = offsetX + ${ft.dilations[1]} * imod(imod(pos, ${Tt}), ${bt[2]});

                if(d1 < ${ht[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${Tt}.);
                    innerDims = vec2(d0, d1);
                    result[${2*mn+yn}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const ln=`
      ${Nt}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${Ft}
          ${Ct.output} = result;
      }
            `;return Object.assign(Object.assign({},ot),{output:{dims:$t,type:ct.type,textureType:d.TextureType.packed},shaderSource:ln,hasMain:!0})})(b,g,et,st,$,it)})}},3248:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.calculateIm2ColDims=e.createIm2ColProgramInfoLoader=void 0;const a=s(2039);e.createIm2ColProgramInfoLoader=(d,h,b,et,st)=>{const $=(it=st.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[a.TextureType.unpacked],cacheHint:it});var it;return Object.assign(Object.assign({},$),{get:()=>((g,c,_,ot,ct,dt)=>{const pt=_.dims,ft=ot.dims,ht=ct.length,bt=(0,e.calculateIm2ColDims)(pt,ft,ct,4),mt=`
        const int XC = ${pt[1]};
        const int XH = ${pt[2]};
        const int XW = ${pt[3]};
        const int KH = ${dt.kernelShape[0]};
        const int KW = ${dt.kernelShape[1]};
        const int dilationH = ${dt.dilations[0]};
        const int dilationW = ${dt.dilations[1]};
        const int strideH = ${dt.strides[0]};
        const int strideW = ${dt.strides[1]};
        const int padH = ${dt.pads[0]};
        const int padW = ${dt.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${ht}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${pt.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},c),{output:{dims:bt,type:_.type,textureType:a.TextureType.packedLastDimension},shaderSource:mt})})(0,$,h,b,et,st)})},e.calculateIm2ColDims=(d,h,b,et=4)=>[b[0],b[2],b[3],Math.ceil(d[1]*h[2]*h[3]/et)]},6572:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseImageScalerAttributes=e.imageScaler=void 0;const a=s(246),d=s(2039);e.imageScaler=($,it,g)=>(st(it),[$.run(b($,it,g),it)]),e.parseImageScalerAttributes=$=>{const it=$.attributes.getFloat("scale"),g=$.attributes.getFloats("bias");return(0,a.createAttributeWithCacheKey)({scale:it,bias:g})};const h={name:"ImageScaler",inputNames:["X"],inputTypes:[d.TextureType.unpacked]},b=($,it,g)=>{const c=Object.assign(Object.assign({},h),{cacheHint:g.cacheKey});return Object.assign(Object.assign({},c),{get:()=>((_,ot,ct,dt)=>{const pt=ct[0].dims.slice(),ft=pt.length,ht=`
      ${et(dt.bias.length)}
      float process(int indices[${ft}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},ot),{output:{dims:pt,type:ct[0].type,textureType:d.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:dt.bias.length,data:dt.bias},{name:"scale",type:"float",data:dt.scale}],shaderSource:ht})})(0,c,it,g)})},et=$=>{const it=[`float getBias(float bias[${$}], int channel) {`];for(let g=0;g<$;++g)g===0?it.push(`	if (channel == ${g}) { return bias[${g}]; }`):g===$-1?it.push(`	else { return bias[${g}]; }`):it.push(`	else if (channel == ${g}) { return bias[${g}]; }`);return it.push("	}"),it.join(`
`)},st=$=>{if(!$||$.length!==1)throw new Error("ImageScaler requires 1 input.");if($[0].dims.length!==4)throw new Error("Invalid input shape.");if($[0].type!=="float32"&&$[0].type!=="float64")throw new Error("Invalid input type.")}},3346:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseInstanceNormalizationAttributes=e.instanceNormalization=void 0;const a=s(5060),d=s(2039);e.instanceNormalization=(it,g,c)=>{$(g);const _=it.run(b(g[0]),g);return[it.run(st(it,g[0],c,_.dims),[g[0],_,g[1],g[2]])]},e.parseInstanceNormalizationAttributes=it=>it.attributes.getFloat("epsilon",1e-5);const h={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[d.TextureType.unpacked]},b=it=>Object.assign(Object.assign({},h),{get:()=>((g,c)=>{const _=c.dims.slice(),ot=_[1],ct=_[2]*_[3],dt=[_[0],ot],pt=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${_[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${_[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${ct});
        temp = 0.0;
        for(int a2=0; a2<${_[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${_[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${ct});

        return v;
      }`;return Object.assign(Object.assign({},g),{output:{dims:dt,type:c.type,textureType:d.TextureType.packedLastDimension},shaderSource:pt})})(h,it)}),et={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[d.TextureType.unpacked,d.TextureType.packedLastDimension,d.TextureType.unpacked,d.TextureType.unpacked]},st=(it,g,c,_)=>{const ot=Object.assign(Object.assign({},et),{cacheHint:`${c}`});return Object.assign(Object.assign({},ot),{get:()=>((ct,dt,pt,ft,ht)=>{const bt=(0,a.getGlsl)(ct.session.backend.glContext.version),[mt,$t]=ct.calculateTextureWidthAndHeight(ht,d.TextureType.packedLastDimension),[Tt,Nt]=[mt/4,$t],Ct=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${Tt}, ${Nt});
        return ${bt.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},dt),{output:{dims:pt.dims,type:pt.type,textureType:d.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:ft}],shaderSource:Ct})})(it,ot,g,c,_)})},$=it=>{if(!it||it.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const g=it[0],c=it[1],_=it[2];if(g.dims.length<3||c.dims.length!==1||_.dims.length!==1)throw new Error("Invalid input shape.");if(c.dims[0]!==g.dims[1]||_.dims[0]!==g.dims[1])throw new Error("Input shapes are mismatched.");if(g.type!=="float32"&&g.type!=="float64"||c.type!=="float32"&&c.type!=="float64"||_.type!=="float32"&&_.type!=="float64")throw new Error("Invalid input type.");if(it[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},708:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedMatmulProgramInfoLoader=void 0;const a=s(2517),d=s(5060),h=s(2039),b=s(9390),et=s(2823),st=s(5623);e.createPackedMatmulProgramInfoLoader=($,it,g)=>{const c=(_=it.length>2,ot=g.activationCacheKey,{name:"MatMul (packed)",inputNames:_?["A","B","Bias"]:["A","B"],inputTypes:_?[h.TextureType.packed,h.TextureType.packed,h.TextureType.packed]:[h.TextureType.packed,h.TextureType.packed],cacheHint:ot});var _,ot;return Object.assign(Object.assign({},c),{get:()=>((ct,dt,pt,ft)=>{const ht=pt.length>2,bt=ht?"value += getBiasForMatmul();":"",mt=pt[0].dims,$t=pt[1].dims,Tt=a.BroadcastUtil.calcShape(mt,$t,!0),Nt=!a.ShapeUtil.areEqual(pt[0].dims,pt[1].dims);if(!Tt)throw new Error("Can't use matmul on the given tensors");const Ct=mt[mt.length-1],Ft=Math.ceil(Ct/2),ln=mt.length,mn=$t.length,yn=(0,d.getGlsl)(ct.session.backend.glContext.version),pn=(0,b.getCoordsDataType)(Tt.length),Ht=Tt.length,Gt=(0,b.getGlChannels)(),{activationFunction:cn,applyActivation:xn}=(0,et.getActivationSnippet)(ft),dn=ht?`${(0,st.getBiasForMatmul)(pn,Gt,pt[2].dims,Tt,!0)}`:"",wn=Nt?`${function(Sr,xr,Vr,Fr){let _f=[],h0=[];const Po=Vr[0].dims,No=Vr[1].dims,o0=Po.length,t0=No.length,xu=Fr.length,M0=xu-o0,k0=xu-t0;_f=Po.map((_i,x0)=>`coords.${xr[x0+M0]}`),_f[o0-1]="i*2",_f.join(", "),h0=No.map((_i,x0)=>`coords.${xr[x0+k0]}`),h0[t0-2]="i*2",h0.join(", ");const T0=a.BroadcastUtil.getBroadcastDims(Po,Fr),j0=a.BroadcastUtil.getBroadcastDims(No,Fr),O0=T0.map(_i=>`coords.${xr[_i+M0]} = 0;`).join(`
`),v0=j0.map(_i=>`coords.${xr[_i+k0]} = 0;`).join(`
`),A0=`int lastDim = coords.${xr[xu-1]};
  coords.${xr[xu-1]} = coords.${xr[xu-2]};
  coords.${xr[xu-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${Sr} coords = getOutputCoords();
  ${A0}
  ${O0}
  vec4 outputValue = getA(${_f});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${Sr} coords = getOutputCoords();
  ${A0}
  ${v0}
  vec4 outputValue = getB(${h0});
  return outputValue;
}`}(pn,Gt,pt,Tt)}`:"",gn=Nt?"getAAtOutCoordsMatmul(i)":`getA(${function(Sr,xr){let Vr="";for(let Fr=0;Fr<xr-2;Fr++)Vr+=`rc.${Sr[Fr]}, `;return Vr+=`rc.${Sr[xr-2]}, i*2`,Vr}(Gt,ln)})`,En=Nt?"getBAtOutCoordsMatmul(i)":`getB(${function(Sr,xr){let Vr="";for(let Fr=0;Fr<xr-2;Fr++)Vr+=`rc.${Sr[Fr]}, `;return Vr+=`i*2, rc.${Sr[xr-1]}`,Vr}(Gt,mn)})`,_r=`
            ${wn}
            ${dn}
            ${cn}
            void main() {
              ${Nt?"":`${pn} rc =
          getOutputCoords(); int lastDim = rc.${Gt[Ht-1]}; rc.${Gt[Ht-1]} =
          rc.${Gt[Ht-2]}; rc.${Gt[Ht-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${Ft}; i++) {
                vec4 a = ${gn};
                vec4 b = ${En};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${bt}
              ${xn}
              ${yn.output} = value;
            }`;return Object.assign(Object.assign({},dt),{output:{dims:Tt,type:pt[0].type,textureType:h.TextureType.packed},shaderSource:_r,hasMain:!0})})($,c,it,g)})}},5623:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getBiasForMatmul=e.createMatmulProgramInfoLoader=e.parseMatMulAttributes=e.matMul=void 0;const a=s(2517),d=s(2039),h=s(9390),b=s(2823),et=s(708);function st(g,c){const _=(ot=g.length>2,ct=c.activationCacheKey,{name:"MatMul",inputNames:ot?["A","B","Bias"]:["A","B"],inputTypes:ot?[d.TextureType.unpacked,d.TextureType.unpacked,d.TextureType.unpacked]:[d.TextureType.unpacked,d.TextureType.unpacked],cacheHint:ct});var ot,ct;return Object.assign(Object.assign({},_),{get:()=>function(dt,pt,ft){const ht=pt[0].dims,bt=pt[1].dims,mt=a.BroadcastUtil.calcShape(ht,bt,!0);if(!mt)throw new Error("Can't use matmul on the given tensors");const $t=(0,h.getCoordsDataType)(mt.length),Tt=(0,h.getGlChannels)(),{activationFunction:Nt,applyActivation:Ct}=(0,b.getActivationSnippet)(ft),Ft=pt.length>2,ln=Ft?"value += getBiasForMatmul();":"",mn=Ft?`${it($t,Tt,pt[2].dims,mt,!1)}`:"",yn=mt.length,pn=ht.length,Ht=bt.length,Gt=`
    ${Nt}
    ${mn}
    float process(int indices[${yn}]) {
        int a[${pn}];
        int b[${Ht}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${ht[ht.length-1]}; ++k) {
            a[${pn-1}] = k;
            b[${Ht-2}] = k;
            value += _A(a) * _B(b);
        }
        ${ln}
        ${Ct}
        return value;
    }`;return Object.assign(Object.assign({},dt),{output:{dims:mt,type:pt[0].type,textureType:d.TextureType.unpacked},shaderSource:Gt})}(_,g,c)})}e.matMul=(g,c,_)=>($(c),g.session.pack?[g.run((0,et.createPackedMatmulProgramInfoLoader)(g,c,_),c)]:[g.run(st(c,_),c)]),e.parseMatMulAttributes=g=>(0,b.parseInternalActivationAttributes)(g.attributes),e.createMatmulProgramInfoLoader=st;const $=g=>{if(!g||g.length!==2)throw new Error("MatMul requires 2 inputs.");if(g[0].dims[g[0].dims.length-1]!==g[1].dims[g[1].dims.length-2])throw new Error("shared dimension does not match.");if(g[0].type!=="float32"&&g[0].type!=="float64"||g[1].type!=="float32"&&g[1].type!=="float64")throw new Error("inputs should be float type");if(g[0].type!==g[1].type)throw new Error("inputs types should match")};function it(g,c,_,ot,ct){let dt="";const pt=_.length,ft=ot.length,ht=ft-pt;dt=ft<2&&pt>0?"coords":_.map(($t,Tt)=>`coords.${c[Tt+ht]}`).join(", ");const bt=a.BroadcastUtil.getBroadcastDims(_,ot).map($t=>`coords.${c[$t+ht]} = 0;`).join(`
`);let mt="vec4(outputValue.xx, outputValue.yy)";return a.ShapeUtil.size(_)===1&&(mt="vec4(outputValue.x)"),ct?`
vec4 getBiasForMatmul() {
  ${g} coords = getOutputCoords();
  ${bt}
  vec4 outputValue = getBias(${dt});
  return ${mt};
}`:`
float getBiasForMatmul() {
  ${g} coords = getOutputCoords();
  ${bt}
  return getBias(coords.x);
}`}e.getBiasForMatmul=it},2403:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackProgramInfoLoader=void 0;const a=s(5060),d=s(2039),h=s(9390),b=s(2827),et={name:"pack",inputNames:["A"],inputTypes:[d.TextureType.unpackedReversed]};e.createPackProgramInfoLoader=(st,$)=>Object.assign(Object.assign({},et),{get:()=>((it,g)=>{const c=(0,a.getGlsl)(it.session.backend.glContext.version),_=g.dims,ot=_.length,ct=g.dims.length,dt=(0,h.getCoordsDataType)(ct),pt=(0,b.getChannels)("rc",ct),ft=(ht=ct,bt=pt,mt=_[_.length-2],$t=_[_.length-1],ht===0||ht===1?"":`
    int r = ${bt[ht-2]};
    int c = ${bt[ht-1]};
    int rp1 = ${bt[ht-2]} + 1;
    int cp1 = ${bt[ht-1]} + 1;
    bool rEdge = rp1 >= ${$t};
    bool cEdge = cp1 >= ${mt};
    `);var ht,bt,mt,$t;let Tt;Tt=ot===0?[1,1]:ot===1?[_[0],1]:[_[ct-1],_[ct-2]];const Nt=function(ln,mn,yn){if(ln===0)return"false";if(ln===1)return`rc > ${mn[0]}`;let pn="";for(let Ht=ln-2;Ht<ln;Ht++)pn+=`${yn[Ht]} >= ${mn[Ht-ln+2]}`,Ht<ln-1&&(pn+="||");return pn}(ct,Tt,pt),Ct=function(ln,mn){const yn=ln.length;if(yn===0)return"getA(), 0, 0, 0";if(yn===1)return`getA(rc),
            rc + 1 >= ${ln[0]} ? 0. : getA(rc + 1),
            0, 0`;let pn="";if(yn>2)for(let Ht=0;Ht<yn-2;++Ht)pn+=`${mn[Ht]},`;return`getA(${pn}r, c),
          rEdge ? 0. : getA(${pn}rp1, c),
          cEdge ? 0. : getA(${pn}r, cp1),
          rEdge || cEdge ? 0. : getA(${pn}rp1, cp1)`}(_,pt),Ft=`
        void main() {
          ${dt} rc = getOutputCoords();

          if(${Nt}) {
            ${c.output} = vec4(0);
          } else {
            ${ft}

            ${c.output} = vec4(${Ct});
          }
        }
      `;return Object.assign(Object.assign({},et),{hasMain:!0,output:{dims:g.dims,type:g.type,textureType:d.TextureType.packed},shaderSource:Ft})})(st,$)})},2827:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.unpackFromChannel=e.getChannels=e.getVecChannels=void 0;const a=s(9390);function d(h,b){return(0,a.getGlChannels)(b).map(et=>`${h}.${et}`)}e.getVecChannels=d,e.getChannels=function(h,b){return b===1?[h]:d(h,b)},e.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},2870:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parsePadAttributesV11=e.padV11=e.parsePadAttributesV2=e.padV2=void 0;const a=s(246),d=s(2517),h=s(5060),b=s(2039),et={name:"Pad",inputNames:["A"],inputTypes:[b.TextureType.unpacked]};e.padV2=(dt,pt,ft)=>(it(pt),[dt.run(Object.assign(Object.assign({},et),{cacheHint:ft.cacheKey,get:()=>$(dt,pt[0],ft)}),pt)]),e.parsePadAttributesV2=dt=>{const pt=dt.attributes.getString("mode","constant"),ft=dt.attributes.getFloat("value",0),ht=dt.attributes.getInts("pads");return(0,a.createAttributeWithCacheKey)({mode:pt,value:ft,pads:ht})},e.padV11=(dt,pt,ft)=>{g(pt);const ht=st(dt,pt,ft);return(0,e.padV2)(dt,[pt[0]],ht)},e.parsePadAttributesV11=dt=>dt.attributes.getString("mode","constant");const st=(dt,pt,ft)=>{if(!dt.session.isInitializer(pt[1].dataId)||pt.length>=3&&!dt.session.isInitializer(pt[2].dataId))throw new Error("dynamic pad attributes are not allowed");const ht=Array.from(pt[1].integerData),bt=pt.length>=3?pt[2].floatData[0]:0;return(0,a.createAttributeWithCacheKey)({mode:ft,pads:ht,value:bt})},$=(dt,pt,ft)=>{const ht=d.ShapeUtil.padShape(pt.dims.slice(),ft.pads),bt=ht.length,mt=`
      ${c(dt,pt,ft)}
      float process(int[${bt}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[b.TextureType.unpacked],output:{dims:ht,type:pt.type,textureType:b.TextureType.unpacked},shaderSource:mt}},it=dt=>{if(!dt||dt.length!==1)throw new Error("Pad requires 1 input");if(dt[0].type!=="float32"&&dt[0].type!=="float64")throw new Error("Invalid input type.")},g=dt=>{if(!dt||dt.length!==2&&dt.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(dt[1].type!=="int32")throw new Error("Invalid input type.");if(dt.length>=3&&dt[2].type==="string")throw new Error("Invalid input type.")},c=(dt,pt,ft)=>{const ht=(0,h.getGlsl)(dt.session.backend.glContext.version),[bt,mt]=dt.calculateTextureWidthAndHeight(pt.dims,b.TextureType.unpacked),$t=d.ShapeUtil.computeStrides(pt.dims);switch(ft.mode){case"constant":return _(ht,pt.dims,$t,bt,mt,ft.pads,ft.value);case"reflect":return ot(ht,pt.dims,$t,bt,mt,ft.pads);case"edge":return ct(ht,pt.dims,$t,bt,mt,ft.pads);default:throw new Error("Invalid mode")}},_=(dt,pt,ft,ht,bt,mt,$t)=>{const Tt=pt.length;let Nt="";for(let Ct=Tt-1;Ct>=0;--Ct)Nt+=`
        k = m[${Ct}] - ${mt[Ct]};
        if (k < 0)  return constant;
        if (k >= ${pt[Ct]}) return constant;
        offset += k * ${ft[Ct]};
        `;return`
      float padA(int m[${Tt}]) {
        const float constant = float(${$t});
        int offset = 0;
        int k = 0;
        ${Nt}
        vec2 coords = offsetToCoords(offset, ${ht}, ${bt});
        float value = getColorAsFloat(${dt.texture2D}(A, coords));
        return value;
      }
      `},ot=(dt,pt,ft,ht,bt,mt)=>{const $t=pt.length;let Tt="";for(let Nt=$t-1;Nt>=0;--Nt)Tt+=`
        k = m[${Nt}] - ${mt[Nt]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(pt[Nt]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${pt[Nt]}) { k = _2n_1 - k; }
        }
        offset += k * ${ft[Nt]};
        `;return`
      float padA(int m[${$t}]) {
        int offset = 0;
        int k = 0;
        ${Tt}
        vec2 coords = offsetToCoords(offset, ${ht}, ${bt});
        float value = getColorAsFloat(${dt.texture2D}(A, coords));
        return value;
      }
      `},ct=(dt,pt,ft,ht,bt,mt)=>{const $t=pt.length;let Tt="";for(let Nt=$t-1;Nt>=0;--Nt)Tt+=`
        k = m[${Nt}] - ${mt[Nt]};
        if (k < 0)  k = 0;
        if (k >= ${pt[Nt]}) k = ${pt[Nt]-1};
        offset += k * ${ft[Nt]};
      `;return`
      float padA(int m[${$t}]) {
        int offset = 0;
        int k = 0;
        ${Tt}
        vec2 coords = offsetToCoords(offset, ${ht}, ${bt});
        float value = getColorAsFloat(${dt.texture2D}(A, coords));
        return value;
      }
      `}},2143:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.globalMaxPool=e.parseMaxPoolAttributes=e.maxPool=e.parseGlobalAveragePoolAttributes=e.globalAveragePool=e.parseAveragePoolAttributes=e.averagePool=void 0;const a=s(246),d=s(2517),h=s(2039);e.averagePool=(ct,dt,pt)=>{g(dt);const ft={name:"AveragePool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:pt.cacheKey};return[ct.run(Object.assign(Object.assign({},ft),{get:()=>b(dt,ft,!1,pt)}),dt)]},e.parseAveragePoolAttributes=ct=>{const dt=ct.attributes.getString("auto_pad","NOTSET"),pt=ct.attributes.getInt("ceil_mode",0),ft=ct.attributes.getInt("count_include_pad",0)!==0,ht=ct.attributes.getInts("kernel_shape"),bt=ct.attributes.getInts("strides",[]),mt=ct.attributes.getInts("pads",[]);if(pt!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,a.createAttributeWithCacheKey)({autoPad:dt,ceilMode:pt,countIncludePad:ft,kernelShape:ht,strides:bt,pads:mt})};const b=(ct,dt,pt,ft)=>{const[ht,bt]=st(ct,ft,pt),mt=d.ShapeUtil.size(ht.kernelShape);let $t="";ht.countIncludePad?$t+=`value /= float(${mt});`:$t+=`value /= float(${mt} - pad);`;const Tt=`
        ${c(ct[0].dims,ht,"value += _X(x);",$t,"0.0")}
      `;return Object.assign(Object.assign({},dt),{output:{dims:bt,type:ct[0].type,textureType:h.TextureType.unpacked},shaderSource:Tt})};e.globalAveragePool=(ct,dt,pt)=>{g(dt);const ft={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:`${pt.countIncludePad}`};return[ct.run(Object.assign(Object.assign({},ft),{get:()=>b(dt,ft,!0,pt)}),dt)]},e.parseGlobalAveragePoolAttributes=ct=>{const dt=ct.attributes.getInt("count_include_pad",0)!==0;return(0,a.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:dt,kernelShape:[],strides:[],pads:[]})},e.maxPool=(ct,dt,pt)=>{g(dt);const ft={name:"MaxPool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:pt.cacheKey};return[ct.run(Object.assign(Object.assign({},ft),{get:()=>et(dt,ft,!1,pt)}),dt)]},e.parseMaxPoolAttributes=ct=>{const dt=ct.attributes.getString("auto_pad","NOTSET"),pt=ct.attributes.getInt("ceil_mode",0),ft=ct.attributes.getInts("kernel_shape"),ht=ct.attributes.getInts("strides",[]),bt=ct.attributes.getInts("pads",[]),mt=ct.attributes.getInt("storage_order",0),$t=ct.attributes.getInts("dilations",[]);if(mt!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(pt!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,a.createAttributeWithCacheKey)({autoPad:dt,ceilMode:pt,countIncludePad:!1,kernelShape:ft,strides:ht,pads:bt,storageOrder:mt,dilations:$t})};const et=(ct,dt,pt,ft)=>{const[ht,bt]=st(ct,ft,pt),mt=`
      ${c(ct[0].dims,ht,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},dt),{output:{dims:bt,type:ct[0].type,textureType:h.TextureType.unpacked},shaderSource:mt})},st=(ct,dt,pt)=>{const ft=ct[0].dims.slice(),ht=Object.hasOwnProperty.call(dt,"dilations"),bt=dt.kernelShape.slice(),mt=dt.strides.slice(),$t=ht?dt.dilations.slice():[],Tt=dt.pads.slice();d.PoolConvUtil.adjustPoolAttributes(pt,ft,bt,mt,$t,Tt);const Nt=d.PoolConvUtil.computePoolOutputShape(pt,ft,mt,$t,bt,Tt,dt.autoPad),Ct=Object.assign({},dt);return ht?Object.assign(Ct,{kernelShape:bt,strides:mt,pads:Tt,dilations:$t,cacheKey:dt.cacheKey}):Object.assign(Ct,{kernelShape:bt,strides:mt,pads:Tt,cacheKey:dt.cacheKey}),[Ct,Nt]},$={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},it={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[h.TextureType.unpacked]};e.globalMaxPool=(ct,dt)=>(g(dt),[ct.run(Object.assign(Object.assign({},it),{get:()=>et(dt,it,!0,$)}),dt)]);const g=ct=>{if(!ct||ct.length!==1)throw new Error("Pool ops requires 1 input.");if(ct[0].type!=="float32"&&ct[0].type!=="float64")throw new Error("Invalid input type.")},c=(ct,dt,pt,ft,ht)=>{const bt=ct.length;if(dt.kernelShape.length<=2){const mt=dt.kernelShape[dt.kernelShape.length-1],$t=dt.strides[dt.strides.length-1],Tt=dt.pads[dt.pads.length/2-1],Nt=dt.pads[dt.pads.length-1],Ct=ct[bt-1];let Ft="",ln="",mn="";if(Ft=Tt+Nt!==0?`
          for (int i = 0; i < ${mt}; i++) {
            x[${bt} - 1] = indices[${bt} - 1] * ${$t} - ${Tt} + i;
            if (x[${bt} - 1] < 0 || x[${bt} - 1] >= ${Ct}) {
              pad++;
              continue;
            }
            ${pt}
          }`:`
          for (int i = 0; i < ${mt}; i++) {
            x[${bt} - 1] = indices[${bt} - 1] * ${$t} - ${Tt} + i;
            ${pt}
          }`,dt.kernelShape.length===2){const yn=dt.kernelShape[dt.kernelShape.length-2],pn=dt.strides[dt.strides.length-2],Ht=dt.pads[dt.pads.length/2-2],Gt=dt.pads[dt.pads.length-2],cn=ct[bt-2];ln=Ht+Gt!==0?`
            for (int j = 0; j < ${yn}; j++) {
              x[${bt} - 2] = indices[${bt} - 2] * ${pn} - ${Ht} + j;
              if (x[${bt} - 2] < 0 || x[${bt} - 2] >= ${cn}) {
                pad+= ${mt};
                continue;
              }
          `:`
            for (int j = 0; j < ${yn}; j++) {
              x[${bt} - 2] = indices[${bt} - 2] * ${pn} - ${Ht} + j;
            `,mn=`
          }
        `}return`
        float process(int indices[${bt}]) {
          int x[${bt}];
          copyVec(indices, x);

          float value = ${ht};
          int pad = 0;
          ${ln}
          ${Ft}
          ${mn}
          ${ft}
          return value;
        }
      `}{const mt=d.ShapeUtil.size(dt.kernelShape),$t=d.ShapeUtil.computeStrides(dt.kernelShape),Tt=$t.length,Nt=dt.pads.length,Ct=ot(Tt),Ft=_(ct,"inputDims"),ln=_(dt.pads,"pads"),mn=_($t,"kernelStrides"),yn=_(dt.strides,"strides");let pn="";return pn=dt.pads.reduce((Ht,Gt)=>Ht+Gt)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${pt}
          }`:`
          }
          ${pt}
        `,`
        ${Ct}
        float process(int indices[${bt}]) {
          int x[${bt}];
          copyVec(indices, x);
          int offset[${Tt}];
          int pads[${Nt}];
          int inputDims[${bt}];
          int kernelStrides[${Tt}];
          int strides[${Tt}];
          ${ln}
          ${Ft}
          ${yn}
          ${mn}

          float value = ${ht};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${mt}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${bt} - ${Tt}; j < ${bt}; j++) {
              x[j] = indices[j] * strides[j - ${bt} + ${Tt}]
                + offset[j - ${bt} + ${Tt}] - pads[j - 2];
              ${pn}
          }
          ${ft}

          return value;
        }
      `}},_=(ct,dt)=>{let pt="";for(let ft=0;ft<ct.length;ft++)pt+=`
      ${dt}[${ft}] = ${ct[ft]};
    `;return pt},ot=ct=>`
  void offsetToIndices(int offset, int[${ct}] strides, out int[${ct}] indices) {
    if (${ct} == 0) {
      return;
    }
    for (int i = 0; i < ${ct} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${ct} - 1] = offset;
  }`},4939:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.reduceLogSumSquare=e.reduceLogSum=e.reduceProd=e.reduceMin=e.reduceMax=e.reduceMean=e.reduceSum=e.parseReduceAttributes=void 0;const a=s(246),d=s(782),h=s(2517),b=s(2039),et=(it,g,c,_,ot)=>{$(g);const ct={name:_,inputNames:["A"],inputTypes:[b.TextureType.unpacked]};return[it.run(Object.assign(Object.assign({},ct),{cacheHint:c.cacheKey,get:()=>st(it,g,c,_,ot,ct)}),g)]};e.parseReduceAttributes=it=>{const g=it.attributes.getInts("axes",[]),c=it.attributes.getInt("keepdims",1)===1;return(0,a.createAttributeWithCacheKey)({axes:g,keepDims:c})};const st=(it,g,c,_,ot,ct)=>{const dt=[],pt=g[0].dims.length||1,ft=[],ht=h.ShapeUtil.normalizeAxes(c.axes,g[0].dims.length),bt=ot(g,ht);let mt=bt[1];for(let Tt=0;Tt<g[0].dims.length;Tt++)ht.indexOf(Tt)>=0||ht.length===0?(c.keepDims&&dt.push(1),mt=`
          for(int j${Tt} = 0; j${Tt} < ${g[0].dims[Tt]}; j${Tt}++) {
            inputIdx[${Tt}] = j${Tt};
            ${mt}
          }`):(ft.push(`inputIdx[${Tt}] = outputIdx[${dt.length}];`),dt.push(g[0].dims[Tt]));const $t=`
      float process(int outputIdx[${dt.length||1}]) {
        float value;                 // final result
        int inputIdx[${pt}];      // addressing input data
        ${ft.join(`
`)}
        ${bt[0]}       // init ops for reduce max/min
        ${mt}
        ${bt[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},ct),{output:{dims:dt,type:g[0].type,textureType:b.TextureType.unpacked},shaderSource:$t})},$=it=>{if(!it||it.length!==1)throw new Error("Reduce op requires 1 input.");if(d.NUMBER_TYPES.indexOf(it[0].type)===-1)throw new Error("Invalid input type.")};e.reduceSum=(it,g,c)=>et(it,g,c,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),e.reduceMean=(it,g,c)=>et(it,g,c,"ReduceMean",(_,ot)=>{let ct=1;for(let dt=0;dt<_[0].dims.length;dt++)(ot.indexOf(dt)>=0||ot.length===0)&&(ct*=_[0].dims[dt]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${ct}.;`]}),e.reduceMax=(it,g,c)=>et(it,g,c,"ReduceMax",(_,ot)=>{const ct=[];for(let dt=0;dt<_[0].dims.length;dt++)(ot.indexOf(dt)>=0||ot.length===0)&&ct.push(`inputIdx[${dt}] = 0;`);return[`${ct.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),e.reduceMin=(it,g,c)=>et(it,g,c,"ReduceMin",(_,ot)=>{const ct=[];for(let dt=0;dt<_[0].dims.length;dt++)(ot.indexOf(dt)>=0||ot.length===0)&&ct.push(`inputIdx[${dt}] = 0;`);return[`${ct.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),e.reduceProd=(it,g,c)=>et(it,g,c,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),e.reduceLogSum=(it,g,c)=>et(it,g,c,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),e.reduceLogSumSquare=(it,g,c)=>et(it,g,c,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7019:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.isReshapeCheap=e.processDims3D=e.createPackedReshape3DProgramInfoLoader=void 0;const a=s(2517),d=s(5060),h=s(2039),b=s(2827);e.createPackedReshape3DProgramInfoLoader=(et,st,$)=>{const it=(g=>({name:"Reshape (packed)",inputTypes:[h.TextureType.packed],inputNames:["A"],cacheHint:`${g}`}))($);return Object.assign(Object.assign({},it),{get:()=>((g,c,_,ot)=>{const ct=c.dims,dt=ot;let pt="";for(let bt=0;bt<4;bt++){let mt="";switch(bt){case 0:mt="outputCoords = rc;";break;case 1:mt="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:mt="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:mt="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}pt+=`
        ${mt}
        ${bt>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${bt}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${bt>0?"}":""}
      `}const ft=(0,d.getGlsl)(g.session.backend.glContext.version),ht=`
      ${function(bt){const mt=a.ShapeUtil.computeStrides(bt),$t=["b","r","c"],Tt="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${mt.map((Nt,Ct)=>`int ${$t[Ct]} = ${Tt} / ${Nt}; ${Ct===mt.length-1?`int ${$t[Ct+1]} = ${Tt} - ${$t[Ct]} * ${Nt}`:`index -= ${$t[Ct]} * ${Nt}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(ct)}
      ${function(bt){const mt=a.ShapeUtil.computeStrides(bt);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${mt[0]} + coords.z * ${mt[1]} + coords.y;
  }
`}(dt)}
      ${(0,b.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${dt[2]};
        int cols = ${dt[1]};

        ${pt}
        ${ft.output} = result;
      }
    `;return Object.assign(Object.assign({},_),{output:{dims:dt,type:c.type,textureType:h.TextureType.packed},shaderSource:ht,hasMain:!0})})(et,st,it,$)})},e.processDims3D=function(et){if(et.length===0)return[1,1,1];let st=1;for(let $=0;$<et.length-2;++$)st*=et[$];return[st,et.length>1?et[et.length-2]:1,et[et.length-1]]},e.isReshapeCheap=function(et,st){let $=!1;return $=et.length===0||st.length===0||(et.length<2||st.length<2?et[et.length-1]===st[st.length-1]:et[et.length-1]===st[st.length-1]&&et[et.length-2]===st[st.length-2]),$}},718:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.reshape=void 0;const a=s(2517);e.reshape=(d,h)=>{const b=a.ShapeUtil.calculateReshapedDims(h[0].dims,h[1].integerData);return d.session.pack?[d.reshapePacked(h[0],b)]:[d.reshapeUnpacked(h[0],b)]}},2268:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseResizeAttributesV11=e.parseResizeAttributesV10=e.resize=void 0;const a=s(5060),d=s(2039),h=s(9390),b=s(2827),et=s(9793),st={name:"Resize",inputNames:["A"],inputTypes:[d.TextureType.packed]};e.resize=(_,ot,ct)=>((0,et.validateInputs)(ot,ct),[_.run(Object.assign(Object.assign({},st),{cacheHint:ct.cacheKey,get:()=>$(_,ot,ct)}),ot)]),e.parseResizeAttributesV10=_=>(0,et.parseUpsampleAttributes)(_,10),e.parseResizeAttributesV11=_=>(0,et.parseUpsampleAttributes)(_,11);const $=(_,ot,ct)=>{const dt=(0,a.getGlsl)(_.session.backend.glContext.version),[pt,ft]=it(ot,ct);if(pt.every(pn=>pn===1)&&ct.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},st),{output:{dims:ft,type:ot[0].type,textureType:d.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${dt.texture2D}(X, TexCoords);
                    ${dt.output} = v;
                }`});const ht=ft.length;if(ht<2)throw new Error(`output dimension should be at least 2, but got ${ht}`);const bt=ft[ht-2],mt=ft[ht-1],$t=ot[0].dims;if(ht!==$t.length)throw new Error(`output dimension should match input ${$t.length}, but got ${ht}`);const Tt=$t[ht-2],Nt=$t[ht-1],Ct=pt[ht-2],Ft=pt[ht-1];let ln="";if(ct.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${ct.mode}'`);switch(ct.coordinateTransformMode){case"asymmetric":ln=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":ln=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":ln=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${mt}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${bt}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${mt}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${bt}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":ln=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${mt}.0 - 1.0, ${bt}.0 - 1.0, ${mt}.0 - 1.0,
                            ${bt}.0 - 1.0);
                        vec4 original = vec4(${Nt}.0 - 1.0, ${Tt}.0 - 1.0, ${Nt}.0 - 1.0,
                            ${Tt}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${ct.coordinateTransformMode}'`)}const mn=(0,h.getCoordsDataType)(ht),yn=`
            const vec2 inputWH = vec2(${Tt}.0, ${Nt}.0);
            const vec4 scaleWHWH = vec4(float(${Ct}), float(${Ft}), float(${Ct}), float(${Ft}));
            ${(0,b.unpackFromChannel)()}
            ${ln}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${mn} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${bt-1};
                bool hasNextCol = rc.z < ${mt-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${dt.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},st),{output:{dims:ft,type:ot[0].type,textureType:d.TextureType.packed},hasMain:!0,shaderSource:yn})},it=(_,ot)=>{const ct=_[0].dims;let dt,pt=ot.scales;if(pt.length===0){const ht=_[ot.scalesInputIdx];if(ht&&ht.size!==0){if(_[ot.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");pt=g(ht,ot.mode,ot.isResize)}else{const bt=_[ot.sizesInputIdx];if(!bt||bt.size===0)throw new Error("Either scales or sizes MUST be provided as input.");dt=Array.from(bt.integerData),pt=c(dt,ct,ot.mode,ot.isResize)}}else if(_[ot.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const ft=dt||ct.map((ht,bt)=>Math.floor(ht*pt[bt]));return[pt,ft]},g=(_,ot,ct)=>{const dt=Array.from(_.floatData);return(0,et.scalesValidation)(dt,ot,ct),dt},c=(_,ot,ct,dt)=>{const pt=ot.length,ft=new Array(pt);for(let ht=0,bt=pt;ht<bt;ht++)if(ot[ht]===0){if(_[ht]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");ft[ht]=1}else ft[ht]=_[ht]/ot[ht];return(0,et.scalesValidation)(ft,ct,dt),ft}},8117:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.shape=void 0;const a=s(9162);e.shape=(h,b)=>(d(b),[new a.Tensor([b[0].dims.length],"int32",void 0,void 0,new Int32Array(b[0].dims))]);const d=h=>{if(!h||h.length!==1)throw new Error("Shape requires 1 input.")}},2278:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.sliceV10=e.parseSliceAttributes=e.slice=void 0;const a=s(246),d=s(782),h=s(2517),b=s(2039),et={name:"Slice",inputNames:["A"],inputTypes:[b.TextureType.unpacked]};e.slice=(c,_,ot)=>($(_),[c.run(Object.assign(Object.assign({},et),{cacheHint:ot.cacheKey,get:()=>st(c,_[0],ot)}),_)]),e.parseSliceAttributes=c=>{const _=c.attributes.getInts("starts"),ot=c.attributes.getInts("ends"),ct=c.attributes.getInts("axes",[]);return(0,a.createAttributeWithCacheKey)({starts:_,ends:ot,axes:ct})};const st=(c,_,ot)=>{const ct=ot.axes.length===0?_.dims.slice(0).map(($t,Tt)=>Tt):ot.axes,dt=h.ShapeUtil.normalizeAxes(ct,_.dims.length),pt=ot.starts.map(($t,Tt)=>$t>_.dims[dt[Tt]]-1?_.dims[dt[Tt]]:h.ShapeUtil.normalizeAxis($t,_.dims[dt[Tt]])),ft=ot.ends.map(($t,Tt)=>$t>_.dims[dt[Tt]]-1?_.dims[dt[Tt]]:h.ShapeUtil.normalizeAxis($t,_.dims[dt[Tt]])),ht=_.dims.slice(),bt=[];for(let $t=0;$t<dt.length;$t++)ht[dt[$t]]=ft[$t]-pt[$t],pt[$t]>0&&bt.push(`outputIdx[${dt[$t]}] += ${pt[$t]};`);const mt=`
      float process(int outputIdx[${ht.length}]) {
        ${bt.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},et),{output:{dims:ht,type:_.type,textureType:b.TextureType.unpacked},shaderSource:mt})},$=c=>{if(!c||c.length!==1)throw new Error("Slice requires 1 input.");if(d.NUMBER_TYPES.indexOf(c[0].type)===-1)throw new Error("Invalid input type.")};e.sliceV10=(c,_)=>{g(_);const ot=it(c,_);return[c.run(Object.assign(Object.assign({},et),{cacheHint:ot.cacheKey,get:()=>st(c,_[0],ot)}),[_[0]])]};const it=(c,_)=>{if(!c.session.isInitializer(_[1].dataId)||!c.session.isInitializer(_[2].dataId)||_.length>=4&&!c.session.isInitializer(_[3].dataId)||_.length>=5&&!c.session.isInitializer(_[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(_.length>=5&&_[4].integerData.some(pt=>pt!==1))throw new Error("currently non-1 steps is not supported for Slice");const ot=Array.from(_[1].integerData),ct=Array.from(_[2].integerData),dt=_.length>=4?Array.from(_[3].integerData):[];return{starts:ot,ends:ct,axes:dt,cacheKey:`${dt};${ot};${ct}`}},g=c=>{if(!c||c.length<3||c.length>5)throw new Error("Invalid input number.");if(c[1].type!=="int32"||c[1].dims.length!==1)throw new Error("Invalid input type.");if(c[2].type!=="int32"||c[2].dims.length!==1)throw new Error("Invalid input type.");if(c.length>=4&&(c[3].type!=="int32"||c[3].dims.length!==1))throw new Error("Invalid input type.");if(c.length>=5&&(c[4].type!=="int32"||c[4].dims.length!==1))throw new Error("Invalid input type.")}},5524:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.softmaxV13=e.parseSoftmaxAttributesV13=e.parseSoftmaxAttributes=e.softmax=void 0;const a=s(246),d=s(2517),h=s(5060),b=s(2039),et=s(3738),st={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[b.TextureType.unpacked]},$={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[b.TextureType.unpacked,b.TextureType.unpacked]},it={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[b.TextureType.unpacked,b.TextureType.unpacked,b.TextureType.unpacked]};e.softmax=(dt,pt,ft)=>{ct(pt);const ht=pt[0].dims.slice(),bt=d.ShapeUtil.normalizeAxis(ft.axis,ht.length),mt=d.ShapeUtil.sizeToDimension(ht,bt),$t=d.ShapeUtil.sizeFromDimension(ht,bt);return g(dt,pt,ft,mt,$t)},e.parseSoftmaxAttributes=dt=>(0,a.createAttributeWithCacheKey)({axis:dt.attributes.getInt("axis",1)}),e.parseSoftmaxAttributesV13=dt=>(0,a.createAttributeWithCacheKey)({axis:dt.attributes.getInt("axis",-1)}),e.softmaxV13=(dt,pt,ft)=>{ct(pt);const ht=pt[0].dims.slice(),bt=d.ShapeUtil.normalizeAxis(ft.axis,ht.length),mt=ht.length,$t=bt!==mt-1,Tt=[];let Nt,Ct=[],Ft=[];$t&&(Ct=Array.from({length:mt}).map((pn,Ht)=>Ht),Ct[bt]=mt-1,Ct[mt-1]=bt,Ct.map(pn=>Tt.push(ht[pn])),Nt=(0,a.createAttributeWithCacheKey)({perm:Ct}),Ft=(0,et.transpose)(dt,pt,Nt));const ln=$t?d.ShapeUtil.sizeToDimension(Tt,mt-1):d.ShapeUtil.sizeToDimension(ht,mt-1),mn=$t?d.ShapeUtil.sizeFromDimension(Tt,mt-1):d.ShapeUtil.sizeFromDimension(ht,mt-1),yn=g(dt,$t?Ft:pt,ft,ln,mn);return $t?(0,et.transpose)(dt,yn,Nt):yn};const g=(dt,pt,ft,ht,bt)=>{const mt=c(dt,pt[0],ht,bt,[ht]),$t=dt.run(Object.assign(Object.assign({},st),{cacheHint:ft.cacheKey,get:()=>mt}),pt),Tt=_(dt,pt[0],ht,bt,mt.output.dims,[ht]),Nt=dt.run(Object.assign(Object.assign({},$),{cacheHint:ft.cacheKey,get:()=>Tt}),[pt[0],$t]),Ct=ot(dt,pt[0],ht,bt,mt.output.dims,Tt.output.dims);return[dt.run(Object.assign(Object.assign({},it),{cacheHint:ft.cacheKey,get:()=>Ct}),[pt[0],$t,Nt])]},c=(dt,pt,ft,ht,bt)=>{const[mt,$t]=dt.calculateTextureWidthAndHeight(pt.dims,b.TextureType.unpacked),Tt=bt.length;if(ft<1||ht<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(bt.length!==1)throw new Error("Dimensionality of the output should be 1");if(bt[0]!==ft)throw new Error("Shape of the output should be equal to logical row count");const Nt=(0,h.getGlsl)(dt.session.backend.glContext.version),Ct=`
      float process(int[${Tt}] indices) {
        int logical_row_start_offset = indices[0] * ${ht};

        float max = getColorAsFloat(${Nt.texture2D}(A, offsetToCoords(logical_row_start_offset, ${mt},
        ${$t} )));
        for(int i=1; i<${ht}; ++i)
        {
          float current = getColorAsFloat(${Nt.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${mt}, ${$t})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},st),{output:{dims:bt,type:pt.type,textureType:b.TextureType.unpacked},shaderSource:Ct})},_=(dt,pt,ft,ht,bt,mt)=>{const[$t,Tt]=dt.calculateTextureWidthAndHeight(pt.dims,b.TextureType.unpacked),Nt=mt.length;if(ft<1||ht<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(mt.length!==1)throw new Error("Dimensionality of the output should be 1");if(mt[0]!==ft)throw new Error("Shape of the output should be equal to logical row count");if(bt.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(bt[0]!==ft)throw new Error("Shape of the intermediate results should be equal to logical row count");const Ct=`
      float process(int[${Nt}] indices) {
        int logical_row_start_offset = indices[0] * ${ht};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${ht}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,h.getGlsl)(dt.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${$t}, ${Tt}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},$),{output:{dims:mt,type:pt.type,textureType:b.TextureType.unpacked},shaderSource:Ct})},ot=(dt,pt,ft,ht,bt,mt)=>{const[$t,Tt]=dt.calculateTextureWidthAndHeight(pt.dims,b.TextureType.unpacked),Nt=pt.dims.length;if(ft<1||ht<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(bt.length!==1||mt.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(bt[0]!==ft||mt[0]!==ft)throw new Error("Shape of the intermediate results should be equal to logical row count");const Ct=`
      float process(int[${Nt}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${$t}, ${Tt});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${ht};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},it),{output:{dims:pt.dims,type:pt.type,textureType:b.TextureType.unpacked},shaderSource:Ct})},ct=dt=>{if(!dt||dt.length!==1)throw new Error("Softmax requires 1 input.");if(dt[0].type!=="float32"&&dt[0].type!=="float64")throw new Error("Invalid input type")}},5975:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseSplitAttributes=e.split=void 0;const a=s(246),d=s(2517),h=s(2039),b={name:"Split",inputNames:["A"],inputTypes:[h.TextureType.unpacked]};e.split=(it,g,c)=>{$(g);const _=d.ShapeUtil.normalizeAxis(c.axis,g[0].dims.length),ot=et(it,g,_,c),ct=[];for(let dt=0;dt<ot;++dt)ct.push(it.run(Object.assign(Object.assign({},b),{cacheHint:`${c.cacheKey};${dt}`,get:()=>st(it,g[0],c,_,dt)}),g));return ct},e.parseSplitAttributes=it=>{const g=it.attributes.getInt("axis",0),c=it.attributes.getInts("split",[]),_=it.outputs.length;return(0,a.createAttributeWithCacheKey)({axis:g,split:c,numOutputs:_})};const et=(it,g,c,_)=>{const[,ot]=d.SplitUtil.splitShape(g[0].dims,c,_.split,_.numOutputs);return ot.length},st=(it,g,c,_,ot)=>{const[ct,dt]=d.SplitUtil.splitShape(g.dims,_,c.split,c.numOutputs),pt=dt[ot],ft=ct[ot],ht=`
      float process(int indices[${ft.length}]) {
        indices[${_}] += ${pt};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},b),{cacheHint:`${c.cacheKey}:${ot}`,output:{dims:ft,type:g.type,textureType:h.TextureType.unpacked},shaderSource:ht})},$=it=>{if(!it||it.length!==1)throw new Error("Split requires one input.");if(it[0].type!=="int8"&&it[0].type!=="uint8"&&it[0].type!=="int16"&&it[0].type!=="uint16"&&it[0].type!=="int32"&&it[0].type!=="uint32"&&it[0].type!=="float32"&&it[0].type!=="float64"&&it[0].type!=="bool")throw new Error("Invalid input type.")}},3933:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseSqueezeAttributes=e.squeezeV13=e.squeeze=void 0;const a=s(2517);e.squeeze=(b,et,st)=>{d(et);const $=a.ShapeUtil.squeezeShape(et[0].dims,st);return[b.reshapeUnpacked(et[0],$)]},e.squeezeV13=(b,et)=>(h(et),(0,e.squeeze)(b,[et[0]],Array.from(et[1].integerData))),e.parseSqueezeAttributes=b=>b.attributes.getInts("axes");const d=b=>{if(!b||b.length!==1)throw new Error("Squeeze requires 1 input.");if(b[0].type==="string")throw new Error("invalid input tensor types.")},h=b=>{if(!b||b.length!==2)throw new Error("Squeeze requires 2 inputs.");if(b[1].type!=="int32")throw new Error("Invalid input type.")}},6558:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.sum=void 0;const a=s(5060),d=s(2039);e.sum=(et,st)=>{b(st);const $={name:"Sum",inputNames:st.map((it,g)=>`X${g}`),inputTypes:new Array(st.length).fill(d.TextureType.unpacked)};return[et.run(Object.assign(Object.assign({},$),{get:()=>h(et,st,$)}),st)]};const h=(et,st,$)=>{const it=(0,a.getGlsl)(et.session.backend.glContext.version),g=st[0].dims.slice(),c=`
      void main() {
        vec4 result = ${st.map((_,ot)=>`${it.texture2D}(X${ot},TexCoords)`).join(" + ")};
        ${it.output} = result;
      }
    `;return Object.assign(Object.assign({},$),{output:{dims:g,type:st[0].type,textureType:d.TextureType.unpacked},hasMain:!0,shaderSource:c})},b=et=>{if(!et||et.length===0)throw new Error("Sum requires inputs.");const st=et[0].dims.length;for(let $=1;$<et.length;$++){if(st!==et[$].dims.length)throw new Error("Input shapes are mismatched.");for(let it=0;it<st;it++)if(et[0].dims[it]!==et[$].dims[it])throw new Error("Input shapes are not matched.")}if(et[0].type!=="float32"&&et[0].type!=="float64")throw new Error("Invalid input type.");for(let $=1;$<et.length;$++)if(et[0].type!==et[$].type)throw new Error("Input types are not matched.")}},5723:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.tile=void 0;const a=s(782),d=s(2039);e.tile=(et,st)=>{b(st);const $={name:"Tile",inputNames:["A"],inputTypes:[d.TextureType.unpacked]};return[et.run(Object.assign(Object.assign({},$),{get:()=>h(et,st,$)}),st)]};const h=(et,st,$)=>{const it=st[0].dims.slice(),g=new Array(it.length),c=[];for(let ct=0;ct<it.length;ct++)g[ct]=it[ct]*st[1].numberData[ct],c.push(`inputIdx[${ct}] = int(mod(float(outputIdx[${ct}]), ${it[ct]}.));`);const _=g.length,ot=`
      float process(int outputIdx[${_}]) {
        int inputIdx[${_}];
        ${c.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},$),{output:{dims:g,type:st[0].type,textureType:d.TextureType.unpacked},shaderSource:ot})},b=et=>{if(!et||et.length!==2)throw new Error("Tile requires 2 input.");if(et[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(et[1].dims[0]!==et[0].dims.length)throw new Error("Invalid input shape.");if(a.NUMBER_TYPES.indexOf(et[0].type)===-1)throw new Error("Invalid input type.");if(et[1].type!=="int32"&&et[1].type!=="int16")throw new Error("Invalid repeat type.")}},3738:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseTransposeAttributes=e.transpose=void 0;const a=s(246),d=s(2517),h=s(2039),b={name:"Transpose",inputNames:["A"],inputTypes:[h.TextureType.unpacked]};e.transpose=(c,_,ot)=>(g(_),[c.run(Object.assign(Object.assign({},b),{cacheHint:ot.cacheKey,get:()=>et(c,_[0],ot.perm)}),_)]),e.parseTransposeAttributes=c=>(0,a.createAttributeWithCacheKey)({perm:c.attributes.getInts("perm",[])});const et=(c,_,ot)=>{const ct=_.dims;ot=st(ct,ot);const dt=$(ct,ot),pt=ct.length,ft=`
      ${it("perm",ot,pt)}
      float process(int indices[${pt}]) {
        int a[${pt}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},b),{output:{dims:dt,type:_.type,textureType:h.TextureType.unpacked},shaderSource:ft})},st=(c,_)=>(_&&_.length!==c.length&&(_=[...c.keys()].reverse()),_),$=(c,_)=>(_=st(c,_),d.ShapeUtil.sortBasedOnPerm(c,_)),it=(c,_,ot)=>{const ct=[];ct.push(`void ${c}(out int a[${ot}], int src[${ot}]) {`);for(let dt=0;dt<ot;++dt)ct.push(`	a[${_[dt]}]=src[${dt}];`);return ct.push("	}"),ct.join(`
`)},g=c=>{if(!c||c.length!==1)throw new Error("Transpose requires 1 input.");if(c[0].type!=="float32"&&c[0].type!=="float64")throw new Error("input should be float tensor")}},8710:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.encodeAsUint8=void 0;const a=s(5060),d=s(2039);e.encodeAsUint8=(h,b)=>{const et=b.shape,st=(0,a.getGlsl)(h.session.backend.glContext.version),$=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${st.texture2D}(X,TexCoords).r;
      ${st.output} = encodeAsUint8(value);
    }`,it={name:"Uint8Encode",inputTypes:[d.TextureType.unpacked],inputNames:["X"],output:{dims:et,type:b.tensor.type,textureType:d.TextureType.downloadUint8AsFloat},shaderSource:$,hasMain:!0};return h.executeProgram(it,[b.tensor])}},4909:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.tanh=e.tan=e.sqrt=e.sin=e.sigmoid=e.relu=e.not=e.neg=e.log=e.parseLeakyReluAttributes=e.leakyRelu=e.identity=e.floor=e.exp=e.parseEluAttributes=e.elu=e.cos=e.ceil=e.clipV11=e.parseClipAttributes=e.clip=e.atan=e.asin=e.acos=e.abs=e.glslTanh=e.glslTan=e.glslSqrt=e.glslSigmoid=e.glslRelu=e.glslSin=e.glslNot=e.glslNeg=e.glslLog=e.glslLeakyRelu=e.glslIdentity=e.glslClip=e.glslFloor=e.glslExp=e.glslElu=e.glslCos=e.glslCeil=e.glslAtan=e.glslAsin=e.glslAcos=e.glslAbs=void 0;const a=s(246),d=s(2517),h=s(8520),b=s(5060),et=s(2039);function st(){return yn("abs")}function $(){return yn("acos")}function it(){return yn("asin")}function g(){return yn("atan")}function c(){return yn("ceil")}function _(){return yn("cos")}function ot(Gt){const cn="elu";return{body:`
  const float alpha = float(${Gt});

  float ${cn}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${cn}_(vec4 v) {
    return vec4(${cn}_(v.x), ${cn}_(v.y), ${cn}_(v.z), ${cn}_(v.w));
  }
  `,name:cn,type:h.FunctionType.ValueBased}}function ct(){return yn("exp")}function dt(){return yn("floor")}function pt(Gt,cn){const xn="clip";return{body:`
  const float min = float(${Gt});
  const float max = float(${cn});

  float ${xn}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${xn}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:xn,type:h.FunctionType.ValueBased}}function ft(){const Gt="indentity";return{body:`
  float ${Gt}_(float a) {
    return a;
  }
  vec4 ${Gt}_(vec4 v) {
    return v;
  }
  `,name:Gt,type:h.FunctionType.ValueBased}}function ht(Gt){const cn="leakyRelu";return{body:`
  const float alpha = float(${Gt});

  float ${cn}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${cn}_(vec4 v) {
    return vec4(${cn}_(v.x), ${cn}_(v.y), ${cn}_(v.z), ${cn}_(v.w));
  }
  `,name:cn,type:h.FunctionType.ValueBased}}function bt(){return yn("log")}function mt(){const Gt="neg";return{body:`
  float ${Gt}_(float a) {
    return -a;
  }
  vec4 ${Gt}_(vec4 v) {
    return -v;
  }
  `,name:Gt,type:h.FunctionType.ValueBased}}function $t(){const Gt="not";return{body:`
  float ${Gt}_(float a) {
    return float( ! bool(a) );
  }
  bool ${Gt}_(bool a) {
    return !a;
  }
  vec4 ${Gt}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${Gt}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:Gt,type:h.FunctionType.ValueBased}}function Tt(){return yn("sin")}function Nt(){const Gt="relu";return{body:`
  float ${Gt}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${Gt}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:Gt,type:h.FunctionType.ValueBased}}function Ct(){const Gt="sigmoid";return{body:`
  float ${Gt}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${Gt}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:Gt,type:h.FunctionType.ValueBased}}function Ft(){return yn("sqrt")}function ln(){return yn("tan")}function mn(){const Gt="tanh";return{body:`
  float ${Gt}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${Gt}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:Gt,type:h.FunctionType.ValueBased}}function yn(Gt){return{body:`
  float ${Gt}_(float a) {
    return ${Gt}(a);
  }
  vec4 ${Gt}_(vec4 v) {
    return ${Gt}(v);
  }
  `,name:Gt,type:h.FunctionType.ValueBased}}e.glslAbs=st,e.glslAcos=$,e.glslAsin=it,e.glslAtan=g,e.glslCeil=c,e.glslCos=_,e.glslElu=ot,e.glslExp=ct,e.glslFloor=dt,e.glslClip=pt,e.glslIdentity=ft,e.glslLeakyRelu=ht,e.glslLog=bt,e.glslNeg=mt,e.glslNot=$t,e.glslSin=Tt,e.glslRelu=Nt,e.glslSigmoid=Ct,e.glslSqrt=Ft,e.glslTan=ln,e.glslTanh=mn;const pn=(Gt,cn,xn,dn)=>{const wn=Gt.session.pack?et.TextureType.packed:et.TextureType.unpacked,gn={name:xn.name,inputTypes:[wn],inputNames:["A"],cacheHint:dn};return Object.assign(Object.assign({},gn),{get:()=>((En,_r,Sr,xr)=>{const Vr=En.session.pack?et.TextureType.packed:et.TextureType.unpacked,Fr=(0,b.getGlsl)(En.session.backend.glContext.version);return Object.assign(Object.assign({},_r),{output:{dims:Sr.dims,type:Sr.type,textureType:Vr},shaderSource:`
     ${xr.body}
     void main() {
       vec4 v = ${Fr.texture2D}(A, TexCoords);
       v = ${xr.name}_(v);
       ${Fr.output} = v;
     }
     `,hasMain:!0})})(Gt,gn,cn,xn)})};e.abs=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],st()),cn)],e.acos=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],$()),cn)],e.asin=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],it()),cn)],e.atan=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],g()),cn)],e.clip=(Gt,cn,xn)=>[Gt.run(pn(Gt,cn[0],pt(xn.min,xn.max),xn.cacheKey),cn)],e.parseClipAttributes=Gt=>(0,a.createAttributeWithCacheKey)({min:Gt.attributes.getFloat("min",d.MIN_CLIP),max:Gt.attributes.getFloat("max",d.MAX_CLIP)}),e.clipV11=(Gt,cn)=>{const xn=Ht(Gt,cn);return(0,e.clip)(Gt,[cn[0]],xn)};const Ht=(Gt,cn)=>{if(cn.length>=3&&(!Gt.session.isInitializer(cn[1].dataId)||!Gt.session.isInitializer(cn[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const xn=cn.length>=3?cn[1].numberData[0]:d.MIN_CLIP,dn=cn.length>=3?cn[2].numberData[0]:d.MAX_CLIP;return(0,a.createAttributeWithCacheKey)({min:xn,max:dn})};e.ceil=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],c()),cn)],e.cos=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],_()),cn)],e.elu=(Gt,cn,xn)=>[Gt.run(pn(Gt,cn[0],ot(xn.alpha),xn.cacheKey),cn)],e.parseEluAttributes=Gt=>(0,a.createAttributeWithCacheKey)({alpha:Gt.attributes.getFloat("alpha",1)}),e.exp=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],ct()),cn)],e.floor=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],dt()),cn)],e.identity=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],ft()),cn)],e.leakyRelu=(Gt,cn,xn)=>[Gt.run(pn(Gt,cn[0],ht(xn.alpha),xn.cacheKey),cn)],e.parseLeakyReluAttributes=Gt=>(0,a.createAttributeWithCacheKey)({alpha:Gt.attributes.getFloat("alpha",.01)}),e.log=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],bt()),cn)],e.neg=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],mt()),cn)],e.not=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],$t()),cn)],e.relu=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],Nt()),cn)],e.sigmoid=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],Ct()),cn)],e.sin=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],Tt()),cn)],e.sqrt=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],Ft()),cn)],e.tan=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],ln()),cn)],e.tanh=(Gt,cn)=>[Gt.run(pn(Gt,cn[0],mn()),cn)]},5611:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createUnpackProgramInfoLoader=e.createUnpackProgramInfo=void 0;const a=s(5060),d=s(2039),h=s(9390),b=s(2827),et={name:"unpack",inputNames:["A"],inputTypes:[d.TextureType.packed]};e.createUnpackProgramInfo=(st,$)=>{const it=$.dims.length,g=(0,b.getChannels)("rc",it),c=g.slice(-2),_=(0,h.getCoordsDataType)(it),ot=(0,b.unpackFromChannel)(),ct=$.dims.length===0?"":function(ft,ht){if(ft===1)return"rc";let bt="";for(let mt=0;mt<ft;mt++)bt+=ht[mt],mt<ft-1&&(bt+=",");return bt}(it,g),dt=it<=1?"rc":`vec2(${c.join(",")})`,pt=`
    ${ot}
    void main() {
      ${_} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${ct});

       ${(0,a.getGlsl)(st.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${dt}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},et),{hasMain:!0,output:{dims:$.dims,type:$.type,textureType:d.TextureType.unpacked},shaderSource:pt})},e.createUnpackProgramInfoLoader=(st,$)=>Object.assign(Object.assign({},et),{get:()=>(0,e.createUnpackProgramInfo)(st,$)})},8428:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseUnsqueezeAttributes=e.unsqueezeV13=e.unsqueeze=void 0;const a=s(2517);e.unsqueeze=(b,et,st)=>{d(et);const $=a.ShapeUtil.unsqueezeShape(et[0].dims,st);return[b.reshapeUnpacked(et[0],$)]},e.unsqueezeV13=(b,et)=>(h(et),(0,e.unsqueeze)(b,[et[0]],Array.from(et[1].integerData))),e.parseUnsqueezeAttributes=b=>b.attributes.getInts("axes");const d=b=>{if(!b||b.length!==1)throw new Error("Unsqueeze requires 1 input.");if(b[0].type==="string")throw new Error("invalid input tensor types.")},h=b=>{if(!b||b.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(b[1].type!=="int32")throw new Error("Invalid input type.")}},9793:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.scalesValidation=e.validateInputs=e.parseUpsampleAttributes=e.parseUpsampleAttributesV9=e.parseUpsampleAttributesV7=e.upsample=void 0;const a=s(246),d=s(5060),h=s(2039),b={name:"Upsample",inputNames:["X"],inputTypes:[h.TextureType.unpacked]};e.upsample=(st,$,it)=>((0,e.validateInputs)($,it),[st.run(Object.assign(Object.assign({},b),{cacheHint:it.cacheKey,get:()=>et(st,$,it)}),$)]),e.parseUpsampleAttributesV7=st=>(0,e.parseUpsampleAttributes)(st,7),e.parseUpsampleAttributesV9=st=>(0,e.parseUpsampleAttributes)(st,9),e.parseUpsampleAttributes=(st,$)=>{const it=$>=10,g=st.attributes.getString("mode","nearest");if(g!=="nearest"&&g!=="linear"&&($<11||g!=="cubic"))throw new Error(`unrecognized mode: ${g}`);let c=[];$<9&&(c=st.attributes.getFloats("scales"),(0,e.scalesValidation)(c,g,it));const _=st.attributes.getFloat("extrapolation_value",0),ot=$>10?st.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(ot)===-1)throw new Error(`coordinate_transform_mode '${ot}' is not supported`);const ct=ot==="tf_crop_and_resize",dt=ct,pt=g==="nearest"&&$>=11?st.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(pt)===-1)throw new Error(`nearest_mode '${pt}' is not supported`);const ft=st.attributes.getFloat("cubic_coeff_a",-.75),ht=st.attributes.getInt("exclude_outside",0)!==0;if(ht&&g!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const bt=$<11||g==="nearest"&&ot==="asymmetric"&&pt==="floor";let mt=0,$t=0,Tt=0;return $>10?st.inputs.length>2?(mt=1,$t=2,Tt=3):($t=1,Tt=2):$===9&&($t=1),(0,a.createAttributeWithCacheKey)({opset:$,isResize:it,mode:g,scales:c,extrapolationValue:_,coordinateTransformMode:ot,useExtrapolation:dt,needRoiInput:ct,nearestMode:pt,cubicCoefficientA:ft,excludeOutside:ht,useNearest2xOptimization:bt,roiInputIdx:mt,scalesInputIdx:$t,sizesInputIdx:Tt})};const et=(st,$,it)=>{const g=(0,d.getGlsl)(st.session.backend.glContext.version),[c,_]=st.calculateTextureWidthAndHeight($[0].dims,h.TextureType.unpacked),ot=$[0].dims.map((Tt,Nt)=>Math.floor(Tt*it.scales[Nt])),[ct,dt]=st.calculateTextureWidthAndHeight(ot,h.TextureType.unpacked),pt=ot.length,ft=new Array(pt),ht=new Array(pt);let bt=`
      int output_pitches[${pt}];
      int input_pitches[${pt}];
      `;for(let Tt=pt-1;Tt>=0;Tt--)ft[Tt]=Tt===pt-1?1:ft[Tt+1]*ot[Tt+1],ht[Tt]=Tt===pt-1?1:ht[Tt+1]*$[0].dims[Tt+1],bt+=`
        output_pitches[${Tt}] = ${ft[Tt]};
        input_pitches[${Tt}] = ${ht[Tt]};
        `;const mt=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${c}, ${_});
        float value = getColorAsFloat(${g.texture2D}(X, coords));
        return value;
      }
      `,$t=it.mode==="nearest"?`
    ${mt}
    float process(int indices[${pt}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${ct}, ${dt});

      ${bt}

      int d, m;
      for (int dim = 0; dim < ${pt}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:pt===4?`
    ${mt}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${ct}, ${dt});

      ${bt}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${$[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${mt}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${ct}, ${dt});

      ${bt}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${$[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},b),{output:{dims:ot,type:$[0].type,textureType:h.TextureType.unpacked},shaderSource:$t,variables:[{name:"scales",type:"int",arrayLength:it.scales.length,data:it.scales.map(Tt=>Math.ceil(Tt))}]})};e.validateInputs=(st,$)=>{if(!st||$.opset<9&&st.length!==1||$.opset>=9&&$.opset<11&&st.length!==2||$.opset>=11&&st.length<2)throw new Error("invalid inputs.");if($.scales.length>0&&st[0].dims.length!==$.scales.length)throw new Error("Invalid input shape.");if(st[0].type==="string")throw new Error("Invalid input tensor types.")},e.scalesValidation=(st,$,it)=>{if(it){for(const g of st)if(g<=0)throw new Error("Scale value should be greater than 0.")}else for(const g of st)if(g<1)throw new Error("Scale value should be greater than or equal to 1.");if(!($!=="linear"&&$!=="cubic"||st.length===2||st.length===4&&st[0]===1&&st[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${it?"Resize":"Upsample"} opeartor.`)}},1958:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ProgramManager=void 0;const a=s(1670),d=s(6231),h=s(8879),b=s(5060);e.ProgramManager=class{constructor(et,st,$){this.profiler=et,this.glContext=st,this.textureLayoutStrategy=$,this.repo=new Map,this.attributesBound=!1}getArtifact(et){return this.repo.get(et)}setArtifact(et,st){this.repo.set(et,st)}run(et,st,$){var it;this.profiler.event("op",`ProgramManager.run ${(it=et.programInfo.name)!==null&&it!==void 0?it:"unknown kernel"}`,()=>{var g;const c=this.glContext.gl,_=et.program;c.useProgram(_);try{this.bindOutput($),this.attributesBound||this.bindAttributes(et.attribLocations),this.bindUniforms(et.uniformLocations,(g=et.programInfo.variables)!==null&&g!==void 0?g:[],st)}catch(ot){throw d.Logger.error("ProgramManager",et.programInfo.shaderSource),ot}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(et=>this.glContext.deleteProgram(et.program))}build(et,st,$){return this.profiler.event("backend","ProgramManager.build",()=>{const it=new h.GlslPreprocessor(this.glContext,et,st,$),g=it.preprocess(),c=this.compile(g);return{programInfo:et,program:c,uniformLocations:this.getUniformLocations(c,it.context.programInfo.inputNames,it.context.programInfo.variables),attribLocations:this.getAttribLocations(c)}})}compile(et){if(!this.vertexShader){d.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const it=(0,b.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(it,this.glContext.gl.VERTEX_SHADER)}a.env.debug&&d.Logger.verbose("ProrgramManager",`FragShader:
${et}
`);const st=this.glContext.compileShader(et,this.glContext.gl.FRAGMENT_SHADER),$=this.glContext.createProgram(this.vertexShader,st);return this.glContext.deleteShader(st),$}bindOutput(et){const st=et.width,$=et.height;d.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${st}/${$}, shape=${et.shape}, type=${et.tensor.type}`),this.glContext.attachFramebuffer(et.texture,st,$)}bindAttributes(et){const st=et.position,$=et.textureCoord;this.glContext.setVertexAttributes(st,$),this.attributesBound=!0}bindUniforms(et,st,$){var it;const g=this.glContext.gl;let c=0;for(const{name:_,type:ot,location:ct,arrayLength:dt}of et){const pt=(it=st.find(ft=>ft.name===_))===null||it===void 0?void 0:it.data;if(ot!=="sampler2D"&&!pt)throw new Error(`variable '${_}' does not have data defined in program info`);switch(ot){case"sampler2D":this.bindTexture($[c],ct,c),c++;break;case"float":dt?g.uniform1fv(ct,pt):g.uniform1f(ct,pt);break;case"int":dt?g.uniform1iv(ct,pt):g.uniform1i(ct,pt);break;default:throw new Error(`Uniform not implemented: ${ot}`)}}}bindTexture(et,st,$){this.glContext.bindTextureToUniform(et.texture,$,st)}getAttribLocations(et){return{position:this.getAttribLocation(et,"position"),textureCoord:this.getAttribLocation(et,"textureCoord")}}getUniformLocations(et,st,$){const it=[];if(st)for(const g of st)it.push({name:g,type:"sampler2D",location:this.getUniformLocation(et,g)});if($)for(const g of $)it.push(Object.assign(Object.assign({},g),{location:this.getUniformLocation(et,g.name)}));return it}getUniformLocation(et,st){const $=this.glContext.gl.getUniformLocation(et,st);if($===null)throw new Error(`Uniform ${st} not found.`);return $}getAttribLocation(et,st){return this.glContext.gl.getAttribLocation(et,st)}}},6416:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLSessionHandler=void 0;const a=s(6231),d=s(1047),h=s(8316),b=s(1640),et=s(1958),st=s(7859),$=s(5702);e.WebGLSessionHandler=class{constructor(it,g){this.backend=it,this.context=g,this.layoutStrategy=new st.PreferLogicalStrategy(it.glContext.maxTextureSize),this.programManager=new et.ProgramManager(this.context.profiler,it.glContext,this.layoutStrategy),this.textureManager=new $.TextureManager(it.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:it.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=it.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new h.WebGLInferenceHandler(this)}onGraphInitialized(it){const g=it.getValues().filter(c=>c.from===-1&&c.tensor).map(c=>c.tensor.dataId);this.initializers=new Set(g)}isInitializer(it){return!!this.initializers&&this.initializers.has(it)}addInitializer(it){this.initializers.add(it)}getTextureData(it,g){return g?this.packedTextureDataCache.get(it):this.unpackedTextureDataCache.get(it)}setTextureData(it,g,c=!1){a.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),c?this.packedTextureDataCache.set(it,g):this.unpackedTextureDataCache.set(it,g)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(it=>this.textureManager.releaseTexture(it,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(it=>this.textureManager.releaseTexture(it,!0)),this.unpackedTextureDataCache=new Map}resolve(it,g,c){const _=(0,d.resolveOperator)(it,g,b.WEBGL_OP_RESOLVE_RULES);return{impl:_.opImpl,context:_.opInit?_.opInit(it,c):it}}}},7769:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Uint8DataEncoder=e.RGBAFloatDataEncoder=e.RedFloat32DataEncoder=void 0;const a=s(6231);e.RedFloat32DataEncoder=class{constructor(d,h=1){if(h===1)this.internalFormat=d.R32F,this.format=d.RED,this.textureType=d.FLOAT,this.channelSize=h;else{if(h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=d.RGBA32F,this.format=d.RGBA,this.textureType=d.FLOAT,this.channelSize=h}}encode(d,h){let b,et;return d.constructor!==Float32Array&&(a.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),et=new Float32Array(d)),h*this.channelSize>d.length?(a.Logger.warning("Encoder","Source data too small. Allocating larger array"),et=d,b=this.allocate(h*this.channelSize),et.forEach((st,$)=>b[$]=st)):(et=d,b=et),b}allocate(d){return new Float32Array(4*d)}decode(d,h){return this.channelSize===1?d.filter((b,et)=>et%4==0).subarray(0,h):d.subarray(0,h)}},e.RGBAFloatDataEncoder=class{constructor(d,h=1,b){if(h!==1&&h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=d.RGBA,this.format=d.RGBA,this.channelSize=h,this.textureType=b||d.FLOAT}encode(d,h){let b=d;return this.channelSize===1&&(a.Logger.verbose("Encoder","Exploding into a larger array"),b=this.allocate(h),d.forEach((et,st)=>b[4*st]=et)),b}allocate(d){return new Float32Array(4*d)}decode(d,h){return this.channelSize===1?d.filter((b,et)=>et%4==0).subarray(0,h):d.subarray(0,h)}},e.Uint8DataEncoder=class{constructor(d,h=1){if(this.channelSize=4,h===1)this.internalFormat=d.ALPHA,this.format=d.ALPHA,this.textureType=d.UNSIGNED_BYTE,this.channelSize=h;else{if(h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=d.RGBA,this.format=d.RGBA,this.textureType=d.UNSIGNED_BYTE,this.channelSize=h}}encode(d,h){return new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}allocate(d){return new Uint8Array(d*this.channelSize)}decode(d,h){if(d instanceof Uint8Array)return d.subarray(0,h);throw new Error(`Invalid array type: ${d.constructor}`)}}},7859:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getBatchDim=e.sizeToSquarishShape=e.getRowsCols=e.sizeFromShape=e.isInt=e.parseAxisParam=e.squeezeShape=e.PreferLogicalStrategy=e.AlwaysKeepOriginalSizeStrategy=void 0;const a=s(6231),d=s(2517);function h(it,g){const c=[],_=[],ot=g!=null&&Array.isArray(g)&&g.length===0,ct=g==null||ot?null:b(g,it).sort();let dt=0;for(let pt=0;pt<it.length;++pt){if(ct!=null){if(ct[dt]===pt&&it[pt]!==1)throw new Error(`Can't squeeze axis ${pt} since its dim '${it[pt]}' is not 1`);(ct[dt]==null||ct[dt]>pt)&&it[pt]===1&&(c.push(it[pt]),_.push(pt)),ct[dt]<=pt&&dt++}it[pt]!==1&&(c.push(it[pt]),_.push(pt))}return{newShape:c,keptDims:_}}function b(it,g){const c=g.length;return it=it==null?g.map((_,ot)=>ot):[].concat(it),(0,d.assert)(it.every(_=>_>=-c&&_<c),()=>`All values in axis param must be in range [-${c}, ${c}) but got axis ${it}`),(0,d.assert)(it.every(et),()=>`All values in axis param must be integers but got axis ${it}`),it.map(_=>_<0?c+_:_)}function et(it){return it%1==0}function st(it){if(it.length===0)return 1;let g=it[0];for(let c=1;c<it.length;c++)g*=it[c];return g}function $(it){const g=Math.ceil(Math.sqrt(it));return[g,Math.ceil(it/g)]}e.AlwaysKeepOriginalSizeStrategy=class{constructor(it){this.maxTextureSize=it}computeTextureWH(it,g){if(it.length===0)return[1,1];const c=this.maxTextureSize;if(g&&g.breakAxis!==void 0){const ct=g.breakAxis>=it.length?1:it.slice(g.breakAxis).reduce((pt,ft)=>pt*ft),dt=g.breakAxis<=0?1:it.slice(0,g.breakAxis).reduce((pt,ft)=>pt*ft);if(!(ct>c||dt>c))return[ct,dt];a.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${it}, breakAxis:${g.breakAxis}`)}const _=it.reduce((ct,dt)=>ct*dt);let ot=Math.floor(Math.sqrt(_));for(;ot<c&&ot<_&&_%ot!=0;ot++);if(ot>=c||_%ot!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${it}`);return[ot,_/ot]}},e.PreferLogicalStrategy=class{constructor(it){this.maxTextureSize=it}computeTextureWH(it,g){const c=this.computeTexture(it,g);return g&&g.isPacked&&(c[0]/=2,c[1]/=2),g&&g.reverseWH?[c[1],c[0]]:c}computeTexture(it,g){const c=g&&g.isPacked;if(it.length===0)return c?[2,2]:[1,1];let _=this.maxTextureSize;if(g&&g.breakAxis!==void 0){const dt=g.breakAxis>=it.length?1:it.slice(g.breakAxis).reduce((ft,ht)=>ft*ht),pt=g.breakAxis<=0?1:it.slice(0,g.breakAxis).reduce((ft,ht)=>ft*ht);if(!(dt>_||pt>_))return[dt,pt];a.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${it}, breakAxis:${g.breakAxis}`)}let ot=it.slice(0);c&&(_*=2,ot=ot.map((dt,pt)=>pt>=ot.length-2?ot[pt]%2==0?ot[pt]:ot[pt]+1:ot[pt]),ot.length===1&&(ot=[2,ot[0]])),ot.length!==2&&(ot=h(ot).newShape);const ct=st(ot);return ot.length<=1&&ct<=_?[1,ct]:ot.length===2&&ot[0]<=_&&ot[1]<=_?ot:ot.length===3&&ot[0]*ot[1]<=_&&ot[2]<=_?[ot[0]*ot[1],ot[2]]:ot.length===3&&ot[0]<=_&&ot[1]*ot[2]<=_?[ot[0],ot[1]*ot[2]]:ot.length===4&&ot[0]*ot[1]*ot[2]<=_&&ot[3]<=_?[ot[0]*ot[1]*ot[2],ot[3]]:ot.length===4&&ot[0]<=_&&ot[1]*ot[2]*ot[3]<=_?[ot[0],ot[1]*ot[2]*ot[3]]:c?$(ct/4).map(dt=>2*dt):$(ct)}},e.squeezeShape=h,e.parseAxisParam=b,e.isInt=et,e.sizeFromShape=st,e.getRowsCols=function(it){if(it.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[it.length>1?it[it.length-2]:1,it[it.length-1]]},e.sizeToSquarishShape=$,e.getBatchDim=function(it,g=2){return st(it.slice(0,it.length-g))}},4057:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createTextureLayoutFromShape=e.calculateTextureWidthAndHeight=e.createTextureLayoutFromTextureType=void 0;const a=s(2517),d=s(2039);e.createTextureLayoutFromTextureType=(h,b,et)=>{const st=et===d.TextureType.unpacked||et===d.TextureType.unpackedReversed?1:4,$=et===d.TextureType.packed,it=et===d.TextureType.unpackedReversed||et===d.TextureType.packed,g=et===d.TextureType.packedLastDimension?b.length-1:void 0,c=et===d.TextureType.packedLastDimension?b.map((_,ot)=>ot===b.length-1?4*_:_):void 0;return(0,e.createTextureLayoutFromShape)(h,b,st,c,{isPacked:$,reverseWH:it,breakAxis:g})},e.calculateTextureWidthAndHeight=(h,b,et)=>{const st=(0,e.createTextureLayoutFromTextureType)(h,b,et);return[st.width,st.height]},e.createTextureLayoutFromShape=(h,b,et=1,st,$)=>{const it=!(!$||!$.isPacked),[g,c]=h.computeTextureWH(it&&st||b,$),_=b.length;let ot=b.slice(0);if(_===0&&(ot=[1]),et===1)st=b;else if(it){if(et!==4)throw new Error("a packed texture must be 4-channel");st=b,_>0&&(ot[_-1]=Math.ceil(ot[_-1]/2)),_>1&&(ot[_-2]=Math.ceil(ot[_-2]/2))}else if(!st)throw new Error("Unpacked shape is needed when using channels > 1");return{width:g,height:c,channels:et,isPacked:it,shape:ot,strides:a.ShapeUtil.computeStrides(ot),unpackedShape:st,reversedWH:$&&$.reverseWH}}},5702:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TextureManager=void 0;const a=s(6231);e.TextureManager=class{constructor(d,h,b,et){this.glContext=d,this.layoutStrategy=h,this.profiler=b,this.config=et,this.pendingRead=new Map,et.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(d,h,b,et){const st=this.toEncoderType(d),$=this.glContext.getEncoder(st,h.channels||1,et);if(h.isPacked&&et===1)throw new Error("not implemented");const it=h.width,g=h.height;let c,_;if(this.config.reuseTextures){c=`${it}x${g}_${$.format}_${$.internalFormat}_${$.textureType}`,_=this.inUseTextures.get(c),_||(_=[],this.inUseTextures.set(c,_));const ct=this.idleTextures.get(c);if(ct&&ct.length>0){const dt=ct.pop();return _.push(dt),et===1&&this.glContext.updateTexture(dt,it,g,$,this.toTextureData(d,b)),dt}}a.Logger.verbose("TextureManager",`Creating new texture of size ${h.width}x${h.height}`);const ot=this.glContext.allocateTexture(it,g,$,this.toTextureData(d,b));return this.config.reuseTextures&&(_.push(ot),this.textureLookup.set(ot,c)),ot}readTexture(d,h,b){return b||(b=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const et=d.shape.reduce(($,it)=>$*it)*b,st=this.glContext.readTexture(d.texture,d.width,d.height,et,this.toEncoderType(h),b);return this.toTensorData(h,st)})}async readTextureAsync(d,h,b){const et=d.tensor.dataId;if(b||(b=1),this.pendingRead.has(et)){const st=this.pendingRead.get(et);return new Promise($=>st?.push($))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(et,[]);const st=d.shape.reduce((c,_)=>c*_)*b;await this.glContext.createAndWaitForFence();const $=this.glContext.readTexture(d.texture,d.width,d.height,st,this.toEncoderType(h),b),it=this.toTensorData(h,$),g=this.pendingRead.get(et);return this.pendingRead.delete(et),g?.forEach(c=>c(it)),it})}readUint8TextureAsFloat(d){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const h=d.shape.reduce((et,st)=>et*st),b=this.glContext.readTexture(d.texture,d.width,d.height,4*h,"byte",4);return new Float32Array(b.buffer,b.byteOffset,h)})}releaseTexture(d,h){let b;if(this.config.reuseTextures&&(b=this.textureLookup.get(d.texture),b)){h&&this.textureLookup.delete(b);const et=this.inUseTextures.get(b);if(et){const st=et.indexOf(d.texture);if(st!==-1){et.splice(st,1);let $=this.idleTextures.get(b);$||($=[],this.idleTextures.set(b,$)),$.push(d.texture)}}}b&&!h||(a.Logger.verbose("TextureManager",`Deleting texture of size ${d.width}x${d.height}`),this.glContext.deleteTexture(d.texture))}toTensorData(d,h){switch(d){case"int16":return h instanceof Int16Array?h:Int16Array.from(h);case"int32":return h instanceof Int32Array?h:Int32Array.from(h);case"int8":return h instanceof Int8Array?h:Int8Array.from(h);case"uint16":return h instanceof Uint16Array?h:Uint16Array.from(h);case"uint32":return h instanceof Uint32Array?h:Uint32Array.from(h);case"uint8":case"bool":return h instanceof Uint8Array?h:Uint8Array.from(h);case"float32":return h instanceof Float32Array?h:Float32Array.from(h);case"float64":return h instanceof Float64Array?h:Float64Array.from(h);default:throw new Error(`TensorData type ${d} is not supported`)}}toTextureData(d,h){if(h)return h instanceof Float32Array?h:new Float32Array(h)}toEncoderType(d){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(o,e)=>{var s;Object.defineProperty(e,"__esModule",{value:!0}),e.TextureType=void 0,(s=e.TextureType||(e.TextureType={}))[s.unpacked=0]="unpacked",s[s.unpackedReversed=1]="unpackedReversed",s[s.packed=2]="packed",s[s.downloadUint8AsFloat=3]="downloadUint8AsFloat",s[s.packedLastDimension=4]="packedLastDimension"},9390:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getGlChannels=e.getCoordsDataType=e.getSqueezedParams=e.squeezeInputShape=e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=e.generateShaderFuncNameFromInputSamplerName=e.repeatedTry=e.getPackedShape=void 0;const a=s(2517);e.getPackedShape=function(d){const h=d.length;return d.slice(0,h-1).concat(d[h-1]/4)},e.repeatedTry=async function(d,h=et=>0,b){return new Promise((et,st)=>{let $=0;const it=()=>{if(d())return void et();$++;const g=h($);b!=null&&$>=b?st():setTimeout(it,g)};it()})},e.generateShaderFuncNameFromInputSamplerName=function(d){return(0,a.assert)(d!==void 0&&d.length!==0,()=>"empty string found for sampler name"),"get"+d.charAt(0).toUpperCase()+d.slice(1)},e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(d){return(0,a.assert)(d!==void 0&&d.length!==0,()=>"empty string found for sampler name"),"get"+d.charAt(0).toUpperCase()+d.slice(1)+"AtOutCoords"},e.squeezeInputShape=function(d,h){let b=JSON.parse(JSON.stringify(d));return b=h,b},e.getSqueezedParams=function(d,h){return h.map(b=>d[b]).join(", ")},e.getCoordsDataType=function(d){if(d<=1)return"int";if(d===2)return"ivec2";if(d===3)return"ivec3";if(d===4)return"ivec4";if(d===5)return"ivec5";if(d===6)return"ivec6";throw Error(`GPU for rank ${d} is not yet supported`)},e.getGlChannels=function(d=6){return["x","y","z","w","u","v"].slice(0,d)}},7305:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createNewWebGLContext=e.createWebGLContext=void 0;const a=s(6231),d=s(1713),h={};function b(et){const st=function(){if(typeof document>"u"){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const g=document.createElement("canvas");return g.width=1,g.height=1,g}();let $;const it={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!et||et==="webgl2")&&($=st.getContext("webgl2",it),$))try{return new d.WebGLContext($,2)}catch(g){a.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${g}`)}if((!et||et==="webgl")&&($=st.getContext("webgl",it)||st.getContext("experimental-webgl",it),$))try{return new d.WebGLContext($,1)}catch(g){a.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${g}`)}throw new Error("WebGL is not supported")}e.createWebGLContext=function et(st){let $;st&&st!=="webgl2"||!("webgl2"in h)?st&&st!=="webgl"||!("webgl"in h)||($=h.webgl):$=h.webgl2,$=$||b(st),st=st||$.version===1?"webgl":"webgl2";const it=$.gl;return h[st]=$,it.isContextLost()?(delete h[st],et(st)):(it.disable(it.DEPTH_TEST),it.disable(it.STENCIL_TEST),it.disable(it.BLEND),it.disable(it.DITHER),it.disable(it.POLYGON_OFFSET_FILL),it.disable(it.SAMPLE_COVERAGE),it.enable(it.SCISSOR_TEST),it.enable(it.CULL_FACE),it.cullFace(it.BACK),$)},e.createNewWebGLContext=b},1713:function(o,e,s){var a=this&&this.__createBinding||(Object.create?function(it,g,c,_){_===void 0&&(_=c);var ot=Object.getOwnPropertyDescriptor(g,c);ot&&!("get"in ot?!g.__esModule:ot.writable||ot.configurable)||(ot={enumerable:!0,get:function(){return g[c]}}),Object.defineProperty(it,_,ot)}:function(it,g,c,_){_===void 0&&(_=c),it[_]=g[c]}),d=this&&this.__setModuleDefault||(Object.create?function(it,g){Object.defineProperty(it,"default",{enumerable:!0,value:g})}:function(it,g){it.default=g}),h=this&&this.__importStar||function(it){if(it&&it.__esModule)return it;var g={};if(it!=null)for(var c in it)c!=="default"&&Object.prototype.hasOwnProperty.call(it,c)&&a(g,it,c);return d(g,it),g};Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLContext=e.linearSearchLastTrue=void 0;const b=s(1670),et=h(s(7769)),st=s(9390);function $(it){let g=0;for(;g<it.length&&it[g]();++g);return g-1}e.linearSearchLastTrue=$,e.WebGLContext=class{constructor(it,g){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=it,this.version=g,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(it,g,c,_){const ot=this.gl,ct=ot.createTexture();ot.bindTexture(ot.TEXTURE_2D,ct),ot.texParameteri(ot.TEXTURE_2D,ot.TEXTURE_MIN_FILTER,ot.NEAREST),ot.texParameteri(ot.TEXTURE_2D,ot.TEXTURE_MAG_FILTER,ot.NEAREST),ot.texParameteri(ot.TEXTURE_2D,ot.TEXTURE_WRAP_S,ot.CLAMP_TO_EDGE),ot.texParameteri(ot.TEXTURE_2D,ot.TEXTURE_WRAP_T,ot.CLAMP_TO_EDGE);const dt=_?c.encode(_,it*g):null;return ot.texImage2D(ot.TEXTURE_2D,0,c.internalFormat,it,g,0,c.format,c.textureType,dt),this.checkError(),ct}updateTexture(it,g,c,_,ot){const ct=this.gl;ct.bindTexture(ct.TEXTURE_2D,it);const dt=_.encode(ot,g*c);ct.texSubImage2D(ct.TEXTURE_2D,0,0,0,g,c,_.format,_.textureType,dt),this.checkError()}attachFramebuffer(it,g,c){const _=this.gl;_.bindTexture(_.TEXTURE_2D,it),_.bindFramebuffer(_.FRAMEBUFFER,this.framebuffer),_.framebufferTexture2D(_.FRAMEBUFFER,_.COLOR_ATTACHMENT0,_.TEXTURE_2D,it,0),this.checkError(),_.viewport(0,0,g,c),_.scissor(0,0,g,c)}readTexture(it,g,c,_,ot,ct){const dt=this.gl;ct||(ct=1),this.frameBufferBound||this.attachFramebuffer(it,g,c);const pt=this.getEncoder(ot,ct),ft=pt.allocate(g*c);return dt.bindTexture(dt.TEXTURE_2D,it),dt.framebufferTexture2D(dt.FRAMEBUFFER,dt.COLOR_ATTACHMENT0,dt.TEXTURE_2D,it,0),dt.readPixels(0,0,g,c,dt.RGBA,pt.textureType,ft),this.checkError(),pt.decode(ft,_)}isFramebufferReady(){return!0}getActiveTexture(){const it=this.gl;return"TEXTURE"+(it.getParameter(this.gl.ACTIVE_TEXTURE)-it.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(it,g){const c=this.gl;c.vertexAttribPointer(it,3,c.FLOAT,!1,20,0),c.enableVertexAttribArray(it),g!==-1&&(c.vertexAttribPointer(g,2,c.FLOAT,!1,20,12),c.enableVertexAttribArray(g)),this.checkError()}createProgram(it,g){const c=this.gl,_=c.createProgram();return c.attachShader(_,it),c.attachShader(_,g),c.linkProgram(_),_}compileShader(it,g){const c=this.gl,_=c.createShader(g);if(!_)throw new Error(`createShader() returned null with type ${g}`);if(c.shaderSource(_,it),c.compileShader(_),c.getShaderParameter(_,c.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${c.getShaderInfoLog(_)}
Shader source:
${it}`);return _}deleteShader(it){this.gl.deleteShader(it)}bindTextureToUniform(it,g,c){const _=this.gl;_.activeTexture(_.TEXTURE0+g),this.checkError(),_.bindTexture(_.TEXTURE_2D,it),this.checkError(),_.uniform1i(c,g),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(b.env.debug){const it=this.gl,g=it.getError();let c="";switch(g){case it.NO_ERROR:return;case it.INVALID_ENUM:c="INVALID_ENUM";break;case it.INVALID_VALUE:c="INVALID_VALUE";break;case it.INVALID_OPERATION:c="INVALID_OPERATION";break;case it.INVALID_FRAMEBUFFER_OPERATION:c="INVALID_FRAMEBUFFER_OPERATION";break;case it.OUT_OF_MEMORY:c="OUT_OF_MEMORY";break;case it.CONTEXT_LOST_WEBGL:c="CONTEXT_LOST_WEBGL";break;default:c=`Unknown WebGL Error: ${g.toString(16)}`}throw new Error(c)}}deleteTexture(it){this.gl.deleteTexture(it)}deleteProgram(it){this.gl.deleteProgram(it)}getEncoder(it,g,c=0){if(this.version===2)return new et.RedFloat32DataEncoder(this.gl,g);switch(it){case"float":return c===1||this.isRenderFloat32Supported?new et.RGBAFloatDataEncoder(this.gl,g):new et.RGBAFloatDataEncoder(this.gl,g,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new et.Uint8DataEncoder(this.gl,g);default:throw new Error(`Invalid dataType: ${it}`)}}clearActiveTextures(){const it=this.gl;for(let g=0;g<this.maxTextureImageUnits;++g)it.activeTexture(it.TEXTURE0+g),it.bindTexture(it.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const it=this.gl;it.bindFramebuffer(it.FRAMEBUFFER,null),it.deleteFramebuffer(this.framebuffer),it.bindBuffer(it.ARRAY_BUFFER,null),it.deleteBuffer(this.vertexbuffer),it.bindBuffer(it.ELEMENT_ARRAY_BUFFER,null),it.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const it=this.gl,g=it.createBuffer();if(!g)throw new Error("createBuffer() returned null");const c=this.createDefaultGeometry();return it.bindBuffer(it.ARRAY_BUFFER,g),it.bufferData(it.ARRAY_BUFFER,c,it.STATIC_DRAW),this.checkError(),g}createFramebuffer(){const it=this.gl.createFramebuffer();if(!it)throw new Error("createFramebuffer returned null");return it}queryVitalParameters(){const it=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=it.getParameter(it.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=it.getParameter(it.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const it=this.gl,g=it.createTexture();it.bindTexture(it.TEXTURE_2D,g);const c=this.version===2?it.RGBA32F:it.RGBA;it.texImage2D(it.TEXTURE_2D,0,c,1,1,0,it.RGBA,it.FLOAT,null);const _=it.createFramebuffer();it.bindFramebuffer(it.FRAMEBUFFER,_),it.framebufferTexture2D(it.FRAMEBUFFER,it.COLOR_ATTACHMENT0,it.TEXTURE_2D,g,0);const ot=it.checkFramebufferStatus(it.FRAMEBUFFER)===it.FRAMEBUFFER_COMPLETE;return it.bindTexture(it.TEXTURE_2D,null),it.bindFramebuffer(it.FRAMEBUFFER,null),it.deleteTexture(g),it.deleteFramebuffer(_),ot}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const it=this.gl;let g,c,_,ot,ct;try{g=it.createTexture(),c=it.createFramebuffer(),it.bindTexture(it.TEXTURE_2D,g);const dt=this.version===2?it.RGBA32F:it.RGBA;return it.texImage2D(it.TEXTURE_2D,0,dt,1,1,0,it.RGBA,it.FLOAT,null),it.bindFramebuffer(it.FRAMEBUFFER,c),it.framebufferTexture2D(it.FRAMEBUFFER,it.COLOR_ATTACHMENT0,it.TEXTURE_2D,g,0),it.enable(it.BLEND),_=it.createShader(it.VERTEX_SHADER),!!_&&(it.shaderSource(_,"void main(){}"),it.compileShader(_),ot=it.createShader(it.FRAGMENT_SHADER),!!ot&&(it.shaderSource(ot,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),it.compileShader(ot),ct=it.createProgram(),!!ct&&(it.attachShader(ct,_),it.attachShader(ct,ot),it.linkProgram(ct),it.useProgram(ct),it.drawArrays(it.POINTS,0,1),it.getError()===it.NO_ERROR)))}finally{it.disable(it.BLEND),ct&&it.deleteProgram(ct),_&&it.deleteShader(_),ot&&it.deleteShader(ot),c&&(it.bindFramebuffer(it.FRAMEBUFFER,null),it.deleteFramebuffer(c)),g&&(it.bindTexture(it.TEXTURE_2D,null),it.deleteTexture(g))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const it=this.gl,g=this.disjointTimerQueryWebgl2Extension,c=it.createQuery();return it.beginQuery(g.TIME_ELAPSED_EXT,c),c}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const it=this.gl,g=this.disjointTimerQueryWebgl2Extension;it.endQuery(g.TIME_ELAPSED_EXT)}}isTimerResultAvailable(it){let g=!1,c=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const _=this.gl,ot=this.disjointTimerQueryWebgl2Extension;g=_.getQueryParameter(it,_.QUERY_RESULT_AVAILABLE),c=_.getParameter(ot.GPU_DISJOINT_EXT)}return g&&!c}getTimerResult(it){let g=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const c=this.gl;g=c.getQueryParameter(it,c.QUERY_RESULT),c.deleteQuery(it)}return g/1e6}async waitForQueryAndGetTime(it){return await(0,st.repeatedTry)(()=>this.isTimerResultAvailable(it)),this.getTimerResult(it)}async createAndWaitForFence(){const it=this.createFence(this.gl);return this.pollFence(it)}createFence(it){let g;const c=it,_=c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE,0);return it.flush(),g=_===null?()=>!0:()=>{const ot=c.clientWaitSync(_,0,0);return ot===c.ALREADY_SIGNALED||ot===c.CONDITION_SATISFIED},{query:_,isFencePassed:g}}async pollFence(it){return new Promise(g=>{this.addItemToPoll(()=>it.isFencePassed(),()=>g())})}pollItems(){const it=$(this.itemsToPoll.map(g=>g.isDoneFn));for(let g=0;g<=it;++g){const{resolveFn:c}=this.itemsToPoll[g];c()}this.itemsToPoll=this.itemsToPoll.slice(it+1)}async addItemToPoll(it,g){this.itemsToPoll.push({isDoneFn:it,resolveFn:g}),this.itemsToPoll.length>1||await(0,st.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},1036:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ExecutionPlan=void 0;const a=s(6231);class d{constructor(b,et){this.op=b,this.node=et}}e.ExecutionPlan=class{constructor(h,b,et){this.graph=h,this.profiler=et,this.initialize(b)}initialize(h){this.profiler.event("session","ExecutionPlan.initialize",()=>{const b=this.graph.getNodes();if(b.length!==h.length)throw new Error("The size of nodes and OPs do not match.");this._ops=h.map((et,st)=>new d(et,b[st])),this.reset(),this._starter=[],this._ops.forEach((et,st)=>{let $=!0;for(const it of et.node.inputs)if(!this._values[it]&&this.graph.getInputIndices().indexOf(it)===-1){$=!1;break}$&&this._starter.push(st)})})}reset(){this._values=this.graph.getValues().map(h=>h.tensor)}async execute(h,b){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();const et=h.createInferenceHandler(),st=this.graph.getInputIndices();if(b.length!==st.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${b.length} expected: ${st.length}`);b.forEach((ot,ct)=>{const dt=st[ct];this._values[dt]=ot});const $=this._starter.slice(0),it=this.graph.getValues(),g=this.graph.getNodes();let c=0;for(;c<$.length;){const ot=$[c++],ct=this._ops[ot],dt=ct.node.inputs.map(bt=>this._values[bt]);if(dt.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${ct.node}`);const pt=dt;a.Logger.verbose("ExecPlan",`Runing op:${ct.node.name} (${pt.map((bt,mt)=>`'${ct.node.inputs[mt]}': ${bt.type}[${bt.dims.join(",")}]`).join(", ")})`);const ft=await this.profiler.event("node",ct.node.name,async()=>ct.op.impl(et,pt,ct.op.context));if(ft.length!==ct.node.outputs.length)throw new Error("the size of output does not match model definition.");ft.forEach((bt,mt)=>{const $t=ct.node.outputs[mt];if(this._values[$t])throw new Error(`output [${$t}] already has value: op:${ct.node.name}`);this._values[$t]=bt});const ht=new Set;ft.forEach((bt,mt)=>{const $t=ct.node.outputs[mt];for(const Tt of it[$t].to){const Nt=g[Tt];let Ct=!0;for(const Ft of Nt.inputs)if(!this._values[Ft]){Ct=!1;break}Ct&&ht.add(Tt)}}),$.push(...ht)}const _=[];for(let ot=0;ot<this.graph.getOutputIndices().length;ot++){const ct=this.graph.getOutputIndices()[ot],dt=this._values[ct];if(dt===void 0)throw new Error(`required output [${ct}] does not have value`);ct===0?await dt.getData():dt.data,_.push(dt)}return a.Logger.verbose("ExecPlan","disposing of inferenceHandler"),et.dispose(),_})}}},7070:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Graph=void 0;const a=s(1446),d=s(7778),h=s(9395),b=s(9162),et=s(2517);var st=h.onnxruntime.experimental.fbs;e.Graph={from:(c,_)=>new g(c,_)};class ${constructor(_){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,_&&(this.type=et.ProtoUtil.tensorValueTypeFromProto(_.type.tensorType))}get from(){return this._from}get to(){return this._to}}class it{constructor(_,ot){_ instanceof a.onnx.NodeProto?(this.name=_.name,this.opType=_.opType,this.attributes=new d.Attribute(_.attribute)):_ instanceof st.Node&&(this.name=ot??_.name(),this.opType=_.opType(),this.attributes=new d.Attribute(et.ProtoUtil.tensorAttributesFromORTFormat(_))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class g{constructor(_,ot){if(!_)throw new TypeError("graph is empty");this.buildGraph(_),this.transformGraph(ot),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(_){if(_ instanceof a.onnx.GraphProto)this.buildGraphFromOnnxFormat(_);else{if(!(_ instanceof st.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(_)}}buildGraphFromOnnxFormat(_){const ot=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const ct=new Map;if(!_.input)throw new Error("missing information in graph: input");const dt=[];for(const pt of _.input){if(ot.has(pt.name))throw new Error(`duplicated input name: ${pt.name}`);const ft=this._allData.push(new $(pt))-1;ot.set(pt.name,ft),dt.push(pt.name)}if(!_.initializer)throw new Error("missing information in graph: initializer");for(const pt of _.initializer){let ft=ot.get(pt.name);if(ft===void 0){const ht=new $;ht.type={shape:{dims:et.ProtoUtil.tensorDimsFromProto(pt.dims)},tensorType:et.ProtoUtil.tensorDataTypeFromProto(pt.dataType)},ft=this._allData.push(ht)-1,ot.set(pt.name,ft)}this._allData[ft]._from=-1,this._allData[ft].tensor=b.Tensor.fromProto(pt)}for(let pt=0;pt<this._allData.length;pt++)this._allData[pt].tensor||(this._allInputIndices.push(pt),this._allInputNames.push(dt[pt]));if(!_.output)throw new Error("missing information in graph: output");for(const pt of _.output){if(ot.has(pt.name))throw new Error(`duplicated output name: ${pt.name}`);const ft=this._allData.push(new $(pt))-1;ot.set(pt.name,ft),this._allOutputIndices.push(ft),this._allOutputNames.push(pt.name)}if(!_.node)throw new Error("missing information in graph: node");for(const pt of _.node){if(!pt.name)for(let ht=0;;ht++){const bt=`unnamed_${pt.opType}_${ht}`;if(!ct.has(bt)){pt.name=bt;break}}if(ct.has(pt.name))throw new Error(`duplicated node name: ${pt.name}`);const ft=this._nodes.push(new it(pt))-1;ct.set(pt.name,ft)}for(let pt=0;pt<this._nodes.length;pt++){const ft=this._nodes[pt],ht=_.node[pt];if(!ht.output)throw new Error(`missing output for node: ${ht.name}`);for(const bt of ht.output){let mt=ot.get(bt);if(mt===void 0&&(mt=this._allData.push(new $)-1,ot.set(bt,mt)),ft.outputs.push(mt),this._allData[mt]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${mt}`);if(this._allData[mt]._from=pt,ht.opType==="Constant"){if(!ht.attribute||ht.attribute.length!==1||!ht.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!ht.output||ht.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");ft.outputs.pop(),ft.executeNode=!1,this._allData[mt]._from=-1,this._allData[mt].tensor=b.Tensor.fromProto(ht.attribute[0].t)}}}for(let pt=0;pt<this._nodes.length;pt++){const ft=this._nodes[pt],ht=_.node[pt];if(!ht.input)throw new Error(`missing input for node: ${ht.name}`);for(const bt of ht.input){const mt=ot.get(bt);if(mt===void 0){if(bt===""&&ht.input.length===3&&ht.opType==="Resize")continue;throw new Error(`unrecognized input '${bt}' for node: ${ht.name}`)}ft.inputs.push(mt),this._allData[mt]._to.push(pt)}}return!0}buildGraphFromOrtFormat(_){var ot,ct,dt;const pt=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const ft=new Map,ht=[];for(let bt=0;bt<_.inputsLength();bt++){const mt=_.inputs(bt);if(pt.has(mt))throw new Error(`duplicated input name: ${mt}`);for(let $t=0;$t<_.nodeArgsLength();$t++)if(((ot=_.nodeArgs($t))===null||ot===void 0?void 0:ot.name())===mt){const Tt=new $;if(((dt=(ct=_.nodeArgs($t))===null||ct===void 0?void 0:ct.type())===null||dt===void 0?void 0:dt.valueType())!==st.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const Nt=_.nodeArgs($t).type().value(new st.TensorTypeAndShape),Ct=et.ProtoUtil.tensorDataTypeFromProto(Nt.elemType()),Ft=Nt.shape(),ln=[];for(let yn=0;yn<Ft.dimLength();yn++)ln.push(et.LongUtil.longToNumber(Ft.dim(yn).value().dimValue()));Tt.type={shape:{dims:ln},tensorType:Ct};const mn=this._allData.push(Tt)-1;pt.set(mt,mn),ht.push(mt)}}for(let bt=0;bt<_.initializersLength();bt++){const mt=_.initializers(bt);let $t=pt.get(mt.name());if($t===void 0){const Tt=new $,Nt=et.ProtoUtil.tensorDimsFromORTFormat(mt),Ct=et.ProtoUtil.tensorDataTypeFromProto(mt.dataType());Tt.type={shape:{dims:Nt},tensorType:Ct},$t=this._allData.push(Tt)-1,pt.set(mt.name(),$t)}this._allData[$t]._from=-1,this._allData[$t].tensor=b.Tensor.fromOrtTensor(mt)}for(let bt=0;bt<this._allData.length;bt++)this._allData[bt].tensor||(this._allInputIndices.push(bt),this._allInputNames.push(ht[bt]));for(let bt=0;bt<_.outputsLength();bt++){const mt=_.outputs(bt);if(pt.has(mt))throw new Error(`duplicated output name: ${mt}`);const $t=this._allData.push(new $)-1;pt.set(mt,$t),this._allOutputIndices.push($t),this._allOutputNames.push(mt)}if(!_.nodes)throw new Error("missing information in graph: node");for(let bt=0;bt<_.nodesLength();bt++){const mt=_.nodes(bt);let $t=mt.name();if(!$t)for(let Nt=0;$t=`unnamed_${mt.opType()}_${Nt}`,ft.has($t);Nt++);if(ft.has($t))throw new Error(`duplicated node name: ${$t}`);const Tt=this._nodes.push(new it(mt,$t))-1;ft.set($t,Tt)}for(let bt=0;bt<this._nodes.length;bt++){const mt=this._nodes[bt],$t=_.nodes(bt);if($t==null)throw new Error(`No node exists at index ${bt}`);if($t?.outputsLength()===0)throw new Error(`missing output for node: ${$t.name}`);for(let Tt=0;Tt<$t?.outputsLength();Tt++){const Nt=$t?.outputs(Tt);let Ct=pt.get(Nt);if(Ct===void 0&&(Ct=this._allData.push(new $)-1,pt.set(Nt,Ct)),mt.outputs.push(Ct),this._allData[Ct]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${Ct}`);if(this._allData[Ct]._from=bt,$t.opType()==="Constant"){if($t.attributesLength()!==1||!$t.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if($t.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");mt.outputs.pop(),mt.executeNode=!1,this._allData[Ct]._from=-1,this._allData[Ct].tensor=b.Tensor.fromOrtTensor($t.attributes(0).t())}}}for(let bt=0;bt<this._nodes.length;bt++){const mt=this._nodes[bt],$t=_.nodes(bt);if($t.inputsLength()===0)throw new Error(`missing input for node: ${$t.name}`);for(let Tt=0;Tt<$t.inputsLength();Tt++){const Nt=$t.inputs(Tt),Ct=pt.get(Nt);if(Ct===void 0)throw new Error(`unrecognized input '${Nt}' for node: ${$t.name()}`);mt.inputs.push(Ct),this._allData[Ct]._to.push(bt)}}}checkIsAcyclic(){const _=new Set;this._allInputIndices.forEach(dt=>{this._allData[dt]._to.forEach(pt=>{_.add(pt)})});const ot=Array.from(_),ct=new Array(this._nodes.length).fill("white");for(;ot.length>0;){const dt=ot.pop();ct[dt]==="gray"?ct[dt]="black":(ot.push(dt),ct[dt]="gray",this._nodes[dt].outputs.forEach(pt=>{const ft=this._allData[pt];if(ft.tensor!==void 0)throw new Error("node outputs should not be initialized");if(ft._from!==dt)throw new Error("from property of the Value object doesn't match index of Node being processed");ft._to.forEach(ht=>{if(ct[ht]==="gray")throw new Error("model graph is cyclic");ct[ht]==="white"&&ot.push(ht)})}))}}transformGraph(_){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),_&&_.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let _=0;for(let ot=0;ot<this._nodes.length;ot++)this._nodes[ot].executeNode?_>0&&(this._nodes[ot].inputs.forEach(ct=>{const dt=this._allData[ct]._to.indexOf(ot+_);dt!==-1&&(this._allData[ct]._to[dt]=ot)}),this._nodes[ot].outputs.forEach(ct=>{this._allData[ct]._from&&this._allData[ct]._from===ot+_&&(this._allData[ct]._from=ot)})):(_++,this._nodes[ot].outputs.forEach(ct=>{this._allData[ct]._from=-2}),this._nodes.splice(ot,1),ot--);_=0;for(let ot=0;ot<this._allData.length;ot++)if(this._allData[ot].from!==-2||this._allOutputIndices.indexOf(ot+_)!==-1){if(_>0){let ct=-1;this._allData[ot].from!==void 0&&this._allData[ot].from!==-1?(ct=this._nodes[this._allData[ot].from].outputs.indexOf(ot+_),ct!==-1&&(this._nodes[this._allData[ot].from].outputs[ct]=ot)):(ct=this._allInputIndices.indexOf(ot+_),ct!==-1&&(this._allInputIndices[ct]=ot)),this._allData[ot].to.forEach(dt=>{ct=this._nodes[dt].inputs.indexOf(ot+_),ct!==-1&&(this._nodes[dt].inputs[ct]=ot)}),this._allData[ot].to.length===0&&(ct=this._allOutputIndices.indexOf(ot+_),ct!==-1&&(this._allOutputIndices[ct]=ot))}}else _++,this._allData.splice(ot,1),ot--}deleteNode(_){const ot=this._nodes[_];if(ot.outputs.length>1){for(let bt=1;bt<ot.outputs.length;bt++)if(this._allData[ot.outputs[bt]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}ot.executeNode=!1;const ct=ot.inputs[0],dt=ot.outputs[0],pt=this._allData[dt].to,ft=this._allData[ct].to.indexOf(_);if(ft===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[ct].to.splice(ft,1),this._allData[dt]._to=[];const ht=this._allOutputIndices.indexOf(dt);if(ht!==-1&&(this._allOutputIndices[ht]=ct),pt&&pt.length>0)for(const bt of pt){const mt=this._nodes[bt].inputs.indexOf(dt);if(mt===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[bt].inputs[mt]=ct,this._allData[ct].to.push(bt)}}removeAllDropoutNodes(){let _=0;for(const ot of this._nodes){if(ot.opType==="Dropout"){if(ot.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(ot.outputs.length!==1&&ot.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(ot.outputs.length===2&&this._allData[ot.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(_)}_++}}removeAllIdentityNodes(){let _=0;for(const ot of this._nodes)ot.opType==="Identity"&&this.deleteNode(_),_++}isActivation(_){switch(_.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const _ of this._nodes)if(_.opType==="Conv"){const ot=this._allData[_.outputs[0]]._to;if(ot.length===1&&this.isActivation(this._nodes[ot[0]])){const ct=this._nodes[ot[0]];if(ct.opType==="Clip")if(ct.inputs.length===1)try{_.attributes.set("activation_params","floats",[ct.attributes.getFloat("min"),ct.attributes.getFloat("max")])}catch{_.attributes.set("activation_params","floats",[et.MIN_CLIP,et.MAX_CLIP])}else{if(!(ct.inputs.length>=3&&this._allData[ct.inputs[1]].tensor!==void 0&&this._allData[ct.inputs[2]].tensor!==void 0))continue;_.attributes.set("activation_params","floats",[this._allData[ct.inputs[1]].tensor.floatData[0],this._allData[ct.inputs[2]].tensor.floatData[0]])}_.attributes.set("activation","string",ct.opType),this.deleteNode(ot[0])}}}}},6231:(o,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.now=e.Profiler=e.Logger=void 0;const s={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},a={none:new class{log(it,g,c){}},console:new class{log(it,g,c){console.log(`${this.color(it)} ${c?"\x1B[35m"+c+"\x1B[0m ":""}${g}`)}color(it){switch(it){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${it}`)}}}},d={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let h={"":d};function b(it,g,c,_){if(g===void 0)return ot=it,{verbose:b.verbose.bind(null,ot),info:b.info.bind(null,ot),warning:b.warning.bind(null,ot),error:b.error.bind(null,ot),fatal:b.fatal.bind(null,ot)};if(c===void 0)et(it,g);else if(typeof c=="number"&&_===void 0)et(it,g);else if(typeof c=="string"&&_===void 0)et(it,c,0,g);else{if(typeof c!="string"||typeof _!="number")throw new TypeError("input is valid");et(it,c,0,g)}var ot}function et(it,g,c,_){const ot=h[_||""]||h[""];s[it]<s[ot.minimalSeverity]||(ot.logDateTime&&(g=`${new Date().toISOString()}|${g}`),ot.logSourceLocation,a[ot.provider].log(it,g,_))}(function(it){function g(_){h={},c("",_||{})}function c(_,ot){if(_==="*")g(ot);else{const ct=h[_]||d;h[_]={provider:ot.provider||ct.provider,minimalSeverity:ot.minimalSeverity||ct.minimalSeverity,logDateTime:ot.logDateTime===void 0?ct.logDateTime:ot.logDateTime,logSourceLocation:ot.logSourceLocation===void 0?ct.logSourceLocation:ot.logSourceLocation}}}it.verbose=function(_,ot){it("verbose",_,ot)},it.info=function(_,ot){it("info",_,ot)},it.warning=function(_,ot){it("warning",_,ot)},it.error=function(_,ot){it("error",_,ot)},it.fatal=function(_,ot){it("fatal",_,ot)},it.reset=g,it.set=c,it.setWithEnv=function(_){const ot={};_.logLevel&&(ot.minimalSeverity=_.logLevel),c("",ot)}})(b||(b={})),e.Logger=b;class st{constructor(g,c,_,ot,ct,dt){this.category=g,this.name=c,this.startTime=_,this.endCallback=ot,this.timer=ct,this.ctx=dt}end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class ${constructor(g,c,_,ot){this.category=g,this.name=c,this.startTime=_,this.endTime=ot}}e.Profiler=class{static create(it){return it===void 0?new this:new this(it.maxNumberEvents,it.flushBatchSize,it.flushIntervalInMilliseconds)}constructor(it,g,c){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=it===void 0?1e4:it,this._flushBatchSize=g===void 0?10:g,this._flushIntervalInMilliseconds=c===void 0?5e3:c}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,e.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(it,g,c,_){const ot=this._started?this.begin(it,g,_):void 0;let ct=!1;const dt=c();if(dt&&typeof dt.then=="function")return ct=!0,new Promise((pt,ft)=>{dt.then(async ht=>{ot&&await ot.end(),pt(ht)},async ht=>{ot&&await ot.end(),ft(ht)})});if(!ct&&ot){const pt=ot.end();if(pt&&typeof pt.then=="function")return new Promise((ft,ht)=>{pt.then(()=>{ft(dt)},bt=>{ht(bt)})})}return dt}begin(it,g,c){if(!this._started)throw new Error("profiler is not started yet");if(c===void 0){const _=(0,e.now)();return this.flush(_),new st(it,g,_,ot=>this.endSync(ot))}{const _=c.beginTimer();return new st(it,g,0,async ot=>this.end(ot),_,c)}}async end(it){const g=await it.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new $(it.category,it.name,it.startTime,g)),this.flush(g))}endSync(it){const g=(0,e.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new $(it.category,it.name,it.startTime,g)),this.flush(g))}logOneEvent(it){e.Logger.verbose(`Profiler.${it.category}`,`${(it.endTime-it.startTime).toFixed(2)}ms on event '${it.name}' at ${it.endTime.toFixed(2)}`)}flush(it){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||it-this._flushTime>=this._flushIntervalInMilliseconds){for(const g=this._flushPointer;this._flushPointer<g+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,e.now)()}}get started(){return this._started}},e.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},2644:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Model=void 0;const a=s(5686),d=s(1446),h=s(7070),b=s(9395),et=s(2517);var st=b.onnxruntime.experimental.fbs;e.Model=class{constructor(){}load($,it,g){if(!g)try{return void this.loadFromOnnxFormat($,it)}catch(c){if(g!==void 0)throw c}this.loadFromOrtFormat($,it)}loadFromOnnxFormat($,it){const g=d.onnx.ModelProto.decode($);if(et.LongUtil.longToNumber(g.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=g.opsetImport.map(c=>({domain:c.domain,version:et.LongUtil.longToNumber(c.version)})),this._graph=h.Graph.from(g.graph,it)}loadFromOrtFormat($,it){const g=new a.flatbuffers.ByteBuffer($),c=st.InferenceSession.getRootAsInferenceSession(g).model();if(et.LongUtil.longToNumber(c.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let _=0;_<c.opsetImportLength();_++){const ot=c.opsetImport(_);this._opsets.push({domain:ot?.domain(),version:et.LongUtil.longToNumber(ot.version())})}this._graph=h.Graph.from(c.graph(),it)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(o,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.FLOAT_TYPES=e.INT_TYPES=e.NUMBER_TYPES=void 0,e.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],e.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],e.FLOAT_TYPES=["float32","float64"]},1047:(o,e)=>{function s(a,d){if(d.endsWith("+")){const h=Number.parseInt(d.substring(0,d.length-1),10);return!isNaN(h)&&h<=a}if(d.split("-").length===2){const h=d.split("-"),b=Number.parseInt(h[0],10),et=Number.parseInt(h[1],10);return!isNaN(b)&&!isNaN(et)&&b<=a&&a<=et}return Number.parseInt(d,10)===a}Object.defineProperty(e,"__esModule",{value:!0}),e.resolveOperator=void 0,e.resolveOperator=function(a,d,h){for(const b of h){const et=b[0],st=b[1],$=b[2],it=b[3],g=b[4];if(a.opType===et){for(const c of d)if((c.domain===st||c.domain==="ai.onnx"&&st==="")&&s(c.version,$))return{opImpl:it,opInit:g}}}throw new TypeError(`cannot resolve operator '${a.opType}' with opsets: ${d.map(b=>`${b.domain||"ai.onnx"} v${b.version}`).join(", ")}`)}},9395:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.onnxruntime=void 0;const a=s(5686);var d,h;d=e.onnxruntime||(e.onnxruntime={}),function(b){(function(et){et[et.UNDEFINED=0]="UNDEFINED",et[et.FLOAT=1]="FLOAT",et[et.INT=2]="INT",et[et.STRING=3]="STRING",et[et.TENSOR=4]="TENSOR",et[et.GRAPH=5]="GRAPH",et[et.FLOATS=6]="FLOATS",et[et.INTS=7]="INTS",et[et.STRINGS=8]="STRINGS",et[et.TENSORS=9]="TENSORS",et[et.GRAPHS=10]="GRAPHS",et[et.SPARSE_TENSOR=11]="SPARSE_TENSOR",et[et.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(b.AttributeType||(b.AttributeType={}))}((h=d.experimental||(d.experimental={})).fbs||(h.fbs={})),function(b){(function(et){(function(st){(function($){$[$.UNKNOWN=0]="UNKNOWN",$[$.VALUE=1]="VALUE",$[$.PARAM=2]="PARAM"})(st.DimensionValueType||(st.DimensionValueType={}))})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){(function($){$[$.UNDEFINED=0]="UNDEFINED",$[$.FLOAT=1]="FLOAT",$[$.UINT8=2]="UINT8",$[$.INT8=3]="INT8",$[$.UINT16=4]="UINT16",$[$.INT16=5]="INT16",$[$.INT32=6]="INT32",$[$.INT64=7]="INT64",$[$.STRING=8]="STRING",$[$.BOOL=9]="BOOL",$[$.FLOAT16=10]="FLOAT16",$[$.DOUBLE=11]="DOUBLE",$[$.UINT32=12]="UINT32",$[$.UINT64=13]="UINT64",$[$.COMPLEX64=14]="COMPLEX64",$[$.COMPLEX128=15]="COMPLEX128",$[$.BFLOAT16=16]="BFLOAT16"})(st.TensorDataType||(st.TensorDataType={}))})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){(function($){$[$.Primitive=0]="Primitive",$[$.Fused=1]="Fused"})(st.NodeType||(st.NodeType={}))})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){(function($){$[$.NONE=0]="NONE",$[$.tensor_type=1]="tensor_type",$[$.sequence_type=2]="sequence_type",$[$.map_type=3]="map_type"})(st.TypeInfoValue||(st.TypeInfoValue={}))})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsShape(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsShape(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}dim(g,c){let _=this.bb.__offset(this.bb_pos,4);return _?(c||new b.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*g),this.bb):null}dimLength(){let g=this.bb.__offset(this.bb_pos,4);return g?this.bb.__vector_len(this.bb_pos+g):0}static startShape(g){g.startObject(1)}static addDim(g,c){g.addFieldOffset(0,c,0)}static createDimVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startDimVector(g,c){g.startVector(4,c,4)}static endShape(g){return g.endObject()}static createShape(g,c){return $.startShape(g),$.addDim(g,c),$.endShape(g)}}st.Shape=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsDimension(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsDimension(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}value(g){let c=this.bb.__offset(this.bb_pos,4);return c?(g||new b.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}denotation(g){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__string(this.bb_pos+c,g):null}static startDimension(g){g.startObject(2)}static addValue(g,c){g.addFieldOffset(0,c,0)}static addDenotation(g,c){g.addFieldOffset(1,c,0)}static endDimension(g){return g.endObject()}static createDimension(g,c,_){return $.startDimension(g),$.addValue(g,c),$.addDenotation(g,_),$.endDimension(g)}}st.Dimension=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsDimensionValue(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsDimensionValue(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}dimType(){let g=this.bb.__offset(this.bb_pos,4);return g?this.bb.readInt8(this.bb_pos+g):b.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let g=this.bb.__offset(this.bb_pos,6);return g?this.bb.readInt64(this.bb_pos+g):this.bb.createLong(0,0)}dimParam(g){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__string(this.bb_pos+c,g):null}static startDimensionValue(g){g.startObject(3)}static addDimType(g,c){g.addFieldInt8(0,c,b.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(g,c){g.addFieldInt64(1,c,g.createLong(0,0))}static addDimParam(g,c){g.addFieldOffset(2,c,0)}static endDimensionValue(g){return g.endObject()}static createDimensionValue(g,c,_,ot){return $.startDimensionValue(g),$.addDimType(g,c),$.addDimValue(g,_),$.addDimParam(g,ot),$.endDimensionValue(g)}}st.DimensionValue=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsTensorTypeAndShape(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsTensorTypeAndShape(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}elemType(){let g=this.bb.__offset(this.bb_pos,4);return g?this.bb.readInt32(this.bb_pos+g):b.experimental.fbs.TensorDataType.UNDEFINED}shape(g){let c=this.bb.__offset(this.bb_pos,6);return c?(g||new b.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}static startTensorTypeAndShape(g){g.startObject(2)}static addElemType(g,c){g.addFieldInt32(0,c,b.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(g,c){g.addFieldOffset(1,c,0)}static endTensorTypeAndShape(g){return g.endObject()}static createTensorTypeAndShape(g,c,_){return $.startTensorTypeAndShape(g),$.addElemType(g,c),$.addShape(g,_),$.endTensorTypeAndShape(g)}}st.TensorTypeAndShape=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsMapType(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsMapType(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}keyType(){let g=this.bb.__offset(this.bb_pos,4);return g?this.bb.readInt32(this.bb_pos+g):b.experimental.fbs.TensorDataType.UNDEFINED}valueType(g){let c=this.bb.__offset(this.bb_pos,6);return c?(g||new b.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}static startMapType(g){g.startObject(2)}static addKeyType(g,c){g.addFieldInt32(0,c,b.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(g,c){g.addFieldOffset(1,c,0)}static endMapType(g){return g.endObject()}static createMapType(g,c,_){return $.startMapType(g),$.addKeyType(g,c),$.addValueType(g,_),$.endMapType(g)}}st.MapType=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsSequenceType(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsSequenceType(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}elemType(g){let c=this.bb.__offset(this.bb_pos,4);return c?(g||new b.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}static startSequenceType(g){g.startObject(1)}static addElemType(g,c){g.addFieldOffset(0,c,0)}static endSequenceType(g){return g.endObject()}static createSequenceType(g,c){return $.startSequenceType(g),$.addElemType(g,c),$.endSequenceType(g)}}st.SequenceType=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(et.fbs||(et.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(st,$){return this.bb_pos=st,this.bb=$,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(st,$,it,g){return st.prep(4,12),st.writeInt32(g),st.writeInt32(it),st.writeInt32($),st.offset()}}})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsNodeEdge(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsNodeEdge(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}nodeIndex(){let g=this.bb.__offset(this.bb_pos,4);return g?this.bb.readUint32(this.bb_pos+g):0}inputEdges(g,c){let _=this.bb.__offset(this.bb_pos,6);return _?(c||new b.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+_)+12*g,this.bb):null}inputEdgesLength(){let g=this.bb.__offset(this.bb_pos,6);return g?this.bb.__vector_len(this.bb_pos+g):0}outputEdges(g,c){let _=this.bb.__offset(this.bb_pos,8);return _?(c||new b.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+_)+12*g,this.bb):null}outputEdgesLength(){let g=this.bb.__offset(this.bb_pos,8);return g?this.bb.__vector_len(this.bb_pos+g):0}static startNodeEdge(g){g.startObject(3)}static addNodeIndex(g,c){g.addFieldInt32(0,c,0)}static addInputEdges(g,c){g.addFieldOffset(1,c,0)}static startInputEdgesVector(g,c){g.startVector(12,c,4)}static addOutputEdges(g,c){g.addFieldOffset(2,c,0)}static startOutputEdgesVector(g,c){g.startVector(12,c,4)}static endNodeEdge(g){return g.endObject()}static createNodeEdge(g,c,_,ot){return $.startNodeEdge(g),$.addNodeIndex(g,c),$.addInputEdges(g,_),$.addOutputEdges(g,ot),$.endNodeEdge(g)}}st.NodeEdge=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsNode(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsNode(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}name(g){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__string(this.bb_pos+c,g):null}docString(g){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__string(this.bb_pos+c,g):null}domain(g){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__string(this.bb_pos+c,g):null}sinceVersion(){let g=this.bb.__offset(this.bb_pos,10);return g?this.bb.readInt32(this.bb_pos+g):0}index(){let g=this.bb.__offset(this.bb_pos,12);return g?this.bb.readUint32(this.bb_pos+g):0}opType(g){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.__string(this.bb_pos+c,g):null}type(){let g=this.bb.__offset(this.bb_pos,16);return g?this.bb.readInt32(this.bb_pos+g):b.experimental.fbs.NodeType.Primitive}executionProviderType(g){let c=this.bb.__offset(this.bb_pos,18);return c?this.bb.__string(this.bb_pos+c,g):null}inputs(g,c){let _=this.bb.__offset(this.bb_pos,20);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*g,c):null}inputsLength(){let g=this.bb.__offset(this.bb_pos,20);return g?this.bb.__vector_len(this.bb_pos+g):0}outputs(g,c){let _=this.bb.__offset(this.bb_pos,22);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*g,c):null}outputsLength(){let g=this.bb.__offset(this.bb_pos,22);return g?this.bb.__vector_len(this.bb_pos+g):0}attributes(g,c){let _=this.bb.__offset(this.bb_pos,24);return _?(c||new b.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*g),this.bb):null}attributesLength(){let g=this.bb.__offset(this.bb_pos,24);return g?this.bb.__vector_len(this.bb_pos+g):0}inputArgCounts(g){let c=this.bb.__offset(this.bb_pos,26);return c?this.bb.readInt32(this.bb.__vector(this.bb_pos+c)+4*g):0}inputArgCountsLength(){let g=this.bb.__offset(this.bb_pos,26);return g?this.bb.__vector_len(this.bb_pos+g):0}inputArgCountsArray(){let g=this.bb.__offset(this.bb_pos,26);return g?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+g),this.bb.__vector_len(this.bb_pos+g)):null}implicitInputs(g,c){let _=this.bb.__offset(this.bb_pos,28);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*g,c):null}implicitInputsLength(){let g=this.bb.__offset(this.bb_pos,28);return g?this.bb.__vector_len(this.bb_pos+g):0}static startNode(g){g.startObject(13)}static addName(g,c){g.addFieldOffset(0,c,0)}static addDocString(g,c){g.addFieldOffset(1,c,0)}static addDomain(g,c){g.addFieldOffset(2,c,0)}static addSinceVersion(g,c){g.addFieldInt32(3,c,0)}static addIndex(g,c){g.addFieldInt32(4,c,0)}static addOpType(g,c){g.addFieldOffset(5,c,0)}static addType(g,c){g.addFieldInt32(6,c,b.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(g,c){g.addFieldOffset(7,c,0)}static addInputs(g,c){g.addFieldOffset(8,c,0)}static createInputsVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startInputsVector(g,c){g.startVector(4,c,4)}static addOutputs(g,c){g.addFieldOffset(9,c,0)}static createOutputsVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startOutputsVector(g,c){g.startVector(4,c,4)}static addAttributes(g,c){g.addFieldOffset(10,c,0)}static createAttributesVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startAttributesVector(g,c){g.startVector(4,c,4)}static addInputArgCounts(g,c){g.addFieldOffset(11,c,0)}static createInputArgCountsVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addInt32(c[_]);return g.endVector()}static startInputArgCountsVector(g,c){g.startVector(4,c,4)}static addImplicitInputs(g,c){g.addFieldOffset(12,c,0)}static createImplicitInputsVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startImplicitInputsVector(g,c){g.startVector(4,c,4)}static endNode(g){return g.endObject()}static createNode(g,c,_,ot,ct,dt,pt,ft,ht,bt,mt,$t,Tt,Nt){return $.startNode(g),$.addName(g,c),$.addDocString(g,_),$.addDomain(g,ot),$.addSinceVersion(g,ct),$.addIndex(g,dt),$.addOpType(g,pt),$.addType(g,ft),$.addExecutionProviderType(g,ht),$.addInputs(g,bt),$.addOutputs(g,mt),$.addAttributes(g,$t),$.addInputArgCounts(g,Tt),$.addImplicitInputs(g,Nt),$.endNode(g)}}st.Node=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsValueInfo(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsValueInfo(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}name(g){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__string(this.bb_pos+c,g):null}docString(g){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__string(this.bb_pos+c,g):null}type(g){let c=this.bb.__offset(this.bb_pos,8);return c?(g||new b.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}static startValueInfo(g){g.startObject(3)}static addName(g,c){g.addFieldOffset(0,c,0)}static addDocString(g,c){g.addFieldOffset(1,c,0)}static addType(g,c){g.addFieldOffset(2,c,0)}static endValueInfo(g){return g.endObject()}static createValueInfo(g,c,_,ot){return $.startValueInfo(g),$.addName(g,c),$.addDocString(g,_),$.addType(g,ot),$.endValueInfo(g)}}st.ValueInfo=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsTypeInfo(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsTypeInfo(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}denotation(g){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__string(this.bb_pos+c,g):null}valueType(){let g=this.bb.__offset(this.bb_pos,6);return g?this.bb.readUint8(this.bb_pos+g):b.experimental.fbs.TypeInfoValue.NONE}value(g){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__union(g,this.bb_pos+c):null}static startTypeInfo(g){g.startObject(3)}static addDenotation(g,c){g.addFieldOffset(0,c,0)}static addValueType(g,c){g.addFieldInt8(1,c,b.experimental.fbs.TypeInfoValue.NONE)}static addValue(g,c){g.addFieldOffset(2,c,0)}static endTypeInfo(g){return g.endObject()}static createTypeInfo(g,c,_,ot){return $.startTypeInfo(g),$.addDenotation(g,c),$.addValueType(g,_),$.addValue(g,ot),$.endTypeInfo(g)}}st.TypeInfo=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsOperatorSetId(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsOperatorSetId(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}domain(g){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__string(this.bb_pos+c,g):null}version(){let g=this.bb.__offset(this.bb_pos,6);return g?this.bb.readInt64(this.bb_pos+g):this.bb.createLong(0,0)}static startOperatorSetId(g){g.startObject(2)}static addDomain(g,c){g.addFieldOffset(0,c,0)}static addVersion(g,c){g.addFieldInt64(1,c,g.createLong(0,0))}static endOperatorSetId(g){return g.endObject()}static createOperatorSetId(g,c,_){return $.startOperatorSetId(g),$.addDomain(g,c),$.addVersion(g,_),$.endOperatorSetId(g)}}st.OperatorSetId=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsTensor(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsTensor(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}name(g){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__string(this.bb_pos+c,g):null}docString(g){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__string(this.bb_pos+c,g):null}dims(g){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.readInt64(this.bb.__vector(this.bb_pos+c)+8*g):this.bb.createLong(0,0)}dimsLength(){let g=this.bb.__offset(this.bb_pos,8);return g?this.bb.__vector_len(this.bb_pos+g):0}dataType(){let g=this.bb.__offset(this.bb_pos,10);return g?this.bb.readInt32(this.bb_pos+g):b.experimental.fbs.TensorDataType.UNDEFINED}rawData(g){let c=this.bb.__offset(this.bb_pos,12);return c?this.bb.readUint8(this.bb.__vector(this.bb_pos+c)+g):0}rawDataLength(){let g=this.bb.__offset(this.bb_pos,12);return g?this.bb.__vector_len(this.bb_pos+g):0}rawDataArray(){let g=this.bb.__offset(this.bb_pos,12);return g?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+g),this.bb.__vector_len(this.bb_pos+g)):null}stringData(g,c){let _=this.bb.__offset(this.bb_pos,14);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*g,c):null}stringDataLength(){let g=this.bb.__offset(this.bb_pos,14);return g?this.bb.__vector_len(this.bb_pos+g):0}static startTensor(g){g.startObject(6)}static addName(g,c){g.addFieldOffset(0,c,0)}static addDocString(g,c){g.addFieldOffset(1,c,0)}static addDims(g,c){g.addFieldOffset(2,c,0)}static createDimsVector(g,c){g.startVector(8,c.length,8);for(let _=c.length-1;_>=0;_--)g.addInt64(c[_]);return g.endVector()}static startDimsVector(g,c){g.startVector(8,c,8)}static addDataType(g,c){g.addFieldInt32(3,c,b.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(g,c){g.addFieldOffset(4,c,0)}static createRawDataVector(g,c){g.startVector(1,c.length,1);for(let _=c.length-1;_>=0;_--)g.addInt8(c[_]);return g.endVector()}static startRawDataVector(g,c){g.startVector(1,c,1)}static addStringData(g,c){g.addFieldOffset(5,c,0)}static createStringDataVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startStringDataVector(g,c){g.startVector(4,c,4)}static endTensor(g){return g.endObject()}static createTensor(g,c,_,ot,ct,dt,pt){return $.startTensor(g),$.addName(g,c),$.addDocString(g,_),$.addDims(g,ot),$.addDataType(g,ct),$.addRawData(g,dt),$.addStringData(g,pt),$.endTensor(g)}}st.Tensor=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsSparseTensor(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsSparseTensor(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}values(g){let c=this.bb.__offset(this.bb_pos,4);return c?(g||new b.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}indices(g){let c=this.bb.__offset(this.bb_pos,6);return c?(g||new b.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}dims(g){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.readInt64(this.bb.__vector(this.bb_pos+c)+8*g):this.bb.createLong(0,0)}dimsLength(){let g=this.bb.__offset(this.bb_pos,8);return g?this.bb.__vector_len(this.bb_pos+g):0}static startSparseTensor(g){g.startObject(3)}static addValues(g,c){g.addFieldOffset(0,c,0)}static addIndices(g,c){g.addFieldOffset(1,c,0)}static addDims(g,c){g.addFieldOffset(2,c,0)}static createDimsVector(g,c){g.startVector(8,c.length,8);for(let _=c.length-1;_>=0;_--)g.addInt64(c[_]);return g.endVector()}static startDimsVector(g,c){g.startVector(8,c,8)}static endSparseTensor(g){return g.endObject()}static createSparseTensor(g,c,_,ot){return $.startSparseTensor(g),$.addValues(g,c),$.addIndices(g,_),$.addDims(g,ot),$.endSparseTensor(g)}}st.SparseTensor=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsAttribute(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsAttribute(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}name(g){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__string(this.bb_pos+c,g):null}docString(g){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__string(this.bb_pos+c,g):null}type(){let g=this.bb.__offset(this.bb_pos,8);return g?this.bb.readInt32(this.bb_pos+g):b.experimental.fbs.AttributeType.UNDEFINED}f(){let g=this.bb.__offset(this.bb_pos,10);return g?this.bb.readFloat32(this.bb_pos+g):0}i(){let g=this.bb.__offset(this.bb_pos,12);return g?this.bb.readInt64(this.bb_pos+g):this.bb.createLong(0,0)}s(g){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.__string(this.bb_pos+c,g):null}t(g){let c=this.bb.__offset(this.bb_pos,16);return c?(g||new b.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}g(g){let c=this.bb.__offset(this.bb_pos,18);return c?(g||new b.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}floats(g){let c=this.bb.__offset(this.bb_pos,20);return c?this.bb.readFloat32(this.bb.__vector(this.bb_pos+c)+4*g):0}floatsLength(){let g=this.bb.__offset(this.bb_pos,20);return g?this.bb.__vector_len(this.bb_pos+g):0}floatsArray(){let g=this.bb.__offset(this.bb_pos,20);return g?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+g),this.bb.__vector_len(this.bb_pos+g)):null}ints(g){let c=this.bb.__offset(this.bb_pos,22);return c?this.bb.readInt64(this.bb.__vector(this.bb_pos+c)+8*g):this.bb.createLong(0,0)}intsLength(){let g=this.bb.__offset(this.bb_pos,22);return g?this.bb.__vector_len(this.bb_pos+g):0}strings(g,c){let _=this.bb.__offset(this.bb_pos,24);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*g,c):null}stringsLength(){let g=this.bb.__offset(this.bb_pos,24);return g?this.bb.__vector_len(this.bb_pos+g):0}tensors(g,c){let _=this.bb.__offset(this.bb_pos,26);return _?(c||new b.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*g),this.bb):null}tensorsLength(){let g=this.bb.__offset(this.bb_pos,26);return g?this.bb.__vector_len(this.bb_pos+g):0}graphs(g,c){let _=this.bb.__offset(this.bb_pos,28);return _?(c||new b.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*g),this.bb):null}graphsLength(){let g=this.bb.__offset(this.bb_pos,28);return g?this.bb.__vector_len(this.bb_pos+g):0}static startAttribute(g){g.startObject(13)}static addName(g,c){g.addFieldOffset(0,c,0)}static addDocString(g,c){g.addFieldOffset(1,c,0)}static addType(g,c){g.addFieldInt32(2,c,b.experimental.fbs.AttributeType.UNDEFINED)}static addF(g,c){g.addFieldFloat32(3,c,0)}static addI(g,c){g.addFieldInt64(4,c,g.createLong(0,0))}static addS(g,c){g.addFieldOffset(5,c,0)}static addT(g,c){g.addFieldOffset(6,c,0)}static addG(g,c){g.addFieldOffset(7,c,0)}static addFloats(g,c){g.addFieldOffset(8,c,0)}static createFloatsVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addFloat32(c[_]);return g.endVector()}static startFloatsVector(g,c){g.startVector(4,c,4)}static addInts(g,c){g.addFieldOffset(9,c,0)}static createIntsVector(g,c){g.startVector(8,c.length,8);for(let _=c.length-1;_>=0;_--)g.addInt64(c[_]);return g.endVector()}static startIntsVector(g,c){g.startVector(8,c,8)}static addStrings(g,c){g.addFieldOffset(10,c,0)}static createStringsVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startStringsVector(g,c){g.startVector(4,c,4)}static addTensors(g,c){g.addFieldOffset(11,c,0)}static createTensorsVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startTensorsVector(g,c){g.startVector(4,c,4)}static addGraphs(g,c){g.addFieldOffset(12,c,0)}static createGraphsVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startGraphsVector(g,c){g.startVector(4,c,4)}static endAttribute(g){return g.endObject()}static createAttribute(g,c,_,ot,ct,dt,pt,ft,ht,bt,mt,$t,Tt,Nt){return $.startAttribute(g),$.addName(g,c),$.addDocString(g,_),$.addType(g,ot),$.addF(g,ct),$.addI(g,dt),$.addS(g,pt),$.addT(g,ft),$.addG(g,ht),$.addFloats(g,bt),$.addInts(g,mt),$.addStrings(g,$t),$.addTensors(g,Tt),$.addGraphs(g,Nt),$.endAttribute(g)}}st.Attribute=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsGraph(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsGraph(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}initializers(g,c){let _=this.bb.__offset(this.bb_pos,4);return _?(c||new b.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*g),this.bb):null}initializersLength(){let g=this.bb.__offset(this.bb_pos,4);return g?this.bb.__vector_len(this.bb_pos+g):0}nodeArgs(g,c){let _=this.bb.__offset(this.bb_pos,6);return _?(c||new b.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*g),this.bb):null}nodeArgsLength(){let g=this.bb.__offset(this.bb_pos,6);return g?this.bb.__vector_len(this.bb_pos+g):0}nodes(g,c){let _=this.bb.__offset(this.bb_pos,8);return _?(c||new b.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*g),this.bb):null}nodesLength(){let g=this.bb.__offset(this.bb_pos,8);return g?this.bb.__vector_len(this.bb_pos+g):0}maxNodeIndex(){let g=this.bb.__offset(this.bb_pos,10);return g?this.bb.readUint32(this.bb_pos+g):0}nodeEdges(g,c){let _=this.bb.__offset(this.bb_pos,12);return _?(c||new b.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*g),this.bb):null}nodeEdgesLength(){let g=this.bb.__offset(this.bb_pos,12);return g?this.bb.__vector_len(this.bb_pos+g):0}inputs(g,c){let _=this.bb.__offset(this.bb_pos,14);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*g,c):null}inputsLength(){let g=this.bb.__offset(this.bb_pos,14);return g?this.bb.__vector_len(this.bb_pos+g):0}outputs(g,c){let _=this.bb.__offset(this.bb_pos,16);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*g,c):null}outputsLength(){let g=this.bb.__offset(this.bb_pos,16);return g?this.bb.__vector_len(this.bb_pos+g):0}sparseInitializers(g,c){let _=this.bb.__offset(this.bb_pos,18);return _?(c||new b.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*g),this.bb):null}sparseInitializersLength(){let g=this.bb.__offset(this.bb_pos,18);return g?this.bb.__vector_len(this.bb_pos+g):0}static startGraph(g){g.startObject(8)}static addInitializers(g,c){g.addFieldOffset(0,c,0)}static createInitializersVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startInitializersVector(g,c){g.startVector(4,c,4)}static addNodeArgs(g,c){g.addFieldOffset(1,c,0)}static createNodeArgsVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startNodeArgsVector(g,c){g.startVector(4,c,4)}static addNodes(g,c){g.addFieldOffset(2,c,0)}static createNodesVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startNodesVector(g,c){g.startVector(4,c,4)}static addMaxNodeIndex(g,c){g.addFieldInt32(3,c,0)}static addNodeEdges(g,c){g.addFieldOffset(4,c,0)}static createNodeEdgesVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startNodeEdgesVector(g,c){g.startVector(4,c,4)}static addInputs(g,c){g.addFieldOffset(5,c,0)}static createInputsVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startInputsVector(g,c){g.startVector(4,c,4)}static addOutputs(g,c){g.addFieldOffset(6,c,0)}static createOutputsVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startOutputsVector(g,c){g.startVector(4,c,4)}static addSparseInitializers(g,c){g.addFieldOffset(7,c,0)}static createSparseInitializersVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startSparseInitializersVector(g,c){g.startVector(4,c,4)}static endGraph(g){return g.endObject()}static createGraph(g,c,_,ot,ct,dt,pt,ft,ht){return $.startGraph(g),$.addInitializers(g,c),$.addNodeArgs(g,_),$.addNodes(g,ot),$.addMaxNodeIndex(g,ct),$.addNodeEdges(g,dt),$.addInputs(g,pt),$.addOutputs(g,ft),$.addSparseInitializers(g,ht),$.endGraph(g)}}st.Graph=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsModel(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsModel(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}irVersion(){let g=this.bb.__offset(this.bb_pos,4);return g?this.bb.readInt64(this.bb_pos+g):this.bb.createLong(0,0)}opsetImport(g,c){let _=this.bb.__offset(this.bb_pos,6);return _?(c||new b.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*g),this.bb):null}opsetImportLength(){let g=this.bb.__offset(this.bb_pos,6);return g?this.bb.__vector_len(this.bb_pos+g):0}producerName(g){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__string(this.bb_pos+c,g):null}producerVersion(g){let c=this.bb.__offset(this.bb_pos,10);return c?this.bb.__string(this.bb_pos+c,g):null}domain(g){let c=this.bb.__offset(this.bb_pos,12);return c?this.bb.__string(this.bb_pos+c,g):null}modelVersion(){let g=this.bb.__offset(this.bb_pos,14);return g?this.bb.readInt64(this.bb_pos+g):this.bb.createLong(0,0)}docString(g){let c=this.bb.__offset(this.bb_pos,16);return c?this.bb.__string(this.bb_pos+c,g):null}graph(g){let c=this.bb.__offset(this.bb_pos,18);return c?(g||new b.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}graphDocString(g){let c=this.bb.__offset(this.bb_pos,20);return c?this.bb.__string(this.bb_pos+c,g):null}static startModel(g){g.startObject(9)}static addIrVersion(g,c){g.addFieldInt64(0,c,g.createLong(0,0))}static addOpsetImport(g,c){g.addFieldOffset(1,c,0)}static createOpsetImportVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startOpsetImportVector(g,c){g.startVector(4,c,4)}static addProducerName(g,c){g.addFieldOffset(2,c,0)}static addProducerVersion(g,c){g.addFieldOffset(3,c,0)}static addDomain(g,c){g.addFieldOffset(4,c,0)}static addModelVersion(g,c){g.addFieldInt64(5,c,g.createLong(0,0))}static addDocString(g,c){g.addFieldOffset(6,c,0)}static addGraph(g,c){g.addFieldOffset(7,c,0)}static addGraphDocString(g,c){g.addFieldOffset(8,c,0)}static endModel(g){return g.endObject()}static createModel(g,c,_,ot,ct,dt,pt,ft,ht,bt){return $.startModel(g),$.addIrVersion(g,c),$.addOpsetImport(g,_),$.addProducerName(g,ot),$.addProducerVersion(g,ct),$.addDomain(g,dt),$.addModelVersion(g,pt),$.addDocString(g,ft),$.addGraph(g,ht),$.addGraphDocString(g,bt),$.endModel(g)}}st.Model=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsKernelCreateInfos(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsKernelCreateInfos(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}nodeIndices(g){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.readUint32(this.bb.__vector(this.bb_pos+c)+4*g):0}nodeIndicesLength(){let g=this.bb.__offset(this.bb_pos,4);return g?this.bb.__vector_len(this.bb_pos+g):0}nodeIndicesArray(){let g=this.bb.__offset(this.bb_pos,4);return g?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+g),this.bb.__vector_len(this.bb_pos+g)):null}kernelDefHashes(g){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.readUint64(this.bb.__vector(this.bb_pos+c)+8*g):this.bb.createLong(0,0)}kernelDefHashesLength(){let g=this.bb.__offset(this.bb_pos,6);return g?this.bb.__vector_len(this.bb_pos+g):0}static startKernelCreateInfos(g){g.startObject(2)}static addNodeIndices(g,c){g.addFieldOffset(0,c,0)}static createNodeIndicesVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addInt32(c[_]);return g.endVector()}static startNodeIndicesVector(g,c){g.startVector(4,c,4)}static addKernelDefHashes(g,c){g.addFieldOffset(1,c,0)}static createKernelDefHashesVector(g,c){g.startVector(8,c.length,8);for(let _=c.length-1;_>=0;_--)g.addInt64(c[_]);return g.endVector()}static startKernelDefHashesVector(g,c){g.startVector(8,c,8)}static endKernelCreateInfos(g){return g.endObject()}static createKernelCreateInfos(g,c,_){return $.startKernelCreateInfos(g),$.addNodeIndices(g,c),$.addKernelDefHashes(g,_),$.endKernelCreateInfos(g)}}st.KernelCreateInfos=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsSubGraphSessionState(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsSubGraphSessionState(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}graphId(g){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__string(this.bb_pos+c,g):null}sessionState(g){let c=this.bb.__offset(this.bb_pos,6);return c?(g||new b.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}static startSubGraphSessionState(g){g.startObject(2)}static addGraphId(g,c){g.addFieldOffset(0,c,0)}static addSessionState(g,c){g.addFieldOffset(1,c,0)}static endSubGraphSessionState(g){let c=g.endObject();return g.requiredField(c,4),c}static createSubGraphSessionState(g,c,_){return $.startSubGraphSessionState(g),$.addGraphId(g,c),$.addSessionState(g,_),$.endSubGraphSessionState(g)}}st.SubGraphSessionState=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsSessionState(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsSessionState(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}kernels(g){let c=this.bb.__offset(this.bb_pos,4);return c?(g||new b.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}subGraphSessionStates(g,c){let _=this.bb.__offset(this.bb_pos,6);return _?(c||new b.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*g),this.bb):null}subGraphSessionStatesLength(){let g=this.bb.__offset(this.bb_pos,6);return g?this.bb.__vector_len(this.bb_pos+g):0}static startSessionState(g){g.startObject(2)}static addKernels(g,c){g.addFieldOffset(0,c,0)}static addSubGraphSessionStates(g,c){g.addFieldOffset(1,c,0)}static createSubGraphSessionStatesVector(g,c){g.startVector(4,c.length,4);for(let _=c.length-1;_>=0;_--)g.addOffset(c[_]);return g.endVector()}static startSubGraphSessionStatesVector(g,c){g.startVector(4,c,4)}static endSessionState(g){return g.endObject()}static createSessionState(g,c,_){return $.startSessionState(g),$.addKernels(g,c),$.addSubGraphSessionStates(g,_),$.endSessionState(g)}}st.SessionState=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(b){(function(et){(function(st){class ${constructor(){this.bb=null,this.bb_pos=0}__init(g,c){return this.bb_pos=g,this.bb=c,this}static getRootAsInferenceSession(g,c){return(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static getSizePrefixedRootAsInferenceSession(g,c){return g.setPosition(g.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(c||new $).__init(g.readInt32(g.position())+g.position(),g)}static bufferHasIdentifier(g){return g.__has_identifier("ORTM")}ortVersion(g){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__string(this.bb_pos+c,g):null}model(g){let c=this.bb.__offset(this.bb_pos,6);return c?(g||new b.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}sessionState(g){let c=this.bb.__offset(this.bb_pos,8);return c?(g||new b.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+c),this.bb):null}static startInferenceSession(g){g.startObject(3)}static addOrtVersion(g,c){g.addFieldOffset(0,c,0)}static addModel(g,c){g.addFieldOffset(1,c,0)}static addSessionState(g,c){g.addFieldOffset(2,c,0)}static endInferenceSession(g){return g.endObject()}static finishInferenceSessionBuffer(g,c){g.finish(c,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(g,c){g.finish(c,"ORTM",!0)}static createInferenceSession(g,c,_,ot){return $.startInferenceSession(g),$.addOrtVersion(g,c),$.addModel(g,_),$.addSessionState(g,ot),$.endInferenceSession(g)}}st.InferenceSession=$})(et.fbs||(et.fbs={}))})(b.experimental||(b.experimental={}))}(e.onnxruntime||(e.onnxruntime={}))},7448:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.OnnxjsSessionHandler=void 0;const a=s(1670),d=s(9162);e.OnnxjsSessionHandler=class{constructor(h){this.session=h,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(h,b,et){const st=new Map;for(const g in h)if(Object.hasOwnProperty.call(h,g)){const c=h[g];st.set(g,new d.Tensor(c.dims,c.type,void 0,void 0,c.data))}const $=await this.session.run(st),it={};return $.forEach((g,c)=>{it[c]=new a.Tensor(g.type,g.data,g.dims)}),it}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Session=void 0;const a=s(7067),d=s(1296),h=s(7091),b=s(1036),et=s(6231),st=s(2644);e.Session=class{constructor($={}){this._initialized=!1,this.backendHint=$.backendHint,this.profiler=et.Profiler.create($.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel($,it,g){await this.profiler.event("session","Session.loadModel",async()=>{const c=await(0,h.resolveBackend)(this.backendHint);if(this.sessionHandler=c.createSessionHandler(this.context),this._model=new st.Model,typeof $=="string"){const _=$.endsWith(".ort");if(typeof fetch>"u"){const ot=await(0,d.promisify)(a.readFile)($);this.initialize(ot,_)}else{const ot=await fetch($),ct=await ot.arrayBuffer();this.initialize(new Uint8Array(ct),_)}}else if(ArrayBuffer.isView($))this.initialize($);else{const _=new Uint8Array($,it||0,g||$.byteLength);this.initialize(_)}})}initialize($,it){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{const g=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load($,g,it),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new b.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run($){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{const it=this.normalizeAndValidateInputs($),g=await this._executionPlan.execute(this.sessionHandler,it);return this.createOutput(g)})}normalizeAndValidateInputs($){const it=this._model.graph.getInputNames();if(Array.isArray($)){if($.length!==it.length)throw new Error(`incorrect input array length: expected ${it.length} but got ${$.length}`)}else{if($.size!==it.length)throw new Error(`incorrect input map size: expected ${it.length} but got ${$.size}`);const g=new Array($.size);let c=0;for(let _=0;_<it.length;++_){const ot=$.get(it[_]);if(!ot)throw new Error(`missing input tensor for: '${name}'`);g[c++]=ot}$=g}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,$,!1);else{const g=this._model.graph.getInputIndices(),c=this._model.graph.getValues(),_=new Array(g.length);for(let ot=0;ot<g.length;++ot){const ct=c[g[ot]];_[ot]=ct.type.shape.dims,this.context.graphInputTypes.push(ct.type.tensorType),this.context.graphInputDims.push($[ot].dims)}this.validateInputTensorDims(_,$,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,$),$}validateInputTensorTypes($,it){for(let g=0;g<it.length;g++){const c=$[g],_=it[g].type;if(c!==_)throw new Error(`input tensor[${g}] check failed: expected type '${c}' but got ${_}`)}}validateInputTensorDims($,it,g){for(let c=0;c<it.length;c++){const _=$[c],ot=it[c].dims;if(!this.compareTensorDims(_,ot,g))throw new Error(`input tensor[${c}] check failed: expected shape '[${_.join(",")}]' but got [${ot.join(",")}]`)}}compareTensorDims($,it,g){if($.length!==it.length)return!1;for(let c=0;c<$.length;++c)if($[c]!==it[c]&&(!g||$[c]!==0))return!1;return!0}createOutput($){const it=this._model.graph.getOutputNames();if($.length!==it.length)throw new Error("expected number of outputs do not match number of generated outputs");const g=new Map;for(let c=0;c<it.length;++c)g.set(it[c],$[c]);return g}initializeOps($){const it=$.getNodes();this._ops=new Array(it.length);for(let g=0;g<it.length;g++)this._ops[g]=this.sessionHandler.resolve(it[g],this._model.opsets,$)}}},9162:function(o,e,s){var a=this&&this.__importDefault||function(ct){return ct&&ct.__esModule?ct:{default:ct}};Object.defineProperty(e,"__esModule",{value:!0}),e.Tensor=void 0;const d=s(3442),h=a(s(3720)),b=s(1446),et=s(9395),st=s(2517);var $=et.onnxruntime.experimental.fbs;class it{get data(){if(this.cache===void 0){const dt=this.dataProvider(this.dataId);if(dt.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=dt}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(dt){return this.data[st.ShapeUtil.indicesToOffset(dt,this.strides)]}set(dt,pt){this.data[st.ShapeUtil.indicesToOffset(dt,this.strides)]=pt}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=st.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(dt,pt,ft,ht,bt,mt=d.Guid.create()){this.dims=dt,this.type=pt,this.dataProvider=ft,this.asyncDataProvider=ht,this.cache=bt,this.dataId=mt,this.size=st.ShapeUtil.validateDimsAndCalcSize(dt);const $t=this.size,Tt=ft===void 0&&ht===void 0&&bt===void 0;if(bt!==void 0&&bt.length!==$t)throw new RangeError("Input dims doesn't match data length.");if(pt==="string"){if(!(bt===void 0||Array.isArray(bt)&&bt.every(Nt=>typeof Nt=="string")))throw new TypeError("cache should be a string array");Tt&&(this.cache=new Array($t))}else{if(bt!==void 0){const Nt=c(pt);if(!(bt instanceof Nt))throw new TypeError(`cache should be type ${Nt.name}`)}if(Tt){const Nt=new ArrayBuffer($t*function(Ct){switch(Ct){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${Ct}`)}}(pt));this.cache=function(Ct,Ft){return new(c(Ft))(Ct)}(Nt,pt)}}}static fromProto(dt){if(!dt)throw new Error("cannot construct Value from an empty tensor");const pt=st.ProtoUtil.tensorDataTypeFromProto(dt.dataType),ft=st.ProtoUtil.tensorDimsFromProto(dt.dims),ht=new it(ft,pt);if(pt==="string")dt.stringData.forEach((bt,mt)=>{ht.data[mt]=(0,st.decodeUtf8String)(bt)});else if(dt.rawData&&typeof dt.rawData.byteLength=="number"&&dt.rawData.byteLength>0){const bt=ht.data,mt=new DataView(dt.rawData.buffer,dt.rawData.byteOffset,dt.rawData.byteLength),$t=g(dt.dataType),Tt=dt.rawData.byteLength/$t;if(dt.rawData.byteLength%$t!=0)throw new Error("invalid buffer length");if(bt.length!==Tt)throw new Error("buffer length mismatch");for(let Nt=0;Nt<Tt;Nt++){const Ct=ot(mt,dt.dataType,Nt*$t);bt[Nt]=Ct}}else{let bt;switch(dt.dataType){case b.onnx.TensorProto.DataType.FLOAT:bt=dt.floatData;break;case b.onnx.TensorProto.DataType.INT32:case b.onnx.TensorProto.DataType.INT16:case b.onnx.TensorProto.DataType.UINT16:case b.onnx.TensorProto.DataType.INT8:case b.onnx.TensorProto.DataType.UINT8:case b.onnx.TensorProto.DataType.BOOL:bt=dt.int32Data;break;case b.onnx.TensorProto.DataType.INT64:bt=dt.int64Data;break;case b.onnx.TensorProto.DataType.DOUBLE:bt=dt.doubleData;break;case b.onnx.TensorProto.DataType.UINT32:case b.onnx.TensorProto.DataType.UINT64:bt=dt.uint64Data;break;default:throw new Error("unspecific error")}if(bt==null)throw new Error("failed to populate data from a tensorproto value");const mt=ht.data;if(mt.length!==bt.length)throw new Error("array length mismatch");for(let $t=0;$t<bt.length;$t++){const Tt=bt[$t];h.default.isLong(Tt)?mt[$t]=_(Tt,dt.dataType):mt[$t]=Tt}}return ht}static fromData(dt,pt,ft){return new it(pt,ft,void 0,void 0,dt)}static fromOrtTensor(dt){if(!dt)throw new Error("cannot construct Value from an empty tensor");const pt=st.ProtoUtil.tensorDimsFromORTFormat(dt),ft=st.ProtoUtil.tensorDataTypeFromProto(dt.dataType()),ht=new it(pt,ft);if(ft==="string")for(let bt=0;bt<dt.stringDataLength();bt++)ht.data[bt]=dt.stringData(bt);else if(dt.rawDataArray()&&typeof dt.rawDataLength()=="number"&&dt.rawDataLength()>0){const bt=ht.data,mt=new DataView(dt.rawDataArray().buffer,dt.rawDataArray().byteOffset,dt.rawDataLength()),$t=g(dt.dataType()),Tt=dt.rawDataLength()/$t;if(dt.rawDataLength()%$t!=0)throw new Error("invalid buffer length");if(bt.length!==Tt)throw new Error("buffer length mismatch");for(let Nt=0;Nt<Tt;Nt++){const Ct=ot(mt,dt.dataType(),Nt*$t);bt[Nt]=Ct}}return ht}}function g(ct){switch(ct){case b.onnx.TensorProto.DataType.UINT8:case b.onnx.TensorProto.DataType.INT8:case b.onnx.TensorProto.DataType.BOOL:return 1;case b.onnx.TensorProto.DataType.UINT16:case b.onnx.TensorProto.DataType.INT16:return 2;case b.onnx.TensorProto.DataType.FLOAT:case b.onnx.TensorProto.DataType.INT32:case b.onnx.TensorProto.DataType.UINT32:return 4;case b.onnx.TensorProto.DataType.INT64:case b.onnx.TensorProto.DataType.DOUBLE:case b.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${b.onnx.TensorProto.DataType[ct]}`)}}function c(ct){switch(ct){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function _(ct,dt){if(dt===b.onnx.TensorProto.DataType.INT64||dt===$.TensorDataType.INT64){if(ct.greaterThanOrEqual(2147483648)||ct.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(dt!==b.onnx.TensorProto.DataType.UINT32&&dt!==$.TensorDataType.UINT32&&dt!==b.onnx.TensorProto.DataType.UINT64&&dt!==$.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${b.onnx.TensorProto.DataType[dt]}`);if(ct.greaterThanOrEqual(4294967296)||ct.lessThan(0))throw new TypeError("uint64 is not supported")}return ct.toNumber()}function ot(ct,dt,pt){switch(dt){case b.onnx.TensorProto.DataType.BOOL:case b.onnx.TensorProto.DataType.UINT8:return ct.getUint8(pt);case b.onnx.TensorProto.DataType.INT8:return ct.getInt8(pt);case b.onnx.TensorProto.DataType.UINT16:return ct.getUint16(pt,!0);case b.onnx.TensorProto.DataType.INT16:return ct.getInt16(pt,!0);case b.onnx.TensorProto.DataType.FLOAT:return ct.getFloat32(pt,!0);case b.onnx.TensorProto.DataType.INT32:return ct.getInt32(pt,!0);case b.onnx.TensorProto.DataType.UINT32:return ct.getUint32(pt,!0);case b.onnx.TensorProto.DataType.INT64:return _(h.default.fromBits(ct.getUint32(pt,!0),ct.getUint32(pt+4,!0),!1),dt);case b.onnx.TensorProto.DataType.DOUBLE:return ct.getFloat64(pt,!0);case b.onnx.TensorProto.DataType.UINT64:return _(h.default.fromBits(ct.getUint32(pt,!0),ct.getUint32(pt+4,!0),!0),dt);default:throw new Error(`cannot read from DataView for type ${b.onnx.TensorProto.DataType[dt]}`)}}e.Tensor=it},2517:function(o,e,s){var a=this&&this.__importDefault||function(dt){return dt&&dt.__esModule?dt:{default:dt}};Object.defineProperty(e,"__esModule",{value:!0}),e.decodeUtf8String=e.MAX_CLIP=e.MIN_CLIP=e.PoolConvUtil=e.ReduceUtil=e.SplitUtil=e.MathUtil=e.ShapeUtil=e.LongUtil=e.ProtoUtil=e.GemmUtil=e.arrayCopyHelper=e.BroadcastUtil=e.MatMulUtil=e.ArrayUtil=e.assert=e.checkInputsShape=void 0;const d=s(5686),h=a(s(3720)),b=s(1446),et=s(9162);e.checkInputsShape=function(dt,...pt){if(!dt||dt.length!==pt.length)return!1;for(let ft=0;ft<dt.length;ft++)if(!dt[ft].dims||dt[ft].dims.length!==pt[ft])return!1;return!0},e.assert=function(dt,pt){if(!dt)throw new Error(typeof pt=="string"?pt:pt())},e.ArrayUtil=class{static arraysEqual(dt,pt){if(dt.length!==pt.length)return!1;for(let ft=0;ft<dt.length;ft++)if(dt[ft]!==pt[ft])return!1;return!0}};class st{static preprocessInputShapes(pt,ft){return[pt.length===1?[1,pt[0]]:pt,ft.length===1?[ft[0],1]:ft]}static postprocessOutputShape(pt,ft,ht){ft===1&&pt.splice(pt.length-2,1),ht===1&&pt.pop()}static calcMatMulShape(pt,ft){return pt[1]!==ft[0]?void 0:[pt[0],ft[1]]}}e.MatMulUtil=st;class ${static calcShape(pt,ft,ht=!1){const bt=pt.length,mt=ft.length;if(bt===0)return ft;if(mt===0)return pt;const $t=Math.max(pt.length,ft.length),Tt=new Array($t);if(ht){if(bt<2||mt<2)return;const Nt=st.calcMatMulShape([pt[bt-2],pt[bt-1]],[ft[mt-2],ft[mt-1]]);if(Nt===void 0)return;[Tt[$t-2],Tt[$t-1]]=Nt}for(let Nt=ht?3:1;Nt<=$t;Nt++){const Ct=bt-Nt<0?1:pt[bt-Nt],Ft=mt-Nt<0?1:ft[mt-Nt];if(Ct!==Ft&&Ct>1&&Ft>1)return;Tt[$t-Nt]=Math.max(Ct,Ft)}return Tt}static index(pt,ft){const ht=new Array(ft.length);return $.fillIndex(pt,ft,ht),ht}static fillIndex(pt,ft,ht){const bt=pt.length-ft.length;for(let mt=0;mt<ft.length;mt++)ht[mt]=pt[bt+mt]%ft[mt]}static calc(pt,ft,ht,bt,mt){const $t=$.calcShape(pt.dims,ft.dims);if($t){if(bt&&!c.areEqual($t,pt.dims))return;const Tt=c.size($t),Nt=bt?pt:new et.Tensor($t,mt||pt.type);if($t.length===0)Nt.set([],ht(pt.get([]),ft.get([])));else{const Ct=new Array($t.length),Ft=new Array(pt.dims.length),ln=new Array(ft.dims.length);let mn,yn=0,pn=0,Ht=!1,Gt=!1;pt.dims.length===0&&(yn=pt.get([]),Ht=!0),ft.dims.length===0&&(pn=ft.get([]),Gt=!0);for(let cn=0;cn<Tt;cn++){mn=cn;for(let xn=$t.length-1;xn>=0;xn--)Ct[xn]=mn%$t[xn],mn=Math.floor(mn/$t[xn]);Ht||($.fillIndex(Ct,pt.dims,Ft),yn=pt.get(Ft)),Gt||($.fillIndex(Ct,ft.dims,ln),pn=ft.get(ln)),Nt.set(Ct,ht(yn,pn))}}return Nt}}static isValidBroadcast(pt,ft){const ht=pt.length,bt=ft.length;if(ht>bt)return!1;for(let mt=1;mt<=ht;mt++)if(pt[ht-mt]!==1&&pt[ht-mt]!==ft[bt-mt])return!1;return!0}static getBroadcastDims(pt,ft){const ht=pt.length,bt=[];for(let mt=0;mt<ht;mt++){const $t=ht-1-mt,Tt=pt[$t]||1;(ft[ft.length-1-mt]||1)>1&&Tt===1&&bt.unshift($t)}return bt}}e.BroadcastUtil=$,e.arrayCopyHelper=function(dt,pt,ft,ht,bt){if(ht<0||ht>=pt.length)throw new Error("sourceIndex out of bounds");if(ft<0||ft>=dt.length)throw new Error("targetIndex out of bounds");if(ht+bt>pt.length)throw new Error("source indices to be copied are outside bounds");if(ft+bt>dt.length)throw new Error("target array is too small to hold result");for(let mt=0;mt<bt;mt++)dt[ft+mt]=pt[ht+mt]},e.GemmUtil=class{static getShapeOfGemmResult(dt,pt,ft,ht,bt){if(dt.length!==2||ft.length!==2)throw new Error("shape need to be of size 2");let mt,$t,Tt;pt?(mt=dt[1],$t=dt[0]):(mt=dt[0],$t=dt[1]);let Nt=-1;if(ht?(Tt=ft[0],Nt=1):(Tt=ft[1],Nt=0),ft[Nt]!==$t)throw new Error("dimension mismatch");if(mt<=0||Tt<=0||$t<=0)throw new Error("invalid shape specified");if(bt&&!$.isValidBroadcast(bt,[mt,Tt]))throw new Error("gemm: invalid bias shape for broadcast");return[mt,Tt,$t]}};class it{static tensorDataTypeFromProto(pt){switch(pt){case b.onnx.TensorProto.DataType.INT8:return"int8";case b.onnx.TensorProto.DataType.UINT8:return"uint8";case b.onnx.TensorProto.DataType.BOOL:return"bool";case b.onnx.TensorProto.DataType.INT16:return"int16";case b.onnx.TensorProto.DataType.UINT16:return"uint16";case b.onnx.TensorProto.DataType.INT32:return"int32";case b.onnx.TensorProto.DataType.UINT32:return"uint32";case b.onnx.TensorProto.DataType.FLOAT:return"float32";case b.onnx.TensorProto.DataType.DOUBLE:return"float64";case b.onnx.TensorProto.DataType.STRING:return"string";case b.onnx.TensorProto.DataType.INT64:return"int32";case b.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${b.onnx.TensorProto.DataType[pt]}`)}}static tensorDataTypeStringToEnum(pt){switch(pt){case"int8":return b.onnx.TensorProto.DataType.INT8;case"uint8":return b.onnx.TensorProto.DataType.UINT8;case"bool":return b.onnx.TensorProto.DataType.BOOL;case"int16":return b.onnx.TensorProto.DataType.INT16;case"uint16":return b.onnx.TensorProto.DataType.UINT16;case"int32":return b.onnx.TensorProto.DataType.INT32;case"uint32":return b.onnx.TensorProto.DataType.UINT32;case"float32":return b.onnx.TensorProto.DataType.FLOAT;case"float64":return b.onnx.TensorProto.DataType.DOUBLE;case"string":return b.onnx.TensorProto.DataType.STRING;case"int64":return b.onnx.TensorProto.DataType.INT64;case"uint64":return b.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${pt}`)}}static tensorDimsFromProto(pt){return pt.map(ft=>h.default.isLong(ft)?ft.toNumber():ft)}static tensorValueTypeFromProto(pt){return{tensorType:it.tensorDataTypeFromProto(pt.elemType),shape:{dims:it.tensorDimsFromProto(pt.shape.dim.map(ft=>ft.dimValue))}}}static tensorDimsFromORTFormat(pt){const ft=[];for(let ht=0;ht<pt.dimsLength();ht++)ft.push(g.longToNumber(pt.dims(ht)));return ft}static tensorAttributesFromORTFormat(pt){const ft=[];for(let ht=0;ht<pt.attributesLength();ht++)ft.push(pt.attributes(ht));return ft}}e.ProtoUtil=it;class g{static longToNumber(pt,ft){return h.default.isLong(pt)?pt.toNumber():pt instanceof d.flatbuffers.Long?h.default.fromValue({low:pt.low,high:pt.high,unsigned:ft!=null&&ft}).toNumber():pt}static isLong(pt){return h.default.isLong(pt)||pt instanceof d.flatbuffers.Long}}e.LongUtil=g;class c{static size(pt){return c.getSizeFromDimensionRange(pt,0,pt.length)}static sizeFromDimension(pt,ft){if(ft<0||ft>pt.length)throw new Error(`invalid dimension of ${ft} for sizeFromDimension as Tensor has ${pt.length} dimensions.`);return c.getSizeFromDimensionRange(pt,ft,pt.length)}static sizeToDimension(pt,ft){if(ft<0||ft>pt.length)throw new Error(`invalid dimension of ${ft} for sizeToDimension as Tensor has ${pt.length} dimensions.`);return c.getSizeFromDimensionRange(pt,0,ft)}static getSizeFromDimensionRange(pt,ft,ht){let bt=1;for(let mt=ft;mt<ht;mt++){if(pt[mt]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");bt*=pt[mt]}return bt}static computeStrides(pt){const ft=pt.length;if(ft===0)return[];if(ft===1)return[1];const ht=new Array(ft);ht[ft-1]=1,ht[ft-2]=pt[ft-1];for(let bt=ft-3;bt>=0;--bt)ht[bt]=ht[bt+1]*pt[bt+1];return ht}static transpose(pt){return pt.slice().reverse()}static indicesToOffset(pt,ft,ht){ht===void 0&&(ht=pt.length);let bt=0;for(let mt=0;mt<ht;++mt)bt+=ft[mt]*pt[mt];return bt}static offsetToIndices(pt,ft){const ht=ft.length;if(ht===0)return[];if(ht===1)return[pt*ft[0]];const bt=new Array(ft.length);for(let mt=0;mt<bt.length-1;++mt)bt[mt]=Math.floor(pt/ft[mt]),pt-=bt[mt]*ft[mt];return bt[bt.length-1]=pt,bt}static normalizeAxis(pt,ft){if(pt<-ft&&pt>=ft)throw new Error("unsupported axis for this operation.");return pt<0?pt+ft:pt}static normalizeAxes(pt,ft){return pt.map(ht=>this.normalizeAxis(ht,ft))}static incrementIndex(pt,ft,ht){if(ft.length===0||pt.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(ht===void 0)ht=ft.length;else if(ht<=0||ht>ft.length)throw new Error("Incorrect axis to increment on");for(let bt=ht-1;bt>=0&&(pt[bt]++,!(pt[bt]<ft[bt]));--bt)pt[bt]=0}static calculateReshapedDims(pt,ft){if(ft.length===0){if(pt.length===0||c.size(pt)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const ht=ft.length,bt=new Array(ht);let mt=-1,$t=1;for(let Nt=0;Nt<ht;Nt++){if(ft[Nt]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(ft[Nt]===-1){if(mt!==-1)throw new Error("at most one dimension in shape hints can be -1");mt=Nt}else{if(ft[Nt]===0){if(Nt>=pt.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");bt[Nt]=pt[Nt]}else bt[Nt]=ft[Nt];$t*=bt[Nt]}}const Tt=c.size(pt);if(mt!==-1){if(Tt%$t!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${pt}] Output shape: [${ft}]`);bt[mt]=Tt/$t}else if($t!==Tt)throw new Error("reshapedDims and originalDims don't have matching sizes");return bt}static sortBasedOnPerm(pt,ft){return ft?ft.map(ht=>pt[ht]):pt.slice().reverse()}static padShape(pt,ft){const ht=pt.length;return pt.map((bt,mt)=>bt+ft[mt]+ft[mt+ht])}static areEqual(pt,ft){return pt.length===ft.length&&pt.every((ht,bt)=>ht===ft[bt])}static validateDimsAndCalcSize(pt){if(pt.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let ft=1;for(const ht of pt){if(!Number.isInteger(ht))throw new TypeError(`Invalid shape: ${ht} is not an integer`);if(ht<0||ht>2147483647)throw new TypeError(`Invalid shape: length ${ht} is not allowed`);ft*=ht}return ft}static flattenShape(pt,ft){ft<0&&(ft+=pt.length);const ht=pt.reduce((mt,$t)=>mt*$t,1),bt=pt.slice(ft).reduce((mt,$t)=>mt*$t,1);return[ht/bt,bt]}static squeezeShape(pt,ft){const ht=new Array;ft=c.normalizeAxes(ft,pt.length);for(let bt=0;bt<pt.length;bt++){const mt=ft.indexOf(bt)>=0;if(mt&&pt[bt]!==1)throw new Error("squeeze an axis of size different than 1");(ft.length===0&&pt[bt]>1||ft.length>0&&!mt)&&ht.push(pt[bt])}return ht}static unsqueezeShape(pt,ft){const ht=new Array(pt.length+ft.length);ht.fill(0);for(let mt=0;mt<ft.length;mt++){const $t=c.normalizeAxis(ft[mt],ht.length);if($t>=ht.length)throw new Error("'axes' has an out of range axis");if(ht[$t]!==0)throw new Error("'axes' has a duplicate axis");ht[$t]=1}let bt=0;for(let mt=0;mt<ht.length;mt++)ht[mt]===0&&(ht[mt]=pt[bt++]);if(bt!==pt.length)throw new Error("the unsqueezed dimension could not be established");return ht}}e.ShapeUtil=c,e.MathUtil=class{static sqr(dt,pt,ft,ht,bt){if(ht<0||ht>=pt.length)throw new Error("sourceIndex out of bounds");if(ft<0||ft>=dt.length)throw new Error("targetIndex out of bounds");if(ht+bt>pt.length)throw new Error("source indices to be copied are outside bounds");if(ft+bt>dt.length)throw new Error("target array is too small to hold result");for(let mt=0;mt<bt;mt++)dt[ft+mt]+=Math.pow(pt[ht+mt],2)}static axpy(dt,pt,ft,ht,bt,mt){if(ht<0||ht>=pt.length)throw new Error("sourceIndex out of bounds");if(ft<0||ft>=dt.length)throw new Error("targetIndex out of bounds");if(ht+bt>pt.length)throw new Error("source indices to be copied are outside bounds");if(ft+bt>dt.length)throw new Error("target array is too small to hold result");for(let $t=0;$t<bt;$t++)dt[ft+$t]+=mt*pt[ht+$t]}static powx(dt,pt,ft,ht,bt,mt){if(ht<0||ht>=pt.length)throw new Error("sourceIndex out of bounds");if(ft<0||ft>=dt.length)throw new Error("targetIndex out of bounds");if(ht+bt>pt.length)throw new Error("source indices to be copied are outside bounds");if(ft+bt>dt.length)throw new Error("target array is too small to hold result");for(let $t=0;$t<bt;$t++)dt[ft+$t]=Math.pow(pt[ht+$t],mt)}static mul(dt,pt,ft,ht,bt){if(ht<0||ht>=pt.length)throw new Error("sourceIndex out of bounds");if(ft<0||ft>=dt.length)throw new Error("targetIndex out of bounds");if(ht+bt>pt.length)throw new Error("source indices to be copied are outside bounds");if(ft+bt>dt.length)throw new Error("target array is too small to hold result");for(let mt=0;mt<bt;mt++)dt[ft+mt]=pt[ht+mt]*dt[ft+mt]}};class _{static splitShape(pt,ft,ht,bt){if(ht.length===0){if(!bt)throw new Error("need to know number of outputs when the 'split' attribute is not specified");_.determineSplit(pt[ft],bt,ht)}const mt=[],$t=[0];for(let Tt=0;Tt<ht.length;++Tt){Tt!==0&&$t.push($t[Tt-1]+ht[Tt-1]);const Nt=pt.slice();Nt[ft]=ht[Tt],mt.push(Nt)}return[mt,$t]}static determineSplit(pt,ft,ht){if(pt%ft!=0)throw new Error("cannot split tensor to equal sized parts");for(let bt=0;bt<ft;++bt)ht.push(pt/ft)}}e.SplitUtil=_;class ot{static calcReduce(pt,ft,ht,bt,mt){const $t=pt.dims.slice(0);ft.length===0&&$t.forEach((yn,pn)=>ft.push(pn));const Tt=ot.calcReduceShape($t,ft,!0),Nt=c.size(Tt),Ct=new et.Tensor(Tt,pt.type),Ft=c.computeStrides(Tt),ln=c.computeStrides($t),mn=new Array($t.length);for(let yn=0;yn<Nt;yn++){const pn=c.offsetToIndices(yn,Ft);$.fillIndex(pn,$t,mn),Ct.set(pn,ot.calcReduceByAxis(pt.numberData,ft,$t,0,c.indicesToOffset(mn,ln),bt,mt))}return ht?Ct:new et.Tensor(ot.calcReduceShape($t,ft,ht),Ct.type,void 0,void 0,Ct.data,Ct.dataId)}static calcReduceByAxis(pt,ft,ht,bt,mt,$t,Tt){let Nt=0;if(bt>=ft.length)return $t(pt[mt]);const Ct=ft[bt],Ft=Ct>=ht.length?1:c.size(ht.slice(Ct+1));for(let ln=0;ln<ht[Ct];ln++)Nt=ln===0?ot.calcReduceByAxis(pt,ft,ht,bt+1,mt,$t,Tt):Tt(Nt,ot.calcReduceByAxis(pt,ft,ht,bt+1,mt,$t,Tt)),mt+=Ft;return Nt}static calcReduceShape(pt,ft,ht){const bt=pt.slice();for(let mt=0;mt<ft.length;mt++)bt[ft[mt]]=ht?1:0;return bt.filter(mt=>mt!==0)}}e.ReduceUtil=ot;class ct{static adjustPoolAttributes(pt,ft,ht,bt,mt,$t){if(!pt&&ht.length!==ft.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(pt)for(let Tt=0;Tt<ft.length-2;Tt++)Tt>=ht.length?ht.push(ft[Tt+2]):ht[Tt]=ft[Tt+2];for(let Tt=0;Tt<ht.length;Tt++)if(Tt<bt.length){if(bt[Tt]<0)throw new Error("strides should be greater than or equal to 1")}else bt.push(1);for(let Tt=0;Tt<ht.length;Tt++)if(Tt<mt.length){if(mt[Tt]<0)throw new Error("dilations should be greater than or equal to 1")}else mt.push(1);for(let Tt=0;Tt<2*ht.length;Tt++)if(Tt<$t.length){if($t[Tt]<0)throw new Error("pad should be greater than or equal to 1")}else $t.push(0);for(let Tt=0;Tt<ht.length;Tt++){if(ht[Tt]<=0)throw new Error("kernel shapes need to be greater than 0");if($t[Tt]>=ht[Tt]||$t[Tt+ht.length]>=ht[Tt])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(pt,ft,ht,bt,mt,$t){if($t){if(mt.length!==2*(pt.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(ft.length!==pt.length-2)throw new Error("length of strides should be the length of data dimensions");if(bt.length!==pt.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let Tt=0;Tt<pt.length-2;Tt++)ct.adjustPadAndReturnShape(pt[Tt+2],ft[Tt],ht[Tt],bt[Tt],mt,Tt,Tt+pt.length-2,$t)}}static computePoolOutputShape(pt,ft,ht,bt,mt,$t,Tt){if(ft.length<=0)throw new Error("input shape must be of size greater than 0");const Nt=[ft[0],ft[1]];return ct.computeShapeHelper(pt,ft,Nt,ht,bt,mt,$t,Tt),Nt}static computeConvOutputShape(pt,ft,ht,bt,mt,$t,Tt){if(pt.length<=0||ft.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const Nt=[pt[0],ft[0]];return ct.computeShapeHelper(!1,pt,Nt,ht,bt,mt,$t,Tt),Nt}static computeShapeHelper(pt,ft,ht,bt,mt,$t,Tt,Nt){if(pt)for(let Ct=0;Ct<ft.length-2;Ct++)ht.push(1);else for(let Ct=0;Ct<ft.length-2;Ct++)ht.push(ct.adjustPadAndReturnShape(ft[Ct+2],bt[Ct],mt[Ct],$t[Ct],Tt,Ct,Ct+ft.length-2,Nt))}static adjustPadAndReturnShape(pt,ft,ht,bt,mt,$t,Tt,Nt){const Ct=ht*(bt-1)+1;if(!Nt||Nt==="NOTSET")return Math.floor((pt+mt[$t]+mt[Tt]-Ct)/ft+1);switch(Nt){case"VALID":return mt[$t]=0,mt[Tt]=0,Math.floor((pt-Ct)/ft+1);case"SAME_LOWER":case"SAME_UPPER":if(ht!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const Ft=((pt+ft-1)/ft-1)*ft+bt-pt;return mt[$t]=Math.floor(Nt==="SAME_LOWER"?(Ft+1)/2:Ft/2),mt[Tt]=Ft-mt[$t],Math.floor((pt+Ft-bt)/ft+1)}default:throw new Error("Unsupported AutoPad type")}}}e.PoolConvUtil=ct,e.MIN_CLIP=-34028234663852886e22,e.MAX_CLIP=34028234663852886e22,e.decodeUtf8String=function(dt){return new TextDecoder().decode(dt)}},7967:(o,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(s,a,d,h)=>{if(typeof s=="object"&&s!==null){if(d.has(s))throw new Error("Circular reference in options");d.add(s)}Object.entries(s).forEach(([b,et])=>{const st=a?a+b:b;if(typeof et=="object")(0,e.iterateExtraOptions)(et,st+".",d,h);else if(typeof et=="string"||typeof et=="number")h(st,et.toString());else{if(typeof et!="boolean")throw new Error("Can't handle extra config type: "+typeof et);h(st,et?"1":"0")}})}},2157:function(o,e,s){var a,d=this&&this.__createBinding||(Object.create?function(Ft,ln,mn,yn){yn===void 0&&(yn=mn);var pn=Object.getOwnPropertyDescriptor(ln,mn);pn&&!("get"in pn?!ln.__esModule:pn.writable||pn.configurable)||(pn={enumerable:!0,get:function(){return ln[mn]}}),Object.defineProperty(Ft,yn,pn)}:function(Ft,ln,mn,yn){yn===void 0&&(yn=mn),Ft[yn]=ln[mn]}),h=this&&this.__setModuleDefault||(Object.create?function(Ft,ln){Object.defineProperty(Ft,"default",{enumerable:!0,value:ln})}:function(Ft,ln){Ft.default=ln}),b=this&&this.__importStar||function(Ft){if(Ft&&Ft.__esModule)return Ft;var ln={};if(Ft!=null)for(var mn in Ft)mn!=="default"&&Object.prototype.hasOwnProperty.call(Ft,mn)&&d(ln,Ft,mn);return h(ln,Ft),ln};Object.defineProperty(e,"__esModule",{value:!0}),e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=e.initWasm=void 0;const et=s(1670),st=b(s(349)),$=s(6361),it=()=>!!et.env.wasm.proxy&&typeof document<"u";let g,c,_,ot=!1,ct=!1,dt=!1;const pt=[],ft=[],ht=[],bt=[],mt=[],$t=[],Tt=()=>{if(ot||!ct||dt||!g)throw new Error("worker not ready")},Nt=Ft=>{switch(Ft.data.type){case"init-wasm":ot=!1,Ft.data.err?(dt=!0,c[1](Ft.data.err)):(ct=!0,c[0]());break;case"init-ort":Ft.data.err?_[1](Ft.data.err):_[0]();break;case"create_allocate":Ft.data.err?pt.shift()[1](Ft.data.err):pt.shift()[0](Ft.data.out);break;case"create_finalize":Ft.data.err?ft.shift()[1](Ft.data.err):ft.shift()[0](Ft.data.out);break;case"create":Ft.data.err?ht.shift()[1](Ft.data.err):ht.shift()[0](Ft.data.out);break;case"release":Ft.data.err?bt.shift()[1](Ft.data.err):bt.shift()[0]();break;case"run":Ft.data.err?mt.shift()[1](Ft.data.err):mt.shift()[0](Ft.data.out);break;case"end-profiling":Ft.data.err?$t.shift()[1](Ft.data.err):$t.shift()[0]()}},Ct=typeof document<"u"?(a=document?.currentScript)===null||a===void 0?void 0:a.src:void 0;e.initWasm=async()=>{if(it()){if(ct)return;if(ot)throw new Error("multiple calls to 'initWasm()' detected.");if(dt)throw new Error("previous call to 'initWasm()' failed.");return ot=!0,et.env.wasm.wasmPaths===void 0&&Ct&&Ct.indexOf("blob:")!==0&&(et.env.wasm.wasmPaths=Ct.substr(0,+Ct.lastIndexOf("/")+1)),new Promise((Ft,ln)=>{g?.terminate(),g=s(9710).Z(),g.onmessage=Nt,c=[Ft,ln];const mn={type:"init-wasm",in:et.env.wasm};g.postMessage(mn)})}return(0,$.initializeWebAssembly)(et.env.wasm)},e.initOrt=async(Ft,ln)=>{if(it())return Tt(),new Promise((mn,yn)=>{_=[mn,yn];const pn={type:"init-ort",in:{numThreads:Ft,loggingLevel:ln}};g.postMessage(pn)});st.initOrt(Ft,ln)},e.createSessionAllocate=async Ft=>it()?(Tt(),new Promise((ln,mn)=>{pt.push([ln,mn]);const yn={type:"create_allocate",in:{model:Ft}};g.postMessage(yn,[Ft.buffer])})):st.createSessionAllocate(Ft),e.createSessionFinalize=async(Ft,ln)=>it()?(Tt(),new Promise((mn,yn)=>{ft.push([mn,yn]);const pn={type:"create_finalize",in:{modeldata:Ft,options:ln}};g.postMessage(pn)})):st.createSessionFinalize(Ft,ln),e.createSession=async(Ft,ln)=>it()?(Tt(),new Promise((mn,yn)=>{ht.push([mn,yn]);const pn={type:"create",in:{model:Ft,options:ln}};g.postMessage(pn,[Ft.buffer])})):st.createSession(Ft,ln),e.releaseSession=async Ft=>{if(it())return Tt(),new Promise((ln,mn)=>{bt.push([ln,mn]);const yn={type:"release",in:Ft};g.postMessage(yn)});st.releaseSession(Ft)},e.run=async(Ft,ln,mn,yn,pn)=>it()?(Tt(),new Promise((Ht,Gt)=>{mt.push([Ht,Gt]);const cn={type:"run",in:{sessionId:Ft,inputIndices:ln,inputs:mn,outputIndices:yn,options:pn}};g.postMessage(cn,st.extractTransferableBuffers(mn))})):st.run(Ft,ln,mn,yn,pn),e.endProfiling=async Ft=>{if(it())return Tt(),new Promise((ln,mn)=>{$t.push([ln,mn]);const yn={type:"end-profiling",in:Ft};g.postMessage(yn)});st.endProfiling(Ft)}},586:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const a=s(7967),d=s(4983),h=s(6361);e.setRunOptions=b=>{const et=(0,h.getInstance)();let st=0;const $=[],it=b||{};try{if(b?.logSeverityLevel===void 0)it.logSeverityLevel=2;else if(typeof b.logSeverityLevel!="number"||!Number.isInteger(b.logSeverityLevel)||b.logSeverityLevel<0||b.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${b.logSeverityLevel}`);if(b?.logVerbosityLevel===void 0)it.logVerbosityLevel=0;else if(typeof b.logVerbosityLevel!="number"||!Number.isInteger(b.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${b.logVerbosityLevel}`);b?.terminate===void 0&&(it.terminate=!1);let g=0;if(b?.tag!==void 0&&(g=(0,d.allocWasmString)(b.tag,$)),st=et._OrtCreateRunOptions(it.logSeverityLevel,it.logVerbosityLevel,!!it.terminate,g),st===0)throw new Error("Can't create run options");return b?.extra!==void 0&&(0,a.iterateExtraOptions)(b.extra,"",new WeakSet,(c,_)=>{const ot=(0,d.allocWasmString)(c,$),ct=(0,d.allocWasmString)(_,$);if(et._OrtAddRunConfigEntry(st,ot,ct)!==0)throw new Error(`Can't set a run config entry: ${c} - ${_}`)}),[st,$]}catch(g){throw st!==0&&et._OrtReleaseRunOptions(st),$.forEach(et._free),g}}},2306:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.OnnxruntimeWebAssemblySessionHandler=void 0;const a=s(2806),d=s(1670),h=s(2850),b=s(2157);let et;e.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(st){const $=await fetch(st),it=await $.arrayBuffer();return(0,b.createSessionAllocate)(new Uint8Array(it))}async loadModel(st,$){if(et||(await(0,b.initOrt)(d.env.wasm.numThreads,(it=>{switch(it){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${it}`)}})(d.env.logLevel)),et=!0),typeof st=="string")if(typeof fetch>"u"){const it=await(0,h.promisify)(a.readFile)(st);[this.sessionId,this.inputNames,this.outputNames]=await(0,b.createSession)(it,$)}else{const it=await this.createSessionAllocate(st);[this.sessionId,this.inputNames,this.outputNames]=await(0,b.createSessionFinalize)(it,$)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,b.createSession)(st,$)}async dispose(){return(0,b.releaseSession)(this.sessionId)}async run(st,$,it){const g=[],c=[];Object.entries(st).forEach(dt=>{const pt=dt[0],ft=dt[1],ht=this.inputNames.indexOf(pt);if(ht===-1)throw new Error(`invalid input '${pt}'`);g.push(ft),c.push(ht)});const _=[];Object.entries($).forEach(dt=>{const pt=dt[0],ft=this.outputNames.indexOf(pt);if(ft===-1)throw new Error(`invalid output '${pt}'`);_.push(ft)});const ot=await(0,b.run)(this.sessionId,c,g.map(dt=>[dt.type,dt.dims,dt.data]),_,it),ct={};for(let dt=0;dt<ot.length;dt++)ct[this.outputNames[_[dt]]]=new d.Tensor(ot[dt][0],ot[dt][2],ot[dt][1]);return ct}startProfiling(){}endProfiling(){(0,b.endProfiling)(this.sessionId)}}},4919:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const a=s(7967),d=s(4983),h=s(6361);e.setSessionOptions=b=>{const et=(0,h.getInstance)();let st=0;const $=[],it=b||{};(g=>{g.extra||(g.extra={}),g.extra.session||(g.extra.session={});const c=g.extra.session;c.use_ort_model_bytes_directly||(c.use_ort_model_bytes_directly="1")})(it);try{b?.graphOptimizationLevel===void 0&&(it.graphOptimizationLevel="all");const g=(ot=>{switch(ot){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${ot}`)}})(it.graphOptimizationLevel);b?.enableCpuMemArena===void 0&&(it.enableCpuMemArena=!0),b?.enableMemPattern===void 0&&(it.enableMemPattern=!0),b?.executionMode===void 0&&(it.executionMode="sequential");const c=(ot=>{switch(ot){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${ot}`)}})(it.executionMode);let _=0;if(b?.logId!==void 0&&(_=(0,d.allocWasmString)(b.logId,$)),b?.logSeverityLevel===void 0)it.logSeverityLevel=2;else if(typeof b.logSeverityLevel!="number"||!Number.isInteger(b.logSeverityLevel)||b.logSeverityLevel<0||b.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${b.logSeverityLevel}`);if(b?.logVerbosityLevel===void 0)it.logVerbosityLevel=0;else if(typeof b.logVerbosityLevel!="number"||!Number.isInteger(b.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${b.logVerbosityLevel}`);if(b?.enableProfiling===void 0&&(it.enableProfiling=!1),st=et._OrtCreateSessionOptions(g,!!it.enableCpuMemArena,!!it.enableMemPattern,c,!!it.enableProfiling,0,_,it.logSeverityLevel,it.logVerbosityLevel),st===0)throw new Error("Can't create session options");return b?.executionProviders&&((ot,ct,dt)=>{for(const pt of ct){let ft=typeof pt=="string"?pt:pt.name;switch(ft){case"xnnpack":ft="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${ft}`)}const ht=(0,d.allocWasmString)(ft,dt);if((0,h.getInstance)()._OrtAppendExecutionProvider(ot,ht)!==0)throw new Error(`Can't append execution provider: ${ft}`)}})(st,b.executionProviders,$),b?.extra!==void 0&&(0,a.iterateExtraOptions)(b.extra,"",new WeakSet,(ot,ct)=>{const dt=(0,d.allocWasmString)(ot,$),pt=(0,d.allocWasmString)(ct,$);if(et._OrtAddSessionConfigEntry(st,dt,pt)!==0)throw new Error(`Can't set a session config entry: ${ot} - ${ct}`)}),[st,$]}catch(g){throw st!==0&&et._OrtReleaseSessionOptions(st),$.forEach(et._free),g}}},4983:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const a=s(6361);e.allocWasmString=(d,h)=>{const b=(0,a.getInstance)(),et=b.lengthBytesUTF8(d)+1,st=b._malloc(et);return b.stringToUTF8(d,st,et),h.push(st),st}},349:(o,e,s)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const a=s(586),d=s(4919),h=s(4983),b=s(6361);e.initOrt=(g,c)=>{const _=(0,b.getInstance)()._OrtInit(g,c);if(_!==0)throw new Error(`Can't initialize onnxruntime. error code = ${_}`)};const et=new Map;e.createSessionAllocate=g=>{const c=(0,b.getInstance)(),_=c._malloc(g.byteLength);return c.HEAPU8.set(g,_),[_,g.byteLength]},e.createSessionFinalize=(g,c)=>{const _=(0,b.getInstance)();let ot=0,ct=0,dt=[];try{if([ct,dt]=(0,d.setSessionOptions)(c),ot=_._OrtCreateSession(g[0],g[1],ct),ot===0)throw new Error("Can't create a session")}finally{_._free(g[0]),_._OrtReleaseSessionOptions(ct),dt.forEach(_._free)}const pt=_._OrtGetInputCount(ot),ft=_._OrtGetOutputCount(ot),ht=[],bt=[],mt=[],$t=[];for(let Tt=0;Tt<pt;Tt++){const Nt=_._OrtGetInputName(ot,Tt);if(Nt===0)throw new Error("Can't get an input name");bt.push(Nt),ht.push(_.UTF8ToString(Nt))}for(let Tt=0;Tt<ft;Tt++){const Nt=_._OrtGetOutputName(ot,Tt);if(Nt===0)throw new Error("Can't get an output name");$t.push(Nt),mt.push(_.UTF8ToString(Nt))}return et.set(ot,[ot,bt,$t]),[ot,ht,mt]},e.createSession=(g,c)=>{const _=(0,e.createSessionAllocate)(g);return(0,e.createSessionFinalize)(_,c)},e.releaseSession=g=>{const c=(0,b.getInstance)(),_=et.get(g);if(!_)throw new Error("invalid session id");const ot=_[0],ct=_[1],dt=_[2];ct.forEach(c._OrtFree),dt.forEach(c._OrtFree),c._OrtReleaseSession(ot),et.delete(g)};const st=g=>{switch(g){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${g}`)}},$=g=>{switch(g){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${g}`)}},it=g=>{switch(g){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${g}`)}};e.run=(g,c,_,ot,ct)=>{const dt=(0,b.getInstance)(),pt=et.get(g);if(!pt)throw new Error("invalid session id");const ft=pt[0],ht=pt[1],bt=pt[2],mt=c.length,$t=ot.length;let Tt=0,Nt=[];const Ct=[],Ft=[];try{[Tt,Nt]=(0,a.setRunOptions)(ct);for(let Gt=0;Gt<mt;Gt++){const cn=_[Gt][0],xn=_[Gt][1],dn=_[Gt][2];let wn,gn;if(Array.isArray(dn)){gn=4*dn.length,wn=dt._malloc(gn),Ft.push(wn);let Sr=wn/4;for(let xr=0;xr<dn.length;xr++){if(typeof dn[xr]!="string")throw new TypeError(`tensor data at index ${xr} is not a string`);dt.HEAPU32[Sr++]=(0,h.allocWasmString)(dn[xr],Ft)}}else gn=dn.byteLength,wn=dt._malloc(gn),Ft.push(wn),dt.HEAPU8.set(new Uint8Array(dn.buffer,dn.byteOffset,gn),wn);const En=dt.stackSave(),_r=dt.stackAlloc(4*xn.length);try{let Sr=_r/4;xn.forEach(Vr=>dt.HEAP32[Sr++]=Vr);const xr=dt._OrtCreateTensor(st(cn),wn,gn,_r,xn.length);if(xr===0)throw new Error("Can't create a tensor");Ct.push(xr)}finally{dt.stackRestore(En)}}const ln=dt.stackSave(),mn=dt.stackAlloc(4*mt),yn=dt.stackAlloc(4*mt),pn=dt.stackAlloc(4*$t),Ht=dt.stackAlloc(4*$t);try{let Gt=mn/4,cn=yn/4,xn=pn/4,dn=Ht/4;for(let En=0;En<mt;En++)dt.HEAPU32[Gt++]=Ct[En],dt.HEAPU32[cn++]=ht[c[En]];for(let En=0;En<$t;En++)dt.HEAPU32[xn++]=0,dt.HEAPU32[dn++]=bt[ot[En]];let wn=dt._OrtRun(ft,yn,mn,mt,Ht,$t,pn,Tt);const gn=[];if(wn===0)for(let En=0;En<$t;En++){const _r=dt.HEAPU32[pn/4+En],Sr=dt.stackSave(),xr=dt.stackAlloc(16);let Vr,Fr=0;try{if(wn=dt._OrtGetTensorData(_r,xr,xr+4,xr+8,xr+12),wn!==0)throw new Error(`Can't access output tensor data. error code = ${wn}`);let _f=xr/4;const h0=dt.HEAPU32[_f++];Fr=dt.HEAPU32[_f++];const Po=dt.HEAPU32[_f++],No=dt.HEAPU32[_f++],o0=[];for(let xu=0;xu<No;xu++)o0.push(dt.HEAPU32[Po/4+xu]);dt._OrtFree(Po);const t0=o0.length===0?1:o0.reduce((xu,M0)=>xu*M0);if(Vr=$(h0),Vr==="string"){const xu=[];let M0=Fr/4;for(let k0=0;k0<t0;k0++){const T0=dt.HEAPU32[M0++],j0=k0===t0-1?void 0:dt.HEAPU32[M0]-T0;xu.push(dt.UTF8ToString(T0,j0))}gn.push([Vr,o0,xu])}else{const xu=new(it(Vr))(t0);new Uint8Array(xu.buffer,xu.byteOffset,xu.byteLength).set(dt.HEAPU8.subarray(Fr,Fr+xu.byteLength)),gn.push([Vr,o0,xu])}}finally{dt.stackRestore(Sr),Vr==="string"&&Fr&&dt._free(Fr),dt._OrtReleaseTensor(_r)}}if(wn===0)return gn;throw new Error(`failed to call OrtRun(). error code = ${wn}.`)}finally{dt.stackRestore(ln)}}finally{Ct.forEach(dt._OrtReleaseTensor),Ft.forEach(dt._free),dt._OrtReleaseRunOptions(Tt),Nt.forEach(dt._free)}},e.endProfiling=g=>{const c=(0,b.getInstance)(),_=et.get(g);if(!_)throw new Error("invalid session id");const ot=_[0],ct=c._OrtEndProfiling(ot);if(ct===0)throw new Error("Can't get an profile file name");c._OrtFree(ct)},e.extractTransferableBuffers=g=>{const c=[];for(const _ of g){const ot=_[2];!Array.isArray(ot)&&ot.buffer&&c.push(ot.buffer)}return c}},6361:function(o,e,s){var a=this&&this.__createBinding||(Object.create?function(ct,dt,pt,ft){ft===void 0&&(ft=pt);var ht=Object.getOwnPropertyDescriptor(dt,pt);ht&&!("get"in ht?!dt.__esModule:ht.writable||ht.configurable)||(ht={enumerable:!0,get:function(){return dt[pt]}}),Object.defineProperty(ct,ft,ht)}:function(ct,dt,pt,ft){ft===void 0&&(ft=pt),ct[ft]=dt[pt]}),d=this&&this.__setModuleDefault||(Object.create?function(ct,dt){Object.defineProperty(ct,"default",{enumerable:!0,value:dt})}:function(ct,dt){ct.default=dt}),h=this&&this.__importStar||function(ct){if(ct&&ct.__esModule)return ct;var dt={};if(ct!=null)for(var pt in ct)pt!=="default"&&Object.prototype.hasOwnProperty.call(ct,pt)&&a(dt,ct,pt);return d(dt,ct),dt},b=this&&this.__importDefault||function(ct){return ct&&ct.__esModule?ct:{default:ct}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const et=h(s(6449)),st=b(s(932)),$=s(3474);let it,g=!1,c=!1,_=!1;const ot=(ct,dt)=>dt?ct?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":ct?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async ct=>{if(g)return Promise.resolve();if(c)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(_)throw new Error("previous call to 'initializeWebAssembly()' failed.");c=!0;const dt=ct.initTimeout,pt=ct.numThreads,ft=ct.simd,ht=pt>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),bt=ft&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),mt=typeof ct.wasmPaths=="string"?ct.wasmPaths:void 0,$t=ot(!1,ht),Tt=ot(bt,ht),Nt=typeof ct.wasmPaths=="object"?ct.wasmPaths[Tt]:void 0;let Ct=!1;const Ft=[];if(dt>0&&Ft.push(new Promise(ln=>{setTimeout(()=>{Ct=!0,ln()},dt)})),Ft.push(new Promise((ln,mn)=>{const yn=ht?$:st.default,pn={locateFile:(Ht,Gt)=>ht&&Ht.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([s(4154)],{type:"text/javascript"})):Ht===$t?Nt??(mt??Gt)+Tt:Gt+Ht};if(ht)if(typeof Blob>"u")pn.mainScriptUrlOrBlob=et.join("/","ort-wasm-threaded.js");else{const Ht=`var ortWasmThreaded=(function(){var _scriptDir;return ${yn.toString()}})();`;pn.mainScriptUrlOrBlob=new Blob([Ht],{type:"text/javascript"})}yn(pn).then(Ht=>{c=!1,g=!0,it=Ht,ln()},Ht=>{c=!1,_=!0,mn(Ht)})})),await Promise.race(Ft),Ct)throw new Error(`WebAssembly backend initializing failed due to timeout: ${dt}ms`)},e.getInstance=()=>{if(g&&it)return it;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var ct;!g||c||_||(c=!0,(ct=it.PThread)===null||ct===void 0||ct.terminateAllThreads(),it=void 0,c=!1,g=!1,_=!0)}},9710:(o,e,s)=>{s.d(e,{Z:()=>h});var a=s(477),d=s.n(a);function h(){return d()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:o=>{o.exports=function(e,s,a,d){var h=self||window;try{try{var b;try{b=new h.Blob([e])}catch{(b=new(h.BlobBuilder||h.WebKitBlobBuilder||h.MozBlobBuilder||h.MSBlobBuilder)).append(e),b=b.getBlob()}var et=h.URL||h.webkitURL,st=et.createObjectURL(b),$=new h[s](st,a);return et.revokeObjectURL(st),$}catch{return new h[s]("data:application/javascript,".concat(encodeURIComponent(e)),a)}}catch{if(!d)throw Error("Inline worker is not supported");return new h[s](d,a)}}},4154:o=>{o.exports=`"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`},1670:o=>{o.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(o,e,s)=>{s.r(e),s.d(e,{flatbuffers:()=>a});var a={};a.Offset,a.Table,a.SIZEOF_SHORT=2,a.SIZEOF_INT=4,a.FILE_IDENTIFIER_LENGTH=4,a.SIZE_PREFIX_LENGTH=4,a.Encoding={UTF8_BYTES:1,UTF16_STRING:2},a.int32=new Int32Array(2),a.float32=new Float32Array(a.int32.buffer),a.float64=new Float64Array(a.int32.buffer),a.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,a.Long=function(d,h){this.low=0|d,this.high=0|h},a.Long.create=function(d,h){return d==0&&h==0?a.Long.ZERO:new a.Long(d,h)},a.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},a.Long.prototype.equals=function(d){return this.low==d.low&&this.high==d.high},a.Long.ZERO=new a.Long(0,0),a.Builder=function(d){if(d)h=d;else var h=1024;this.bb=a.ByteBuffer.allocate(h),this.space=h,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},a.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},a.Builder.prototype.forceDefaults=function(d){this.force_defaults=d},a.Builder.prototype.dataBuffer=function(){return this.bb},a.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},a.Builder.prototype.prep=function(d,h){d>this.minalign&&(this.minalign=d);for(var b=1+~(this.bb.capacity()-this.space+h)&d-1;this.space<b+d+h;){var et=this.bb.capacity();this.bb=a.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-et}this.pad(b)},a.Builder.prototype.pad=function(d){for(var h=0;h<d;h++)this.bb.writeInt8(--this.space,0)},a.Builder.prototype.writeInt8=function(d){this.bb.writeInt8(this.space-=1,d)},a.Builder.prototype.writeInt16=function(d){this.bb.writeInt16(this.space-=2,d)},a.Builder.prototype.writeInt32=function(d){this.bb.writeInt32(this.space-=4,d)},a.Builder.prototype.writeInt64=function(d){this.bb.writeInt64(this.space-=8,d)},a.Builder.prototype.writeFloat32=function(d){this.bb.writeFloat32(this.space-=4,d)},a.Builder.prototype.writeFloat64=function(d){this.bb.writeFloat64(this.space-=8,d)},a.Builder.prototype.addInt8=function(d){this.prep(1,0),this.writeInt8(d)},a.Builder.prototype.addInt16=function(d){this.prep(2,0),this.writeInt16(d)},a.Builder.prototype.addInt32=function(d){this.prep(4,0),this.writeInt32(d)},a.Builder.prototype.addInt64=function(d){this.prep(8,0),this.writeInt64(d)},a.Builder.prototype.addFloat32=function(d){this.prep(4,0),this.writeFloat32(d)},a.Builder.prototype.addFloat64=function(d){this.prep(8,0),this.writeFloat64(d)},a.Builder.prototype.addFieldInt8=function(d,h,b){(this.force_defaults||h!=b)&&(this.addInt8(h),this.slot(d))},a.Builder.prototype.addFieldInt16=function(d,h,b){(this.force_defaults||h!=b)&&(this.addInt16(h),this.slot(d))},a.Builder.prototype.addFieldInt32=function(d,h,b){(this.force_defaults||h!=b)&&(this.addInt32(h),this.slot(d))},a.Builder.prototype.addFieldInt64=function(d,h,b){!this.force_defaults&&h.equals(b)||(this.addInt64(h),this.slot(d))},a.Builder.prototype.addFieldFloat32=function(d,h,b){(this.force_defaults||h!=b)&&(this.addFloat32(h),this.slot(d))},a.Builder.prototype.addFieldFloat64=function(d,h,b){(this.force_defaults||h!=b)&&(this.addFloat64(h),this.slot(d))},a.Builder.prototype.addFieldOffset=function(d,h,b){(this.force_defaults||h!=b)&&(this.addOffset(h),this.slot(d))},a.Builder.prototype.addFieldStruct=function(d,h,b){h!=b&&(this.nested(h),this.slot(d))},a.Builder.prototype.nested=function(d){if(d!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},a.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},a.Builder.prototype.slot=function(d){this.vtable[d]=this.offset()},a.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},a.Builder.growByteBuffer=function(d){var h=d.capacity();if(3221225472&h)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var b=h<<1,et=a.ByteBuffer.allocate(b);return et.setPosition(b-h),et.bytes().set(d.bytes(),b-h),et},a.Builder.prototype.addOffset=function(d){this.prep(a.SIZEOF_INT,0),this.writeInt32(this.offset()-d+a.SIZEOF_INT)},a.Builder.prototype.startObject=function(d){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=d;for(var h=0;h<d;h++)this.vtable[h]=0;this.isNested=!0,this.object_start=this.offset()},a.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var d=this.offset(),h=this.vtable_in_use-1;h>=0&&this.vtable[h]==0;h--);for(var b=h+1;h>=0;h--)this.addInt16(this.vtable[h]!=0?d-this.vtable[h]:0);this.addInt16(d-this.object_start);var et=(b+2)*a.SIZEOF_SHORT;this.addInt16(et);var st=0,$=this.space;e:for(h=0;h<this.vtables.length;h++){var it=this.bb.capacity()-this.vtables[h];if(et==this.bb.readInt16(it)){for(var g=a.SIZEOF_SHORT;g<et;g+=a.SIZEOF_SHORT)if(this.bb.readInt16($+g)!=this.bb.readInt16(it+g))continue e;st=this.vtables[h];break}}return st?(this.space=this.bb.capacity()-d,this.bb.writeInt32(this.space,st-d)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-d,this.offset()-d)),this.isNested=!1,d},a.Builder.prototype.finish=function(d,h,b){var et=b?a.SIZE_PREFIX_LENGTH:0;if(h){var st=h;if(this.prep(this.minalign,a.SIZEOF_INT+a.FILE_IDENTIFIER_LENGTH+et),st.length!=a.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+a.FILE_IDENTIFIER_LENGTH);for(var $=a.FILE_IDENTIFIER_LENGTH-1;$>=0;$--)this.writeInt8(st.charCodeAt($))}this.prep(this.minalign,a.SIZEOF_INT+et),this.addOffset(d),et&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},a.Builder.prototype.finishSizePrefixed=function(d,h){this.finish(d,h,!0)},a.Builder.prototype.requiredField=function(d,h){var b=this.bb.capacity()-d,et=b-this.bb.readInt32(b);if(this.bb.readInt16(et+h)==0)throw new Error("FlatBuffers: field "+h+" must be set")},a.Builder.prototype.startVector=function(d,h,b){this.notNested(),this.vector_num_elems=h,this.prep(a.SIZEOF_INT,d*h),this.prep(b,d*h)},a.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},a.Builder.prototype.createString=function(d){if(d instanceof Uint8Array)var h=d;else{h=[];for(var b=0;b<d.length;){var et,st=d.charCodeAt(b++);(et=st<55296||st>=56320?st:(st<<10)+d.charCodeAt(b++)+-56613888)<128?h.push(et):(et<2048?h.push(et>>6&31|192):(et<65536?h.push(et>>12&15|224):h.push(et>>18&7|240,et>>12&63|128),h.push(et>>6&63|128)),h.push(63&et|128))}}this.addInt8(0),this.startVector(1,h.length,1),this.bb.setPosition(this.space-=h.length),b=0;for(var $=this.space,it=this.bb.bytes();b<h.length;b++)it[$++]=h[b];return this.endVector()},a.Builder.prototype.createLong=function(d,h){return a.Long.create(d,h)},a.ByteBuffer=function(d){this.bytes_=d,this.position_=0},a.ByteBuffer.allocate=function(d){return new a.ByteBuffer(new Uint8Array(d))},a.ByteBuffer.prototype.clear=function(){this.position_=0},a.ByteBuffer.prototype.bytes=function(){return this.bytes_},a.ByteBuffer.prototype.position=function(){return this.position_},a.ByteBuffer.prototype.setPosition=function(d){this.position_=d},a.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},a.ByteBuffer.prototype.readInt8=function(d){return this.readUint8(d)<<24>>24},a.ByteBuffer.prototype.readUint8=function(d){return this.bytes_[d]},a.ByteBuffer.prototype.readInt16=function(d){return this.readUint16(d)<<16>>16},a.ByteBuffer.prototype.readUint16=function(d){return this.bytes_[d]|this.bytes_[d+1]<<8},a.ByteBuffer.prototype.readInt32=function(d){return this.bytes_[d]|this.bytes_[d+1]<<8|this.bytes_[d+2]<<16|this.bytes_[d+3]<<24},a.ByteBuffer.prototype.readUint32=function(d){return this.readInt32(d)>>>0},a.ByteBuffer.prototype.readInt64=function(d){return new a.Long(this.readInt32(d),this.readInt32(d+4))},a.ByteBuffer.prototype.readUint64=function(d){return new a.Long(this.readUint32(d),this.readUint32(d+4))},a.ByteBuffer.prototype.readFloat32=function(d){return a.int32[0]=this.readInt32(d),a.float32[0]},a.ByteBuffer.prototype.readFloat64=function(d){return a.int32[a.isLittleEndian?0:1]=this.readInt32(d),a.int32[a.isLittleEndian?1:0]=this.readInt32(d+4),a.float64[0]},a.ByteBuffer.prototype.writeInt8=function(d,h){this.bytes_[d]=h},a.ByteBuffer.prototype.writeUint8=function(d,h){this.bytes_[d]=h},a.ByteBuffer.prototype.writeInt16=function(d,h){this.bytes_[d]=h,this.bytes_[d+1]=h>>8},a.ByteBuffer.prototype.writeUint16=function(d,h){this.bytes_[d]=h,this.bytes_[d+1]=h>>8},a.ByteBuffer.prototype.writeInt32=function(d,h){this.bytes_[d]=h,this.bytes_[d+1]=h>>8,this.bytes_[d+2]=h>>16,this.bytes_[d+3]=h>>24},a.ByteBuffer.prototype.writeUint32=function(d,h){this.bytes_[d]=h,this.bytes_[d+1]=h>>8,this.bytes_[d+2]=h>>16,this.bytes_[d+3]=h>>24},a.ByteBuffer.prototype.writeInt64=function(d,h){this.writeInt32(d,h.low),this.writeInt32(d+4,h.high)},a.ByteBuffer.prototype.writeUint64=function(d,h){this.writeUint32(d,h.low),this.writeUint32(d+4,h.high)},a.ByteBuffer.prototype.writeFloat32=function(d,h){a.float32[0]=h,this.writeInt32(d,a.int32[0])},a.ByteBuffer.prototype.writeFloat64=function(d,h){a.float64[0]=h,this.writeInt32(d,a.int32[a.isLittleEndian?0:1]),this.writeInt32(d+4,a.int32[a.isLittleEndian?1:0])},a.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+a.SIZEOF_INT+a.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var d="",h=0;h<a.FILE_IDENTIFIER_LENGTH;h++)d+=String.fromCharCode(this.readInt8(this.position_+a.SIZEOF_INT+h));return d},a.ByteBuffer.prototype.__offset=function(d,h){var b=d-this.readInt32(d);return h<this.readInt16(b)?this.readInt16(b+h):0},a.ByteBuffer.prototype.__union=function(d,h){return d.bb_pos=h+this.readInt32(h),d.bb=this,d},a.ByteBuffer.prototype.__string=function(d,h){d+=this.readInt32(d);var b=this.readInt32(d),et="",st=0;if(d+=a.SIZEOF_INT,h===a.Encoding.UTF8_BYTES)return this.bytes_.subarray(d,d+b);for(;st<b;){var $,it=this.readUint8(d+st++);if(it<192)$=it;else{var g=this.readUint8(d+st++);if(it<224)$=(31&it)<<6|63&g;else{var c=this.readUint8(d+st++);$=it<240?(15&it)<<12|(63&g)<<6|63&c:(7&it)<<18|(63&g)<<12|(63&c)<<6|63&this.readUint8(d+st++)}}$<65536?et+=String.fromCharCode($):($-=65536,et+=String.fromCharCode(55296+($>>10),56320+(1023&$)))}return et},a.ByteBuffer.prototype.__indirect=function(d){return d+this.readInt32(d)},a.ByteBuffer.prototype.__vector=function(d){return d+this.readInt32(d)+a.SIZEOF_INT},a.ByteBuffer.prototype.__vector_len=function(d){return this.readInt32(d+this.readInt32(d))},a.ByteBuffer.prototype.__has_identifier=function(d){if(d.length!=a.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+a.FILE_IDENTIFIER_LENGTH);for(var h=0;h<a.FILE_IDENTIFIER_LENGTH;h++)if(d.charCodeAt(h)!=this.readInt8(this.position_+a.SIZEOF_INT+h))return!1;return!0},a.ByteBuffer.prototype.createLong=function(d,h){return a.Long.create(d,h)}}},__webpack_module_cache__={};function __webpack_require__(o){var e=__webpack_module_cache__[o];if(e!==void 0)return e.exports;var s=__webpack_module_cache__[o]={exports:{}};return __webpack_modules__[o].call(s.exports,s,s.exports,__webpack_require__),s.exports}__webpack_require__.n=o=>{var e=o&&o.__esModule?()=>o.default:()=>o;return __webpack_require__.d(e,{a:e}),e},__webpack_require__.d=(o,e)=>{for(var s in e)__webpack_require__.o(e,s)&&!__webpack_require__.o(o,s)&&Object.defineProperty(o,s,{enumerable:!0,get:e[s]})},__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),__webpack_require__.o=(o,e)=>Object.prototype.hasOwnProperty.call(o,e),__webpack_require__.r=o=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(6018);return __webpack_exports__})())})(ortWeb_min$1);var ortWeb_minExports=ortWeb_min$1.exports;const ortWeb_min=getDefaultExportFromCjs(ortWeb_minExports),ONNX_WEB=_mergeNamespaces({__proto__:null,default:ortWeb_min},[ortWeb_minExports]);let ONNX;const executionProviders=["wasm"];typeof process<"u"&&process?.release?.name==="node"?(ONNX=sharp??ONNX_NODE,executionProviders.unshift("cpu")):(ONNX=ortWeb_min??ONNX_WEB,typeof navigator<"u"&&/iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent)&&(ONNX.env.wasm.simd=!1));const{env:onnx_env}=ONNX,VERSION="2.17.2",WEB_CACHE_AVAILABLE=typeof self<"u"&&"caches"in self,FS_AVAILABLE=!isEmpty(sharp),PATH_AVAILABLE=!isEmpty(sharp),RUNNING_LOCALLY=FS_AVAILABLE&&PATH_AVAILABLE,__dirname$1=RUNNING_LOCALLY?sharp.dirname(sharp.dirname(sharp.fileURLToPath(import.meta.url))):"./",DEFAULT_CACHE_DIR=RUNNING_LOCALLY?sharp.join(__dirname$1,"/.cache/"):null,DEFAULT_LOCAL_MODEL_PATH="/models/",localModelPath=RUNNING_LOCALLY?sharp.join(__dirname$1,DEFAULT_LOCAL_MODEL_PATH):DEFAULT_LOCAL_MODEL_PATH;onnx_env?.wasm&&(onnx_env.wasm.wasmPaths=RUNNING_LOCALLY?sharp.join(__dirname$1,"/dist/"):`https://cdn.jsdelivr.net/npm/@xenova/transformers@${VERSION}/dist/`);const env$1={backends:{onnx:onnx_env,tfjs:{}},__dirname:__dirname$1,version:VERSION,allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!0,localModelPath,useFS:FS_AVAILABLE,useBrowserCache:WEB_CACHE_AVAILABLE,useFSCache:FS_AVAILABLE,cacheDir:DEFAULT_CACHE_DIR,useCustomCache:!1,customCache:null};function isEmpty(o){return Object.keys(o).length===0}var define_process_env_default={};class FileResponse{_CONTENT_TYPE_MAP={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};constructor(e){if(this.filePath=e,this.headers=new Headers,this.exists=sharp.existsSync(e),this.exists){this.status=200,this.statusText="OK";let s=sharp.statSync(e);this.headers.set("content-length",s.size.toString()),this.updateContentType();let a=this;this.body=new ReadableStream({start(d){a.arrayBuffer().then(h=>{d.enqueue(new Uint8Array(h)),d.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",this._CONTENT_TYPE_MAP[e]??"application/octet-stream")}clone(){let e=new FileResponse(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await sharp.promises.readFile(this.filePath)).buffer}async blob(){const e=await sharp.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await sharp.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function isValidUrl(o,e=null,s=null){let a;try{a=new URL(o)}catch{return!1}return!(e&&!e.includes(a.protocol)||s&&!s.includes(a.hostname))}async function getFile(o){if(env$1.useFS&&!isValidUrl(o,["http:","https:","blob:"]))return new FileResponse(o);if(typeof process<"u"&&process?.release?.name==="node"){const e=!!define_process_env_default?.TESTING_REMOTELY,s=env$1.version,a=new Headers;if(a.set("User-Agent",`transformers.js/${s}; is_ci/${e};`),isValidUrl(o,["http:","https:"],["huggingface.co","hf.co"])){const h=define_process_env_default?.HF_TOKEN??define_process_env_default?.HF_ACCESS_TOKEN;h&&a.set("Authorization",`Bearer ${h}`)}return fetch(o,{headers:a})}else return fetch(o)}const ERROR_MAPPING={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function handleError$1(o,e,s){if(!s)return null;const a=ERROR_MAPPING[o]??`Error (${o}) occurred while trying to load file`;throw Error(`${a}: "${e}".`)}class FileCache{constructor(e){this.path=e}async match(e){let s=sharp.join(this.path,e),a=new FileResponse(s);if(a.exists)return a}async put(e,s){const a=Buffer.from(await s.arrayBuffer());let d=sharp.join(this.path,e);try{await sharp.promises.mkdir(sharp.dirname(d),{recursive:!0}),await sharp.promises.writeFile(d,a)}catch(h){console.warn("An error occurred while writing the file to cache:",h)}}}async function tryCache(o,...e){for(let s of e)try{let a=await o.match(s);if(a)return a}catch{continue}}async function getModelFile(o,e,s=!0,a={}){if(!env$1.allowLocalModels){if(a.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!env$1.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}dispatchCallback(a.progress_callback,{status:"initiate",name:o,file:e});let d;if(!d&&env$1.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{d=await caches.open("transformers-cache")}catch(pt){console.warn("An error occurred while opening the browser cache:",pt)}}if(!d&&env$1.useFSCache&&(d=new FileCache(a.cache_dir??env$1.cacheDir)),!d&&env$1.useCustomCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");const h=a.revision??"main";let b=pathJoin(o,e),et=pathJoin(env$1.localModelPath,b),st=pathJoin(env$1.remoteHost,env$1.remotePathTemplate.replaceAll("{model}",o).replaceAll("{revision}",encodeURIComponent(h)),e),$=h==="main"?b:pathJoin(o,h,e),it,g=d instanceof FileCache?$:st,c=!1,_;d&&(_=await tryCache(d,et,g));const ot=_!==void 0;if(_===void 0){if(env$1.allowLocalModels)if(isValidUrl(b,["http:","https:"])){if(a.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${b}.`);if(!env$1.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${b}.`)}else try{_=await getFile(et),it=et}catch(ft){console.warn(`Unable to load from local path "${et}": "${ft}"`)}if(_===void 0||_.status===404){if(a.local_files_only||!env$1.allowRemoteModels){if(s)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${et}".`);return null}if(_=await getFile(st),_.status!==200)return handleError$1(_.status,st,s);it=g}c=d&&typeof Response<"u"&&_ instanceof Response&&_.status===200}dispatchCallback(a.progress_callback,{status:"download",name:o,file:e});const ct={status:"progress",name:o,file:e};let dt;return a.progress_callback?ot&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(dt=new Uint8Array(await _.arrayBuffer()),dispatchCallback(a.progress_callback,{...ct,progress:100,loaded:dt.length,total:dt.length})):dt=await readResponse(_,pt=>{dispatchCallback(a.progress_callback,{...ct,...pt})}):dt=new Uint8Array(await _.arrayBuffer()),c&&it&&await d.match(it)===void 0&&await d.put(it,new Response(dt,{headers:_.headers})).catch(pt=>{console.warn(`Unable to add response to browser cache: ${pt}.`)}),dispatchCallback(a.progress_callback,{status:"done",name:o,file:e}),dt}async function getModelJSON(o,e,s=!0,a={}){let d=await getModelFile(o,e,s,a);if(d===null)return{};let b=new TextDecoder("utf-8").decode(d);return JSON.parse(b)}async function readResponse(o,e){const s=o.headers.get("Content-Length");s===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let a=parseInt(s??"0"),d=new Uint8Array(a),h=0;const b=o.body.getReader();async function et(){const{done:st,value:$}=await b.read();if(st)return;let it=h+$.length;if(it>a){a=it;let c=new Uint8Array(a);c.set(d),d=c}d.set($,h),h=it;const g=h/a*100;return e({progress:g,loaded:h,total:a}),et()}return await et(),d}function pathJoin(...o){return o=o.map((e,s)=>(s&&(e=e.replace(new RegExp("^/"),"")),s!==o.length-1&&(e=e.replace(new RegExp("/$"),"")),e)),o.join("/")}function permute_data(o,e,s){const a=new Array(s.length),d=new Array(s.length);for(let et=s.length-1,st=1;et>=0;--et)d[et]=st,a[et]=e[s[et]],st*=a[et];const h=s.map((et,st)=>d[s.indexOf(st)]),b=new o.constructor(o.length);for(let et=0;et<o.length;++et){let st=0;for(let $=e.length-1,it=et;$>=0;--$)st+=it%e[$]*h[$],it=Math.floor(it/e[$]);b[st]=o[et]}return[b,a]}function softmax(o){const e=max$1(o)[0],s=o.map(h=>Math.exp(h-e)),a=s.reduce((h,b)=>h+b,0);return s.map(h=>h/a)}function log_softmax(o){return softmax(o).map(a=>Math.log(a))}function getTopItems(o,e=0){return o=Array.from(o).map((s,a)=>[a,s]).sort((s,a)=>a[1]-s[1]),e!==null&&e>0&&(o=o.slice(0,e)),o}function min$1(o){if(o.length===0)throw Error("Array must not be empty");let e=o[0],s=0;for(let a=1;a<o.length;++a)o[a]<e&&(e=o[a],s=a);return[e,s]}function max$1(o){if(o.length===0)throw Error("Array must not be empty");let e=o[0],s=0;for(let a=1;a<o.length;++a)o[a]>e&&(e=o[a],s=a);return[Number(e),s]}function medianFilter(o,e){if(e%2===0||e<=0)throw new Error("Window size must be a positive odd number");const s=new o.constructor(o.length),a=new o.constructor(e),d=Math.floor(e/2);for(let h=0;h<o.length;++h){let b=0;for(let et=-d;et<=d;++et){let st=h+et;st<0?st=Math.abs(st):st>=o.length&&(st=2*(o.length-1)-st),a[b++]=o[st]}a.sort(),s[h]=a[d]}return s}function round$1(o,e){const s=Math.pow(10,e);return Math.round(o*s)/s}const DataTypeMap=Object.freeze({float32:Float32Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array}),ONNXTensor$1=ONNX.Tensor;class Tensor{dims;type;data;size;constructor(...e){return e[0]instanceof ONNXTensor$1?Object.assign(this,e[0]):Object.assign(this,new ONNXTensor$1(e[0],e[1],e[2])),new Proxy(this,{get:(s,a)=>{if(typeof a=="string"){let d=Number(a);if(Number.isInteger(d))return s._getitem(d)}return s[a]},set:(s,a,d)=>s[a]=d})}*[Symbol.iterator](){const[e,...s]=this.dims;if(s.length>0){const a=s.reduce((d,h)=>d*h);for(let d=0;d<e;++d)yield this._subarray(d,a,s)}else yield*this.data}_getitem(e){const[s,...a]=this.dims;if(e=safeIndex(e,s),a.length>0){const d=a.reduce((h,b)=>h*b);return this._subarray(e,d,a)}else return new Tensor(this.type,[this.data[e]],a)}indexOf(e){for(let s=0;s<this.data.length;++s)if(this.data[s]==e)return s;return-1}_subarray(e,s,a){const d=e*s,h=(e+1)*s,b="subarray"in this.data?this.data.subarray(d,h):this.data.slice(d,h);return new Tensor(this.type,b,a)}item(){if(this.data.length!==1)throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);return this.data[0]}tolist(){return reshape(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){for(let e=0;e<this.data.length;++e)this.data[e]=1/(1+Math.exp(-this.data[e]));return this}mul(e){return this.clone().mul_(e)}mul_(e){for(let s=0;s<this.data.length;++s)this.data[s]*=e;return this}add(e){return this.clone().add_(e)}add_(e){for(let s=0;s<this.data.length;++s)this.data[s]+=e;return this}clone(){return new Tensor(this.type,this.data.slice(),this.dims.slice())}slice(...e){let s=[],a=[];for(let st=0;st<this.dims.length;++st){let $=e[st];if($==null)a.push([0,this.dims[st]]),s.push(this.dims[st]);else if(typeof $=="number")$=safeIndex($,this.dims[st],st),a.push([$,$+1]);else if(Array.isArray($)&&$.length===2){if($[0]>$[1])throw new Error(`Invalid slice: ${$}`);let it=[Math.max($[0],0),Math.min($[1],this.dims[st])];a.push(it),s.push(it[1]-it[0])}else throw new Error(`Invalid slice: ${$}`)}let d=a.map(([st,$])=>$-st),h=d.reduce((st,$)=>st*$),b=new this.data.constructor(h);const et=this.stride();for(let st=0;st<h;++st){let $=0;for(let it=d.length-1,g=st;it>=0;--it){const c=d[it];$+=(g%c+a[it][0])*et[it],g=Math.floor(g/c)}b[st]=this.data[$]}return new Tensor(this.type,b,s)}permute(...e){return permute(this,e)}transpose(...e){return this.permute(...e)}sum(e=null,s=!1){return this.norm(1,e,s)}norm(e="fro",s=null,a=!1){if(e==="fro")e=2;else if(typeof e=="string")throw Error(`Unsupported norm: ${e}`);if(s===null){let b=this.data.reduce((et,st)=>et+st**e,0)**(1/e);return new Tensor(this.type,[b],[])}s=safeIndex(s,this.dims.length);const d=this.dims.slice();d[s]=1;const h=new this.data.constructor(this.data.length/this.dims[s]);for(let b=0;b<this.data.length;++b){let et=0;for(let st=this.dims.length-1,$=b,it=1;st>=0;--st){const g=this.dims[st];if(st!==s){const c=$%g;et+=c*it,it*=d[st]}$=Math.floor($/g)}h[et]+=this.data[b]**e}if(e!==1)for(let b=0;b<h.length;++b)h[b]=h[b]**(1/e);return a||d.splice(s,1),new Tensor(this.type,h,d)}normalize_(e=2,s=1){s=safeIndex(s,this.dims.length);const a=this.norm(e,s,!0);for(let d=0;d<this.data.length;++d){let h=0;for(let b=this.dims.length-1,et=d,st=1;b>=0;--b){const $=this.dims[b];if(b!==s){const it=et%$;h+=it*st,st*=this.dims[b]}et=Math.floor(et/$)}this.data[d]/=a.data[h]}return this}normalize(e=2,s=1){return this.clone().normalize_(e,s)}stride(){return dimsToStride(this.dims)}squeeze(e=null){return new Tensor(this.type,this.data,calc_squeeze_dims(this.dims,e))}squeeze_(e=null){return this.dims=calc_squeeze_dims(this.dims,e),this}unsqueeze(e=null){return new Tensor(this.type,this.data,calc_unsqueeze_dims(this.dims,e))}unsqueeze_(e=null){return this.dims=calc_unsqueeze_dims(this.dims,e),this}flatten_(e=0,s=-1){s=(s+this.dims.length)%this.dims.length;let a=this.dims.slice(0,e),d=this.dims.slice(e,s+1),h=this.dims.slice(s+1);return this.dims=[...a,d.reduce((b,et)=>b*et,1),...h],this}flatten(e=0,s=-1){return this.clone().flatten_(e,s)}view(...e){let s=-1;for(let a=0;a<e.length;++a)if(e[a]===-1){if(s!==-1)throw new Error("Only one dimension can be inferred");s=a}if(s!==-1){const a=e.reduce((d,h,b)=>b!==s?d*h:d,1);e[s]=this.data.length/a}return new Tensor(this.type,this.data,e)}neg_(){for(let e=0;e<this.data.length;++e)this.data[e]=-this.data[e];return this}neg(){return this.clone().neg_()}clamp_(e,s){for(let a=0;a<this.data.length;++a)this.data[a]=Math.min(Math.max(this.data[a],e),s);return this}clamp(e,s){return this.clone().clamp_(e,s)}round_(){for(let e=0;e<this.data.length;++e)this.data[e]=Math.round(this.data[e]);return this}round(){return this.clone().round_()}to(e){if(this.type===e)return this;if(!DataTypeMap.hasOwnProperty(e))throw new Error(`Unsupported type: ${e}`);return new Tensor(e,DataTypeMap[e].from(this.data),this.dims)}}function reshape(o,e){const s=o.length,a=e.reduce((h,b)=>h*b);if(s!==a)throw Error(`cannot reshape array of size ${s} into shape (${e})`);let d=o;for(let h=e.length-1;h>=0;h--)d=d.reduce((b,et)=>{let st=b[b.length-1];return st.length<e[h]?st.push(et):b.push([et]),b},[[]]);return d[0]}function permute(o,e){const[s,a]=permute_data(o.data,o.dims,e);return new Tensor(o.type,s,a)}function calc_squeeze_dims(o,e){return o=o.slice(),e===null?o=o.filter(s=>s!==1):typeof e=="number"?o[e]===1&&o.splice(e,1):Array.isArray(e)&&(o=o.filter((s,a)=>s!==1||!e.includes(a))),o}function calc_unsqueeze_dims(o,e){return e=safeIndex(e,o.length+1),o=o.slice(),o.splice(e,0,1),o}function safeIndex(o,e,s=null){if(o<-e||o>=e)throw new Error(`IndexError: index ${o} is out of bounds for dimension${s===null?"":" "+s} with size ${e}`);return o<0&&(o=(o%e+e)%e),o}function cat(o,e=0){e=safeIndex(e,o[0].dims.length);const s=o[0].dims.slice();s[e]=o.reduce((b,et)=>b+et.dims[e],0);const a=s.reduce((b,et)=>b*et,1),d=new o[0].data.constructor(a),h=o[0].type;if(e===0){let b=0;for(let et of o)d.set(et.data,b),b+=et.data.length}else{let b=0;for(let et=0;et<o.length;++et){let st=o[et];for(let $=0;$<st.data.length;++$){let it=0;for(let g=st.dims.length-1,c=$,_=1;g>=0;--g){const ot=st.dims[g];let ct=c%ot;g===e&&(ct+=b),it+=ct*_,_*=s[g],c=Math.floor(c/ot)}d[it]=st.data[$]}b+=st.dims[e]}}return new Tensor(h,d,s)}function stack(o,e=0){return cat(o.map(s=>s.unsqueeze(e)),e)}function std_mean(o,e=null,s=1,a=!1){if(e===null){const $=o.data.reduce((_,ot)=>_+ot,0)/o.data.length,it=Math.sqrt(o.data.reduce((_,ot)=>_+(ot-$)**2,0)/(o.data.length-s)),g=new Tensor(o.type,[$],[]);return[new Tensor(o.type,[it],[]),g]}e=safeIndex(e,o.dims.length);const d=mean(o,e,a),h=o.dims.slice();h[e]=1;const b=new o.data.constructor(o.data.length/o.dims[e]);for(let st=0;st<o.data.length;++st){let $=0;for(let it=o.dims.length-1,g=st,c=1;it>=0;--it){const _=o.dims[it];if(it!==e){const ot=g%_;$+=ot*c,c*=h[it]}g=Math.floor(g/_)}b[$]+=(o.data[st]-d.data[$])**2}for(let st=0;st<b.length;++st)b[st]=Math.sqrt(b[st]/(o.dims[e]-s));return a||h.splice(e,1),[new Tensor(o.type,b,h),d]}function mean(o,e=null,s=!1){if(e===null){let h=o.data.reduce((b,et)=>b+et,0);return new Tensor(o.type,[h/o.data.length],[])}e=safeIndex(e,o.dims.length);const a=o.dims.slice();a[e]=1;const d=new o.data.constructor(o.data.length/o.dims[e]);for(let h=0;h<o.data.length;++h){let b=0;for(let et=o.dims.length-1,st=h,$=1;et>=0;--et){const it=o.dims[et];if(et!==e){const g=st%it;b+=g*$,$*=a[et]}st=Math.floor(st/it)}d[b]+=o.data[h]}if(o.dims[e]!==1)for(let h=0;h<d.length;++h)d[h]=d[h]/o.dims[e];return s||a.splice(e,1),new Tensor(o.type,d,a)}function dynamicTimeWarping(o){const[e,s]=o.dims,a=[e+1,s+1],d=new Tensor("float32",new Float32Array(a[0]*a[1]).fill(1/0),a),h=new Tensor("float32",new Float32Array(a[0]*a[1]).fill(-1),a);d[0].data[0]=0;for(let it=1;it<s+1;++it)for(let g=1;g<e+1;++g){const c=d[g-1][it-1].item(),_=d[g-1][it].item(),ot=d[g][it-1].item();let ct,dt;c<_&&c<ot?(ct=c,dt=0):_<c&&_<ot?(ct=_,dt=1):(ct=ot,dt=2),d[g].data[it]=o[g-1][it-1].item()+ct,h[g].data[it]=dt}let b=e,et=s;h.data.fill(2,0,a[1]);for(let it=0;it<a[0];++it)h[it].data[0]=1;let st=[],$=[];for(;b>0||et>0;)switch(st.push(b-1),$.push(et-1),h[b][et].item()){case 0:--b,--et;break;case 1:--b;break;case 2:--et;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${b}, ${et}]. Please file a bug report.`)}return st.reverse(),$.reverse(),[st,$]}function dimsToStride(o){const e=new Array(o.length);for(let s=o.length-1,a=1;s>=0;--s)e[s]=a,a*=o[s];return e}function ones(o){const e=o.reduce((s,a)=>s*a,1);return new Tensor("int64",new BigInt64Array(e).fill(1n),o)}function ones_like(o){return ones(o.dims)}class PriorityQueue{constructor(e=(s,a)=>s>a){this._heap=[],this._comparator=e}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const s of e)this._heap.push(s),this._siftUp();return this.size}pop(){const e=this.peek(),s=this.size-1;return s>0&&this._swap(0,s),this._heap.pop(),this._siftDown(),e}replace(e){const s=this.peek();return this._heap[0]=e,this._siftDown(),s}_parent(e){return(e+1>>>1)-1}_left(e){return(e<<1)+1}_right(e){return e+1<<1}_greater(e,s){return this._comparator(this._heap[e],this._heap[s])}_swap(e,s){const a=this._heap[e];this._heap[e]=this._heap[s],this._heap[s]=a}_siftUp(){let e=this.size-1;for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const s=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,s),e=s}}}class CharTrie{constructor(){this.root=CharTrieNode.default()}extend(e){for(let s of e)this.push(s)}push(e){let s=this.root;for(let a of e){let d=s.children.get(a);d===void 0&&(d=CharTrieNode.default(),s.children.set(a,d)),s=d}s.isLeaf=!0}*commonPrefixSearch(e){let s=this.root,a="";for(let d=0;d<e.length&&s!==void 0;++d){const h=e[d];a+=h,s=s.children.get(h),s!==void 0&&s.isLeaf&&(yield a)}}}class CharTrieNode{constructor(e,s){this.isLeaf=e,this.children=s}static default(){return new CharTrieNode(!1,new Map)}}class TokenLattice{constructor(e,s,a){this.sentence=e,this.len=e.length,this.bosTokenId=s,this.eosTokenId=a,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const d=new TokenLatticeNode(this.bosTokenId,0,0,0,0),h=new TokenLatticeNode(this.eosTokenId,1,this.len,0,0);this.nodes.push(d.clone()),this.nodes.push(h.clone()),this.beginNodes[this.len].push(h),this.endNodes[0].push(d)}insert(e,s,a,d){const h=this.nodes.length,b=new TokenLatticeNode(d,h,e,s,a);this.beginNodes[e].push(b),this.endNodes[e+s].push(b),this.nodes.push(b)}viterbi(){const e=this.len;let s=0;for(;s<=e;){if(this.beginNodes[s].length==0)return[];for(let et of this.beginNodes[s]){et.prev=null;let st=0,$=null;for(let it of this.endNodes[s]){const g=it.backtraceScore+et.score;($===null||g>st)&&($=it.clone(),st=g)}if($!==null)et.prev=$,et.backtraceScore=st;else return[]}++s}const a=[],h=this.beginNodes[e][0].prev;if(h===null)return[];let b=h.clone();for(;b.prev!==null;)a.push(b.clone()),b=b.clone().prev.clone();return a.reverse(),a}piece(e){return this.sentence.slice(e.pos,e.pos+e.length)}tokens(){return this.viterbi().map(s=>this.piece(s))}tokenIds(){return this.viterbi().map(s=>s.tokenId)}}class TokenLatticeNode{constructor(e,s,a,d,h){this.tokenId=e,this.nodeId=s,this.pos=a,this.length=d,this.score=h,this.prev=null,this.backtraceScore=0}clone(){const e=new TokenLatticeNode(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}var TOKEN_TYPES=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator"}),KEYWORDS=Object.freeze({set:TOKEN_TYPES.Set,for:TOKEN_TYPES.For,in:TOKEN_TYPES.In,is:TOKEN_TYPES.Is,if:TOKEN_TYPES.If,else:TOKEN_TYPES.Else,endif:TOKEN_TYPES.EndIf,elif:TOKEN_TYPES.ElseIf,endfor:TOKEN_TYPES.EndFor,and:TOKEN_TYPES.And,or:TOKEN_TYPES.Or,not:TOKEN_TYPES.Not,"not in":TOKEN_TYPES.NotIn,true:TOKEN_TYPES.BooleanLiteral,false:TOKEN_TYPES.BooleanLiteral}),Token=class{constructor(o,e){this.value=o,this.type=e}};function isWord(o){return/\w/.test(o)}function isInteger(o){return/[0-9]/.test(o)}var ORDERED_MAPPING_TABLE=[["{%",TOKEN_TYPES.OpenStatement],["%}",TOKEN_TYPES.CloseStatement],["{{",TOKEN_TYPES.OpenExpression],["}}",TOKEN_TYPES.CloseExpression],["(",TOKEN_TYPES.OpenParen],[")",TOKEN_TYPES.CloseParen],["{",TOKEN_TYPES.OpenCurlyBracket],["}",TOKEN_TYPES.CloseCurlyBracket],["[",TOKEN_TYPES.OpenSquareBracket],["]",TOKEN_TYPES.CloseSquareBracket],[",",TOKEN_TYPES.Comma],[".",TOKEN_TYPES.Dot],[":",TOKEN_TYPES.Colon],["|",TOKEN_TYPES.Pipe],["<=",TOKEN_TYPES.ComparisonBinaryOperator],[">=",TOKEN_TYPES.ComparisonBinaryOperator],["==",TOKEN_TYPES.ComparisonBinaryOperator],["!=",TOKEN_TYPES.ComparisonBinaryOperator],["<",TOKEN_TYPES.ComparisonBinaryOperator],[">",TOKEN_TYPES.ComparisonBinaryOperator],["+",TOKEN_TYPES.AdditiveBinaryOperator],["-",TOKEN_TYPES.AdditiveBinaryOperator],["*",TOKEN_TYPES.MultiplicativeBinaryOperator],["/",TOKEN_TYPES.MultiplicativeBinaryOperator],["%",TOKEN_TYPES.MultiplicativeBinaryOperator],["=",TOKEN_TYPES.Equals]],ESCAPE_CHARACTERS=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function preprocess(o,e={}){return o.endsWith(`
`)&&(o=o.slice(0,-1)),o=o.replace(/{#.*?#}/gs,"{##}"),e.lstrip_blocks&&(o=o.replace(/^[ \t]*({[#%])/gm,"$1")),e.trim_blocks&&(o=o.replace(/([#%]})\n/g,"$1")),o.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function tokenize(o,e={}){const s=[],a=preprocess(o,e);let d=0;const h=b=>{let et="";for(;b(a[d]);){if(a[d]==="\\"){if(++d,d>=a.length)throw new SyntaxError("Unexpected end of input");const st=a[d++],$=ESCAPE_CHARACTERS.get(st);if($===void 0)throw new SyntaxError(`Unexpected escaped character: ${st}`);et+=$;continue}if(et+=a[d++],d>=a.length)throw new SyntaxError("Unexpected end of input")}return et};e:for(;d<a.length;){const b=s.at(-1)?.type;if(b===void 0||b===TOKEN_TYPES.CloseStatement||b===TOKEN_TYPES.CloseExpression){let st="";for(;d<a.length&&!(a[d]==="{"&&(a[d+1]==="%"||a[d+1]==="{"));)st+=a[d++];if(st.length>0){s.push(new Token(st,TOKEN_TYPES.Text));continue}}h(st=>/\s/.test(st));const et=a[d];if(et==="-"||et==="+"){const st=s.at(-1)?.type;if(st===TOKEN_TYPES.Text||st===void 0)throw new SyntaxError(`Unexpected character: ${et}`);switch(st){case TOKEN_TYPES.Identifier:case TOKEN_TYPES.NumericLiteral:case TOKEN_TYPES.BooleanLiteral:case TOKEN_TYPES.StringLiteral:case TOKEN_TYPES.CloseParen:case TOKEN_TYPES.CloseSquareBracket:break;default:{++d;const $=h(isInteger);s.push(new Token(`${et}${$}`,$.length>0?TOKEN_TYPES.NumericLiteral:TOKEN_TYPES.UnaryOperator));continue}}}for(const[st,$]of ORDERED_MAPPING_TABLE)if(a.slice(d,d+st.length)===st){s.push(new Token(st,$)),d+=st.length;continue e}if(et==="'"||et==='"'){++d;const st=h($=>$!==et);s.push(new Token(st,TOKEN_TYPES.StringLiteral)),++d;continue}if(isInteger(et)){const st=h(isInteger);s.push(new Token(st,TOKEN_TYPES.NumericLiteral));continue}if(isWord(et)){const st=h(isWord),$=Object.hasOwn(KEYWORDS,st)?KEYWORDS[st]:TOKEN_TYPES.Identifier;$===TOKEN_TYPES.In&&s.at(-1)?.type===TOKEN_TYPES.Not?(s.pop(),s.push(new Token("not in",TOKEN_TYPES.NotIn))):s.push(new Token(st,$));continue}throw new SyntaxError(`Unexpected character: ${et}`)}return s}var Statement=class{type="Statement"},Program=class extends Statement{constructor(o){super(),this.body=o}type="Program"},If=class extends Statement{constructor(o,e,s){super(),this.test=o,this.body=e,this.alternate=s}type="If"},For=class extends Statement{constructor(o,e,s){super(),this.loopvar=o,this.iterable=e,this.body=s}type="For"},SetStatement=class extends Statement{constructor(o,e){super(),this.assignee=o,this.value=e}type="Set"},Expression=class extends Statement{type="Expression"},MemberExpression=class extends Expression{constructor(o,e,s){super(),this.object=o,this.property=e,this.computed=s}type="MemberExpression"},CallExpression=class extends Expression{constructor(o,e){super(),this.callee=o,this.args=e}type="CallExpression"},Identifier=class extends Expression{constructor(o){super(),this.value=o}type="Identifier"},Literal=class extends Expression{constructor(o){super(),this.value=o}type="Literal"},NumericLiteral=class extends Literal{type="NumericLiteral"},StringLiteral=class extends Literal{type="StringLiteral"},BooleanLiteral=class extends Literal{type="BooleanLiteral"},ArrayLiteral=class extends Literal{type="ArrayLiteral"},TupleLiteral=class extends Literal{type="TupleLiteral"},ObjectLiteral=class extends Literal{type="ObjectLiteral"},BinaryExpression=class extends Expression{constructor(o,e,s){super(),this.operator=o,this.left=e,this.right=s}type="BinaryExpression"},FilterExpression=class extends Expression{constructor(o,e){super(),this.operand=o,this.filter=e}type="FilterExpression"},TestExpression=class extends Expression{constructor(o,e,s){super(),this.operand=o,this.negate=e,this.test=s}type="TestExpression"},UnaryExpression=class extends Expression{constructor(o,e){super(),this.operator=o,this.argument=e}type="UnaryExpression"},SliceExpression=class extends Expression{constructor(o=void 0,e=void 0,s=void 0){super(),this.start=o,this.stop=e,this.step=s}type="SliceExpression"},KeywordArgumentExpression=class extends Expression{constructor(o,e){super(),this.key=o,this.value=e}type="KeywordArgumentExpression"};function parse(o){const e=new Program([]);let s=0;function a(Ht,Gt){const cn=o[s++];if(!cn||cn.type!==Ht)throw new Error(`Parser Error: ${Gt}. ${cn.type} !== ${Ht}.`);return cn}function d(){switch(o[s].type){case TOKEN_TYPES.Text:return et();case TOKEN_TYPES.OpenStatement:return st();case TOKEN_TYPES.OpenExpression:return $();default:throw new SyntaxError(`Unexpected token type: ${o[s].type}`)}}function h(...Ht){return s+Ht.length<=o.length&&Ht.some((Gt,cn)=>Gt!==o[s+cn].type)}function b(...Ht){return s+Ht.length<=o.length&&Ht.every((Gt,cn)=>Gt===o[s+cn].type)}function et(){return new StringLiteral(a(TOKEN_TYPES.Text,"Expected text token").value)}function st(){a(TOKEN_TYPES.OpenStatement,"Expected opening statement token");let Ht;switch(o[s].type){case TOKEN_TYPES.Set:++s,Ht=it(),a(TOKEN_TYPES.CloseStatement,"Expected closing statement token");break;case TOKEN_TYPES.If:++s,Ht=g(),a(TOKEN_TYPES.OpenStatement,"Expected {% token"),a(TOKEN_TYPES.EndIf,"Expected endif token"),a(TOKEN_TYPES.CloseStatement,"Expected %} token");break;case TOKEN_TYPES.For:++s,Ht=_(),a(TOKEN_TYPES.OpenStatement,"Expected {% token"),a(TOKEN_TYPES.EndFor,"Expected endfor token"),a(TOKEN_TYPES.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${o[s].type}`)}return Ht}function $(){a(TOKEN_TYPES.OpenExpression,"Expected opening expression token");const Ht=ot();return a(TOKEN_TYPES.CloseExpression,"Expected closing expression token"),Ht}function it(){const Ht=ot();if(b(TOKEN_TYPES.Equals)){++s;const Gt=it();return new SetStatement(Ht,Gt)}return Ht}function g(){const Ht=ot();a(TOKEN_TYPES.CloseStatement,"Expected closing statement token");const Gt=[],cn=[];for(;!(o[s]?.type===TOKEN_TYPES.OpenStatement&&(o[s+1]?.type===TOKEN_TYPES.ElseIf||o[s+1]?.type===TOKEN_TYPES.Else||o[s+1]?.type===TOKEN_TYPES.EndIf));)Gt.push(d());if(o[s]?.type===TOKEN_TYPES.OpenStatement&&o[s+1]?.type!==TOKEN_TYPES.EndIf)if(++s,b(TOKEN_TYPES.ElseIf))a(TOKEN_TYPES.ElseIf,"Expected elseif token"),cn.push(g());else for(a(TOKEN_TYPES.Else,"Expected else token"),a(TOKEN_TYPES.CloseStatement,"Expected closing statement token");!(o[s]?.type===TOKEN_TYPES.OpenStatement&&o[s+1]?.type===TOKEN_TYPES.EndIf);)cn.push(d());return new If(Ht,Gt,cn)}function c(Ht=!1){const Gt=Ht?pn:ot,cn=[Gt()],xn=b(TOKEN_TYPES.Comma);for(;xn&&(++s,cn.push(Gt()),!!b(TOKEN_TYPES.Comma)););return xn?new TupleLiteral(cn):cn[0]}function _(){const Ht=c(!0);if(!(Ht instanceof Identifier||Ht instanceof TupleLiteral))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${Ht.type} instead`);a(TOKEN_TYPES.In,"Expected `in` keyword following loop variable");const Gt=ot();a(TOKEN_TYPES.CloseStatement,"Expected closing statement token");const cn=[];for(;h(TOKEN_TYPES.OpenStatement,TOKEN_TYPES.EndFor);)cn.push(d());return new For(Ht,Gt,cn)}function ot(){return ct()}function ct(){const Ht=dt();if(b(TOKEN_TYPES.If)){++s;const Gt=dt();a(TOKEN_TYPES.Else,"Expected else token");const cn=dt();return new If(Gt,[Ht],[cn])}return Ht}function dt(){let Ht=pt();for(;b(TOKEN_TYPES.Or);){const Gt=o[s];++s;const cn=pt();Ht=new BinaryExpression(Gt,Ht,cn)}return Ht}function pt(){let Ht=ft();for(;b(TOKEN_TYPES.And);){const Gt=o[s];++s;const cn=ft();Ht=new BinaryExpression(Gt,Ht,cn)}return Ht}function ft(){let Ht;for(;b(TOKEN_TYPES.Not);){const Gt=o[s];++s;const cn=ft();Ht=new UnaryExpression(Gt,cn)}return Ht??ht()}function ht(){let Ht=bt();for(;b(TOKEN_TYPES.ComparisonBinaryOperator)||b(TOKEN_TYPES.In)||b(TOKEN_TYPES.NotIn);){const Gt=o[s];++s;const cn=bt();Ht=new BinaryExpression(Gt,Ht,cn)}return Ht}function bt(){let Ht=ln();for(;b(TOKEN_TYPES.AdditiveBinaryOperator);){const Gt=o[s];++s;const cn=ln();Ht=new BinaryExpression(Gt,Ht,cn)}return Ht}function mt(){const Ht=Ft();return b(TOKEN_TYPES.OpenParen)?$t(Ht):Ht}function $t(Ht){let Gt=new CallExpression(Ht,Tt());return b(TOKEN_TYPES.OpenParen)&&(Gt=$t(Gt)),Gt}function Tt(){a(TOKEN_TYPES.OpenParen,"Expected opening parenthesis for arguments list");const Ht=Nt();return a(TOKEN_TYPES.CloseParen,"Expected closing parenthesis for arguments list"),Ht}function Nt(){const Ht=[];for(;!b(TOKEN_TYPES.CloseParen);){let Gt=ot();if(b(TOKEN_TYPES.Equals)){if(++s,!(Gt instanceof Identifier))throw new SyntaxError("Expected identifier for keyword argument");const cn=ot();Gt=new KeywordArgumentExpression(Gt,cn)}Ht.push(Gt),b(TOKEN_TYPES.Comma)&&++s}return Ht}function Ct(){const Ht=[];let Gt=!1;for(;!b(TOKEN_TYPES.CloseSquareBracket);)b(TOKEN_TYPES.Colon)?(Ht.push(void 0),++s,Gt=!0):(Ht.push(ot()),b(TOKEN_TYPES.Colon)&&(++s,Gt=!0));if(Ht.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(Gt){if(Ht.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new SliceExpression(...Ht)}return Ht[0]}function Ft(){let Ht=pn();for(;b(TOKEN_TYPES.Dot)||b(TOKEN_TYPES.OpenSquareBracket);){const Gt=o[s];++s;let cn;const xn=Gt.type!==TOKEN_TYPES.Dot;if(xn)cn=Ct(),a(TOKEN_TYPES.CloseSquareBracket,"Expected closing square bracket");else if(cn=pn(),cn.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");Ht=new MemberExpression(Ht,cn,xn)}return Ht}function ln(){let Ht=mn();for(;b(TOKEN_TYPES.MultiplicativeBinaryOperator);){const Gt=o[s];++s;const cn=mn();Ht=new BinaryExpression(Gt,Ht,cn)}return Ht}function mn(){let Ht=yn();for(;b(TOKEN_TYPES.Is);){++s;const Gt=b(TOKEN_TYPES.Not);Gt&&++s;let cn=pn();if(cn instanceof BooleanLiteral&&(cn=new Identifier(cn.value.toString())),!(cn instanceof Identifier))throw new SyntaxError("Expected identifier for the test");Ht=new TestExpression(Ht,Gt,cn)}return Ht}function yn(){let Ht=mt();for(;b(TOKEN_TYPES.Pipe);){++s;let Gt=pn();if(!(Gt instanceof Identifier))throw new SyntaxError("Expected identifier for the filter");b(TOKEN_TYPES.OpenParen)&&(Gt=$t(Gt)),Ht=new FilterExpression(Ht,Gt)}return Ht}function pn(){const Ht=o[s];switch(Ht.type){case TOKEN_TYPES.NumericLiteral:return++s,new NumericLiteral(Number(Ht.value));case TOKEN_TYPES.StringLiteral:return++s,new StringLiteral(Ht.value);case TOKEN_TYPES.BooleanLiteral:return++s,new BooleanLiteral(Ht.value==="true");case TOKEN_TYPES.Identifier:return++s,new Identifier(Ht.value);case TOKEN_TYPES.OpenParen:{++s;const Gt=c();if(o[s].type!==TOKEN_TYPES.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${o[s].type} instead`);return++s,Gt}case TOKEN_TYPES.OpenSquareBracket:{++s;const Gt=[];for(;!b(TOKEN_TYPES.CloseSquareBracket);)Gt.push(ot()),b(TOKEN_TYPES.Comma)&&++s;return++s,new ArrayLiteral(Gt)}case TOKEN_TYPES.OpenCurlyBracket:{++s;const Gt=new Map;for(;!b(TOKEN_TYPES.CloseCurlyBracket);){const cn=ot();a(TOKEN_TYPES.Colon,"Expected colon between key and value in object literal");const xn=ot();Gt.set(cn,xn),b(TOKEN_TYPES.Comma)&&++s}return++s,new ObjectLiteral(Gt)}default:throw new SyntaxError(`Unexpected token: ${Ht.type}`)}}for(;s<o.length;)e.body.push(d());return e}function range(o,e,s=1){e===void 0&&(e=o,o=0);const a=[];for(let d=o;d<e;d+=s)a.push(d);return a}function slice(o,e,s,a=1){const d=Math.sign(a);d>=0?(e=(e??=0)<0?Math.max(o.length+e,0):Math.min(e,o.length),s=(s??=o.length)<0?Math.max(o.length+s,0):Math.min(s,o.length)):(e=(e??=o.length-1)<0?Math.max(o.length+e,-1):Math.min(e,o.length-1),s=(s??=-1)<-1?Math.max(o.length+s,-1):Math.min(s,o.length-1));const h=[];for(let b=e;d*b<d*s;b+=a)h.push(o[b]);return h}function titleCase(o){return o.replace(/\b\w/g,e=>e.toUpperCase())}var RuntimeValue=class{type="RuntimeValue";value;builtins=new Map;constructor(o=void 0){this.value=o}__bool__(){return new BooleanValue(!!this.value)}},NumericValue=class extends RuntimeValue{type="NumericValue"},StringValue=class extends RuntimeValue{type="StringValue";builtins=new Map([["upper",new FunctionValue(()=>new StringValue(this.value.toUpperCase()))],["lower",new FunctionValue(()=>new StringValue(this.value.toLowerCase()))],["strip",new FunctionValue(()=>new StringValue(this.value.trim()))],["title",new FunctionValue(()=>new StringValue(titleCase(this.value)))],["length",new NumericValue(this.value.length)]])},BooleanValue=class extends RuntimeValue{type="BooleanValue"},ObjectValue=class extends RuntimeValue{type="ObjectValue";__bool__(){return new BooleanValue(this.value.size>0)}builtins=new Map([["get",new FunctionValue(([o,e])=>{if(!(o instanceof StringValue))throw new Error(`Object key must be a string: got ${o.type}`);return this.value.get(o.value)??e??new NullValue})],["items",new FunctionValue(()=>new ArrayValue(Array.from(this.value.entries()).map(([o,e])=>new ArrayValue([new StringValue(o),e]))))]])},ArrayValue=class extends RuntimeValue{type="ArrayValue";builtins=new Map([["length",new NumericValue(this.value.length)]]);__bool__(){return new BooleanValue(this.value.length>0)}},TupleValue=class extends ArrayValue{type="TupleValue"},FunctionValue=class extends RuntimeValue{type="FunctionValue"},NullValue=class extends RuntimeValue{type="NullValue"},UndefinedValue=class extends RuntimeValue{type="UndefinedValue"},Environment=class{constructor(o){this.parent=o}variables=new Map([["namespace",new FunctionValue(o=>{if(o.length===0)return new ObjectValue(new Map);if(o.length!==1||!(o[0]instanceof ObjectValue))throw new Error("`namespace` expects either zero arguments or a single object argument");return o[0]})]]);tests=new Map([["boolean",o=>o.type==="BooleanValue"],["callable",o=>o instanceof FunctionValue],["odd",o=>{if(o.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${o.type}`);return o.value%2!==0}],["even",o=>{if(o.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${o.type}`);return o.value%2===0}],["false",o=>o.type==="BooleanValue"&&!o.value],["true",o=>o.type==="BooleanValue"&&o.value],["number",o=>o.type==="NumericValue"],["integer",o=>o.type==="NumericValue"&&Number.isInteger(o.value)],["iterable",o=>o instanceof ArrayValue||o instanceof StringValue],["lower",o=>{const e=o.value;return o.type==="StringValue"&&e===e.toLowerCase()}],["upper",o=>{const e=o.value;return o.type==="StringValue"&&e===e.toUpperCase()}],["none",o=>o.type==="NullValue"],["defined",o=>o.type!=="UndefinedValue"],["undefined",o=>o.type==="UndefinedValue"],["equalto",(o,e)=>o.value===e.value]]);set(o,e){return this.declareVariable(o,convertToRuntimeValues(e))}declareVariable(o,e){if(this.variables.has(o))throw new SyntaxError(`Variable already declared: ${o}`);return this.variables.set(o,e),e}setVariable(o,e){return this.variables.set(o,e),e}resolve(o){if(this.variables.has(o))return this;if(this.parent)return this.parent.resolve(o);throw new Error(`Unknown variable: ${o}`)}lookupVariable(o){try{return this.resolve(o).variables.get(o)??new UndefinedValue}catch{return new UndefinedValue}}},Interpreter=class{global;constructor(o){this.global=o??new Environment}run(o){return this.evaluate(o,this.global)}evaluateBinaryExpression(o,e){const s=this.evaluate(o.left,e);switch(o.operator.value){case"and":return s.__bool__().value?this.evaluate(o.right,e):s;case"or":return s.__bool__().value?s:this.evaluate(o.right,e)}const a=this.evaluate(o.right,e);switch(o.operator.value){case"==":return new BooleanValue(s.value==a.value);case"!=":return new BooleanValue(s.value!=a.value)}if(s instanceof UndefinedValue||a instanceof UndefinedValue)throw new Error("Cannot perform operation on undefined values");if(s instanceof NullValue||a instanceof NullValue)throw new Error("Cannot perform operation on null values");if(s instanceof NumericValue&&a instanceof NumericValue)switch(o.operator.value){case"+":return new NumericValue(s.value+a.value);case"-":return new NumericValue(s.value-a.value);case"*":return new NumericValue(s.value*a.value);case"/":return new NumericValue(s.value/a.value);case"%":return new NumericValue(s.value%a.value);case"<":return new BooleanValue(s.value<a.value);case">":return new BooleanValue(s.value>a.value);case">=":return new BooleanValue(s.value>=a.value);case"<=":return new BooleanValue(s.value<=a.value)}else if(s instanceof ArrayValue&&a instanceof ArrayValue)switch(o.operator.value){case"+":return new ArrayValue(s.value.concat(a.value))}else if(a instanceof ArrayValue){const d=a.value.find(h=>h.value===s.value)!==void 0;switch(o.operator.value){case"in":return new BooleanValue(d);case"not in":return new BooleanValue(!d)}}if(s instanceof StringValue||a instanceof StringValue)switch(o.operator.value){case"+":return new StringValue(s.value.toString()+a.value.toString())}if(s instanceof StringValue&&a instanceof StringValue)switch(o.operator.value){case"in":return new BooleanValue(a.value.includes(s.value));case"not in":return new BooleanValue(!a.value.includes(s.value))}if(s instanceof StringValue&&a instanceof ObjectValue)switch(o.operator.value){case"in":return new BooleanValue(a.value.has(s.value));case"not in":return new BooleanValue(!a.value.has(s.value))}throw new SyntaxError(`Unknown operator "${o.operator.value}" between ${s.type} and ${a.type}`)}evaluateFilterExpression(o,e){const s=this.evaluate(o.operand,e);if(o.filter.type==="Identifier"){const a=o.filter;if(s instanceof ArrayValue)switch(a.value){case"list":return s;case"first":return s.value[0];case"last":return s.value[s.value.length-1];case"length":return new NumericValue(s.value.length);case"reverse":return new ArrayValue(s.value.reverse());case"sort":return new ArrayValue(s.value.sort((d,h)=>{if(d.type!==h.type)throw new Error(`Cannot compare different types: ${d.type} and ${h.type}`);switch(d.type){case"NumericValue":return d.value-h.value;case"StringValue":return d.value.localeCompare(h.value);default:throw new Error(`Cannot compare type: ${d.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${a.value}`)}else if(s instanceof StringValue)switch(a.value){case"length":return new NumericValue(s.value.length);case"upper":return new StringValue(s.value.toUpperCase());case"lower":return new StringValue(s.value.toLowerCase());case"title":return new StringValue(titleCase(s.value));case"capitalize":return new StringValue(s.value.charAt(0).toUpperCase()+s.value.slice(1));case"trim":return new StringValue(s.value.trim());default:throw new Error(`Unknown StringValue filter: ${a.value}`)}else if(s instanceof NumericValue)switch(a.value){case"abs":return new NumericValue(Math.abs(s.value));default:throw new Error(`Unknown NumericValue filter: ${a.value}`)}else if(s instanceof ObjectValue)switch(a.value){case"items":return new ArrayValue(Array.from(s.value.entries()).map(([d,h])=>new ArrayValue([new StringValue(d),h])));case"length":return new NumericValue(s.value.size);default:throw new Error(`Unknown ObjectValue filter: ${a.value}`)}throw new Error(`Cannot apply filter "${a.value}" to type: ${s.type}`)}else if(o.filter.type==="CallExpression"){const a=o.filter;if(a.callee.type!=="Identifier")throw new Error(`Unknown filter: ${a.callee.type}`);const d=a.callee.value;if(s instanceof ArrayValue){switch(d){case"selectattr":{if(s.value.some(it=>!(it instanceof ObjectValue)))throw new Error("`selectattr` can only be applied to array of objects");if(a.args.some(it=>it.type!=="StringLiteral"))throw new Error("arguments of `selectattr` must be strings");const[h,b,et]=a.args.map(it=>this.evaluate(it,e));let st;if(b){const it=e.tests.get(b.value);if(!it)throw new Error(`Unknown test: ${b.value}`);st=it}else st=(...it)=>it[0].__bool__().value;const $=s.value.filter(it=>{const g=it.value.get(h.value);return g?st(g,et):!1});return new ArrayValue($)}}throw new Error(`Unknown ArrayValue filter: ${d}`)}else throw new Error(`Cannot apply filter "${d}" to type: ${s.type}`)}throw new Error(`Unknown filter: ${o.filter.type}`)}evaluateTestExpression(o,e){const s=this.evaluate(o.operand,e),a=e.tests.get(o.test.value);if(!a)throw new Error(`Unknown test: ${o.test.value}`);const d=a(s);return new BooleanValue(o.negate?!d:d)}evaluateUnaryExpression(o,e){const s=this.evaluate(o.argument,e);switch(o.operator.value){case"not":return new BooleanValue(!s.value);default:throw new SyntaxError(`Unknown operator: ${o.operator.value}`)}}evalProgram(o,e){return this.evaluateBlock(o.body,e)}evaluateBlock(o,e){let s="";for(const a of o){const d=this.evaluate(a,e);d.type!=="NullValue"&&d.type!=="UndefinedValue"&&(s+=d.value)}return new StringValue(s)}evaluateIdentifier(o,e){return e.lookupVariable(o.value)}evaluateCallExpression(o,e){const s=[],a=new Map;for(const h of o.args)if(h.type==="KeywordArgumentExpression"){const b=h;a.set(b.key.value,this.evaluate(b.value,e))}else s.push(this.evaluate(h,e));a.size>0&&s.push(new ObjectValue(a));const d=this.evaluate(o.callee,e);if(d.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${d.type}`);return d.value(s,e)}evaluateSliceExpression(o,e,s){if(!(o instanceof ArrayValue||o instanceof StringValue))throw new Error("Slice object must be an array or string");const a=this.evaluate(e.start,s),d=this.evaluate(e.stop,s),h=this.evaluate(e.step,s);if(!(a instanceof NumericValue||a instanceof UndefinedValue))throw new Error("Slice start must be numeric or undefined");if(!(d instanceof NumericValue||d instanceof UndefinedValue))throw new Error("Slice stop must be numeric or undefined");if(!(h instanceof NumericValue||h instanceof UndefinedValue))throw new Error("Slice step must be numeric or undefined");return o instanceof ArrayValue?new ArrayValue(slice(o.value,a.value,d.value,h.value)):new StringValue(slice(Array.from(o.value),a.value,d.value,h.value).join(""))}evaluateMemberExpression(o,e){const s=this.evaluate(o.object,e);let a;if(o.computed){if(o.property.type==="SliceExpression")return this.evaluateSliceExpression(s,o.property,e);a=this.evaluate(o.property,e)}else a=new StringValue(o.property.value);let d;if(s instanceof ObjectValue){if(!(a instanceof StringValue))throw new Error(`Cannot access property with non-string: got ${a.type}`);d=s.value.get(a.value)??s.builtins.get(a.value)}else if(s instanceof ArrayValue||s instanceof StringValue)if(a instanceof NumericValue)d=s.value.at(a.value),s instanceof StringValue&&(d=new StringValue(s.value.at(a.value)));else if(a instanceof StringValue)d=s.builtins.get(a.value);else throw new Error(`Cannot access property with non-string/non-number: got ${a.type}`);else{if(!(a instanceof StringValue))throw new Error(`Cannot access property with non-string: got ${a.type}`);d=s.builtins.get(a.value)}return d instanceof RuntimeValue?d:new UndefinedValue}evaluateSet(o,e){const s=this.evaluate(o.value,e);if(o.assignee.type==="Identifier"){const a=o.assignee.value;e.setVariable(a,s)}else if(o.assignee.type==="MemberExpression"){const a=o.assignee,d=this.evaluate(a.object,e);if(!(d instanceof ObjectValue))throw new Error("Cannot assign to member of non-object");if(a.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");d.value.set(a.property.value,s)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(o.assignee)}`);return new NullValue}evaluateIf(o,e){const s=this.evaluate(o.test,e);return this.evaluateBlock(s.__bool__().value?o.body:o.alternate,e)}evaluateFor(o,e){const s=new Environment(e),a=this.evaluate(o.iterable,s);if(!(a instanceof ArrayValue))throw new Error(`Expected iterable type in for loop: got ${a.type}`);let d="";for(let h=0;h<a.value.length;++h){const b=new Map([["index",new NumericValue(h+1)],["index0",new NumericValue(h)],["revindex",new NumericValue(a.value.length-h)],["revindex0",new NumericValue(a.value.length-h-1)],["first",new BooleanValue(h===0)],["last",new BooleanValue(h===a.value.length-1)],["length",new NumericValue(a.value.length)],["previtem",h>0?a.value[h-1]:new UndefinedValue],["nextitem",h<a.value.length-1?a.value[h+1]:new UndefinedValue]]);s.setVariable("loop",new ObjectValue(b));const et=a.value[h];if(o.loopvar.type==="Identifier")s.setVariable(o.loopvar.value,et);else if(o.loopvar.type==="TupleLiteral"){const $=o.loopvar;if(et.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${et.type}`);const it=et;if($.value.length!==it.value.length)throw new Error(`Too ${$.value.length>it.value.length?"few":"many"} items to unpack`);for(let g=0;g<$.value.length;++g){if($.value[g].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${$.value[g].type}`);s.setVariable($.value[g].value,it.value[g])}}const st=this.evaluateBlock(o.body,s);d+=st.value}return new StringValue(d)}evaluate(o,e){if(o===void 0)return new UndefinedValue;switch(o.type){case"Program":return this.evalProgram(o,e);case"Set":return this.evaluateSet(o,e);case"If":return this.evaluateIf(o,e);case"For":return this.evaluateFor(o,e);case"NumericLiteral":return new NumericValue(Number(o.value));case"StringLiteral":return new StringValue(o.value);case"BooleanLiteral":return new BooleanValue(o.value);case"ArrayLiteral":return new ArrayValue(o.value.map(s=>this.evaluate(s,e)));case"TupleLiteral":return new TupleValue(o.value.map(s=>this.evaluate(s,e)));case"ObjectLiteral":{const s=new Map;for(const[a,d]of o.value){const h=this.evaluate(a,e);if(!(h instanceof StringValue))throw new Error(`Object keys must be strings: got ${h.type}`);s.set(h.value,this.evaluate(d,e))}return new ObjectValue(s)}case"Identifier":return this.evaluateIdentifier(o,e);case"CallExpression":return this.evaluateCallExpression(o,e);case"MemberExpression":return this.evaluateMemberExpression(o,e);case"UnaryExpression":return this.evaluateUnaryExpression(o,e);case"BinaryExpression":return this.evaluateBinaryExpression(o,e);case"FilterExpression":return this.evaluateFilterExpression(o,e);case"TestExpression":return this.evaluateTestExpression(o,e);default:throw new SyntaxError(`Unknown node type: ${o.type}`)}}};function convertToRuntimeValues(o){switch(typeof o){case"number":return new NumericValue(o);case"string":return new StringValue(o);case"boolean":return new BooleanValue(o);case"object":return o===null?new NullValue:Array.isArray(o)?new ArrayValue(o.map(convertToRuntimeValues)):new ObjectValue(new Map(Object.entries(o).map(([e,s])=>[e,convertToRuntimeValues(s)])));case"function":return new FunctionValue((e,s)=>{const a=o(...e.map(d=>d.value))??null;return convertToRuntimeValues(a)});default:throw new Error(`Cannot convert to runtime value: ${o}`)}}var Template=class{parsed;constructor(o){const e=tokenize(o,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=parse(e)}render(o){const e=new Environment;e.set("false",!1),e.set("true",!0),e.set("raise_exception",d=>{throw new Error(d)}),e.set("range",range);for(const[d,h]of Object.entries(o))e.set(d,h);return new Interpreter(e).run(this.parsed).value}};async function loadTokenizer(o,e){const s=await Promise.all([getModelJSON(o,"tokenizer.json",!0,e),getModelJSON(o,"tokenizer_config.json",!0,e)]);return e.legacy!==null&&(s[1].legacy=e.legacy),s}function regexSplit(o,e){const s=[];let a=0;for(const d of o.matchAll(e)){const h=d[0];a<d.index&&s.push(o.slice(a,d.index)),h.length>0&&s.push(h),a=d.index+h.length}return a<o.length&&s.push(o.slice(a)),s}function createPattern(o,e=!0){if(o.Regex!==void 0){let s=o.Regex.replace(/\\([#&~])/g,"$1");for(const[a,d]of PROBLEMATIC_REGEX_MAP)s=s.replaceAll(a,d);return new RegExp(s,"gu")}else if(o.String!==void 0){const s=escapeRegExp(o.String);return new RegExp(e?s:`(${s})`,"gu")}else return console.warn("Unknown pattern type:",o),null}function objectToMap(o){return new Map(Object.entries(o))}function prepareTensorForDecode(o){const e=o.dims;switch(e.length){case 1:return o.tolist();case 2:if(e[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return o.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${e.length}.`)}}function clean_up_tokenization(o){return o.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function remove_accents(o){return o.replace(/[\u0300-\u036f]/g,"")}function lowercase_and_remove_accent(o){return remove_accents(o.toLowerCase())}function fuse(o,e,s){const a=[];let d=0;for(;d<o.length;){if(a.push(o[d]),(s.get(o[d])??e)!==e){++d;continue}for(;d<o.length&&(s.get(o[d])??e)===e;)++d}return a}function whitespace_split(o){return o.match(/\S+/g)||[]}const PUNCTUATION_REGEX="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",PROBLEMATIC_REGEX_MAP=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"]]);class AddedToken{constructor(e){this.content=e.content,this.id=e.id,this.single_word=e.single_word??!1,this.lstrip=e.lstrip??!1,this.rstrip=e.rstrip??!1,this.special=e.special??!1,this.normalized=e.normalized??null}}class TokenizerModel extends Callable{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(e,...s){switch(e.type){case"WordPiece":return new WordPieceTokenizer(e);case"Unigram":return new Unigram(e,...s);case"BPE":return new BPE(e);default:if(e.vocab)return new LegacyTokenizerModel(e,...s);throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){let s=this.encode(e);return this.fuse_unk&&(s=fuse(s,this.unk_token_id,this.tokens_to_ids)),s}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){return e.map(s=>this.tokens_to_ids.get(s)??this.unk_token_id)}convert_ids_to_tokens(e){return e.map(s=>this.vocab[s]??this.unk_token)}}class WordPieceTokenizer extends TokenizerModel{constructor(e){super(e),this.tokens_to_ids=objectToMap(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.max_input_chars_per_word=e.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[s,a]of this.tokens_to_ids)this.vocab[a]=s}encode(e){const s=[];for(const a of e){const d=[...a];if(d.length>this.max_input_chars_per_word){s.push(this.unk_token);continue}let h=!1,b=0;const et=[];for(;b<d.length;){let st=d.length,$=null;for(;b<st;){let it=d.slice(b,st).join("");if(b>0&&(it=this.config.continuing_subword_prefix+it),this.tokens_to_ids.has(it)){$=it;break}--st}if($===null){h=!0;break}et.push($),b=st}h?s.push(this.unk_token):s.push(...et)}return s}}class Unigram extends TokenizerModel{constructor(e,s){super(e);const a=e.vocab.length;this.vocab=new Array(a),this.scores=new Array(a);for(let d=0;d<a;++d){const h=e.vocab[d];this.vocab[d]=h[0],this.scores[d]=h[1]}this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map((d,h)=>[d,h])),this.bosToken=" ",this.bosTokenId=this.tokens_to_ids.get(this.bosToken),this.eosToken=s.eos_token,this.eosTokenId=this.tokens_to_ids.get(this.eosToken),this.unkToken=this.vocab[this.unk_token_id],this.minScore=min$1(this.scores)[0],this.unkScore=this.minScore-10,this.scores[this.unk_token_id]=this.unkScore,this.trie=new CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const s=e.sentence,a=s.length;let d=0;for(;d<a;){let b=!1;for(let et of this.trie.commonPrefixSearch(s.slice(d))){const st=this.tokens_to_ids.get(et),$=this.scores[st],it=et.length;e.insert(d,it,$,st),!b&&it===1&&(b=!0)}b||e.insert(d,1,this.unkScore,this.unk_token_id),d+=1}}tokenize(e){const s=new TokenLattice(e,this.bosTokenId,this.eosTokenId);return this.populateNodes(s),s.tokens()}encode(e){const s=[];for(const a of e){const d=this.tokenize(a);s.push(...d)}return s}}const BYTES_TO_UNICODE=(()=>{const o=[...Array.from({length:94},(d,h)=>h+33),...Array.from({length:12},(d,h)=>h+161),...Array.from({length:82},(d,h)=>h+174)],e=o.slice();let s=0;for(let d=0;d<256;++d)o.includes(d)||(o.push(d),e.push(256+s),s+=1);const a=e.map(d=>String.fromCharCode(d));return Object.fromEntries(o.map((d,h)=>[d,a[h]]))})(),UNICODE_TO_BYTES=reverseDictionary(BYTES_TO_UNICODE);class BPE extends TokenizerModel{constructor(e){super(e),this.BPE_SPLIT_TOKEN=" ",this.tokens_to_ids=objectToMap(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[s,a]of this.tokens_to_ids)this.vocab[a]=s;this.bpe_ranks=new Map(e.merges.map((s,a)=>[s,a])),this.merges=e.merges.map(s=>s.split(this.BPE_SPLIT_TOKEN)),this.end_of_word_suffix=e.end_of_word_suffix,this.continuing_subword_suffix=e.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(e){if(e.length===0)return[];const s=this.cache.get(e);if(s!==void 0)return s;const a=Array.from(e);this.end_of_word_suffix&&(a[a.length-1]+=this.end_of_word_suffix);let d=[];if(a.length>1){const h=new PriorityQueue((st,$)=>st.score<$.score);let b={token:a[0],bias:0,prev:null,next:null},et=b;for(let st=1;st<a.length;++st){const $={bias:st/a.length,token:a[st],prev:et,next:null};et.next=$,this._add_node(h,et),et=$}for(;!h.isEmpty();){const st=h.pop();if(st.deleted||!st.next||st.next.deleted)continue;if(st.deleted=!0,st.next.deleted=!0,st.prev){const it={...st.prev};st.prev.deleted=!0,st.prev=it,it.prev?it.prev.next=it:b=it}const $={token:st.token+st.next.token,bias:st.bias,prev:st.prev,next:st.next.next};$.prev?($.prev.next=$,this._add_node(h,$.prev)):b=$,$.next&&($.next.prev=$,this._add_node(h,$))}for(let st=b;st!==null;st=st.next)d.push(st.token)}else d=a;if(this.continuing_subword_suffix)for(let h=0;h<d.length-1;++h)d[h]+=this.continuing_subword_suffix;return this.cache.set(e,d),d}_add_node(e,s){const a=this.bpe_ranks.get(s.token+this.BPE_SPLIT_TOKEN+s.next.token);a!==void 0&&(s.score=a+s.bias,e.push(s))}encode(e){const s=[];for(const a of e){if(this.ignore_merges&&this.tokens_to_ids.has(a)){s.push(a);continue}const d=this.bpe(a);for(const h of d)this.tokens_to_ids.has(h)?s.push(h):this.byte_fallback?s.push(...Array.from(this.text_encoder.encode(h)).map(b=>`<0x${b.toString(16).toUpperCase().padStart(2,"0")}>`)):s.push(this.unk_token)}return s}}class LegacyTokenizerModel extends TokenizerModel{constructor(e,s){super(e),this.tokens_to_ids=objectToMap(s.target_lang?e.vocab[s.target_lang]:e.vocab),this.bos_token=s.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=s.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=s.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=s.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[a,d]of this.tokens_to_ids)this.vocab[d]=a}encode(e){return e}}class Normalizer extends Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(e===null)return null;switch(e.type){case"BertNormalizer":return new BertNormalizer(e);case"Precompiled":return new Precompiled(e);case"Sequence":return new NormalizerSequence(e);case"Replace":return new Replace(e);case"NFC":return new NFC(e);case"NFKC":return new NFKC(e);case"NFKD":return new NFKD(e);case"Strip":return new StripNormalizer(e);case"StripAccents":return new StripAccents(e);case"Lowercase":return new Lowercase(e);case"Prepend":return new Prepend(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class Replace extends Normalizer{normalize(e){const s=createPattern(this.config.pattern);return s===null?e:e.replaceAll(s,this.config.content)}}class NFC extends Normalizer{normalize(e){return e=e.normalize("NFC"),e}}class NFKC extends Normalizer{normalize(e){return e=e.normalize("NFKC"),e}}class NFKD extends Normalizer{normalize(e){return e=e.normalize("NFKD"),e}}class StripNormalizer extends Normalizer{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class StripAccents extends Normalizer{normalize(e){return e=remove_accents(e),e}}class Lowercase extends Normalizer{normalize(e){return e=e.toLowerCase(),e}}class Prepend extends Normalizer{normalize(e){return e=this.config.prepend+e,e}}class NormalizerSequence extends Normalizer{constructor(e){super(e),this.normalizers=e.normalizers.map(s=>Normalizer.fromConfig(s))}normalize(e){return this.normalizers.reduce((s,a)=>a.normalize(s),e)}}class BertNormalizer extends Normalizer{_tokenize_chinese_chars(e){const s=[];for(let a=0;a<e.length;++a){const d=e[a],h=d.charCodeAt(0);this._is_chinese_char(h)?(s.push(" "),s.push(d),s.push(" ")):s.push(d)}return s.join("")}_is_chinese_char(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}stripAccents(e){return e.normalize("NFD").replace(/[\u0300-\u036f]/g,"")}_is_control(e){switch(e){case"	":case`
`:case"\r":return!1;default:return/^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(e)}}_clean_text(e){const s=[];for(const a of e){const d=a.charCodeAt(0);d===0||d===65533||this._is_control(a)||(/^\s$/.test(a)?s.push(" "):s.push(a))}return s.join("")}normalize(e){return this.config.clean_text&&(e=this._clean_text(e)),this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),this.config.strip_accents!==!1&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class PreTokenizer extends Callable{static fromConfig(e){if(e===null)return null;switch(e.type){case"BertPreTokenizer":return new BertPreTokenizer(e);case"Sequence":return new PreTokenizerSequence(e);case"Whitespace":return new WhitespacePreTokenizer(e);case"WhitespaceSplit":return new WhitespaceSplit(e);case"Metaspace":return new MetaspacePreTokenizer(e);case"ByteLevel":return new ByteLevelPreTokenizer(e);case"Split":return new SplitPreTokenizer(e);case"Punctuation":return new PunctuationPreTokenizer(e);case"Digits":return new DigitsPreTokenizer(e);case"Replace":return new ReplacePreTokenizer(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e,s){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e,s){return(Array.isArray(e)?e.map(a=>this.pre_tokenize_text(a,s)):this.pre_tokenize_text(e,s)).flat()}_call(e,s){return this.pre_tokenize(e,s)}}class BertPreTokenizer extends PreTokenizer{constructor(e){super(),this.pattern=new RegExp(`[^\\s${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]`,"gu")}pre_tokenize_text(e,s){return e.trim().match(this.pattern)||[]}}class ByteLevelPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu,this.byte_encoder=BYTES_TO_UNICODE,this.text_encoder=new TextEncoder}pre_tokenize_text(e,s){return this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e),(this.use_regex?e.match(this.pattern)||[]:[e]).map(d=>Array.from(this.text_encoder.encode(d),h=>this.byte_encoder[h]).join(""))}}class SplitPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.pattern=createPattern(this.config.pattern,this.config.invert)}pre_tokenize_text(e,s){return this.pattern===null?[]:this.config.invert?e.match(this.pattern)||[]:regexSplit(e,this.pattern)}}class PunctuationPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]+`,"gu")}pre_tokenize_text(e,s){return e.match(this.pattern)||[]}}class DigitsPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e;const s=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(s,"gu")}pre_tokenize_text(e,s){return e.match(this.pattern)||[]}}class PostProcessor extends Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(e===null)return null;switch(e.type){case"TemplateProcessing":return new TemplateProcessing(e);case"ByteLevel":return new ByteLevelPostProcessor(e);case"RobertaProcessing":return new RobertaProcessing(e);case"BertProcessing":return new BertProcessing(e);case"Sequence":return new PostProcessorSequence(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...s){throw Error("post_process should be implemented in subclass.")}_call(e,...s){return this.post_process(e,...s)}}class BertProcessing extends PostProcessor{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,s=null,{add_special_tokens:a=!0}={}){a&&(e=mergeArrays([this.cls],e,[this.sep]));let d=new Array(e.length).fill(0);if(s!==null){const h=a&&this instanceof RobertaProcessing?[this.sep]:[],b=a?[this.sep]:[];e=mergeArrays(e,h,s,b),d=mergeArrays(d,new Array(s.length+h.length+b.length).fill(1))}return{tokens:e,token_type_ids:d}}}class RobertaProcessing extends BertProcessing{}class TemplateProcessing extends PostProcessor{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,s=null,{add_special_tokens:a=!0}={}){const d=s===null?this.single:this.pair;let h=[],b=[];for(const et of d)"SpecialToken"in et?a&&(h.push(et.SpecialToken.id),b.push(et.SpecialToken.type_id)):"Sequence"in et&&(et.Sequence.id==="A"?(h=mergeArrays(h,e),b=mergeArrays(b,new Array(e.length).fill(et.Sequence.type_id))):et.Sequence.id==="B"&&(h=mergeArrays(h,s),b=mergeArrays(b,new Array(s.length).fill(et.Sequence.type_id))));return{tokens:h,token_type_ids:b}}}class ByteLevelPostProcessor extends PostProcessor{post_process(e,s=null){return s&&(e=mergeArrays(e,s)),{tokens:e}}}class PostProcessorSequence extends PostProcessor{constructor(e){super(e),this.processors=e.processors.map(s=>PostProcessor.fromConfig(s))}post_process(e,s=null,a={}){let d;for(const h of this.processors)if(h instanceof ByteLevelPostProcessor)e=h.post_process(e).tokens,s&&(s=h.post_process(s).tokens);else{const b=h.post_process(e,s,a);e=b.tokens,d=b.token_type_ids}return{tokens:e,token_type_ids:d}}}class Decoder extends Callable{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){if(e===null)return null;switch(e.type){case"WordPiece":return new WordPieceDecoder(e);case"Metaspace":return new MetaspaceDecoder(e);case"ByteLevel":return new ByteLevelDecoder(e);case"Replace":return new ReplaceDecoder(e);case"ByteFallback":return new ByteFallback(e);case"Fuse":return new FuseDecoder(e);case"Strip":return new StripDecoder(e);case"Sequence":return new DecoderSequence(e);case"CTC":return new CTCDecoder(e);case"BPEDecoder":return new BPEDecoder(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class ReplaceDecoder extends Decoder{decode_chain(e){const s=createPattern(this.config.pattern);return s===null?e:e.map(a=>a.replaceAll(s,this.config.content))}}class ByteFallback extends Decoder{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){const s=[];let a=[];for(const d of e){let h=null;if(d.length===6&&d.startsWith("<0x")&&d.endsWith(">")){const b=parseInt(d.slice(3,5),16);isNaN(b)||(h=b)}if(h!==null)a.push(h);else{if(a.length>0){const b=this.text_decoder.decode(Uint8Array.from(a));s.push(b),a=[]}s.push(d)}}if(a.length>0){const d=this.text_decoder.decode(Uint8Array.from(a));s.push(d),a=[]}return s}}class FuseDecoder extends Decoder{decode_chain(e){return[e.join("")]}}class StripDecoder extends Decoder{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map(s=>{let a=0;for(let h=0;h<this.start&&s[h]===this.content;++h){a=h+1;continue}let d=s.length;for(let h=0;h<this.stop;++h){const b=s.length-h-1;if(s[b]===this.content){d=b;continue}else break}return s.slice(a,d)})}}class WordPieceDecoder extends Decoder{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map((s,a)=>(a!==0&&(s.startsWith(this.config.prefix)?s=s.replace(this.config.prefix,""):s=" "+s),this.cleanup&&(s=clean_up_tokenization(s)),s))}}class ByteLevelDecoder extends Decoder{constructor(e){super(e),this.byte_decoder=UNICODE_TO_BYTES,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){const s=e.join(""),a=new Uint8Array([...s].map(h=>this.byte_decoder[h]));return this.text_decoder.decode(a)}decode_chain(e){const s=[];let a=[];for(const d of e)this.added_tokens.find(h=>h.content===d)!==void 0?(a.length>0&&(s.push(this.convert_tokens_to_string(a)),a=[]),s.push(d)):a.push(d);return a.length>0&&s.push(this.convert_tokens_to_string(a)),s}}class CTCDecoder extends Decoder{constructor(e){super(e),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(e){if(e.length===0)return"";const s=[e[0]];for(let h=1;h<e.length;++h)e[h]!==s.at(-1)&&s.push(e[h]);let d=s.filter(h=>h!==this.pad_token).join("");return this.cleanup&&(d=clean_up_tokenization(d).replaceAll(this.word_delimiter_token," ").trim()),d}decode_chain(e){return[this.convert_tokens_to_string(e)]}}class DecoderSequence extends Decoder{constructor(e){super(e),this.decoders=e.decoders.map(s=>Decoder.fromConfig(s))}decode_chain(e){return this.decoders.reduce((s,a)=>a.decode_chain(s),e)}}class BPEDecoder extends Decoder{constructor(e){super(e),this.suffix=this.config.suffix}decode_chain(e){return e.map((s,a)=>s.replaceAll(this.suffix,a===e.length-1?"":" "))}}class VitsDecoder extends Decoder{decode_chain(e){let s="";for(let a=1;a<e.length;a+=2)s+=e[a];return[s]}}class MetaspacePreTokenizer extends PreTokenizer{constructor(e){super(),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement,this.prepend_scheme=e.prepend_scheme??"always"}pre_tokenize_text(e,{section_index:s=void 0}={}){let a=e.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!a.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&s===0)&&(a=this.strRep+a),[a]}}class MetaspaceDecoder extends Decoder{constructor(e){super(e),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement}decode_chain(e){const s=[];for(let a=0;a<e.length;++a){let d=e[a].replaceAll(this.replacement," ");this.addPrefixSpace&&a==0&&d.startsWith(" ")&&(d=d.substring(1)),s.push(d)}return s}}class Precompiled extends Normalizer{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){return e=e.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),e=e.replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm," "),e.includes("～")?e=e.split("～").map(a=>a.normalize("NFKC")).join("～"):e=e.normalize("NFKC"),e}}class PreTokenizerSequence extends PreTokenizer{constructor(e){super(),this.tokenizers=e.pretokenizers.map(s=>PreTokenizer.fromConfig(s))}pre_tokenize_text(e,s){return this.tokenizers.reduce((a,d)=>d.pre_tokenize(a,s),[e])}}class WhitespacePreTokenizer extends PreTokenizer{constructor(e){super()}pre_tokenize_text(e,s){return e.match(/\w+|[^\w\s]+/g)||[]}}class WhitespaceSplit extends PreTokenizer{constructor(e){super()}pre_tokenize_text(e,s){return whitespace_split(e)}}class ReplacePreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.pattern=createPattern(this.config.pattern),this.content=this.config.content}pre_tokenize_text(e,s){return this.pattern===null?[e]:[e.replaceAll(this.pattern,this.config.content)]}}const SPECIAL_TOKEN_ATTRIBUTES=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function padHelper(o,e,s,a){for(const d of Object.keys(o)){const h=e-o[d].length,b=s(d),et=new Array(h).fill(b);o[d]=a==="right"?mergeArrays(o[d],et):mergeArrays(et,o[d])}}function truncateHelper(o,e){for(const s of Object.keys(o))o[s].length=e}class PreTrainedTokenizer extends Callable{return_token_type_ids=!1;_default_chat_template=`{% for message in messages %}{{'<|im_start|>' + message['role'] + '
' + message['content'] + '<|im_end|>' + '
'}}{% endfor %}{% if add_generation_prompt %}{{ '<|im_start|>assistant
' }}{% endif %}`;constructor(e,s){super(),this._tokenizer_config=s,this.normalizer=Normalizer.fromConfig(e.normalizer),this.pre_tokenizer=PreTokenizer.fromConfig(e.pre_tokenizer),this.model=TokenizerModel.fromConfig(e.model,s),this.post_processor=PostProcessor.fromConfig(e.post_processor),this.decoder=Decoder.fromConfig(e.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const a of e.added_tokens){const d=new AddedToken(a);this.added_tokens.push(d),this.model.tokens_to_ids.set(d.content,d.id),this.model.vocab[d.id]=d.content,d.special&&(this.special_tokens.push(d.content),this.all_special_ids.push(d.id))}if(this.additional_special_tokens=s.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.map(a=>`${a.lstrip?"\\s*":""}(${escapeRegExp(a.content)})${a.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=s.model_max_length,this.remove_space=s.remove_space,this.clean_up_tokenization_spaces=s.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=s.do_lowercase_and_remove_accent??!1,this.padding_side="right",this.legacy=!1,this.chat_template=s.chat_template??null,Array.isArray(this.chat_template)){const a=Object.create(null);for(const{name:d,template:h}of this.chat_template){if(typeof d!="string"||typeof h!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');a[d]=h}this.chat_template=a}this._compiled_template_cache=new Map}getToken(...e){for(const s of e){const a=this._tokenizer_config[s];if(a)if(typeof a=="object"){if(a.__type==="AddedToken")return a.content;throw Error(`Unknown token: ${a}`)}else return a}return null}static async from_pretrained(e,{progress_callback:s=null,config:a=null,cache_dir:d=null,local_files_only:h=!1,revision:b="main",legacy:et=null}={}){const st=await loadTokenizer(e,{progress_callback:s,config:a,cache_dir:d,local_files_only:h,revision:b,legacy:et});return new this(...st)}_call(e,{text_pair:s=null,add_special_tokens:a=!0,padding:d=!1,truncation:h=null,max_length:b=null,return_tensor:et=!0,return_token_type_ids:st=null}={}){const $=Array.isArray(e);let it;if($){if(e.length===0)throw Error("text array must be non-empty");if(s!==null){if(Array.isArray(s)){if(e.length!==s.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");it=e.map((c,_)=>this._encode_plus(c,s[_],{add_special_tokens:a,return_token_type_ids:st}))}else it=e.map(c=>this._encode_plus(c,null,{add_special_tokens:a,return_token_type_ids:st}))}else{if(e==null)throw Error("text may not be null or undefined");if(Array.isArray(s))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");it=[this._encode_plus(e,s,{add_special_tokens:a,return_token_type_ids:st})]}if(b===null?d==="max_length"?b=this.model_max_length:b=max$1(it.map(c=>c.input_ids.length))[0]:h||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),b=Math.min(b,this.model_max_length),d||h)for(let c=0;c<it.length;++c)it[c].input_ids.length!==b&&(it[c].input_ids.length>b?h&&truncateHelper(it[c],b):d&&padHelper(it[c],b,_=>_==="input_ids"?this.pad_token_id:0,this.padding_side));const g={};if(et){if(!(d&&h)&&it.some(_=>{for(const ot of Object.keys(_))if(_[ot].length!==it[0][ot]?.length)return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const c=[it.length,it[0].input_ids.length];for(const _ of Object.keys(it[0]))g[_]=new Tensor("int64",BigInt64Array.from(it.flatMap(ot=>ot[_]).map(BigInt)),c)}else{for(const c of Object.keys(it[0]))g[c]=it.map(_=>_[c]);if(!$)for(const c of Object.keys(g))g[c]=g[c][0]}return g}_encode_text(e){return e===null?null:(this.added_tokens_regex?e.split(this.added_tokens_regex).filter(d=>d):[e]).map((d,h)=>{if(this.added_tokens.find(et=>et.content===d)!==void 0)return d;{if(this.remove_space===!0&&(d=d.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(d=lowercase_and_remove_accent(d)),this.normalizer!==null&&(d=this.normalizer(d)),d.length===0)return[];const et=this.pre_tokenizer!==null?this.pre_tokenizer(d,{section_index:h}):[d];return this.model(et)}}).flat()}_encode_plus(e,s=null,{add_special_tokens:a=!0,return_token_type_ids:d=null}={}){const h=this._encode_text(e),b=this._encode_text(s),et=this.post_processor?this.post_processor(h,b,{add_special_tokens:a}):{tokens:mergeArrays(h??[],b??[])},st=this.model.convert_tokens_to_ids(et.tokens),$={input_ids:st,attention_mask:new Array(st.length).fill(1)};return(d??this.return_token_type_ids)&&et.token_type_ids&&($.token_type_ids=et.token_type_ids),$}encode(e,s=null,{add_special_tokens:a=!0,return_token_type_ids:d=null}={}){const{input_ids:h}=this._encode_plus(e,s,{add_special_tokens:a,return_token_type_ids:d});return h}batch_decode(e,s={}){return e instanceof Tensor&&(e=e.tolist()),e.map(a=>this.decode(a,s))}decode(e,s={}){if(e instanceof Tensor&&(e=prepareTensorForDecode(e)),!Array.isArray(e)||e.length===0||!isIntegralNumber(e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(e,s)}decode_single(e,{skip_special_tokens:s=!1,clean_up_tokenization_spaces:a=null}){let d=this.model.convert_ids_to_tokens(e);s&&(d=d.filter(b=>!this.special_tokens.includes(b)));let h=this.decoder?this.decoder(d):d.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(h=h.replaceAll(this.decoder.end_of_word_suffix," "),s&&(h=h.trim())),(a??this.clean_up_tokenization_spaces)&&(h=clean_up_tokenization(h)),h}get default_chat_template(){return this._warned_about_chat_template||(console.warn("No chat template is defined for this tokenizer - using a default chat template that implements the ChatML format. If the default is not appropriate for your model, please set `tokenizer.chat_template` to an appropriate template. See https://huggingface.co/docs/transformers/main/chat_templating for more information."),this._warned_about_chat_template=!0),this._default_chat_template}apply_chat_template(e,{chat_template:s=null,add_generation_prompt:a=!1,tokenize:d=!0,padding:h=!1,truncation:b=!1,max_length:et=null,return_tensor:st=!0,tokenizer_kwargs:$={},...it}={}){if(this.chat_template&&typeof this.chat_template=="object"||this.chat_template===null&&this.default_chat_template&&typeof this.default_chat_template=="object"){const ot=this.chat_template??this.default_chat_template;if(s!==null&&Object.hasOwn(ot,s))s=ot[s];else if(s===null&&"default"in ot)s=ot.default;else if(s===null)throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(ot).sort()}.`)}else s??=this.chat_template??this.default_chat_template;if(typeof s!="string")throw Error(`chat_template must be a string, but got ${typeof s}`);let g=this._compiled_template_cache.get(s);g===void 0&&(g=new Template(s),this._compiled_template_cache.set(s,g));const c=Object.create(null);for(const ot of SPECIAL_TOKEN_ATTRIBUTES){const ct=this.getToken(ot);ct&&(c[ot]=ct)}const _=g.render({messages:e,add_generation_prompt:a,...c,...it});return d?this._call(_,{add_special_tokens:!1,padding:h,truncation:b,max_length:et,return_tensor:st,...$}).input_ids:_}}class BertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class AlbertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class MobileBertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class SqueezeBertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class DebertaTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class DebertaV2Tokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class HerbertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class ConvBertTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class RoFormerTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class DistilBertTokenizer extends PreTrainedTokenizer{}class CamembertTokenizer extends PreTrainedTokenizer{}class XLMTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0;constructor(e,s){super(e,s),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class ElectraTokenizer extends PreTrainedTokenizer{return_token_type_ids=!0}class T5Tokenizer extends PreTrainedTokenizer{}class GPT2Tokenizer extends PreTrainedTokenizer{_default_chat_template='{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}'}class BartTokenizer extends PreTrainedTokenizer{}class MBartTokenizer extends PreTrainedTokenizer{constructor(e,s){super(e,s),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(a=>this.languageRegex.test(a)),this.lang_to_token=a=>a}_build_translation_inputs(e,s,a){return _build_translation_inputs(this,e,s,a)}}class MBart50Tokenizer extends MBartTokenizer{}class RobertaTokenizer extends PreTrainedTokenizer{}class BloomTokenizer extends GPT2Tokenizer{constructor(e,s){const a=".,!?…。，、।۔،",d=e.pre_tokenizer?.pretokenizers[0]?.pattern;d&&d.Regex===` ?[^(\\s|[${a}])]+`&&(d.Regex=` ?[^\\s${a}]+`),super(e,s)}}const SPIECE_UNDERLINE="▁";class LlamaTokenizer extends PreTrainedTokenizer{_default_chat_template=`{% if messages[0]['role'] == 'system' %}{% set loop_messages = messages[1:] %}{% set system_message = messages[0]['content'] %}{% elif USE_DEFAULT_PROMPT == true and not '<<SYS>>' in messages[0]['content'] %}{% set loop_messages = messages %}{% set system_message = 'DEFAULT_SYSTEM_MESSAGE' %}{% else %}{% set loop_messages = messages %}{% set system_message = false %}{% endif %}{% for message in loop_messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if loop.index0 == 0 and system_message != false %}{% set content = '<<SYS>>
' + system_message + '
<</SYS>>

' + message['content'] %}{% else %}{% set content = message['content'] %}{% endif %}{% if message['role'] == 'user' %}{{ bos_token + '[INST] ' + content.strip() + ' [/INST]' }}{% elif message['role'] == 'system' %}{{ '<<SYS>>
' + content.strip() + '
<</SYS>>

' }}{% elif message['role'] == 'assistant' %}{{ ' '  + content.strip() + ' ' + eos_token }}{% endif %}{% endfor %}`;DEFAULT_SYSTEM_PROMPT=`You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.

If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.`;constructor(e,s){super(e,s),this.use_default_system_prompt=s.use_default_system_prompt??!1,this.legacy=s.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new MetaspacePreTokenizer({replacement:SPIECE_UNDERLINE,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(e){if(e===null)return null;if(this.legacy||e.length===0)return super._encode_text(e);let s=super._encode_text(SPIECE_UNDERLINE+e.replaceAll(SPIECE_UNDERLINE," "));return s.length>1&&s[0]===SPIECE_UNDERLINE&&this.special_tokens.includes(s[1])&&(s=s.slice(1)),s}get default_chat_template(){return super.default_chat_template.replaceAll("USE_DEFAULT_PROMPT",this.use_default_system_prompt?"true":"false").replaceAll("DEFAULT_SYSTEM_MESSAGE",this.DEFAULT_SYSTEM_PROMPT.replaceAll(`
`,"\\n").replaceAll("'","\\'"))}}class CodeLlamaTokenizer extends LlamaTokenizer{}class XLMRobertaTokenizer extends PreTrainedTokenizer{}class MPNetTokenizer extends PreTrainedTokenizer{}class FalconTokenizer extends PreTrainedTokenizer{}class GPTNeoXTokenizer extends PreTrainedTokenizer{}class EsmTokenizer extends PreTrainedTokenizer{}class Qwen2Tokenizer extends PreTrainedTokenizer{}class GemmaTokenizer extends PreTrainedTokenizer{_default_chat_template=`{% if messages[0]['role'] == 'system' %}{{ raise_exception('System role not supported') }}{% endif %}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if (message['role'] == 'assistant') %}{% set role = 'model' %}{% else %}{% set role = message['role'] %}{% endif %}{{ '<start_of_turn>' + role + '
' + message['content'] | trim + '<end_of_turn>
' }}{% endfor %}{% if add_generation_prompt %}{{'<start_of_turn>model
'}}{% endif %}`}class Grok1Tokenizer extends PreTrainedTokenizer{}function _build_translation_inputs(o,e,s,a){if(!("language_codes"in o)||!Array.isArray(o.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in o)||!(o.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in o)||typeof o.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const d=a.src_lang,h=a.tgt_lang;if(!o.language_codes.includes(h))throw new Error(`Target language code "${h}" is not valid. Must be one of: {${o.language_codes.join(", ")}}`);if(d!==void 0){if(!o.language_codes.includes(d))throw new Error(`Source language code "${d}" is not valid. Must be one of: {${o.language_codes.join(", ")}}`);for(const b of o.post_processor.config.single)if("SpecialToken"in b&&o.languageRegex.test(b.SpecialToken.id)){b.SpecialToken.id=o.lang_to_token(d);break}}return a.forced_bos_token_id=o.model.convert_tokens_to_ids([o.lang_to_token(h)])[0],o._call(e,s)}class NllbTokenizer extends PreTrainedTokenizer{constructor(e,s){super(e,s),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(a=>this.languageRegex.test(a)),this.lang_to_token=a=>a}_build_translation_inputs(e,s,a){return _build_translation_inputs(this,e,s,a)}}class M2M100Tokenizer extends PreTrainedTokenizer{constructor(e,s){super(e,s),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(a=>this.languageRegex.test(a)).map(a=>a.slice(2,-2)),this.lang_to_token=a=>`__${a}__`}_build_translation_inputs(e,s,a){return _build_translation_inputs(this,e,s,a)}}const WHISPER_LANGUAGES=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],WHISPER_LANGUAGE_MAPPING=new Map(WHISPER_LANGUAGES),WHISPER_TO_LANGUAGE_CODE_MAPPING=new Map([...WHISPER_LANGUAGES.map(([o,e])=>[e,o]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);class WhisperTokenizer extends PreTrainedTokenizer{_default_chat_template='{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}';_decode_asr(e,{return_timestamps:s=!1,return_language:a=!1,time_precision:d=null,force_full_sequences:h=!0}={}){if(d===null)throw Error("Must specify time_precision");let b=null;const et=s==="word";function st(){return{language:b,timestamp:[null,null],text:""}}const $=[];let it=st(),g=0;const c=this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1;let _=[],ot=[],ct=!1,dt=null;const pt=new Set(this.all_special_ids);for(const bt of e){const mt=bt.tokens,$t=et?bt.token_timestamps:null;let Tt=null,Nt=c;if("stride"in bt){const[ln,mn,yn]=bt.stride;if(g-=mn,dt=ln-yn,mn&&(Nt=mn/d+c),yn)for(let pn=mt.length-1;pn>=0;--pn){const Ht=mt[pn];if(Ht>=c){if(Tt!==null&&(Ht-c)*d<dt)break;Tt=Ht}}}let Ct=[],Ft=[];for(let ln=0;ln<mt.length;++ln){const mn=mt[ln];if(pt.has(mn)){const yn=this.decode([mn]),pn=WHISPER_LANGUAGE_MAPPING.get(yn.slice(2,-2));if(pn!==void 0){if(b!==null&&pn!==b&&!s){_.push(Ct);const Ht=this.findLongestCommonSequence(_)[0],Gt=this.decode(Ht);it.text=Gt,$.push(it),_=[],Ct=[],it=st()}b=it.language=pn}}else if(mn>=c){const yn=(mn-c)*d+g,pn=round$1(yn,2);if(Tt!==null&&mn>=Tt)ct=!0;else if(ct||_.length>0&&mn<Nt)ct=!1;else if(it.timestamp[0]===null)it.timestamp[0]=pn;else if(pn!==it.timestamp[0]){it.timestamp[1]=pn,_.push(Ct),et&&ot.push(Ft);const[Ht,Gt]=this.findLongestCommonSequence(_,ot),cn=this.decode(Ht);it.text=cn,et&&(it.words=this.collateWordTimestamps(Ht,Gt,b)),$.push(it),_=[],Ct=[],ot=[],Ft=[],it=st()}}else if(Ct.push(mn),et){let yn=round$1($t[ln]+g,2),pn;ln+1<$t.length?pn=round$1($t[ln+1]+g,2):pn=null,Ft.push([yn,pn])}}if("stride"in bt){const[ln,mn,yn]=bt.stride;g+=ln-yn}Ct.length>0?(_.push(Ct),et&&ot.push(Ft)):_.every(ln=>ln.length===0)&&(it=st(),_=[],Ct=[],ot=[],Ft=[])}if(_.length>0){if(h&&s)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[bt,mt]=this.findLongestCommonSequence(_,ot),$t=this.decode(bt);it.text=$t,et&&(it.words=this.collateWordTimestamps(bt,mt,b)),$.push(it)}let ft=Object.create(null);const ht=$.map(bt=>bt.text).join("");if(s||a){for(let bt=0;bt<$.length;++bt){const mt=$[bt];s||delete mt.timestamp,a||delete mt.language}if(et){const bt=[];for(const mt of $)for(const $t of mt.words)bt.push($t);ft={chunks:bt}}else ft={chunks:$}}return[ht,ft]}findLongestCommonSequence(e,s=null){let a=e[0],d=a.length,h=[];const b=Array.isArray(s)&&s.length>0;let et=b?[]:null,st=b?s[0]:null;for(let $=1;$<e.length;++$){const it=e[$];let g=0,c=[d,d,0,0];const _=it.length;for(let bt=1;bt<d+_;++bt){const mt=bt/1e4,$t=Math.max(0,d-bt),Tt=Math.min(d,d+_-bt),Nt=a.slice($t,Tt),Ct=Math.max(0,bt-d),Ft=Math.min(_,bt),ln=it.slice(Ct,Ft);if(Nt.length!==ln.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");const mn=Nt.filter((pn,Ht)=>pn===ln[Ht]).length,yn=mn/bt+mt;mn>1&&yn>g&&(g=yn,c=[$t,Tt,Ct,Ft])}const[ot,ct,dt,pt]=c,ft=Math.floor((ct+ot)/2),ht=Math.floor((pt+dt)/2);h.push(...a.slice(0,ft)),a=it.slice(ht),d=a.length,b&&(et.push(...st.slice(0,ft)),st=s[$].slice(ht))}return h.push(...a),b?(et.push(...st),[h,et]):[h,[]]}collateWordTimestamps(e,s,a){const[d,h,b]=this.combineTokensIntoWords(e,a),et=[];for(let st=0;st<d.length;++st){const $=b[st];et.push({text:d[st],timestamp:[s[$.at(0)][0],s[$.at(-1)][1]]})}return et}combineTokensIntoWords(e,s,a=`"'“¡¿([{-`,d=`"'.。,，!！?？:：”)]}、`){s=s??"english";let h,b,et;return["chinese","japanese","thai","lao","myanmar"].includes(s)?[h,b,et]=this.splitTokensOnUnicode(e):[h,b,et]=this.splitTokensOnSpaces(e),this.mergePunctuations(h,b,et,a,d)}decode(e,s){let a;return s&&s.decode_with_timestamps?(e instanceof Tensor&&(e=prepareTensorForDecode(e)),a=this.decodeWithTimestamps(e,s)):a=super.decode(e,s),a}decodeWithTimestamps(e,s){const a=s?.time_precision??.02,d=Array.from(this.all_special_ids).at(-1)+1;let h=[[]];for(const b of e)if(b>=d){const et=round$1((b-d)*a,2);h.push(`<|${et}|>`),h.push([])}else h[h.length-1].push(b);return h=h.map(b=>typeof b=="string"?b:super.decode(b,s)),h.join("")}splitTokensOnUnicode(e){const s=this.decode(e,{decode_with_timestamps:!0}),a="�",d=[],h=[],b=[];let et=[],st=[],$=0;for(let it=0;it<e.length;++it){const g=e[it];et.push(g),st.push(it);const c=this.decode(et,{decode_with_timestamps:!0});(!c.includes(a)||s[$+c.indexOf(a)]===a)&&(d.push(c),h.push(et),b.push(st),et=[],st=[],$+=c.length)}return[d,h,b]}splitTokensOnSpaces(e){const[s,a,d]=this.splitTokensOnUnicode(e),h=[],b=[],et=[],st=new RegExp(`^[${PUNCTUATION_REGEX}]$`,"gu");for(let $=0;$<s.length;++$){const it=s[$],g=a[$],c=d[$],_=g[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),ot=it.startsWith(" "),ct=it.trim(),dt=st.test(ct);if(_||ot||dt||h.length===0)h.push(it),b.push(g),et.push(c);else{const pt=h.length-1;h[pt]+=it,b[pt].push(...g),et[pt].push(...c)}}return[h,b,et]}mergePunctuations(e,s,a,d,h){const b=structuredClone(e),et=structuredClone(s),st=structuredClone(a);let $=b.length-2,it=b.length-1;for(;$>=0;)b[$].startsWith(" ")&&d.includes(b[$].trim())?(b[it]=b[$]+b[it],et[it]=mergeArrays(et[$],et[it]),st[it]=mergeArrays(st[$],st[it]),b[$]="",et[$]=[],st[$]=[]):it=$,--$;for($=0,it=1;it<b.length;)!b[$].endsWith(" ")&&h.includes(b[it])?(b[$]+=b[it],et[$]=mergeArrays(et[$],et[it]),st[$]=mergeArrays(st[$],st[it]),b[it]="",et[it]=[],st[it]=[]):$=it,++it;return[b.filter(g=>g),et.filter(g=>g.length>0),st.filter(g=>g.length>0)]}get_decoder_prompt_ids({language:e=null,task:s=null,no_timestamps:a=!0}={}){const d=[];if(e){e=e.toLowerCase();let h=WHISPER_TO_LANGUAGE_CODE_MAPPING.get(e);if(h===void 0)if(WHISPER_LANGUAGE_MAPPING.has(e))h=e;else{const st=e.length===2?WHISPER_LANGUAGE_MAPPING.keys():WHISPER_LANGUAGE_MAPPING.values();throw new Error(`Language "${e}" is not supported. Must be one of: ${JSON.stringify(st)}`)}const b=this.model.tokens_to_ids.get(`<|${h}|>`);if(b===void 0)throw new Error(`Unable to find language "${h}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);d.push(b)}else d.push(null);if(s){if(s=s.toLowerCase(),s!=="transcribe"&&s!=="translate")throw new Error(`Task "${s}" is not supported. Must be one of: ["transcribe", "translate"]`);const h=this.model.tokens_to_ids.get(`<|${s}|>`);if(h===void 0)throw new Error(`Unable to find task "${s}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);d.push(h)}else d.push(null);if(a){const h=this.model.tokens_to_ids.get("<|notimestamps|>");if(h===void 0)throw new Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.');d.push(h)}return d.map((h,b)=>[b+1,h]).filter(h=>h[1]!==null)}}class CodeGenTokenizer extends PreTrainedTokenizer{}class CLIPTokenizer extends PreTrainedTokenizer{}class SiglipTokenizer extends PreTrainedTokenizer{}class MarianTokenizer extends PreTrainedTokenizer{constructor(e,s){super(e,s),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(a=>this.languageRegex.test(a)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(e){if(e===null)return null;const[s,...a]=e.trim().split(this.languageRegex);if(a.length===0)return super._encode_text(s);if(a.length===2){const[d,h]=a;return this.supported_language_codes.includes(d)||console.warn(`Unsupported language code "${d}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),mergeArrays([d],super._encode_text(h))}}}class Wav2Vec2CTCTokenizer extends PreTrainedTokenizer{}class BlenderbotTokenizer extends PreTrainedTokenizer{_default_chat_template="{% for message in messages %}{% if message['role'] == 'user' %}{{ ' ' }}{% endif %}{{ message['content'] }}{% if not loop.last %}{{ '  ' }}{% endif %}{% endfor %}{{ eos_token }}"}class BlenderbotSmallTokenizer extends BlenderbotTokenizer{}class SpeechT5Tokenizer extends PreTrainedTokenizer{}class NougatTokenizer extends PreTrainedTokenizer{}class VitsTokenizer extends PreTrainedTokenizer{constructor(e,s){super(e,s),this.decoder=new VitsDecoder({})}}class CohereTokenizer extends PreTrainedTokenizer{}class AutoTokenizer{static TOKENIZER_CLASS_MAPPING={T5Tokenizer,DistilBertTokenizer,CamembertTokenizer,DebertaTokenizer,DebertaV2Tokenizer,BertTokenizer,HerbertTokenizer,ConvBertTokenizer,RoFormerTokenizer,XLMTokenizer,ElectraTokenizer,MobileBertTokenizer,SqueezeBertTokenizer,AlbertTokenizer,GPT2Tokenizer,BartTokenizer,MBartTokenizer,MBart50Tokenizer,RobertaTokenizer,WhisperTokenizer,CodeGenTokenizer,CLIPTokenizer,SiglipTokenizer,MarianTokenizer,BloomTokenizer,NllbTokenizer,M2M100Tokenizer,LlamaTokenizer,CodeLlamaTokenizer,XLMRobertaTokenizer,MPNetTokenizer,FalconTokenizer,GPTNeoXTokenizer,EsmTokenizer,Wav2Vec2CTCTokenizer,BlenderbotTokenizer,BlenderbotSmallTokenizer,SpeechT5Tokenizer,NougatTokenizer,VitsTokenizer,Qwen2Tokenizer,GemmaTokenizer,Grok1Tokenizer,CohereTokenizer,PreTrainedTokenizer};static async from_pretrained(e,{quantized:s=!0,progress_callback:a=null,config:d=null,cache_dir:h=null,local_files_only:b=!1,revision:et="main",legacy:st=null}={}){const[$,it]=await loadTokenizer(e,{quantized:s,progress_callback:a,config:d,cache_dir:h,local_files_only:b,revision:et,legacy:st}),g=it.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let c=this.TOKENIZER_CLASS_MAPPING[g];return c||(console.warn(`Unknown tokenizer class "${g}", attempting to construct from base class.`),c=PreTrainedTokenizer),new c($,it)}}async function loadConfig(o,e){return await getModelJSON(o,"config.json",!0,e)}class PretrainedConfig{constructor(e){this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,e)}static async from_pretrained(e,{progress_callback:s=null,config:a=null,cache_dir:d=null,local_files_only:h=!1,revision:b="main"}={}){let et=a??await loadConfig(e,{progress_callback:s,config:a,cache_dir:d,local_files_only:h,revision:b});return new this(et)}}class AutoConfig{static async from_pretrained(...e){return PretrainedConfig.from_pretrained(...e)}}class LogitsProcessorList extends Callable{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,s){for(let a of s)this.processors.forEach(d=>d(e,a))}[Symbol.iterator](){return this.processors.values()}}class LogitsProcessor extends Callable{_call(e,s){throw Error("`_call` should be implemented in a subclass")}}class ForceTokensLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.force_token_map=Object.fromEntries(e??[])}_call(e,s){let a=this.force_token_map[e.length];return exists(a)&&(s.data.fill(-1/0),s.data[a]=0),s}}class ForcedBOSTokenLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.bos_token_id=e}_call(e,s){return e.length===1&&(s.data.fill(-1/0),s.data[this.bos_token_id]=0),s}}class ForcedEOSTokenLogitsProcessor extends LogitsProcessor{constructor(e,s){super(),this.max_length=e,this.forced_eos_token_id=s}_call(e,s){}}class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor{constructor(e,s){super(),this.begin_suppress_tokens=e,this.begin_index=s}_call(e,s){if(e.length===this.begin_index)for(let a of this.begin_suppress_tokens)s.data[a]=-1/0;return s}}class WhisperTimeStampLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.eos_token_id=e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=(e.forced_decoder_ids||[]).length+2,e.forced_decoder_ids.slice(-1)[0][1]===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,s){const a=s.data;if(a[this.no_timestamps_token_id]=-1/0,e.length===this.begin_index-1)return a.fill(-1/0),a[this.timestamp_begin]=0,s;const d=e.slice(this.begin_index),h=d.length>=1&&d[d.length-1]>=this.timestamp_begin,b=d.length<2||d[d.length-2]>=this.timestamp_begin;if(h&&(b?a.subarray(this.timestamp_begin).fill(-1/0):a.subarray(0,this.eos_token_id).fill(-1/0)),e.length===this.begin_index&&this.max_initial_timestamp_index!==null){const it=this.timestamp_begin+this.max_initial_timestamp_index;a.subarray(it+1).fill(-1/0)}const et=log_softmax(a),st=Math.log(et.subarray(this.timestamp_begin).map(Math.exp).reduce((it,g)=>it+g)),$=max$1(et.subarray(0,this.timestamp_begin))[0];return st>$&&a.subarray(0,this.timestamp_begin).fill(-1/0),s}}class NoRepeatNGramLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const s=e.length,a=[];for(let h=0;h<s+1-this.no_repeat_ngram_size;++h){const b=[];for(let et=0;et<this.no_repeat_ngram_size;++et)b.push(e[h+et]);a.push(b)}const d=new Map;for(const h of a){const b=h.slice(0,h.length-1),et=JSON.stringify(b),st=d.get(et)??[];st.push(h[h.length-1]),d.set(et,st)}return d}getGeneratedNgrams(e,s){const a=s.slice(s.length+1-this.no_repeat_ngram_size,s.length);return e.get(JSON.stringify(a))??[]}calcBannedNgramTokens(e){const s=[];if(e.length+1<this.no_repeat_ngram_size)return s;{const a=this.getNgrams(e);return this.getGeneratedNgrams(a,e)}}_call(e,s){const a=this.calcBannedNgramTokens(e);for(const d of a)s.data[d]=-1/0;return s}}class RepetitionPenaltyLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.penalty=e}_call(e,s){for(const a of e)s.data[a]<0?s.data[a]*=this.penalty:s.data[a]/=this.penalty;return s}}class MinLengthLogitsProcessor extends LogitsProcessor{constructor(e,s){super(),this.min_length=e,this.eos_token_id=Array.isArray(s)?s:[s]}_call(e,s){if(e.length<this.min_length)for(const a of this.eos_token_id)s.data[a]=-1/0;return s}}class MinNewTokensLengthLogitsProcessor extends LogitsProcessor{constructor(e,s,a){super(),this.prompt_length_to_skip=e,this.min_new_tokens=s,this.eos_token_id=Array.isArray(a)?a:[a]}_call(e,s){if(e.length-this.prompt_length_to_skip<this.min_new_tokens)for(const d of this.eos_token_id)s.data[d]=-1/0;return s}}class NoBadWordsLogitsProcessor extends LogitsProcessor{constructor(e,s){super(),this.bad_words_ids=e,this.eos_token_id=Array.isArray(s)?s:[s]}_call(e,s){for(const a of this.bad_words_ids){let d=!0;for(let h=1;h<=a.length-1&&a.length<e.length;++h)if(a.at(-h-1)!==e.at(-h)){d=!1;break}d&&(s.data[a.at(-1)]=-1/0)}return s}}const GenerationConfig=class{constructor(o={}){this.max_length=o.max_length??20,this.max_new_tokens=o.max_new_tokens??null,this.min_length=o.min_length??0,this.min_new_tokens=o.min_new_tokens??null,this.early_stopping=o.early_stopping??!1,this.max_time=o.max_time??null,this.do_sample=o.do_sample??!1,this.num_beams=o.num_beams??1,this.num_beam_groups=o.num_beam_groups??1,this.penalty_alpha=o.penalty_alpha??null,this.use_cache=o.use_cache??!0,this.temperature=o.temperature??1,this.top_k=o.top_k??50,this.top_p=o.top_p??1,this.typical_p=o.typical_p??1,this.epsilon_cutoff=o.epsilon_cutoff??0,this.eta_cutoff=o.eta_cutoff??0,this.diversity_penalty=o.diversity_penalty??0,this.repetition_penalty=o.repetition_penalty??1,this.encoder_repetition_penalty=o.encoder_repetition_penalty??1,this.length_penalty=o.length_penalty??1,this.no_repeat_ngram_size=o.no_repeat_ngram_size??0,this.bad_words_ids=o.bad_words_ids??null,this.force_words_ids=o.force_words_ids??null,this.renormalize_logits=o.renormalize_logits??!1,this.constraints=o.constraints??null,this.forced_bos_token_id=o.forced_bos_token_id??null,this.forced_eos_token_id=o.forced_eos_token_id??null,this.remove_invalid_values=o.remove_invalid_values??!1,this.exponential_decay_length_penalty=o.exponential_decay_length_penalty??null,this.suppress_tokens=o.suppress_tokens??null,this.begin_suppress_tokens=o.begin_suppress_tokens??null,this.forced_decoder_ids=o.forced_decoder_ids??null,this.num_return_sequences=o.num_return_sequences??1,this.output_attentions=o.output_attentions??!1,this.output_hidden_states=o.output_hidden_states??!1,this.output_scores=o.output_scores??!1,this.return_dict_in_generate=o.return_dict_in_generate??!1,this.pad_token_id=o.pad_token_id??null,this.bos_token_id=o.bos_token_id??null,this.eos_token_id=o.eos_token_id??null,this.encoder_no_repeat_ngram_size=o.encoder_no_repeat_ngram_size??0,this.decoder_start_token_id=o.decoder_start_token_id??null,this.generation_kwargs=o.generation_kwargs??{}}};class Sampler extends Callable{constructor(e){super(),this.generation_config=e}_call(e,s=-1){return this.sample(e,s)}sample(e,s){throw Error("sample should be implemented in subclasses.")}getLogits(e,s){let a=e.dims.at(-1),d=e.data;if(s===-1)d=d.slice(-a);else{let h=s*a;d=d.slice(h,h+a)}return this.generation_config.temperature>0&&(d=d.map(h=>h/this.generation_config.temperature)),d}randomSelect(e){let s=e.reduce((d,h)=>d+h,0),a=Math.random()*s;for(let d=0;d<e.length;++d)if(a-=e[d],a<=0)return d;return 0}static getSampler(e){if(e.do_sample)return new MultinomialSampler(e);if(e.num_beams>1)return new BeamSearchSampler(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new GreedySampler(e)}}class GreedySampler extends Sampler{sample(e,s=-1){let a=this.getLogits(e,s);return[[max$1(a)[1],0]]}}class MultinomialSampler extends Sampler{sample(e,s=-1){let a=e.dims.at(-1);this.generation_config.top_k>0&&(a=Math.min(this.generation_config.top_k,a));const d=this.getLogits(e,s),h=getTopItems(d,a),b=softmax(h.map(et=>et[1]));return Array.from({length:this.generation_config.num_beams},()=>{const et=this.randomSelect(b);return[h[et][0],Math.log(b[et])]})}}class BeamSearchSampler extends Sampler{sample(e,s=-1){let a=e.dims.at(-1);this.generation_config.top_k>0&&(a=Math.min(this.generation_config.top_k,a));const d=this.getLogits(e,s),h=getTopItems(d,a),b=softmax(h.map(et=>et[1]));return Array.from({length:this.generation_config.num_beams},(et,st)=>[h[st][0],Math.log(b[st])])}}const{InferenceSession,Tensor:ONNXTensor,env}=ONNX,MODEL_TYPES={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5},MODEL_TYPE_MAPPING=new Map,MODEL_NAME_TO_CLASS_MAPPING=new Map,MODEL_CLASS_TO_NAME_MAPPING=new Map;async function constructSession(o,e,s){let a=`onnx/${e}${s.quantized?"_quantized":""}.onnx`,d=await getModelFile(o,a,!0,s);try{return await InferenceSession.create(d,{executionProviders})}catch(h){if(executionProviders.length===1&&executionProviders[0]==="wasm")throw h;return console.warn(h),console.warn("Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "),await InferenceSession.create(d,{executionProviders:["wasm"]})}}function validateInputs(o,e){const s=Object.create(null),a=[];for(const b of o.inputNames){const et=e[b];if(!(et instanceof Tensor)){a.push(b);continue}s[b]=env.wasm.proxy?et.clone():et}if(a.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${a.join(", ")}.`);const d=Object.keys(e).length,h=o.inputNames.length;if(d>h){let b=Object.keys(e).filter(et=>!o.inputNames.includes(et));console.warn(`WARNING: Too many inputs were provided (${d} > ${h}). The following inputs will be ignored: "${b.join(", ")}".`)}return s}async function sessionRun(o,e){const s=validateInputs(o,e);try{let a=await o.run(s);return a=replaceTensors(a),a}catch(a){throw console.error(`An error occurred during model execution: "${a}".`),console.error("Inputs given to model:",s),a}}function replaceTensors(o){for(let e in o)o[e]instanceof ONNXTensor?o[e]=new Tensor(o[e]):typeof o[e]=="object"&&replaceTensors(o[e]);return o}function toI64Tensor(o){if(o instanceof Tensor)return o;if(o.length===0)throw Error("items must be non-empty");if(Array.isArray(o[0])){if(o.some(e=>e.length!==o[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new Tensor("int64",BigInt64Array.from(o.flat().map(e=>BigInt(e))),[o.length,o[0].length])}else return new Tensor("int64",BigInt64Array.from(o.map(e=>BigInt(e))),[1,o.length])}function prepareAttentionMask(o,e){let s=o.config.pad_token_id??null,a=o.config.eos_token_id??null;isIntegralNumber(a)&&(a=[a]);let d=e.indexOf(s)!==-1,h=a===null||!a.includes(s);if(d&&h){let b=BigInt64Array.from(e.data.map(et=>et!=s));return new Tensor("int64",b,e.dims)}else return ones_like(e)}function preparePositionIds(o,e,s){if(!o.inputNames.includes("position_ids"))return;const a=new BigInt64Array(e.attention_mask.data.length);for(let d=0;d<e.attention_mask.dims[0];++d){let h=d*e.attention_mask.dims[1],b=BigInt(0);for(let et=0;et<e.attention_mask.dims[1];++et){const st=h+et;e.attention_mask.data[st]===0n?a[st]=BigInt(1):(a[st]=b,b+=e.attention_mask.data[st])}}e.position_ids=new Tensor("int64",a,e.attention_mask.dims),s&&(e.position_ids=e.position_ids.slice(null,-1).unsqueeze_(-1))}function boolTensor(o){return new Tensor("bool",[o],[1])}async function seq2seqForward(o,e){let{encoder_outputs:s,past_key_values:a}=e;s||(s=(await encoderForward(o,e)).last_hidden_state);let d={input_ids:e.decoder_input_ids,encoder_hidden_states:s};const h=!!a;o.decoder_merged_session.inputNames.includes("use_cache_branch")&&(d.use_cache_branch=boolTensor(h)),o.decoder_merged_session.inputNames.includes("encoder_attention_mask")&&(d.encoder_attention_mask=e.attention_mask),preparePositionIds(o.decoder_merged_session,d,h),o.addPastKeyValues(d,a);const b=await sessionRun(o.decoder_merged_session,d);let et=b.logits;a=o.getPastKeyValues(b,a);const st=o.getAttentions(b);return new Seq2SeqLMOutput({logits:et,past_key_values:a,encoder_outputs:s,...st})}function seq2seqStartBeams(o,e,s,a){let d=[],h=0;const b=o.requires_attention_mask??!0;let et=s.decoder_input_ids??s.decoder_start_token_id??s.bos_token_id??s.eos_token_id;et instanceof Tensor?et=et.tolist().flat():Array.isArray(et)||(et=[et]);for(let st of e){st.dims=[1,...st.dims];let $={inputs:st,encoder_outputs:null,prev_model_outputs:null,output_token_ids:et,done:!1,score:0,id:h++};b&&($.attention_mask=prepareAttentionMask(o,st)),d.push($)}return d}async function seq2seqRunBeam(o,e){const s=o.main_input_name;let a=e.output_token_ids;e.prev_model_outputs&&(a=a.slice(-1));let d={[s]:e.inputs,decoder_input_ids:toI64Tensor(a),encoder_outputs:e.encoder_outputs,past_key_values:e.prev_model_outputs?.past_key_values};e.attention_mask&&(d.attention_mask=e.attention_mask);let h=await o.forward(d);return e.prev_model_outputs=h,e.encoder_outputs=h.encoder_outputs,h}function seq2seqUpdatebeam(o,e){o.output_token_ids=[...o.output_token_ids,e]}async function encoderForward(o,e){const s=Object.create(null);for(const a of o.session.inputNames)s[a]=e[a];return o.session.inputNames.includes("token_type_ids")&&!s.token_type_ids&&(s.token_type_ids=new Tensor("int64",new BigInt64Array(s.input_ids.data.length),s.input_ids.dims)),await sessionRun(o.session,s)}async function decoderForward(o,e){let{input_ids:s,past_key_values:a,attention_mask:d}=e,h={input_ids:s,attention_mask:d??prepareAttentionMask(o,s)};const b=!!a;o.session.inputNames.includes("use_cache_branch")&&(h.use_cache_branch=boolTensor(b)),preparePositionIds(o.session,h,b),o.addPastKeyValues(h,a);let et=await sessionRun(o.session,h),st=et.logits;return a=o.getPastKeyValues(et,a),{logits:st,past_key_values:a}}function decoderStartBeams(o,e,s,a,d){let h=[],b=0;for(let et of e){let st=et.tolist().map(Number);et.dims=[1,...et.dims];let $;d?($=d[b],$.dims=[1,...$.dims]):$=prepareAttentionMask(o,et);let it={input:et,model_input_ids:et,attention_mask:$,prev_model_outputs:null,output_token_ids:st,num_output_tokens:a,done:!1,score:0,id:b++};h.push(it)}return h}async function decoderRunBeam(o,e){let s=new BigInt64Array(e.output_token_ids.length).fill(1n),a={input_ids:e.model_input_ids,attention_mask:new Tensor("int64",s,[1,s.length]),past_key_values:e.prev_model_outputs?.past_key_values},d=await o.forward(a);return e.prev_model_outputs=d,d}function decoderUpdatebeam(o,e){o.output_token_ids=[...o.output_token_ids,e],o.model_input_ids=new Tensor("int64",[BigInt(e)],[1,1])}class PreTrainedModel extends Callable{main_input_name="input_ids";constructor(e,s){super(),this.config=e,this.session=s;const a=MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor),d=MODEL_TYPE_MAPPING.get(a);this.can_generate=!1,this._runBeam=null,this._getStartBeams=null,this._updateBeam=null,this._forward=null,d===MODEL_TYPES.DecoderOnly?(this.can_generate=!0,this._runBeam=decoderRunBeam,this._getStartBeams=decoderStartBeams,this._updateBeam=decoderUpdatebeam,this._forward=decoderForward):d===MODEL_TYPES.Seq2Seq||d===MODEL_TYPES.Vision2Seq?(this.can_generate=!0,this._runBeam=seq2seqRunBeam,this._getStartBeams=seq2seqStartBeams,this._updateBeam=seq2seqUpdatebeam,this._forward=seq2seqForward):d===MODEL_TYPES.EncoderDecoder?this._forward=encoderForward:this._forward=encoderForward}async dispose(){const e=[];for(let s of Object.keys(this)){const a=this[s];a instanceof InferenceSession&&e.push(a.handler.dispose())}return await Promise.all(e)}static async from_pretrained(e,{quantized:s=!0,progress_callback:a=null,config:d=null,cache_dir:h=null,local_files_only:b=!1,revision:et="main",model_file_name:st=null}={}){let $={quantized:s,progress_callback:a,config:d,cache_dir:h,local_files_only:b,revision:et,model_file_name:st};const it=MODEL_CLASS_TO_NAME_MAPPING.get(this),g=MODEL_TYPE_MAPPING.get(it);let c;return g===MODEL_TYPES.DecoderOnly?c=await Promise.all([AutoConfig.from_pretrained(e,$),constructSession(e,$.model_file_name??"decoder_model_merged",$),getModelJSON(e,"generation_config.json",!1,$)]):g===MODEL_TYPES.Seq2Seq||g===MODEL_TYPES.Vision2Seq?c=await Promise.all([AutoConfig.from_pretrained(e,$),constructSession(e,"encoder_model",$),constructSession(e,"decoder_model_merged",$),getModelJSON(e,"generation_config.json",!1,$)]):g===MODEL_TYPES.MaskGeneration?c=await Promise.all([AutoConfig.from_pretrained(e,$),constructSession(e,"vision_encoder",$),constructSession(e,"prompt_encoder_mask_decoder",$)]):g===MODEL_TYPES.EncoderDecoder?c=await Promise.all([AutoConfig.from_pretrained(e,$),constructSession(e,"encoder_model",$),constructSession(e,"decoder_model_merged",$)]):(g!==MODEL_TYPES.EncoderOnly&&console.warn(`Model type for '${it??d?.model_type}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`),c=await Promise.all([AutoConfig.from_pretrained(e,$),constructSession(e,$.model_file_name??"model",$)])),new this(...c)}async _call(e){return await this.forward(e)}async forward(e){return await this._forward(this,e)}_get_logits_processor(e,s,a=null){const d=new LogitsProcessorList;if(e.repetition_penalty!==null&&e.repetition_penalty!==1&&d.push(new RepetitionPenaltyLogitsProcessor(e.repetition_penalty)),e.no_repeat_ngram_size!==null&&e.no_repeat_ngram_size>0&&d.push(new NoRepeatNGramLogitsProcessor(e.no_repeat_ngram_size)),e.bad_words_ids!==null&&d.push(new NoBadWordsLogitsProcessor(e.bad_words_ids,e.eos_token_id)),e.min_length!==null&&e.eos_token_id!==null&&e.min_length>0&&d.push(new MinLengthLogitsProcessor(e.min_length,e.eos_token_id)),e.min_new_tokens!==null&&e.eos_token_id!==null&&e.min_new_tokens>0&&d.push(new MinNewTokensLengthLogitsProcessor(s,e.min_new_tokens,e.eos_token_id)),e.forced_bos_token_id!==null&&d.push(new ForcedBOSTokenLogitsProcessor(e.forced_bos_token_id)),e.forced_eos_token_id!==null&&d.push(new ForcedEOSTokenLogitsProcessor(e.max_length,e.forced_eos_token_id)),e.begin_suppress_tokens!==null){let h=s>1||e.forced_bos_token_id===null?s:s+1;e.forced_decoder_ids!==null&&(h+=e.forced_decoder_ids[e.forced_decoder_ids.length-1][0]),d.push(new SuppressTokensAtBeginLogitsProcessor(e.begin_suppress_tokens,h))}return e.forced_decoder_ids!==null&&d.push(new ForceTokensLogitsProcessor(e.forced_decoder_ids)),a!==null&&d.extend(a),d}_get_generation_config(e){let s=new GenerationConfig(this.config);return"generation_config"in this&&Object.assign(s,this.generation_config),e!==null&&Object.assign(s,e),s}async generate(e,s=null,a=null,{inputs_attention_mask:d=null}={}){if(!this.can_generate){let dt=`The current model class (${MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor)}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;const pt=this.config.model_type,ft=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(pt)??MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES.get(pt)??MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES.get(pt)??MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES.get(pt);throw ft&&(dt+=` Please use the following class instead: '${ft[0]}'`),Error(dt)}if(!(e instanceof Tensor)&&!isTypedArray(e)&&!Array.isArray(e))throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${e.constructor.name}".`);let h;if(this.config.is_encoder_decoder)h=0;else if(h=e instanceof Tensor?e.dims.at(-1):e.length,h===0)throw Error("Must supply a non-empty array of input token ids.");s=this._get_generation_config(s),a=a??new LogitsProcessorList,a=this._get_logits_processor(s,h,a);let b=s.eos_token_id;b!==null&&!Array.isArray(b)&&(b=[b]);let et=1;const st=et+(s.max_new_tokens??1/0),$=Number.isInteger(s.max_length)&&(s.max_new_tokens??null)===null;let it=Sampler.getSampler(s),g=this.getStartBeams(e,s,et,d);for(;g.some(ct=>!ct.done)&&et<st;){let ct=[];for(let dt of g){if(dt.done){ct.push(dt);continue}if($&&dt.output_token_ids.length>=s.max_length){dt.done=!0,ct.push(dt);continue}let pt=await this.runBeam(dt);s.output_attentions&&this.addAttentionsToBeam(dt,pt),s.output_scores;let ft=pt.logits.slice(null,-1,null);a(dt.output_token_ids,ft);let ht=it(ft);for(let[bt,mt]of ht){let $t={...dt};this.updateBeam($t,bt),$t.score+=mt,b&&b.includes(bt)&&($t.done=!0),ct.push($t)}}++et,ct=this.groupBeams(ct).map(dt=>dt.sort((pt,ft)=>ft.score-pt.score).slice(0,s.num_beams)),g=ct.flat(),s.callback_function&&s.callback_function(g)}const c=this.groupBeams(g),_=ct=>c.map(dt=>s.num_return_sequences>1?dt.slice(0,s.num_return_sequences).map(pt=>pt[ct]):[dt[0][ct]]).flat(),ot=_("output_token_ids");if(s.return_dict_in_generate){const ct=_("decoder_attentions"),dt=_("cross_attentions");return{sequences:ot,decoder_attentions:ct,cross_attentions:dt}}else return ot}addAttentionsToBeam(e,s){if(this.config.is_encoder_decoder){if(!s.cross_attentions||s.cross_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`.");e.cross_attentions||(e.cross_attentions=[]),e.cross_attentions.push(s.cross_attentions)}if(!s.decoder_attentions||s.decoder_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`.");e.decoder_attentions||(e.decoder_attentions=[]),e.decoder_attentions.push(s.decoder_attentions)}groupBeams(e){const s=Object.create(null);for(const a of e)s[a.id]===void 0?s[a.id]=[a]:s[a.id].push(a);return Object.values(s)}getPastKeyValues(e,s){const a=Object.create(null);for(const d in e)if(d.startsWith("present")){let h=d.replace("present","past_key_values");s&&d.includes("encoder")?a[h]=s[h]:a[h]=e[d]}return a}getAttentions(e){const s=Object.create(null);for(const a of["cross_attentions","decoder_attentions"]){const d=[];for(const h in e)if(h.startsWith(a)){const b=h.split(".").pop();d[b]=e[h]}s[a]=d}return s}addPastKeyValues(e,s){if(s)Object.assign(e,s);else if(this.config.is_encoder_decoder&&(this.add_encoder_pkv??!0)){let d=[1,this.num_encoder_heads,0,this.encoder_dim_kv],h=[1,this.num_decoder_heads,0,this.decoder_dim_kv];for(let b=0;b<this.num_decoder_layers;++b)e[`past_key_values.${b}.encoder.key`]=new Tensor("float32",[],d),e[`past_key_values.${b}.encoder.value`]=new Tensor("float32",[],d),e[`past_key_values.${b}.decoder.key`]=new Tensor("float32",[],h),e[`past_key_values.${b}.decoder.value`]=new Tensor("float32",[],h)}else if(this.config.model_type==="falcon"){let d=[1*this.num_heads,0,this.dim_kv];for(let h=0;h<this.num_layers;++h)e[`past_key_values.${h}.key`]=new Tensor("float32",[],d),e[`past_key_values.${h}.value`]=new Tensor("float32",[],d)}else if(this.config.multi_query){let d=[1*this.num_heads,0,2*this.dim_kv];for(let h=0;h<this.num_layers;++h)e[`past_key_values.${h}.key_value`]=new Tensor("float32",[],d)}else if(this.config.model_type==="bloom"){let d=[1*this.num_heads,this.dim_kv,0],h=[1*this.num_heads,0,this.dim_kv];for(let b=0;b<this.num_layers;++b)e[`past_key_values.${b}.key`]=new Tensor("float32",[],d),e[`past_key_values.${b}.value`]=new Tensor("float32",[],h)}else{let d=[1,this.num_heads,0,this.dim_kv];for(let h=0;h<this.num_layers;++h)e[`past_key_values.${h}.key`]=new Tensor("float32",[],d),e[`past_key_values.${h}.value`]=new Tensor("float32",[],d)}}getStartBeams(e,s,a,d){return this._getStartBeams(this,e,s,a,d)}async runBeam(e){return await this._runBeam(this,e)}updateBeam(e,s){return this._updateBeam(e,s)}}class ModelOutput{}class BertPreTrainedModel extends PreTrainedModel{}class BertModel extends BertPreTrainedModel{}class BertForMaskedLM extends BertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class BertForSequenceClassification extends BertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class BertForTokenClassification extends BertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class BertForQuestionAnswering extends BertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class NomicBertPreTrainedModel extends PreTrainedModel{}class NomicBertModel extends NomicBertPreTrainedModel{}class RoFormerPreTrainedModel extends PreTrainedModel{}class RoFormerModel extends RoFormerPreTrainedModel{}class RoFormerForMaskedLM extends RoFormerPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class RoFormerForSequenceClassification extends RoFormerPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class RoFormerForTokenClassification extends RoFormerPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class RoFormerForQuestionAnswering extends RoFormerPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class ConvBertPreTrainedModel extends PreTrainedModel{}class ConvBertModel extends ConvBertPreTrainedModel{}class ConvBertForMaskedLM extends ConvBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class ConvBertForSequenceClassification extends ConvBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ConvBertForTokenClassification extends ConvBertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class ConvBertForQuestionAnswering extends ConvBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class ElectraPreTrainedModel extends PreTrainedModel{}class ElectraModel extends ElectraPreTrainedModel{}class ElectraForMaskedLM extends ElectraPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class ElectraForSequenceClassification extends ElectraPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ElectraForTokenClassification extends ElectraPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class ElectraForQuestionAnswering extends ElectraPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class CamembertPreTrainedModel extends PreTrainedModel{}class CamembertModel extends CamembertPreTrainedModel{}class CamembertForMaskedLM extends CamembertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class CamembertForSequenceClassification extends CamembertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class CamembertForTokenClassification extends CamembertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class CamembertForQuestionAnswering extends CamembertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DebertaPreTrainedModel extends PreTrainedModel{}class DebertaModel extends DebertaPreTrainedModel{}class DebertaForMaskedLM extends DebertaPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class DebertaForSequenceClassification extends DebertaPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DebertaForTokenClassification extends DebertaPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class DebertaForQuestionAnswering extends DebertaPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DebertaV2PreTrainedModel extends PreTrainedModel{}class DebertaV2Model extends DebertaV2PreTrainedModel{}class DebertaV2ForMaskedLM extends DebertaV2PreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class DebertaV2ForSequenceClassification extends DebertaV2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DebertaV2ForTokenClassification extends DebertaV2PreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class DebertaV2ForQuestionAnswering extends DebertaV2PreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DistilBertPreTrainedModel extends PreTrainedModel{}class DistilBertModel extends DistilBertPreTrainedModel{}class DistilBertForSequenceClassification extends DistilBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DistilBertForTokenClassification extends DistilBertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class DistilBertForQuestionAnswering extends DistilBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DistilBertForMaskedLM extends DistilBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class EsmPreTrainedModel extends PreTrainedModel{}class EsmModel extends EsmPreTrainedModel{}class EsmForMaskedLM extends EsmPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class EsmForSequenceClassification extends EsmPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class EsmForTokenClassification extends EsmPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class MobileBertPreTrainedModel extends PreTrainedModel{}class MobileBertModel extends MobileBertPreTrainedModel{}class MobileBertForMaskedLM extends MobileBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class MobileBertForSequenceClassification extends MobileBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MobileBertForQuestionAnswering extends MobileBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class MPNetPreTrainedModel extends PreTrainedModel{}class MPNetModel extends MPNetPreTrainedModel{}class MPNetForMaskedLM extends MPNetPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class MPNetForSequenceClassification extends MPNetPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MPNetForTokenClassification extends MPNetPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class MPNetForQuestionAnswering extends MPNetPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class SqueezeBertPreTrainedModel extends PreTrainedModel{}class SqueezeBertModel extends SqueezeBertPreTrainedModel{}class SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class AlbertPreTrainedModel extends PreTrainedModel{}class AlbertModel extends AlbertPreTrainedModel{}class AlbertForSequenceClassification extends AlbertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class AlbertForQuestionAnswering extends AlbertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class AlbertForMaskedLM extends AlbertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class T5PreTrainedModel extends PreTrainedModel{}class T5Model extends T5PreTrainedModel{}class T5ForConditionalGeneration extends T5PreTrainedModel{constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class LongT5PreTrainedModel extends PreTrainedModel{}class LongT5Model extends LongT5PreTrainedModel{}class LongT5ForConditionalGeneration extends LongT5PreTrainedModel{constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class MT5PreTrainedModel extends PreTrainedModel{}class MT5Model extends MT5PreTrainedModel{}class MT5ForConditionalGeneration extends MT5PreTrainedModel{constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class BartPretrainedModel extends PreTrainedModel{}class BartModel extends BartPretrainedModel{}class BartForConditionalGeneration extends BartPretrainedModel{constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BartForSequenceClassification extends BartPretrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MBartPreTrainedModel extends PreTrainedModel{}class MBartModel extends MBartPreTrainedModel{}class MBartForConditionalGeneration extends MBartPreTrainedModel{constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class MBartForSequenceClassification extends MBartPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MBartForCausalLM extends MBartPreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotPreTrainedModel extends PreTrainedModel{}class BlenderbotModel extends BlenderbotPreTrainedModel{}class BlenderbotForConditionalGeneration extends BlenderbotPreTrainedModel{constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotSmallPreTrainedModel extends PreTrainedModel{}class BlenderbotSmallModel extends BlenderbotSmallPreTrainedModel{}class BlenderbotSmallForConditionalGeneration extends BlenderbotSmallPreTrainedModel{constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class RobertaPreTrainedModel extends PreTrainedModel{}class RobertaModel extends RobertaPreTrainedModel{}class RobertaForMaskedLM extends RobertaPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class RobertaForSequenceClassification extends RobertaPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class RobertaForTokenClassification extends RobertaPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class RobertaForQuestionAnswering extends RobertaPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class XLMPreTrainedModel extends PreTrainedModel{}class XLMModel extends XLMPreTrainedModel{}class XLMWithLMHeadModel extends XLMPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class XLMForSequenceClassification extends XLMPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class XLMForTokenClassification extends XLMPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class XLMForQuestionAnswering extends XLMPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class XLMRobertaPreTrainedModel extends PreTrainedModel{}class XLMRobertaModel extends XLMRobertaPreTrainedModel{}class XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class ASTPreTrainedModel extends PreTrainedModel{}class ASTModel extends ASTPreTrainedModel{}class ASTForAudioClassification extends ASTPreTrainedModel{}class WhisperPreTrainedModel extends PreTrainedModel{}class WhisperModel extends WhisperPreTrainedModel{}class WhisperForConditionalGeneration extends WhisperPreTrainedModel{requires_attention_mask=!1;main_input_name="input_features";constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}async generate(e,s=null,a=null){if(s=this._get_generation_config(s),s.return_timestamps??=!1,s.return_timestamps&&(a=[new WhisperTimeStampLogitsProcessor(s)]),s.return_token_timestamps&&(s.output_attentions=!0,s.return_dict_in_generate=!0,s.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),!s.alignment_heads))throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");const d=await super.generate(e,s,a);return s.return_token_timestamps&&s.alignment_heads&&(d.token_timestamps=this._extract_token_timestamps(d,s.alignment_heads,s.num_frames)),d}_extract_token_timestamps(e,s,a=null,d=.02){if(!e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");let h=this.config.median_filter_width;h===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),h=7);const b=e.cross_attentions.map($=>{let it=Array.from({length:this.config.decoder_layers},(dt,pt)=>cat($.map(ft=>ft[pt]),2)),g=stack(s.map(([dt,pt])=>a?it[dt].slice(null,pt,null,[0,a]):it[dt].slice(null,pt)));g=g.transpose(1,0,2,3);let[c,_]=std_mean(g,-2,0,!0),ot=g.clone();for(let dt=0;dt<ot.dims[0];++dt){let pt=ot[dt];for(let ft=0;ft<pt.dims[0];++ft){let ht=pt[ft];const bt=c[dt][ft][0],mt=_[dt][ft][0];for(let $t=0;$t<ht.dims[0];++$t){let Tt=ht[$t];for(let Nt=0;Nt<Tt.data.length;++Nt)Tt.data[Nt]=(Tt.data[Nt]-mt.data[Nt])/bt.data[Nt];Tt.data.set(medianFilter(Tt.data,h))}}}return mean(ot,1)}),et=[e.sequences.length,e.sequences[0].length],st=new Tensor("float32",new Float32Array(et[0]*et[1]),et);for(let $=0;$<et[0];++$){const it=b[$].neg().squeeze_(0);let[g,c]=dynamicTimeWarping(it),_=Array.from({length:g.length-1},(dt,pt)=>g[pt+1]-g[pt]),ot=mergeArrays([1],_).map(dt=>!!dt),ct=[];for(let dt=0;dt<ot.length;++dt)ot[dt]&&ct.push(c[dt]*d);st[$].data.set(ct,1)}return st}}class VisionEncoderDecoderModel extends PreTrainedModel{main_input_name="pixel_values";constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d;const h=this.config.encoder,b=this.config.decoder,et=h.model_type;(MODEL_MAPPING_NAMES_ENCODER_ONLY.get(et)??MODEL_MAPPING_NAMES_ENCODER_DECODER.get(et))||console.warn(`Model type for encoder '${et}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);const $=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(b.model_type);if(!$)throw new Error(`Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`);const it=$[1],g=new it(b,a,d);this.add_encoder_pkv="num_decoder_layers"in g,this.add_encoder_pkv?(this.num_decoder_layers=g.num_decoder_layers,this.num_decoder_heads=g.num_decoder_heads,this.decoder_dim_kv=g.decoder_dim_kv,this.num_encoder_layers=g.num_encoder_layers,this.num_encoder_heads=g.num_encoder_heads,this.encoder_dim_kv=g.encoder_dim_kv):(this.num_layers=g.num_layers,this.num_heads=g.num_heads,this.dim_kv=g.dim_kv)}}class CLIPPreTrainedModel extends PreTrainedModel{}class CLIPModel extends CLIPPreTrainedModel{}class CLIPTextModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(e,s={}){return s.model_file_name??="text_model",super.from_pretrained(e,s)}}class CLIPVisionModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(e,s={}){return s.model_file_name??="vision_model",super.from_pretrained(e,s)}}class SiglipPreTrainedModel extends PreTrainedModel{}class SiglipModel extends SiglipPreTrainedModel{}class SiglipTextModel extends SiglipPreTrainedModel{static async from_pretrained(e,s={}){return s.model_file_name??="text_model",super.from_pretrained(e,s)}}class SiglipVisionModel extends CLIPPreTrainedModel{static async from_pretrained(e,s={}){return s.model_file_name??="vision_model",super.from_pretrained(e,s)}}class ChineseCLIPPreTrainedModel extends PreTrainedModel{}class ChineseCLIPModel extends ChineseCLIPPreTrainedModel{}class CLIPSegPreTrainedModel extends PreTrainedModel{}class CLIPSegModel extends CLIPSegPreTrainedModel{}class CLIPSegForImageSegmentation extends CLIPSegPreTrainedModel{}class GPT2PreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPT2Model extends GPT2PreTrainedModel{}class GPT2LMHeadModel extends GPT2PreTrainedModel{}class GPTNeoPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_heads,this.num_layers=this.config.num_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoModel extends GPTNeoPreTrainedModel{}class GPTNeoForCausalLM extends GPTNeoPreTrainedModel{}class GPTNeoXPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoXModel extends GPTNeoXPreTrainedModel{}class GPTNeoXForCausalLM extends GPTNeoXPreTrainedModel{}class GPTJPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTJModel extends GPTJPreTrainedModel{}class GPTJForCausalLM extends GPTJPreTrainedModel{}class GPTBigCodePreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTBigCodeModel extends GPTBigCodePreTrainedModel{}class GPTBigCodeForCausalLM extends GPTBigCodePreTrainedModel{}class CodeGenPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class CodeGenModel extends CodeGenPreTrainedModel{}class CodeGenForCausalLM extends CodeGenPreTrainedModel{}class LlamaPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class LlamaModel extends LlamaPreTrainedModel{}class LlamaForCausalLM extends LlamaPreTrainedModel{}class Qwen2PreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Qwen2Model extends Qwen2PreTrainedModel{}class Qwen2ForCausalLM extends Qwen2PreTrainedModel{}class PhiPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class PhiModel extends PhiPreTrainedModel{}class PhiForCausalLM extends PhiPreTrainedModel{}class BloomPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.hidden_size/this.num_heads}}class BloomModel extends BloomPreTrainedModel{}class BloomForCausalLM extends BloomPreTrainedModel{}class MptPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_heads,this.num_layers=this.config.n_layers,this.dim_kv=this.config.d_model/this.num_heads}}class MptModel extends MptPreTrainedModel{}class MptForCausalLM extends MptPreTrainedModel{}class OPTPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class OPTModel extends OPTPreTrainedModel{}class OPTForCausalLM extends OPTPreTrainedModel{}class ViTPreTrainedModel extends PreTrainedModel{}class ViTModel extends ViTPreTrainedModel{}class ViTForImageClassification extends ViTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class FastViTPreTrainedModel extends PreTrainedModel{}class FastViTModel extends FastViTPreTrainedModel{}class FastViTForImageClassification extends FastViTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class VitMattePreTrainedModel extends PreTrainedModel{}class VitMatteForImageMatting extends VitMattePreTrainedModel{async _call(e){return new ImageMattingOutput(await super._call(e))}}class MobileViTPreTrainedModel extends PreTrainedModel{}class MobileViTModel extends MobileViTPreTrainedModel{}class MobileViTForImageClassification extends MobileViTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MobileViTV2PreTrainedModel extends PreTrainedModel{}class MobileViTV2Model extends MobileViTV2PreTrainedModel{}class MobileViTV2ForImageClassification extends MobileViTV2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class OwlViTPreTrainedModel extends PreTrainedModel{}class OwlViTModel extends OwlViTPreTrainedModel{}class OwlViTForObjectDetection extends OwlViTPreTrainedModel{}class Owlv2PreTrainedModel extends PreTrainedModel{}class Owlv2Model extends Owlv2PreTrainedModel{}class Owlv2ForObjectDetection extends Owlv2PreTrainedModel{}class BeitPreTrainedModel extends PreTrainedModel{}class BeitModel extends BeitPreTrainedModel{}class BeitForImageClassification extends BeitPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DetrPreTrainedModel extends PreTrainedModel{}class DetrModel extends DetrPreTrainedModel{}class DetrForObjectDetection extends DetrPreTrainedModel{async _call(e){return new DetrObjectDetectionOutput(await super._call(e))}}class DetrForSegmentation extends DetrPreTrainedModel{async _call(e){return new DetrSegmentationOutput(await super._call(e))}}class DetrObjectDetectionOutput extends ModelOutput{constructor({logits:e,pred_boxes:s}){super(),this.logits=e,this.pred_boxes=s}}class DetrSegmentationOutput extends ModelOutput{constructor({logits:e,pred_boxes:s,pred_masks:a}){super(),this.logits=e,this.pred_boxes=s,this.pred_masks=a}}class TableTransformerPreTrainedModel extends PreTrainedModel{}class TableTransformerModel extends TableTransformerPreTrainedModel{}class TableTransformerForObjectDetection extends TableTransformerPreTrainedModel{async _call(e){return new TableTransformerObjectDetectionOutput(await super._call(e))}}class TableTransformerObjectDetectionOutput extends DetrObjectDetectionOutput{}class DeiTPreTrainedModel extends PreTrainedModel{}class DeiTModel extends DeiTPreTrainedModel{}class DeiTForImageClassification extends DeiTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ResNetPreTrainedModel extends PreTrainedModel{}class ResNetModel extends ResNetPreTrainedModel{}class ResNetForImageClassification extends ResNetPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class SwinPreTrainedModel extends PreTrainedModel{}class SwinModel extends SwinPreTrainedModel{}class SwinForImageClassification extends SwinPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class Swin2SRPreTrainedModel extends PreTrainedModel{}class Swin2SRModel extends Swin2SRPreTrainedModel{}class Swin2SRForImageSuperResolution extends Swin2SRPreTrainedModel{}class DPTPreTrainedModel extends PreTrainedModel{}class DPTModel extends DPTPreTrainedModel{}class DPTForDepthEstimation extends DPTPreTrainedModel{}class DepthAnythingPreTrainedModel extends PreTrainedModel{}class DepthAnythingForDepthEstimation extends DepthAnythingPreTrainedModel{}class GLPNPreTrainedModel extends PreTrainedModel{}class GLPNModel extends GLPNPreTrainedModel{}class GLPNForDepthEstimation extends GLPNPreTrainedModel{}class DonutSwinPreTrainedModel extends PreTrainedModel{}class DonutSwinModel extends DonutSwinPreTrainedModel{}class ConvNextPreTrainedModel extends PreTrainedModel{}class ConvNextModel extends ConvNextPreTrainedModel{}class ConvNextForImageClassification extends ConvNextPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ConvNextV2PreTrainedModel extends PreTrainedModel{}class ConvNextV2Model extends ConvNextV2PreTrainedModel{}class ConvNextV2ForImageClassification extends ConvNextV2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class Dinov2PreTrainedModel extends PreTrainedModel{}class Dinov2Model extends Dinov2PreTrainedModel{}class Dinov2ForImageClassification extends Dinov2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class YolosPreTrainedModel extends PreTrainedModel{}class YolosModel extends YolosPreTrainedModel{}class YolosForObjectDetection extends YolosPreTrainedModel{async _call(e){return new YolosObjectDetectionOutput(await super._call(e))}}class YolosObjectDetectionOutput extends ModelOutput{constructor({logits:e,pred_boxes:s}){super(),this.logits=e,this.pred_boxes=s}}class SamPreTrainedModel extends PreTrainedModel{}class SamModel extends SamPreTrainedModel{constructor(e,s,a){super(e,s),this.prompt_encoder_mask_decoder=a}async get_image_embeddings({pixel_values:e}){return await encoderForward(this,{pixel_values:e})}async forward(e){if((!e.image_embeddings||!e.image_positional_embeddings)&&(e={...e,...await this.get_image_embeddings(e)}),!e.input_labels){const s=e.input_points.dims.slice(0,-1),a=s.reduce((d,h)=>d*h,1);e.input_labels=new Tensor("int64",new BigInt64Array(a).fill(1n),s)}return await sessionRun(this.prompt_encoder_mask_decoder,{input_points:e.input_points,input_labels:e.input_labels,image_embeddings:e.image_embeddings,image_positional_embeddings:e.image_positional_embeddings})}async _call(e){return new SamImageSegmentationOutput(await super._call(e))}}class SamImageSegmentationOutput extends ModelOutput{constructor({iou_scores:e,pred_masks:s}){super(),this.iou_scores=e,this.pred_masks=s}}class MarianPreTrainedModel extends PreTrainedModel{}class MarianModel extends MarianPreTrainedModel{}class MarianMTModel extends MarianPreTrainedModel{constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class M2M100PreTrainedModel extends PreTrainedModel{}class M2M100Model extends M2M100PreTrainedModel{}class M2M100ForConditionalGeneration extends M2M100PreTrainedModel{constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class Wav2Vec2PreTrainedModel extends PreTrainedModel{}class Wav2Vec2Model extends Wav2Vec2PreTrainedModel{}class Wav2Vec2ForCTC extends Wav2Vec2PreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class Wav2Vec2ForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class Wav2Vec2ForAudioFrameClassification extends Wav2Vec2PreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class UniSpeechPreTrainedModel extends PreTrainedModel{}class UniSpeechModel extends UniSpeechPreTrainedModel{}class UniSpeechForCTC extends UniSpeechPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class UniSpeechForSequenceClassification extends UniSpeechPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class UniSpeechSatPreTrainedModel extends PreTrainedModel{}class UniSpeechSatModel extends UniSpeechSatPreTrainedModel{}class UniSpeechSatForCTC extends UniSpeechSatPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class UniSpeechSatForSequenceClassification extends UniSpeechSatPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class UniSpeechSatForAudioFrameClassification extends UniSpeechSatPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class Wav2Vec2BertPreTrainedModel extends PreTrainedModel{}class Wav2Vec2BertModel extends Wav2Vec2BertPreTrainedModel{}class Wav2Vec2BertForCTC extends Wav2Vec2BertPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class Wav2Vec2BertForSequenceClassification extends Wav2Vec2BertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class HubertModel extends Wav2Vec2PreTrainedModel{}class HubertForCTC extends Wav2Vec2PreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class HubertForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class WavLMPreTrainedModel extends PreTrainedModel{}class WavLMModel extends WavLMPreTrainedModel{}class WavLMForCTC extends WavLMPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class WavLMForSequenceClassification extends WavLMPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class WavLMForXVector extends WavLMPreTrainedModel{async _call(e){return new XVectorOutput(await super._call(e))}}class WavLMForAudioFrameClassification extends WavLMPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class SpeechT5PreTrainedModel extends PreTrainedModel{}class SpeechT5ForSpeechToText extends SpeechT5PreTrainedModel{}class SpeechT5ForTextToSpeech extends SpeechT5PreTrainedModel{constructor(e,s,a,d){super(e,s),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.hidden_size/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.hidden_size/this.num_encoder_heads}async generate_speech(e,s,{threshold:a=.5,minlenratio:d=0,maxlenratio:h=20,vocoder:b=null}={}){const et={input_ids:e},{encoder_outputs:st,encoder_attention_mask:$}=await encoderForward(this,et),it=st.dims[1]/this.config.reduction_factor,g=Math.floor(it*h),c=Math.floor(it*d),_=this.config.num_mel_bins;let ot=[],ct=null,dt=null,pt=0;for(;;){++pt;const bt=boolTensor(!!dt);let mt;dt?mt=dt.output_sequence_out:mt=new Tensor("float32",new Float32Array(_),[1,1,_]);let $t={use_cache_branch:bt,output_sequence:mt,encoder_attention_mask:$,speaker_embeddings:s,encoder_hidden_states:st};this.addPastKeyValues($t,ct),dt=await sessionRun(this.decoder_merged_session,$t),ct=this.getPastKeyValues(dt,ct);const{prob:Tt,spectrum:Nt}=dt;if(ot.push(Nt),pt>=c&&(Array.from(Tt.data).filter(Ct=>Ct>=a).length>0||pt>=g))break}const ft=cat(ot),{waveform:ht}=await sessionRun(b.session,{spectrogram:ft});return{spectrogram:ft,waveform:ht}}}class SpeechT5HifiGan extends PreTrainedModel{main_input_name="spectrogram"}class TrOCRPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_encoder_layers=this.num_decoder_layers=this.config.decoder_layers,this.num_encoder_heads=this.num_decoder_heads=this.config.decoder_attention_heads,this.encoder_dim_kv=this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads}}class TrOCRForCausalLM extends TrOCRPreTrainedModel{}class MistralPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class MistralModel extends MistralPreTrainedModel{}class MistralForCausalLM extends MistralPreTrainedModel{}class Starcoder2PreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Starcoder2Model extends Starcoder2PreTrainedModel{}class Starcoder2ForCausalLM extends Starcoder2PreTrainedModel{}class FalconPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class FalconModel extends FalconPreTrainedModel{}class FalconForCausalLM extends FalconPreTrainedModel{}class ClapPreTrainedModel extends PreTrainedModel{}class ClapModel extends ClapPreTrainedModel{}class ClapTextModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(e,s={}){return s.model_file_name??="text_model",super.from_pretrained(e,s)}}class ClapAudioModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(e,s={}){return s.model_file_name??="audio_model",super.from_pretrained(e,s)}}class VitsPreTrainedModel extends PreTrainedModel{}class VitsModel extends VitsPreTrainedModel{async _call(e){return new VitsModelOutput(await super._call(e))}}class SegformerPreTrainedModel extends PreTrainedModel{}class SegformerForImageClassification extends SegformerPreTrainedModel{}class SegformerForSemanticSegmentation extends SegformerPreTrainedModel{}class StableLmPreTrainedModel extends PreTrainedModel{constructor(e,s,a){super(e,s),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class StableLmForCausalLM extends StableLmPreTrainedModel{}class EfficientNetPreTrainedModel extends PreTrainedModel{}class EfficientNetModel extends EfficientNetPreTrainedModel{}class EfficientNetForImageClassification extends EfficientNetPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class PretrainedMixin{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(e,{quantized:s=!0,progress_callback:a=null,config:d=null,cache_dir:h=null,local_files_only:b=!1,revision:et="main",model_file_name:st=null}={}){let $={quantized:s,progress_callback:a,config:d,cache_dir:h,local_files_only:b,revision:et,model_file_name:st};if(d=await AutoConfig.from_pretrained(e,$),$.config||($.config=d),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(let it of this.MODEL_CLASS_MAPPINGS){const g=it.get(d.model_type);if(g)return await g[1].from_pretrained(e,$)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${d.model_type}", attempting to construct from base class.`),await PreTrainedModel.from_pretrained(e,$);throw Error(`Unsupported model type: ${d.model_type}`)}}const MODEL_MAPPING_NAMES_ENCODER_ONLY=new Map([["bert",["BertModel",BertModel]],["nomic_bert",["NomicBertModel",NomicBertModel]],["roformer",["RoFormerModel",RoFormerModel]],["electra",["ElectraModel",ElectraModel]],["esm",["EsmModel",EsmModel]],["convbert",["ConvBertModel",ConvBertModel]],["camembert",["CamembertModel",CamembertModel]],["deberta",["DebertaModel",DebertaModel]],["deberta-v2",["DebertaV2Model",DebertaV2Model]],["mpnet",["MPNetModel",MPNetModel]],["albert",["AlbertModel",AlbertModel]],["distilbert",["DistilBertModel",DistilBertModel]],["roberta",["RobertaModel",RobertaModel]],["xlm",["XLMModel",XLMModel]],["xlm-roberta",["XLMRobertaModel",XLMRobertaModel]],["clap",["ClapModel",ClapModel]],["clip",["CLIPModel",CLIPModel]],["clipseg",["CLIPSegModel",CLIPSegModel]],["chinese_clip",["ChineseCLIPModel",ChineseCLIPModel]],["siglip",["SiglipModel",SiglipModel]],["mobilebert",["MobileBertModel",MobileBertModel]],["squeezebert",["SqueezeBertModel",SqueezeBertModel]],["wav2vec2",["Wav2Vec2Model",Wav2Vec2Model]],["wav2vec2-bert",["Wav2Vec2BertModel",Wav2Vec2BertModel]],["unispeech",["UniSpeechModel",UniSpeechModel]],["unispeech-sat",["UniSpeechSatModel",UniSpeechSatModel]],["hubert",["HubertModel",HubertModel]],["wavlm",["WavLMModel",WavLMModel]],["audio-spectrogram-transformer",["ASTModel",ASTModel]],["vits",["VitsModel",VitsModel]],["detr",["DetrModel",DetrModel]],["table-transformer",["TableTransformerModel",TableTransformerModel]],["vit",["ViTModel",ViTModel]],["fastvit",["FastViTModel",FastViTModel]],["mobilevit",["MobileViTModel",MobileViTModel]],["mobilevitv2",["MobileViTV2Model",MobileViTV2Model]],["owlvit",["OwlViTModel",OwlViTModel]],["owlv2",["Owlv2Model",Owlv2Model]],["beit",["BeitModel",BeitModel]],["deit",["DeiTModel",DeiTModel]],["convnext",["ConvNextModel",ConvNextModel]],["convnextv2",["ConvNextV2Model",ConvNextV2Model]],["dinov2",["Dinov2Model",Dinov2Model]],["resnet",["ResNetModel",ResNetModel]],["swin",["SwinModel",SwinModel]],["swin2sr",["Swin2SRModel",Swin2SRModel]],["donut-swin",["DonutSwinModel",DonutSwinModel]],["yolos",["YolosModel",YolosModel]],["dpt",["DPTModel",DPTModel]],["glpn",["GLPNModel",GLPNModel]],["hifigan",["SpeechT5HifiGan",SpeechT5HifiGan]],["efficientnet",["EfficientNetModel",EfficientNetModel]]]),MODEL_MAPPING_NAMES_ENCODER_DECODER=new Map([["t5",["T5Model",T5Model]],["longt5",["LongT5Model",LongT5Model]],["mt5",["MT5Model",MT5Model]],["bart",["BartModel",BartModel]],["mbart",["MBartModel",MBartModel]],["marian",["MarianModel",MarianModel]],["whisper",["WhisperModel",WhisperModel]],["m2m_100",["M2M100Model",M2M100Model]],["blenderbot",["BlenderbotModel",BlenderbotModel]],["blenderbot-small",["BlenderbotSmallModel",BlenderbotSmallModel]]]),MODEL_MAPPING_NAMES_DECODER_ONLY=new Map([["bloom",["BloomModel",BloomModel]],["gpt2",["GPT2Model",GPT2Model]],["gptj",["GPTJModel",GPTJModel]],["gpt_bigcode",["GPTBigCodeModel",GPTBigCodeModel]],["gpt_neo",["GPTNeoModel",GPTNeoModel]],["gpt_neox",["GPTNeoXModel",GPTNeoXModel]],["codegen",["CodeGenModel",CodeGenModel]],["llama",["LlamaModel",LlamaModel]],["qwen2",["Qwen2Model",Qwen2Model]],["phi",["PhiModel",PhiModel]],["mpt",["MptModel",MptModel]],["opt",["OPTModel",OPTModel]],["mistral",["MistralModel",MistralModel]],["starcoder2",["Starcoder2Model",Starcoder2Model]],["falcon",["FalconModel",FalconModel]]]),MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForSpeechToText",SpeechT5ForSpeechToText]],["whisper",["WhisperForConditionalGeneration",WhisperForConditionalGeneration]]]),MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForTextToSpeech",SpeechT5ForTextToSpeech]]]),MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES=new Map([["vits",["VitsModel",VitsModel]]]),MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForSequenceClassification",BertForSequenceClassification]],["roformer",["RoFormerForSequenceClassification",RoFormerForSequenceClassification]],["electra",["ElectraForSequenceClassification",ElectraForSequenceClassification]],["esm",["EsmForSequenceClassification",EsmForSequenceClassification]],["convbert",["ConvBertForSequenceClassification",ConvBertForSequenceClassification]],["camembert",["CamembertForSequenceClassification",CamembertForSequenceClassification]],["deberta",["DebertaForSequenceClassification",DebertaForSequenceClassification]],["deberta-v2",["DebertaV2ForSequenceClassification",DebertaV2ForSequenceClassification]],["mpnet",["MPNetForSequenceClassification",MPNetForSequenceClassification]],["albert",["AlbertForSequenceClassification",AlbertForSequenceClassification]],["distilbert",["DistilBertForSequenceClassification",DistilBertForSequenceClassification]],["roberta",["RobertaForSequenceClassification",RobertaForSequenceClassification]],["xlm",["XLMForSequenceClassification",XLMForSequenceClassification]],["xlm-roberta",["XLMRobertaForSequenceClassification",XLMRobertaForSequenceClassification]],["bart",["BartForSequenceClassification",BartForSequenceClassification]],["mbart",["MBartForSequenceClassification",MBartForSequenceClassification]],["mobilebert",["MobileBertForSequenceClassification",MobileBertForSequenceClassification]],["squeezebert",["SqueezeBertForSequenceClassification",SqueezeBertForSequenceClassification]]]),MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForTokenClassification",BertForTokenClassification]],["roformer",["RoFormerForTokenClassification",RoFormerForTokenClassification]],["electra",["ElectraForTokenClassification",ElectraForTokenClassification]],["esm",["EsmForTokenClassification",EsmForTokenClassification]],["convbert",["ConvBertForTokenClassification",ConvBertForTokenClassification]],["camembert",["CamembertForTokenClassification",CamembertForTokenClassification]],["deberta",["DebertaForTokenClassification",DebertaForTokenClassification]],["deberta-v2",["DebertaV2ForTokenClassification",DebertaV2ForTokenClassification]],["mpnet",["MPNetForTokenClassification",MPNetForTokenClassification]],["distilbert",["DistilBertForTokenClassification",DistilBertForTokenClassification]],["roberta",["RobertaForTokenClassification",RobertaForTokenClassification]],["xlm",["XLMForTokenClassification",XLMForTokenClassification]],["xlm-roberta",["XLMRobertaForTokenClassification",XLMRobertaForTokenClassification]]]),MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES=new Map([["t5",["T5ForConditionalGeneration",T5ForConditionalGeneration]],["longt5",["LongT5ForConditionalGeneration",LongT5ForConditionalGeneration]],["mt5",["MT5ForConditionalGeneration",MT5ForConditionalGeneration]],["bart",["BartForConditionalGeneration",BartForConditionalGeneration]],["mbart",["MBartForConditionalGeneration",MBartForConditionalGeneration]],["marian",["MarianMTModel",MarianMTModel]],["m2m_100",["M2M100ForConditionalGeneration",M2M100ForConditionalGeneration]],["blenderbot",["BlenderbotForConditionalGeneration",BlenderbotForConditionalGeneration]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",BlenderbotSmallForConditionalGeneration]]]),MODEL_WITH_LM_HEAD_MAPPING_NAMES=new Map([["bloom",["BloomForCausalLM",BloomForCausalLM]],["gpt2",["GPT2LMHeadModel",GPT2LMHeadModel]],["gptj",["GPTJForCausalLM",GPTJForCausalLM]],["gpt_bigcode",["GPTBigCodeForCausalLM",GPTBigCodeForCausalLM]],["gpt_neo",["GPTNeoForCausalLM",GPTNeoForCausalLM]],["gpt_neox",["GPTNeoXForCausalLM",GPTNeoXForCausalLM]],["codegen",["CodeGenForCausalLM",CodeGenForCausalLM]],["llama",["LlamaForCausalLM",LlamaForCausalLM]],["qwen2",["Qwen2ForCausalLM",Qwen2ForCausalLM]],["phi",["PhiForCausalLM",PhiForCausalLM]],["mpt",["MptForCausalLM",MptForCausalLM]],["opt",["OPTForCausalLM",OPTForCausalLM]],["mbart",["MBartForCausalLM",MBartForCausalLM]],["mistral",["MistralForCausalLM",MistralForCausalLM]],["starcoder2",["Starcoder2ForCausalLM",Starcoder2ForCausalLM]],["falcon",["FalconForCausalLM",FalconForCausalLM]],["trocr",["TrOCRForCausalLM",TrOCRForCausalLM]],["stablelm",["StableLmForCausalLM",StableLmForCausalLM]]]),MODEL_FOR_MASKED_LM_MAPPING_NAMES=new Map([["bert",["BertForMaskedLM",BertForMaskedLM]],["roformer",["RoFormerForMaskedLM",RoFormerForMaskedLM]],["electra",["ElectraForMaskedLM",ElectraForMaskedLM]],["esm",["EsmForMaskedLM",EsmForMaskedLM]],["convbert",["ConvBertForMaskedLM",ConvBertForMaskedLM]],["camembert",["CamembertForMaskedLM",CamembertForMaskedLM]],["deberta",["DebertaForMaskedLM",DebertaForMaskedLM]],["deberta-v2",["DebertaV2ForMaskedLM",DebertaV2ForMaskedLM]],["mpnet",["MPNetForMaskedLM",MPNetForMaskedLM]],["albert",["AlbertForMaskedLM",AlbertForMaskedLM]],["distilbert",["DistilBertForMaskedLM",DistilBertForMaskedLM]],["roberta",["RobertaForMaskedLM",RobertaForMaskedLM]],["xlm",["XLMWithLMHeadModel",XLMWithLMHeadModel]],["xlm-roberta",["XLMRobertaForMaskedLM",XLMRobertaForMaskedLM]],["mobilebert",["MobileBertForMaskedLM",MobileBertForMaskedLM]],["squeezebert",["SqueezeBertForMaskedLM",SqueezeBertForMaskedLM]]]),MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES=new Map([["bert",["BertForQuestionAnswering",BertForQuestionAnswering]],["roformer",["RoFormerForQuestionAnswering",RoFormerForQuestionAnswering]],["electra",["ElectraForQuestionAnswering",ElectraForQuestionAnswering]],["convbert",["ConvBertForQuestionAnswering",ConvBertForQuestionAnswering]],["camembert",["CamembertForQuestionAnswering",CamembertForQuestionAnswering]],["deberta",["DebertaForQuestionAnswering",DebertaForQuestionAnswering]],["deberta-v2",["DebertaV2ForQuestionAnswering",DebertaV2ForQuestionAnswering]],["mpnet",["MPNetForQuestionAnswering",MPNetForQuestionAnswering]],["albert",["AlbertForQuestionAnswering",AlbertForQuestionAnswering]],["distilbert",["DistilBertForQuestionAnswering",DistilBertForQuestionAnswering]],["roberta",["RobertaForQuestionAnswering",RobertaForQuestionAnswering]],["xlm",["XLMForQuestionAnswering",XLMForQuestionAnswering]],["xlm-roberta",["XLMRobertaForQuestionAnswering",XLMRobertaForQuestionAnswering]],["mobilebert",["MobileBertForQuestionAnswering",MobileBertForQuestionAnswering]],["squeezebert",["SqueezeBertForQuestionAnswering",SqueezeBertForQuestionAnswering]]]),MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",VisionEncoderDecoderModel]]]),MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES=new Map([["vit",["ViTForImageClassification",ViTForImageClassification]],["fastvit",["FastViTForImageClassification",FastViTForImageClassification]],["mobilevit",["MobileViTForImageClassification",MobileViTForImageClassification]],["mobilevitv2",["MobileViTV2ForImageClassification",MobileViTV2ForImageClassification]],["beit",["BeitForImageClassification",BeitForImageClassification]],["deit",["DeiTForImageClassification",DeiTForImageClassification]],["convnext",["ConvNextForImageClassification",ConvNextForImageClassification]],["convnextv2",["ConvNextV2ForImageClassification",ConvNextV2ForImageClassification]],["dinov2",["Dinov2ForImageClassification",Dinov2ForImageClassification]],["resnet",["ResNetForImageClassification",ResNetForImageClassification]],["swin",["SwinForImageClassification",SwinForImageClassification]],["segformer",["SegformerForImageClassification",SegformerForImageClassification]],["efficientnet",["EfficientNetForImageClassification",EfficientNetForImageClassification]]]),MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES=new Map([["detr",["DetrForObjectDetection",DetrForObjectDetection]],["table-transformer",["TableTransformerForObjectDetection",TableTransformerForObjectDetection]],["yolos",["YolosForObjectDetection",YolosForObjectDetection]]]),MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES=new Map([["owlvit",["OwlViTForObjectDetection",OwlViTForObjectDetection]],["owlv2",["Owlv2ForObjectDetection",Owlv2ForObjectDetection]]]),MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES=new Map([["detr",["DetrForSegmentation",DetrForSegmentation]],["clipseg",["CLIPSegForImageSegmentation",CLIPSegForImageSegmentation]]]),MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES=new Map([["segformer",["SegformerForSemanticSegmentation",SegformerForSemanticSegmentation]]]),MODEL_FOR_MASK_GENERATION_MAPPING_NAMES=new Map([["sam",["SamModel",SamModel]]]),MODEL_FOR_CTC_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForCTC",Wav2Vec2ForCTC]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Wav2Vec2BertForCTC]],["unispeech",["UniSpeechForCTC",UniSpeechForCTC]],["unispeech-sat",["UniSpeechSatForCTC",UniSpeechSatForCTC]],["wavlm",["WavLMForCTC",WavLMForCTC]],["hubert",["HubertForCTC",HubertForCTC]]]),MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Wav2Vec2ForSequenceClassification]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Wav2Vec2BertForSequenceClassification]],["unispeech",["UniSpeechForSequenceClassification",UniSpeechForSequenceClassification]],["unispeech-sat",["UniSpeechSatForSequenceClassification",UniSpeechSatForSequenceClassification]],["wavlm",["WavLMForSequenceClassification",WavLMForSequenceClassification]],["hubert",["HubertForSequenceClassification",HubertForSequenceClassification]],["audio-spectrogram-transformer",["ASTForAudioClassification",ASTForAudioClassification]]]),MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES=new Map([["wavlm",["WavLMForXVector",WavLMForXVector]]]),MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",UniSpeechSatForAudioFrameClassification]],["wavlm",["WavLMForAudioFrameClassification",WavLMForAudioFrameClassification]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Wav2Vec2ForAudioFrameClassification]]]),MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES=new Map([["vitmatte",["VitMatteForImageMatting",VitMatteForImageMatting]]]),MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Swin2SRForImageSuperResolution]]]),MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES=new Map([["dpt",["DPTForDepthEstimation",DPTForDepthEstimation]],["depth_anything",["DepthAnythingForDepthEstimation",DepthAnythingForDepthEstimation]],["glpn",["GLPNForDepthEstimation",GLPNForDepthEstimation]]]),MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES=new Map([["clip",["CLIPVisionModelWithProjection",CLIPVisionModelWithProjection]],["siglip",["SiglipVisionModel",SiglipVisionModel]]]),MODEL_CLASS_TYPE_MAPPING=[[MODEL_MAPPING_NAMES_ENCODER_ONLY,MODEL_TYPES.EncoderOnly],[MODEL_MAPPING_NAMES_ENCODER_DECODER,MODEL_TYPES.EncoderDecoder],[MODEL_MAPPING_NAMES_DECODER_ONLY,MODEL_TYPES.DecoderOnly],[MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_WITH_LM_HEAD_MAPPING_NAMES,MODEL_TYPES.DecoderOnly],[MODEL_FOR_MASKED_LM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Vision2Seq],[MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_MASK_GENERATION_MAPPING_NAMES,MODEL_TYPES.MaskGeneration],[MODEL_FOR_CTC_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly]];for(const[o,e]of MODEL_CLASS_TYPE_MAPPING)for(const[s,a]of o.values())MODEL_TYPE_MAPPING.set(s,e),MODEL_CLASS_TO_NAME_MAPPING.set(a,s),MODEL_NAME_TO_CLASS_MAPPING.set(s,a);const CUSTOM_MAPPING=[["CLIPTextModelWithProjection",CLIPTextModelWithProjection,MODEL_TYPES.EncoderOnly],["SiglipTextModel",SiglipTextModel,MODEL_TYPES.EncoderOnly],["ClapTextModelWithProjection",ClapTextModelWithProjection,MODEL_TYPES.EncoderOnly],["ClapAudioModelWithProjection",ClapAudioModelWithProjection,MODEL_TYPES.EncoderOnly]];for(const[o,e,s]of CUSTOM_MAPPING)MODEL_TYPE_MAPPING.set(o,s),MODEL_CLASS_TO_NAME_MAPPING.set(e,o),MODEL_NAME_TO_CLASS_MAPPING.set(o,e);class AutoModel extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=MODEL_CLASS_TYPE_MAPPING.map(e=>e[0]);static BASE_IF_FAIL=!0}class AutoModelForCausalLM extends PretrainedMixin{static MODEL_CLASS_MAPPINGS=[MODEL_WITH_LM_HEAD_MAPPING_NAMES]}class Seq2SeqLMOutput extends ModelOutput{constructor({logits:e,past_key_values:s,encoder_outputs:a,decoder_attentions:d=null,cross_attentions:h=null}){super(),this.logits=e,this.past_key_values=s,this.encoder_outputs=a,this.decoder_attentions=d,this.cross_attentions=h}}class SequenceClassifierOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class XVectorOutput extends ModelOutput{constructor({logits:e,embeddings:s}){super(),this.logits=e,this.embeddings=s}}class TokenClassifierOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class MaskedLMOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class QuestionAnsweringModelOutput extends ModelOutput{constructor({start_logits:e,end_logits:s}){super(),this.start_logits=e,this.end_logits=s}}class CausalLMOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class ImageMattingOutput extends ModelOutput{constructor({alphas:e}){super(),this.alphas=e}}class VitsModelOutput extends ModelOutput{constructor({waveform:e,spectrogram:s}){super(),this.waveform=e,this.spectrogram=s}}const BROWSER_ENV=typeof self<"u";if(!BROWSER_ENV){if(!sharp)throw new Error("Unable to load image processing library.")}/*!
 * ONNX Runtime Web v1.19.0-dev.20240509-69cfcba38a
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var Oi=Object.defineProperty,nc=Object.getOwnPropertyDescriptor,ic=Object.getOwnPropertyNames,ac=Object.prototype.hasOwnProperty,j=(o,e)=>()=>(o&&(e=o(o=0)),e),Er=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),kr=(o,e)=>{for(var s in e)Oi(o,s,{get:e[s],enumerable:!0})},oc=(o,e,s,a)=>{if(e&&typeof e=="object"||typeof e=="function")for(let d of ic(e))!ac.call(o,d)&&d!==s&&Oi(o,d,{get:()=>e[d],enumerable:!(a=nc(e,d))||a.enumerable});return o},sr=o=>oc(Oi({},"__esModule",{value:!0}),o),kn,ur,lr,sc,On,Pn=j(()=>{kn=new Map,ur=[],lr=(o,e,s)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let a=kn.get(o);if(a===void 0)kn.set(o,{backend:e,priority:s});else{if(a.priority>s)return;if(a.priority===s&&a.backend!==e)throw new Error(`cannot register backend "${o}" using priority ${s}`)}if(s>=0){let d=ur.indexOf(o);d!==-1&&ur.splice(d,1);for(let h=0;h<ur.length;h++)if(kn.get(ur[h]).priority<=s){ur.splice(h,0,o);return}ur.push(o)}return}throw new TypeError("not a valid backend")},sc=async o=>{let e=kn.get(o);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let s=!!e.initPromise;try{return s||(e.initPromise=e.backend.init(o)),await e.initPromise,e.initialized=!0,e.backend}catch(a){return s||(e.error=`${a}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},On=async o=>{let e=o.executionProviders||[],s=e.map(st=>typeof st=="string"?st:st.name),a=s.length===0?ur:s,d,h=[],b=new Set;for(let st of a){let $=await sc(st);typeof $=="string"?h.push({name:st,err:$}):(d||(d=$),d===$&&b.add(st))}if(!d)throw new Error(`no available backend found. ERR: ${h.map(st=>`[${st.name}] ${st.err}`).join(", ")}`);for(let{name:st,err:$}of h)s.includes(st)&&console.warn(`removing requested execution provider "${st}" from session options because it is not available: ${$}`);let et=e.filter(st=>b.has(typeof st=="string"?st:st.name));return[d,new Proxy(o,{get:(st,$)=>$==="executionProviders"?et:Reflect.get(st,$)})]}}),to=j(()=>{Pn()}),ro,no=j(()=>{ro="1.18.0-dev.20240424-218b6b0a73"}),io,gt,Pi=j(()=>{no(),io="warning",gt={wasm:{},webgl:{},webgpu:{},versions:{common:ro},set logLevel(o){if(o!==void 0){if(typeof o!="string"||["verbose","info","warning","error","fatal"].indexOf(o)===-1)throw new Error(`Unsupported logging level: ${o}`);io=o}},get logLevel(){return io}},Object.defineProperty(gt,"logLevel",{enumerable:!0})}),ke,ao=j(()=>{Pi(),ke=gt}),oo,so,uo=j(()=>{oo=(o,e)=>{let s=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);s.width=o.dims[3],s.height=o.dims[2];let a=s.getContext("2d");if(a!=null){let d,h;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(d=o.dims[2],h=o.dims[3]):(d=o.dims[3],h=o.dims[2]);let b=e?.format!==void 0?e.format:"RGB",et=e?.norm,st,$;et===void 0||et.mean===void 0?st=[255,255,255,255]:typeof et.mean=="number"?st=[et.mean,et.mean,et.mean,et.mean]:(st=[et.mean[0],et.mean[1],et.mean[2],0],et.mean[3]!==void 0&&(st[3]=et.mean[3])),et===void 0||et.bias===void 0?$=[0,0,0,0]:typeof et.bias=="number"?$=[et.bias,et.bias,et.bias,et.bias]:($=[et.bias[0],et.bias[1],et.bias[2],0],et.bias[3]!==void 0&&($[3]=et.bias[3]));let it=h*d,g=0,c=it,_=it*2,ot=-1;b==="RGBA"?(g=0,c=it,_=it*2,ot=it*3):b==="RGB"?(g=0,c=it,_=it*2):b==="RBG"&&(g=0,_=it,c=it*2);for(let ct=0;ct<h;ct++)for(let dt=0;dt<d;dt++){let pt=(o.data[g++]-$[0])*st[0],ft=(o.data[c++]-$[1])*st[1],ht=(o.data[_++]-$[2])*st[2],bt=ot===-1?255:(o.data[ot++]-$[3])*st[3];a.fillStyle="rgba("+pt+","+ft+","+ht+","+bt+")",a.fillRect(dt,ct,1,1)}if("toDataURL"in s)return s.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},so=(o,e)=>{let s=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),a;if(s!=null){let d,h,b;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(d=o.dims[2],h=o.dims[1],b=o.dims[3]):(d=o.dims[3],h=o.dims[2],b=o.dims[1]);let et=e!==void 0&&e.format!==void 0?e.format:"RGB",st=e?.norm,$,it;st===void 0||st.mean===void 0?$=[255,255,255,255]:typeof st.mean=="number"?$=[st.mean,st.mean,st.mean,st.mean]:($=[st.mean[0],st.mean[1],st.mean[2],255],st.mean[3]!==void 0&&($[3]=st.mean[3])),st===void 0||st.bias===void 0?it=[0,0,0,0]:typeof st.bias=="number"?it=[st.bias,st.bias,st.bias,st.bias]:(it=[st.bias[0],st.bias[1],st.bias[2],0],st.bias[3]!==void 0&&(it[3]=st.bias[3]));let g=h*d;if(e!==void 0&&(e.format!==void 0&&b===4&&e.format!=="RGBA"||b===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let c=4,_=0,ot=1,ct=2,dt=3,pt=0,ft=g,ht=g*2,bt=-1;et==="RGBA"?(pt=0,ft=g,ht=g*2,bt=g*3):et==="RGB"?(pt=0,ft=g,ht=g*2):et==="RBG"&&(pt=0,ht=g,ft=g*2),a=s.createImageData(d,h);for(let mt=0;mt<h*d;_+=c,ot+=c,ct+=c,dt+=c,mt++)a.data[_]=(o.data[pt++]-it[0])*$[0],a.data[ot]=(o.data[ft++]-it[1])*$[1],a.data[ct]=(o.data[ht++]-it[2])*$[2],a.data[dt]=bt===-1?255:(o.data[bt++]-it[3])*$[3]}else throw new Error("Can not access image data");return a}}),Ri,lo,co,po,mo,fo=j(()=>{Rn(),Ri=(o,e)=>{if(o===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:s,width:a}=e,d=e.norm??{mean:255,bias:0},h,b;typeof d.mean=="number"?h=[d.mean,d.mean,d.mean,d.mean]:h=[d.mean[0],d.mean[1],d.mean[2],d.mean[3]??255],typeof d.bias=="number"?b=[d.bias,d.bias,d.bias,d.bias]:b=[d.bias[0],d.bias[1],d.bias[2],d.bias[3]??0];let et=e.format!==void 0?e.format:"RGBA",st=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",$=s*a,it=st==="RGBA"?new Float32Array($*4):new Float32Array($*3),g=4,c=0,_=1,ot=2,ct=3,dt=0,pt=$,ft=$*2,ht=-1;et==="RGB"&&(g=3,c=0,_=1,ot=2,ct=-1),st==="RGBA"?ht=$*3:st==="RBG"?(dt=0,ft=$,pt=$*2):st==="BGR"&&(ft=0,pt=$,dt=$*2);for(let bt=0;bt<$;bt++,c+=g,ot+=g,_+=g,ct+=g)it[dt++]=(o[c]+b[0])/h[0],it[pt++]=(o[_]+b[1])/h[1],it[ft++]=(o[ot]+b[2])/h[2],ht!==-1&&ct!==-1&&(it[ht++]=(o[ct]+b[3])/h[3]);return st==="RGBA"?new at("float32",it,[1,4,s,a]):new at("float32",it,[1,3,s,a])},lo=async(o,e)=>{let s=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,a=typeof ImageData<"u"&&o instanceof ImageData,d=typeof ImageBitmap<"u"&&o instanceof ImageBitmap,h=typeof o=="string",b,et=e??{},st=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},$=it=>it instanceof HTMLCanvasElement||it instanceof OffscreenCanvas?it.getContext("2d"):null;if(s){let it=st();it.width=o.width,it.height=o.height;let g=$(it);if(g!=null){let c=o.height,_=o.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(c=e.resizedHeight,_=e.resizedWidth),e!==void 0){if(et=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");et.tensorFormat="RGBA",et.height=c,et.width=_}else et.tensorFormat="RGBA",et.height=c,et.width=_;g.drawImage(o,0,0),b=g.getImageData(0,0,_,c).data}else throw new Error("Can not access image data")}else if(a){let it,g;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(it=e.resizedHeight,g=e.resizedWidth):(it=o.height,g=o.width),e!==void 0&&(et=e),et.format="RGBA",et.height=it,et.width=g,e!==void 0){let c=st();c.width=g,c.height=it;let _=$(c);if(_!=null)_.putImageData(o,0,0),b=_.getImageData(0,0,g,it).data;else throw new Error("Can not access image data")}else b=o.data}else if(d){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let it=st();it.width=o.width,it.height=o.height;let g=$(it);if(g!=null){let c=o.height,_=o.width;return g.drawImage(o,0,0,_,c),b=g.getImageData(0,0,_,c).data,et.height=c,et.width=_,Ri(b,et)}else throw new Error("Can not access image data")}else{if(h)return new Promise((it,g)=>{let c=st(),_=$(c);if(!o||!_)return g();let ot=new Image;ot.crossOrigin="Anonymous",ot.src=o,ot.onload=()=>{c.width=ot.width,c.height=ot.height,_.drawImage(ot,0,0,c.width,c.height);let ct=_.getImageData(0,0,c.width,c.height);et.height=c.height,et.width=c.width,it(Ri(ct.data,et))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(b!==void 0)return Ri(b,et);throw new Error("Input data provided is not supported - aborted tensor creation")},co=(o,e)=>{let{width:s,height:a,download:d,dispose:h}=e,b=[1,a,s,4];return new at({location:"texture",type:"float32",texture:o,dims:b,download:d,dispose:h})},po=(o,e)=>{let{dataType:s,dims:a,download:d,dispose:h}=e;return new at({location:"gpu-buffer",type:s??"float32",gpuBuffer:o,dims:a,download:d,dispose:h})},mo=(o,e,s)=>new at({location:"cpu-pinned",type:o,data:e,dims:s??[e.length]})}),dr,Qr,ho,go,yo=j(()=>{dr=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Qr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),ho=!1,go=()=>{if(!ho){ho=!0;let o=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,s=typeof Float16Array<"u"&&Float16Array.from;o&&(dr.set("int64",BigInt64Array),Qr.set(BigInt64Array,"int64")),e&&(dr.set("uint64",BigUint64Array),Qr.set(BigUint64Array,"uint64")),s?(dr.set("float16",Float16Array),Qr.set(Float16Array,"float16")):dr.set("float16",Uint16Array)}}}),bo,vo,wo=j(()=>{Rn(),bo=o=>{let e=1;for(let s=0;s<o.length;s++){let a=o[s];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${s}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${s}] must be a non-negative integer, got: ${a}`);e*=a}return e},vo=(o,e)=>{switch(o.location){case"cpu":return new at(o.type,o.data,e);case"cpu-pinned":return new at({location:"cpu-pinned",data:o.data,type:o.type,dims:e});case"texture":return new at({location:"texture",texture:o.texture,type:o.type,dims:e});case"gpu-buffer":return new at({location:"gpu-buffer",gpuBuffer:o.gpuBuffer,type:o.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${o.location} is not supported`)}}}),at,Rn=j(()=>{uo(),fo(),yo(),wo(),at=class{constructor(o,e,s){go();let a,d;if(typeof o=="object"&&"location"in o)switch(this.dataLocation=o.location,a=o.type,d=o.dims,o.location){case"cpu-pinned":{let b=dr.get(a);if(!b)throw new TypeError(`unsupported type "${a}" to create tensor from pinned buffer`);if(!(o.data instanceof b))throw new TypeError(`buffer should be of type ${b.name}`);this.cpuData=o.data;break}case"texture":{if(a!=="float32")throw new TypeError(`unsupported type "${a}" to create tensor from texture`);this.gpuTextureData=o.texture,this.downloader=o.download,this.disposer=o.dispose;break}case"gpu-buffer":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="uint8"&&a!=="bool")throw new TypeError(`unsupported type "${a}" to create tensor from gpu buffer`);this.gpuBufferData=o.gpuBuffer,this.downloader=o.download,this.disposer=o.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let b,et;if(typeof o=="string")if(a=o,et=s,o==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");b=e}else{let st=dr.get(o);if(st===void 0)throw new TypeError(`Unsupported tensor type: ${o}.`);if(Array.isArray(e)){if(o==="float16"&&st===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");o==="uint64"||o==="int64"?b=st.from(e,BigInt):b=st.from(e)}else if(e instanceof st)b=e;else throw new TypeError(`A ${a} tensor's data must be type of ${st}`)}else if(et=e,Array.isArray(o)){if(o.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let st=typeof o[0];if(st==="string")a="string",b=o;else if(st==="boolean")a="bool",b=Uint8Array.from(o);else throw new TypeError(`Invalid element type of data array: ${st}.`)}else{let st=Qr.get(o.constructor);if(st===void 0)throw new TypeError(`Unsupported type for tensor data: ${o.constructor}.`);a=st,b=o}if(et===void 0)et=[b.length];else if(!Array.isArray(et))throw new TypeError("A tensor's dims must be a number array");d=et,this.cpuData=b,this.dataLocation="cpu"}let h=bo(d);if(this.cpuData&&h!==this.cpuData.length)throw new Error(`Tensor's size(${h}) does not match data length(${this.cpuData.length}).`);this.type=a,this.dims=d,this.size=h}static async fromImage(o,e){return lo(o,e)}static fromTexture(o,e){return co(o,e)}static fromGpuBuffer(o,e){return po(o,e)}static fromPinnedBuffer(o,e,s){return mo(o,e,s)}toDataURL(o){return oo(this,o)}toImageData(o){return so(this,o)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(o){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,o&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(o){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return vo(this,o)}}}),tt,zn=j(()=>{Rn(),tt=at}),Bn,$o,yt,ut,zi=j(()=>{Pi(),Bn=(o,e)=>{(typeof gt.trace>"u"?!gt.wasm.trace:!gt.trace)||console.timeStamp(`${o}::ORT::${e}`)},$o=(o,e)=>{let s=new Error().stack?.split(/\r\n|\r|\n/g)||[],a=!1;for(let d=0;d<s.length;d++){if(a&&!s[d].includes("TRACE_FUNC")){let h=`FUNC_${o}::${s[d].trim().split(" ")[1]}`;e&&(h+=`::${e}`),Bn("CPU",h);return}s[d].includes("TRACE_FUNC")&&(a=!0)}},yt=o=>{(typeof gt.trace>"u"?!gt.wasm.trace:!gt.trace)||$o("BEGIN",o)},ut=o=>{(typeof gt.trace>"u"?!gt.wasm.trace:!gt.trace)||$o("END",o)}}),Dn,_o=j(()=>{Pn(),zn(),zi(),Dn=class r_{constructor(e){this.handler=e}async run(e,s,a){yt();let d={},h={};if(typeof e!="object"||e===null||e instanceof tt||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let b=!0;if(typeof s=="object"){if(s===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(s instanceof tt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(s)){if(s.length===0)throw new TypeError("'fetches' cannot be an empty array.");b=!1;for(let $ of s){if(typeof $!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf($)===-1)throw new RangeError(`'fetches' contains invalid output name: ${$}.`);d[$]=null}if(typeof a=="object"&&a!==null)h=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let $=!1,it=Object.getOwnPropertyNames(s);for(let g of this.outputNames)if(it.indexOf(g)!==-1){let c=s[g];(c===null||c instanceof tt)&&($=!0,b=!1,d[g]=c)}if($){if(typeof a=="object"&&a!==null)h=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else h=s}}else if(typeof s<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let $ of this.inputNames)if(typeof e[$]>"u")throw new Error(`input '${$}' is missing in 'feeds'.`);if(b)for(let $ of this.outputNames)d[$]=null;let et=await this.handler.run(e,d,h),st={};for(let $ in et)if(Object.hasOwnProperty.call(et,$)){let it=et[$];it instanceof tt?st[$]=it:st[$]=new tt(it.type,it.data,it.dims)}return ut(),st}async release(){return this.handler.dispose()}static async create(e,s,a,d){yt();let h,b={};if(typeof e=="string"){if(h=e,typeof s=="object"&&s!==null)b=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(h=e,typeof s=="object"&&s!==null)b=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let it=e,g=0,c=e.byteLength;if(typeof s=="object"&&s!==null)b=s;else if(typeof s=="number"){if(g=s,!Number.isSafeInteger(g))throw new RangeError("'byteOffset' must be an integer.");if(g<0||g>=it.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${it.byteLength}).`);if(c=e.byteLength-g,typeof a=="number"){if(c=a,!Number.isSafeInteger(c))throw new RangeError("'byteLength' must be an integer.");if(c<=0||g+c>it.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${it.byteLength-g}].`);if(typeof d=="object"&&d!==null)b=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof s<"u")throw new TypeError("'options' must be an object.");h=new Uint8Array(it,g,c)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[et,st]=await On(b),$=await et.createInferenceSessionHandler(h,st);return ut(),new r_($)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),uc,xo=j(()=>{_o(),uc=Dn}),So=j(()=>{}),Co=j(()=>{}),Io=j(()=>{}),To=j(()=>{}),lc,Mn,Ao=j(()=>{Pn(),zn(),lc="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Mn=class i_{constructor(e,s,a){this.handler=e,this.hasOptimizerModel=s,this.hasEvalModel=a}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,s){let a=e.evalModel||"",d=e.optimizerModel||"",h=s||{},[b,et]=await On(h);if(b.createTrainingSessionHandler){let st=await b.createTrainingSessionHandler(e.checkpointState,e.trainModel,a,d,et);return new i_(st,!!e.optimizerModel,!!e.evalModel)}else throw new Error(lc)}typeNarrowingForRunStep(e,s,a,d,h){let b={},et={};if(typeof a!="object"||a===null||a instanceof tt||Array.isArray(a))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let st=!0;if(typeof d=="object"){if(d===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(d instanceof tt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(d)){if(d.length===0)throw new TypeError("'fetches' cannot be an empty array.");st=!1;for(let $ of d){if(typeof $!="string")throw new TypeError("'fetches' must be a string array or an object.");if(s.indexOf($)===-1)throw new RangeError(`'fetches' contains invalid output name: ${$}.`);b[$]=null}if(typeof h=="object"&&h!==null)et=h;else if(typeof h<"u")throw new TypeError("'options' must be an object.")}else{let $=!1,it=Object.getOwnPropertyNames(d);for(let g of s)if(it.indexOf(g)!==-1){let c=d[g];(c===null||c instanceof tt)&&($=!0,st=!1,b[g]=c)}if($){if(typeof h=="object"&&h!==null)et=h;else if(typeof h<"u")throw new TypeError("'options' must be an object.")}else et=d}}else if(typeof d<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let $ of e)if(typeof a[$]>"u")throw new Error(`input '${$}' is missing in 'feeds'.`);if(st)for(let $ of s)b[$]=null;return[b,et]}convertHandlerReturnTypeToMapOfTensors(e){let s={};for(let a in e)if(Object.hasOwnProperty.call(e,a)){let d=e[a];d instanceof tt?s[a]=d:s[a]=new tt(d.type,d.data,d.dims)}return s}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,s,a){let[d,h]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,s,a),b=await this.handler.runTrainStep(e,d,h);return this.convertHandlerReturnTypeToMapOfTensors(b)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,s,a){if(this.hasEvalModel){let[d,h]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,s,a),b=await this.handler.runEvalStep(e,d,h);return this.convertHandlerReturnTypeToMapOfTensors(b)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,s=!0){let a=await this.getParametersSize(s);if(e.length!==4*a)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,s)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}}),dc,Eo=j(()=>{Ao(),dc=Mn}),Bi={};kr(Bi,{InferenceSession:()=>uc,TRACE:()=>Bn,TRACE_FUNC_BEGIN:()=>yt,TRACE_FUNC_END:()=>ut,Tensor:()=>tt,TrainingSession:()=>dc,env:()=>ke,registerBackend:()=>lr});var _t=j(()=>{to(),ao(),xo(),zn(),So(),Co(),zi(),Io(),To(),Eo()}),Di={};kr(Di,{createReadStream:()=>Oo,readFile:()=>cc,readFileSync:()=>pc});var cc,pc,Oo,Mi=j(()=>{cc=void 0,pc=void 0,Oo=void 0}),Ui={};kr(Ui,{join:()=>mc});var mc,Wi=j(()=>{mc=void 0}),zo=Er((o,e)=>{var s=(()=>{var a=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(a||=__filename),function(d={}){var h=d,b,et,st=new Promise((vt,Lt)=>{b=vt,et=Lt});h.mountExternalData=(vt,Lt)=>{(h.eb||(h.eb=new Map)).set(vt,Lt)},h.unmountExternalData=()=>{delete h.eb};let $=()=>{let vt=(Vt,Jt,_n)=>(...Cn)=>{let or=E0,yr=Jt?.();Cn=Vt(...Cn);let Cr=Jt?.();return yr!==Cr&&(Vt=Cr,_n(yr),Jt=_n=null),E0!=or?vn():Cn},Lt=Vt=>async(...Jt)=>{try{if(h.cb)throw Error("Session already started");let _n=h.cb={xb:Jt[0],errors:[]},Cn=await Vt(...Jt);if(h.cb!==_n)throw Error("Session mismatch");h.kb?.flush();let or=_n.errors;if(0<or.length){let yr=await Promise.all(or);if(yr=yr.filter(Cr=>Cr),0<yr.length)throw Error(yr.join(`
`))}return Cn}finally{h.cb=null}};h._OrtCreateSession=vt(h._OrtCreateSession,()=>h._OrtCreateSession,Vt=>h._OrtCreateSession=Vt),h._OrtRun=Lt(vt(h._OrtRun,()=>h._OrtRun,Vt=>h._OrtRun=Vt)),h._OrtRunWithBinding=Lt(vt(h._OrtRunWithBinding,()=>h._OrtRunWithBinding,Vt=>h._OrtRunWithBinding=Vt)),h._OrtBindInput=vt(h._OrtBindInput,()=>h._OrtBindInput,Vt=>h._OrtBindInput=Vt),$=void 0};h.jsepInit=(vt,Lt)=>{if($?.(),vt==="webgpu"){[h.kb,h.pb,h.tb,h.lb,h.sb,h.Ra,h.ub,h.wb,h.qb,h.rb,h.vb]=Lt;let Vt=h.kb;h.jsepRegisterBuffer=(Jt,_n,Cn,or)=>Vt.registerBuffer(Jt,_n,Cn,or),h.jsepGetBuffer=Jt=>Vt.getBuffer(Jt),h.jsepCreateDownloader=(Jt,_n,Cn)=>Vt.createDownloader(Jt,_n,Cn),h.jsepOnReleaseSession=Jt=>{Vt.onReleaseSession(Jt)},h.jsepOnRunStart=Jt=>Vt.onRunStart(Jt)}};var it=Object.assign({},h),g="./this.program",c=(vt,Lt)=>{throw Lt},_=typeof window=="object",ot=typeof importScripts=="function",ct=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",dt="",pt,ft,ht;if(ct){var bt=(Mi(),sr(Di)),mt=(Wi(),sr(Ui));dt=ot?mt.dirname(dt)+"/":__dirname+"/",pt=(vt,Lt)=>(vt=h0(vt)?new URL(vt):mt.normalize(vt),bt.readFileSync(vt,Lt?void 0:"utf8")),ht=vt=>(vt=pt(vt,!0),vt.buffer||(vt=new Uint8Array(vt)),vt),ft=(vt,Lt,Vt,Jt=!0)=>{vt=h0(vt)?new URL(vt):mt.normalize(vt),bt.readFile(vt,Jt?void 0:"utf8",(_n,Cn)=>{_n?Vt(_n):Lt(Jt?Cn.buffer:Cn)})},!h.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),c=(vt,Lt)=>{throw process.exitCode=vt,Lt}}else(_||ot)&&(ot?dt=self.location.href:typeof document<"u"&&document.currentScript&&(dt=document.currentScript.src),a&&(dt=a),dt.startsWith("blob:")?dt="":dt=dt.substr(0,dt.replace(/[?#].*/,"").lastIndexOf("/")+1),pt=vt=>{var Lt=new XMLHttpRequest;return Lt.open("GET",vt,!1),Lt.send(null),Lt.responseText},ot&&(ht=vt=>{var Lt=new XMLHttpRequest;return Lt.open("GET",vt,!1),Lt.responseType="arraybuffer",Lt.send(null),new Uint8Array(Lt.response)}),ft=(vt,Lt,Vt)=>{var Jt=new XMLHttpRequest;Jt.open("GET",vt,!0),Jt.responseType="arraybuffer",Jt.onload=()=>{Jt.status==200||Jt.status==0&&Jt.response?Lt(Jt.response):Vt()},Jt.onerror=Vt,Jt.send(null)});var $t=console.log.bind(console),Tt=console.error.bind(console);Object.assign(h,it),it=null;var Nt,Ct=!1,Ft,ln,mn,yn,pn,Ht,Gt,cn,xn,dn,wn;function gn(){var vt=Nt.buffer;h.HEAP8=ln=new Int8Array(vt),h.HEAP16=yn=new Int16Array(vt),h.HEAPU8=mn=new Uint8Array(vt),h.HEAPU16=pn=new Uint16Array(vt),h.HEAP32=Ht=new Int32Array(vt),h.HEAPU32=Gt=new Uint32Array(vt),h.HEAPF32=cn=new Float32Array(vt),h.HEAPF64=wn=new Float64Array(vt),h.HEAP64=xn=new BigInt64Array(vt),h.HEAPU64=dn=new BigUint64Array(vt)}var En=[],_r=[],Sr=[],xr=0,Vr=null;function Fr(vt){throw vt="Aborted("+vt+")",Tt(vt),Ct=!0,Ft=1,vt=new WebAssembly.RuntimeError(vt+". Build with -sASSERTIONS for more info."),et(vt),vt}var _f=vt=>vt.startsWith("data:application/octet-stream;base64,"),h0=vt=>vt.startsWith("file://"),Po;if(Po="ort-wasm-simd.wasm",!_f(Po)){var No=Po;Po=h.locateFile?h.locateFile(No,dt):dt+No}function o0(vt){if(ht)return ht(vt);throw"both async and sync fetching of the wasm failed"}function t0(vt){if(_||ot){if(typeof fetch=="function"&&!h0(vt))return fetch(vt,{credentials:"same-origin"}).then(Lt=>{if(!Lt.ok)throw`failed to load wasm binary file at '${vt}'`;return Lt.arrayBuffer()}).catch(()=>o0(vt));if(ft)return new Promise((Lt,Vt)=>{ft(vt,Jt=>Lt(new Uint8Array(Jt)),Vt)})}return Promise.resolve().then(()=>o0(vt))}function xu(vt,Lt,Vt){return t0(vt).then(Jt=>WebAssembly.instantiate(Jt,Lt)).then(Vt,Jt=>{Tt(`failed to asynchronously prepare wasm: ${Jt}`),Fr(Jt)})}function M0(vt,Lt){var Vt=Po;return typeof WebAssembly.instantiateStreaming!="function"||_f(Vt)||h0(Vt)||ct||typeof fetch!="function"?xu(Vt,vt,Lt):fetch(Vt,{credentials:"same-origin"}).then(Jt=>WebAssembly.instantiateStreaming(Jt,vt).then(Lt,function(_n){return Tt(`wasm streaming compile failed: ${_n}`),Tt("falling back to ArrayBuffer instantiation"),xu(Vt,vt,Lt)}))}var k0={824936:(vt,Lt,Vt,Jt)=>{if(typeof h>"u"||!h.eb)return 1;if(vt=_i(vt>>>0),vt.startsWith("./")&&(vt=vt.substring(2)),vt=h.eb.get(vt),!vt)return 2;if(Lt>>>=0,Vt>>>=0,Lt+Vt>vt.byteLength)return 3;try{return mn.set(vt.subarray(Lt,Lt+Vt),Jt>>>0>>>0),0}catch{return 4}},825437:()=>{h.qb()},825468:()=>{h.rb()},825497:()=>{h.vb()},825522:vt=>h.pb(vt),825555:vt=>h.tb(vt),825587:(vt,Lt,Vt)=>{h.lb(vt,Lt,Vt,!0)},825626:(vt,Lt,Vt)=>{h.lb(vt,Lt,Vt)},825659:vt=>{h.Ra("Abs",vt,void 0)},825710:vt=>{h.Ra("Neg",vt,void 0)},825761:vt=>{h.Ra("Floor",vt,void 0)},825814:vt=>{h.Ra("Ceil",vt,void 0)},825866:vt=>{h.Ra("Reciprocal",vt,void 0)},825924:vt=>{h.Ra("Sqrt",vt,void 0)},825976:vt=>{h.Ra("Exp",vt,void 0)},826027:vt=>{h.Ra("Erf",vt,void 0)},826078:vt=>{h.Ra("Sigmoid",vt,void 0)},826133:(vt,Lt,Vt)=>{h.Ra("HardSigmoid",vt,{alpha:Lt,beta:Vt})},826212:vt=>{h.Ra("Log",vt,void 0)},826263:vt=>{h.Ra("Sin",vt,void 0)},826314:vt=>{h.Ra("Cos",vt,void 0)},826365:vt=>{h.Ra("Tan",vt,void 0)},826416:vt=>{h.Ra("Asin",vt,void 0)},826468:vt=>{h.Ra("Acos",vt,void 0)},826520:vt=>{h.Ra("Atan",vt,void 0)},826572:vt=>{h.Ra("Sinh",vt,void 0)},826624:vt=>{h.Ra("Cosh",vt,void 0)},826676:vt=>{h.Ra("Asinh",vt,void 0)},826729:vt=>{h.Ra("Acosh",vt,void 0)},826782:vt=>{h.Ra("Atanh",vt,void 0)},826835:vt=>{h.Ra("Tanh",vt,void 0)},826887:vt=>{h.Ra("Not",vt,void 0)},826938:(vt,Lt,Vt)=>{h.Ra("Clip",vt,{min:Lt,max:Vt})},827007:vt=>{h.Ra("Clip",vt,void 0)},827059:(vt,Lt)=>{h.Ra("Elu",vt,{alpha:Lt})},827117:vt=>{h.Ra("Relu",vt,void 0)},827169:(vt,Lt)=>{h.Ra("LeakyRelu",vt,{alpha:Lt})},827233:(vt,Lt)=>{h.Ra("ThresholdedRelu",vt,{alpha:Lt})},827303:(vt,Lt)=>{h.Ra("Cast",vt,{to:Lt})},827361:vt=>{h.Ra("Add",vt,void 0)},827412:vt=>{h.Ra("Sub",vt,void 0)},827463:vt=>{h.Ra("Mul",vt,void 0)},827514:vt=>{h.Ra("Div",vt,void 0)},827565:vt=>{h.Ra("Pow",vt,void 0)},827616:vt=>{h.Ra("Equal",vt,void 0)},827669:vt=>{h.Ra("Greater",vt,void 0)},827724:vt=>{h.Ra("GreaterOrEqual",vt,void 0)},827786:vt=>{h.Ra("Less",vt,void 0)},827838:vt=>{h.Ra("LessOrEqual",vt,void 0)},827897:(vt,Lt,Vt,Jt,_n)=>{h.Ra("ReduceMean",vt,{keepDims:!!Lt,noopWithEmptyAxes:!!Vt,axes:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},828056:(vt,Lt,Vt,Jt,_n)=>{h.Ra("ReduceMax",vt,{keepDims:!!Lt,noopWithEmptyAxes:!!Vt,axes:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},828214:(vt,Lt,Vt,Jt,_n)=>{h.Ra("ReduceMin",vt,{keepDims:!!Lt,noopWithEmptyAxes:!!Vt,axes:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},828372:(vt,Lt,Vt,Jt,_n)=>{h.Ra("ReduceProd",vt,{keepDims:!!Lt,noopWithEmptyAxes:!!Vt,axes:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},828531:(vt,Lt,Vt,Jt,_n)=>{h.Ra("ReduceSum",vt,{keepDims:!!Lt,noopWithEmptyAxes:!!Vt,axes:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},828689:(vt,Lt,Vt,Jt,_n)=>{h.Ra("ReduceL1",vt,{keepDims:!!Lt,noopWithEmptyAxes:!!Vt,axes:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},828846:(vt,Lt,Vt,Jt,_n)=>{h.Ra("ReduceL2",vt,{keepDims:!!Lt,noopWithEmptyAxes:!!Vt,axes:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},829003:(vt,Lt,Vt,Jt,_n)=>{h.Ra("ReduceLogSum",vt,{keepDims:!!Lt,noopWithEmptyAxes:!!Vt,axes:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},829164:(vt,Lt,Vt,Jt,_n)=>{h.Ra("ReduceSumSquare",vt,{keepDims:!!Lt,noopWithEmptyAxes:!!Vt,axes:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},829328:(vt,Lt,Vt,Jt,_n)=>{h.Ra("ReduceLogSumExp",vt,{keepDims:!!Lt,noopWithEmptyAxes:!!Vt,axes:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},829492:vt=>{h.Ra("Where",vt,void 0)},829545:(vt,Lt,Vt)=>{h.Ra("Transpose",vt,{perm:Lt?Array.from(Ht.subarray(Lt>>>0,Vt>>>0)):[]})},829653:(vt,Lt,Vt,Jt)=>{h.Ra("DepthToSpace",vt,{blocksize:Lt,mode:_i(Vt),format:Jt?"NHWC":"NCHW"})},829786:(vt,Lt,Vt,Jt)=>{h.Ra("DepthToSpace",vt,{blocksize:Lt,mode:_i(Vt),format:Jt?"NHWC":"NCHW"})},829919:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r,jr,e0,i0,Pt,Wt)=>{h.Ra("ConvTranspose",vt,{format:Cr?"NHWC":"NCHW",autoPad:Lt,dilations:[Vt],group:Jt,kernelShape:[_n],pads:[Cn,or],strides:[yr],wIsConst:()=>!!ln[$r>>>0],outputPadding:jr?Array.from(Ht.subarray(jr>>>0,e0>>>0)):[],outputShape:i0?Array.from(Ht.subarray(i0>>>0,Pt>>>0)):[],activation:_i(Wt)})},830320:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r,jr,e0,i0,Pt)=>{h.Ra("ConvTranspose",vt,{format:yr?"NHWC":"NCHW",autoPad:Lt,dilations:Array.from(Ht.subarray(Vt>>>0,(Vt>>>0)+2>>>0)),group:Jt,kernelShape:Array.from(Ht.subarray(_n>>>0,(_n>>>0)+2>>>0)),pads:Array.from(Ht.subarray(Cn>>>0,(Cn>>>0)+4>>>0)),strides:Array.from(Ht.subarray(or>>>0,(or>>>0)+2>>>0)),wIsConst:()=>!!ln[Cr>>>0],outputPadding:$r?Array.from(Ht.subarray($r>>>0,jr>>>0)):[],outputShape:e0?Array.from(Ht.subarray(e0>>>0,i0>>>0)):[],activation:_i(Pt)})},830885:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r,jr,e0,i0,Pt,Wt)=>{h.Ra("ConvTranspose",vt,{format:Cr?"NHWC":"NCHW",autoPad:Lt,dilations:[Vt],group:Jt,kernelShape:[_n],pads:[Cn,or],strides:[yr],wIsConst:()=>!!ln[$r>>>0],outputPadding:jr?Array.from(Ht.subarray(jr>>>0,e0>>>0)):[],outputShape:i0?Array.from(Ht.subarray(i0>>>0,Pt>>>0)):[],activation:_i(Wt)})},831286:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r,jr,e0,i0,Pt)=>{h.Ra("ConvTranspose",vt,{format:yr?"NHWC":"NCHW",autoPad:Lt,dilations:Array.from(Ht.subarray(Vt>>>0,(Vt>>>0)+2>>>0)),group:Jt,kernelShape:Array.from(Ht.subarray(_n>>>0,(_n>>>0)+2>>>0)),pads:Array.from(Ht.subarray(Cn>>>0,(Cn>>>0)+4>>>0)),strides:Array.from(Ht.subarray(or>>>0,(or>>>0)+2>>>0)),wIsConst:()=>!!ln[Cr>>>0],outputPadding:$r?Array.from(Ht.subarray($r>>>0,jr>>>0)):[],outputShape:e0?Array.from(Ht.subarray(e0>>>0,i0>>>0)):[],activation:_i(Pt)})},831851:(vt,Lt)=>{h.Ra("GlobalAveragePool",vt,{format:Lt?"NHWC":"NCHW"})},831942:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r,jr,e0,i0,Pt,Wt,un)=>{h.Ra("AveragePool",vt,{format:un?"NHWC":"NCHW",auto_pad:Lt,ceil_mode:Vt,count_include_pad:Jt,storage_order:_n,dilations:[Cn,or],kernel_shape:[yr,Cr],pads:[$r,jr,e0,i0],strides:[Pt,Wt]})},832226:(vt,Lt)=>{h.Ra("GlobalAveragePool",vt,{format:Lt?"NHWC":"NCHW"})},832317:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r,jr,e0,i0,Pt,Wt,un)=>{h.Ra("AveragePool",vt,{format:un?"NHWC":"NCHW",auto_pad:Lt,ceil_mode:Vt,count_include_pad:Jt,storage_order:_n,dilations:[Cn,or],kernel_shape:[yr,Cr],pads:[$r,jr,e0,i0],strides:[Pt,Wt]})},832601:(vt,Lt)=>{h.Ra("GlobalMaxPool",vt,{format:Lt?"NHWC":"NCHW"})},832688:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r,jr,e0,i0,Pt,Wt,un)=>{h.Ra("MaxPool",vt,{format:un?"NHWC":"NCHW",auto_pad:Lt,ceil_mode:Vt,count_include_pad:Jt,storage_order:_n,dilations:[Cn,or],kernel_shape:[yr,Cr],pads:[$r,jr,e0,i0],strides:[Pt,Wt]})},832968:(vt,Lt)=>{h.Ra("GlobalMaxPool",vt,{format:Lt?"NHWC":"NCHW"})},833055:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r,jr,e0,i0,Pt,Wt,un)=>{h.Ra("MaxPool",vt,{format:un?"NHWC":"NCHW",auto_pad:Lt,ceil_mode:Vt,count_include_pad:Jt,storage_order:_n,dilations:[Cn,or],kernel_shape:[yr,Cr],pads:[$r,jr,e0,i0],strides:[Pt,Wt]})},833335:(vt,Lt,Vt,Jt,_n)=>{h.Ra("Gemm",vt,{alpha:Lt,beta:Vt,transA:Jt,transB:_n})},833439:vt=>{h.Ra("MatMul",vt,void 0)},833493:(vt,Lt,Vt,Jt)=>{h.Ra("ArgMax",vt,{keepDims:!!Lt,selectLastIndex:!!Vt,axis:Jt})},833601:(vt,Lt,Vt,Jt)=>{h.Ra("ArgMin",vt,{keepDims:!!Lt,selectLastIndex:!!Vt,axis:Jt})},833709:(vt,Lt)=>{h.Ra("Softmax",vt,{axis:Lt})},833772:(vt,Lt)=>{h.Ra("Concat",vt,{axis:Lt})},833832:(vt,Lt,Vt,Jt,_n)=>{h.Ra("Split",vt,{axis:Lt,numOutputs:Vt,splitSizes:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},833972:vt=>{h.Ra("Expand",vt,void 0)},834026:(vt,Lt)=>{h.Ra("Gather",vt,{axis:Number(Lt)})},834097:(vt,Lt)=>{h.Ra("GatherElements",vt,{axis:Number(Lt)})},834176:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r,jr)=>{h.Ra("Resize",vt,{antialias:Lt,axes:Vt?Array.from(Ht.subarray(Vt>>>0,Jt>>>0)):[],coordinateTransformMode:_i(_n),cubicCoeffA:Cn,excludeOutside:or,extrapolationValue:yr,keepAspectRatioPolicy:_i(Cr),mode:_i($r),nearestMode:_i(jr)})},834522:(vt,Lt,Vt,Jt,_n,Cn,or)=>{h.Ra("Slice",vt,{starts:Lt?Array.from(Ht.subarray(Lt>>>0,Vt>>>0)):[],ends:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[],axes:Cn?Array.from(Ht.subarray(Cn>>>0,or>>>0)):[]})},834738:vt=>{h.Ra("Tile",vt,void 0)},834790:(vt,Lt,Vt,Jt)=>{h.Ra("LayerNormalization",vt,{axis:Lt,epsilon:Vt,simplified:!!Jt})},834901:(vt,Lt,Vt)=>{h.Ra("InstanceNormalization",vt,{epsilon:Lt,format:Vt?"NHWC":"NCHW"})},835015:(vt,Lt,Vt)=>{h.Ra("InstanceNormalization",vt,{epsilon:Lt,format:Vt?"NHWC":"NCHW"})},835129:vt=>{h.Ra("Range",vt,void 0)},835182:(vt,Lt)=>{h.Ra("Einsum",vt,{equation:_i(Lt)})},835263:(vt,Lt,Vt,Jt,_n)=>{h.Ra("Pad",vt,{mode:Lt,value:Vt,pads:Jt?Array.from(Ht.subarray(Jt>>>0,_n>>>0)):[]})},835390:(vt,Lt,Vt,Jt,_n,Cn)=>{h.Ra("BatchNormalization",vt,{epsilon:Lt,momentum:Vt,spatial:!!_n,trainingMode:!!Jt,format:Cn?"NHWC":"NCHW"})},835559:(vt,Lt,Vt,Jt,_n,Cn)=>{h.Ra("BatchNormalization",vt,{epsilon:Lt,momentum:Vt,spatial:!!_n,trainingMode:!!Jt,format:Cn?"NHWC":"NCHW"})},835728:(vt,Lt,Vt)=>{h.Ra("CumSum",vt,{exclusive:Number(Lt),reverse:Number(Vt)})},835825:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr)=>{h.Ra("Attention",vt,{numHeads:Lt,isUnidirectional:Vt,maskFilterValue:Jt,scale:_n,doRotary:Cn,qkvHiddenSizes:or?Array.from(Ht.subarray(Number(yr)>>>0,Number(yr)+or>>>0)):[],pastPresentShareBuffer:!!Cr})},836097:vt=>{h.Ra("BiasAdd",vt,void 0)},836152:vt=>{h.Ra("BiasSplitGelu",vt,void 0)},836213:vt=>{h.Ra("FastGelu",vt,void 0)},836269:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r,jr,e0,i0)=>{h.Ra("Conv",vt,{format:Cr?"NHWC":"NCHW",auto_pad:Lt,dilations:[Vt],group:Jt,kernel_shape:[_n],pads:Cn?Array.from(Ht.subarray(Cn>>>0,or>>>0)):[],strides:[yr],w_is_const:()=>!!ln[$r>>>0],activation:_i(jr),activation_params:e0?Array.from(cn.subarray(e0>>>0,i0>>>0)):[]})},836639:(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r,jr,e0,i0,Pt,Wt,un)=>{h.Ra("Conv",vt,{format:e0?"NHWC":"NCHW",auto_pad:Lt,dilations:[Vt,Jt],group:_n,kernel_shape:[Cn,or],pads:yr?Array.from(Ht.subarray(yr>>>0,Cr>>>0)):[],strides:[$r,jr],w_is_const:()=>!!ln[i0>>>0],activation:_i(Pt),activation_params:Wt?Array.from(cn.subarray(Wt>>>0,un>>>0)):[]})},837030:vt=>{h.Ra("Gelu",vt,void 0)},837082:(vt,Lt,Vt,Jt,_n,Cn)=>{h.Ra("MatMulNBits",vt,{k:Lt,n:Vt,accuracyLevel:Jt,bits:_n,blockSize:Cn})},837209:(vt,Lt,Vt,Jt,_n,Cn)=>{h.Ra("MultiHeadAttention",vt,{numHeads:Lt,isUnidirectional:Vt,maskFilterValue:Jt,scale:_n,doRotary:Cn})},837368:(vt,Lt,Vt,Jt,_n)=>{h.Ra("RotaryEmbedding",vt,{interleaved:!!Lt,numHeads:Vt,rotaryEmbeddingDim:Jt,scale:_n})},837507:(vt,Lt,Vt)=>{h.Ra("SkipLayerNormalization",vt,{epsilon:Lt,simplified:!!Vt})},837609:(vt,Lt,Vt)=>{h.Ra("SkipLayerNormalization",vt,{epsilon:Lt,simplified:!!Vt})},837711:(vt,Lt,Vt,Jt)=>{h.Ra("LayerNormalization",vt,{axis:Lt,epsilon:Vt,simplified:!!Jt})},837822:vt=>{h.ub(vt)},837856:(vt,Lt)=>h.wb(vt,Lt,h.cb.xb,h.cb.errors)};function T0(vt){this.name="ExitStatus",this.message=`Program terminated with exit(${vt})`,this.status=vt}class j0{constructor(Lt){this.hb=Lt-24}}var O0=0,v0=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,A0=(vt,Lt,Vt)=>{Lt>>>=0;var Jt=Lt+Vt;for(Vt=Lt;vt[Vt]&&!(Vt>=Jt);)++Vt;if(16<Vt-Lt&&vt.buffer&&v0)return v0.decode(vt.subarray(Lt,Vt));for(Jt="";Lt<Vt;){var _n=vt[Lt++];if(_n&128){var Cn=vt[Lt++]&63;if((_n&224)==192)Jt+=String.fromCharCode((_n&31)<<6|Cn);else{var or=vt[Lt++]&63;_n=(_n&240)==224?(_n&15)<<12|Cn<<6|or:(_n&7)<<18|Cn<<12|or<<6|vt[Lt++]&63,65536>_n?Jt+=String.fromCharCode(_n):(_n-=65536,Jt+=String.fromCharCode(55296|_n>>10,56320|_n&1023))}}else Jt+=String.fromCharCode(_n)}return Jt},_i=(vt,Lt)=>(vt>>>=0)?A0(mn,vt,Lt):"",x0=vt=>{for(var Lt=0,Vt=0;Vt<vt.length;++Vt){var Jt=vt.charCodeAt(Vt);127>=Jt?Lt++:2047>=Jt?Lt+=2:55296<=Jt&&57343>=Jt?(Lt+=4,++Vt):Lt+=3}return Lt},y0=(vt,Lt,Vt,Jt)=>{if(Vt>>>=0,!(0<Jt))return 0;var _n=Vt;Jt=Vt+Jt-1;for(var Cn=0;Cn<vt.length;++Cn){var or=vt.charCodeAt(Cn);if(55296<=or&&57343>=or){var yr=vt.charCodeAt(++Cn);or=65536+((or&1023)<<10)|yr&1023}if(127>=or){if(Vt>=Jt)break;Lt[Vt++>>>0]=or}else{if(2047>=or){if(Vt+1>=Jt)break;Lt[Vt++>>>0]=192|or>>6}else{if(65535>=or){if(Vt+2>=Jt)break;Lt[Vt++>>>0]=224|or>>12}else{if(Vt+3>=Jt)break;Lt[Vt++>>>0]=240|or>>18,Lt[Vt++>>>0]=128|or>>12&63}Lt[Vt++>>>0]=128|or>>6&63}Lt[Vt++>>>0]=128|or&63}}return Lt[Vt>>>0]=0,Vt-_n},Ro,C0=vt=>{for(var Lt="";mn[vt>>>0];)Lt+=Ro[mn[vt++>>>0]];return Lt},H0={},Z0={},S0;function q0(vt,Lt,Vt={}){var Jt=Lt.name;if(!vt)throw new S0(`type "${Jt}" must have a positive integer typeid pointer`);if(Z0.hasOwnProperty(vt)){if(Vt.nb)return;throw new S0(`Cannot register type '${Jt}' twice`)}Z0[vt]=Lt,H0.hasOwnProperty(vt)&&(Lt=H0[vt],delete H0[vt],Lt.forEach(_n=>_n()))}function $0(vt,Lt,Vt={}){if(!("argPackAdvance"in Lt))throw new TypeError("registerType registeredInstance requires argPackAdvance");return q0(vt,Lt,Vt)}var m0=(vt,Lt,Vt)=>{switch(Lt){case 1:return Vt?Jt=>ln[Jt>>>0]:Jt=>mn[Jt>>>0];case 2:return Vt?Jt=>yn[Jt>>>1>>>0]:Jt=>pn[Jt>>>1>>>0];case 4:return Vt?Jt=>Ht[Jt>>>2>>>0]:Jt=>Gt[Jt>>>2>>>0];case 8:return Vt?Jt=>xn[Jt>>>3]:Jt=>dn[Jt>>>3];default:throw new TypeError(`invalid integer width (${Lt}): ${vt}`)}},U0=[],Ir=[];function V0(vt){vt>>>=0,9<vt&&--Ir[vt+1]===0&&(Ir[vt]=void 0,U0.push(vt))}var Wo=vt=>{if(!vt)throw new S0("Cannot use deleted val. handle = "+vt);return Ir[vt]},P0=vt=>{switch(vt){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let Lt=U0.pop()||Ir.length;return Ir[Lt]=vt,Ir[Lt+1]=1,Lt}};function D0(vt){return this.fromWireType(Gt[vt>>>2>>>0])}var n0={name:"emscripten::val",fromWireType:vt=>{var Lt=Wo(vt);return V0(vt),Lt},toWireType:(vt,Lt)=>P0(Lt),argPackAdvance:8,readValueFromPointer:D0,bb:null},K0=(vt,Lt)=>{switch(Lt){case 4:return function(Vt){return this.fromWireType(cn[Vt>>>2>>>0])};case 8:return function(Vt){return this.fromWireType(wn[Vt>>>3>>>0])};default:throw new TypeError(`invalid float width (${Lt}): ${vt}`)}},ay=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Ur=(vt,Lt)=>{for(var Vt=vt>>1,Jt=Vt+Lt/2;!(Vt>=Jt)&&pn[Vt>>>0];)++Vt;if(Vt<<=1,32<Vt-vt&&ay)return ay.decode(mn.subarray(vt>>>0,Vt>>>0));for(Vt="",Jt=0;!(Jt>=Lt/2);++Jt){var _n=yn[vt+2*Jt>>>1>>>0];if(_n==0)break;Vt+=String.fromCharCode(_n)}return Vt},Yr=(vt,Lt,Vt)=>{if(Vt??=2147483647,2>Vt)return 0;Vt-=2;var Jt=Lt;Vt=Vt<2*vt.length?Vt/2:vt.length;for(var _n=0;_n<Vt;++_n)yn[Lt>>>1>>>0]=vt.charCodeAt(_n),Lt+=2;return yn[Lt>>>1>>>0]=0,Lt-Jt},qr=vt=>2*vt.length,eo=(vt,Lt)=>{for(var Vt=0,Jt="";!(Vt>=Lt/4);){var _n=Ht[vt+4*Vt>>>2>>>0];if(_n==0)break;++Vt,65536<=_n?(_n-=65536,Jt+=String.fromCharCode(55296|_n>>10,56320|_n&1023)):Jt+=String.fromCharCode(_n)}return Jt},uy=(vt,Lt,Vt)=>{if(Lt>>>=0,Vt??=2147483647,4>Vt)return 0;var Jt=Lt;Vt=Jt+Vt-4;for(var _n=0;_n<vt.length;++_n){var Cn=vt.charCodeAt(_n);if(55296<=Cn&&57343>=Cn){var or=vt.charCodeAt(++_n);Cn=65536+((Cn&1023)<<10)|or&1023}if(Ht[Lt>>>2>>>0]=Cn,Lt+=4,Lt+4>Vt)break}return Ht[Lt>>>2>>>0]=0,Lt-Jt},Y0=vt=>{for(var Lt=0,Vt=0;Vt<vt.length;++Vt){var Jt=vt.charCodeAt(Vt);55296<=Jt&&57343>=Jt&&++Vt,Lt+=4}return Lt},X0=(vt,Lt)=>{var Vt=Z0[vt];if(Vt===void 0)throw vt=by(vt),Vt=C0(vt),R0(vt),new S0(`${Lt} has unknown type ${Vt}`);return Vt},J0=(vt,Lt,Vt)=>{var Jt=[];return vt=vt.toWireType(Jt,Vt),Jt.length&&(Gt[Lt>>>2>>>0]=P0(Jt)),vt},G0=vt=>{try{vt()}catch(Lt){Fr(Lt)}},d0=vt=>{if(!Ct)try{vt();try{Ft=Ft=vt=Ft,h.onExit?.(vt),Ct=!0,c(vt,new T0(vt))}catch(Lt){Lt instanceof T0||Lt=="unwind"||c(1,Lt)}}catch(Lt){Lt instanceof T0||Lt=="unwind"||c(1,Lt)}};function ly(){var vt=Hr,Lt={};for(let[Vt,Jt]of Object.entries(vt))Lt[Vt]=typeof Jt=="function"?(..._n)=>{z0.push(Vt);try{return Jt(..._n)}finally{Ct||(z0.pop(),E0&&N0===1&&z0.length===0&&(N0=0,G0(xy),typeof Fibers<"u"&&Fibers.Db()))}}:Jt;return Lt}var N0=0,E0=null,ey=0,z0=[],ty={},ny={},cy=0,Qt=null,fn=[];function vn(){return new Promise((vt,Lt)=>{Qt={resolve:vt,reject:Lt}})}function Sn(){var vt=iy(65548),Lt=vt+12;Gt[vt>>>2>>>0]=Lt,Gt[vt+4>>>2>>>0]=Lt+65536,Lt=z0[0];var Vt=ty[Lt];return Vt===void 0&&(Vt=cy++,ty[Lt]=Vt,ny[Vt]=Lt),Ht[vt+8>>>2>>>0]=Vt,vt}function An(vt){if(!Ct){if(N0===0){var Lt=!1,Vt=!1;vt((Jt=0)=>{if(!Ct&&(ey=Jt,Lt=!0,Vt)){N0=2,G0(()=>Xr(E0)),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.resume(),Jt=!1;try{var _n=(0,Hr[ny[Ht[E0+8>>>2>>>0]]])()}catch(yr){_n=yr,Jt=!0}var Cn=!1;if(!E0){var or=Qt;or&&(Qt=null,(Jt?or.reject:or.resolve)(_n),Cn=!0)}if(Jt&&!Cn)throw _n}}),Vt=!0,Lt||(N0=1,E0=Sn(),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.pause(),G0(()=>sy(E0)))}else N0===2?(N0=0,G0(B0),R0(E0),E0=null,fn.forEach(d0)):Fr(`invalid state: ${N0}`);return ey}}function In(vt){return An(Lt=>{vt().then(Lt)})}var wr=[],Dr={},Tr=vt=>{var Lt=Dr[vt];return Lt===void 0?C0(vt):Lt},Wr=()=>typeof globalThis=="object"?globalThis:Function("return this")(),r0=vt=>{var Lt=wr.length;return wr.push(vt),Lt},g0=(vt,Lt)=>{for(var Vt=Array(vt),Jt=0;Jt<vt;++Jt)Vt[Jt]=X0(Gt[Lt+4*Jt>>>2>>>0],"parameter "+Jt);return Vt},u0=(vt,Lt)=>Object.defineProperty(Lt,"name",{value:vt});function er(vt){var Lt=Function;if(!(Lt instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof Lt} which is not a function`);var Vt=u0(Lt.name||"unknownFunctionName",function(){});return Vt.prototype=Lt.prototype,Vt=new Vt,vt=Lt.apply(Vt,vt),vt instanceof Object?vt:Vt}var Gr=vt=>vt%4===0&&(vt%100!==0||vt%400===0),s0=[0,31,60,91,121,152,182,213,244,274,305,335],I0=[0,31,59,90,120,151,181,212,243,273,304,334],b0=[],dy=(vt,Lt)=>{b0.length=0;for(var Vt;Vt=mn[vt++>>>0];){var Jt=Vt!=105;Jt&=Vt!=112,Lt+=Jt&&Lt%8?4:0,b0.push(Vt==112?Gt[Lt>>>2>>>0]:Vt==106?xn[Lt>>>3]:Vt==105?Ht[Lt>>>2>>>0]:wn[Lt>>>3>>>0]),Lt+=Jt?8:4}return b0},_0={},L0=()=>{if(!w0){var vt={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"},Lt;for(Lt in _0)_0[Lt]===void 0?delete vt[Lt]:vt[Lt]=_0[Lt];var Vt=[];for(Lt in vt)Vt.push(`${Lt}=${vt[Lt]}`);w0=Vt}return w0},w0,gy=[null,[],[]],wy=[31,29,31,30,31,30,31,31,30,31,30,31],yy=[31,28,31,30,31,30,31,31,30,31,30,31];function Sy(vt){var Lt=Array(x0(vt)+1);return y0(vt,Lt,0,Lt.length),Lt}function Ey(vt,Lt,Vt,Jt){function _n(Pt,Wt,un){for(Pt=typeof Pt=="number"?Pt.toString():Pt||"";Pt.length<Wt;)Pt=un[0]+Pt;return Pt}function Cn(Pt,Wt){return _n(Pt,Wt,"0")}function or(Pt,Wt){function un(Tn){return 0>Tn?-1:0<Tn?1:0}var bn;return(bn=un(Pt.getFullYear()-Wt.getFullYear()))===0&&(bn=un(Pt.getMonth()-Wt.getMonth()))===0&&(bn=un(Pt.getDate()-Wt.getDate())),bn}function yr(Pt){switch(Pt.getDay()){case 0:return new Date(Pt.getFullYear()-1,11,29);case 1:return Pt;case 2:return new Date(Pt.getFullYear(),0,3);case 3:return new Date(Pt.getFullYear(),0,2);case 4:return new Date(Pt.getFullYear(),0,1);case 5:return new Date(Pt.getFullYear()-1,11,31);case 6:return new Date(Pt.getFullYear()-1,11,30)}}function Cr(Pt){var Wt=Pt.$a;for(Pt=new Date(new Date(Pt.ab+1900,0,1).getTime());0<Wt;){var un=Pt.getMonth(),bn=(Gr(Pt.getFullYear())?wy:yy)[un];if(Wt>bn-Pt.getDate())Wt-=bn-Pt.getDate()+1,Pt.setDate(1),11>un?Pt.setMonth(un+1):(Pt.setMonth(0),Pt.setFullYear(Pt.getFullYear()+1));else{Pt.setDate(Pt.getDate()+Wt);break}}return un=new Date(Pt.getFullYear()+1,0,4),Wt=yr(new Date(Pt.getFullYear(),0,4)),un=yr(un),0>=or(Wt,Pt)?0>=or(un,Pt)?Pt.getFullYear()+1:Pt.getFullYear():Pt.getFullYear()-1}vt>>>=0,Lt>>>=0,Vt>>>=0,Jt>>>=0;var $r=Gt[Jt+40>>>2>>>0];Jt={Ab:Ht[Jt>>>2>>>0],zb:Ht[Jt+4>>>2>>>0],fb:Ht[Jt+8>>>2>>>0],jb:Ht[Jt+12>>>2>>>0],gb:Ht[Jt+16>>>2>>>0],ab:Ht[Jt+20>>>2>>>0],Va:Ht[Jt+24>>>2>>>0],$a:Ht[Jt+28>>>2>>>0],Cb:Ht[Jt+32>>>2>>>0],yb:Ht[Jt+36>>>2>>>0],Bb:$r?_i($r):""},Vt=_i(Vt),$r={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var jr in $r)Vt=Vt.replace(new RegExp(jr,"g"),$r[jr]);var e0="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),i0="January February March April May June July August September October November December".split(" ");$r={"%a":Pt=>e0[Pt.Va].substring(0,3),"%A":Pt=>e0[Pt.Va],"%b":Pt=>i0[Pt.gb].substring(0,3),"%B":Pt=>i0[Pt.gb],"%C":Pt=>Cn((Pt.ab+1900)/100|0,2),"%d":Pt=>Cn(Pt.jb,2),"%e":Pt=>_n(Pt.jb,2," "),"%g":Pt=>Cr(Pt).toString().substring(2),"%G":Cr,"%H":Pt=>Cn(Pt.fb,2),"%I":Pt=>(Pt=Pt.fb,Pt==0?Pt=12:12<Pt&&(Pt-=12),Cn(Pt,2)),"%j":Pt=>{for(var Wt=0,un=0;un<=Pt.gb-1;Wt+=(Gr(Pt.ab+1900)?wy:yy)[un++]);return Cn(Pt.jb+Wt,3)},"%m":Pt=>Cn(Pt.gb+1,2),"%M":Pt=>Cn(Pt.zb,2),"%n":()=>`
`,"%p":Pt=>0<=Pt.fb&&12>Pt.fb?"AM":"PM","%S":Pt=>Cn(Pt.Ab,2),"%t":()=>"	","%u":Pt=>Pt.Va||7,"%U":Pt=>Cn(Math.floor((Pt.$a+7-Pt.Va)/7),2),"%V":Pt=>{var Wt=Math.floor((Pt.$a+7-(Pt.Va+6)%7)/7);if(2>=(Pt.Va+371-Pt.$a-2)%7&&Wt++,Wt)Wt==53&&(un=(Pt.Va+371-Pt.$a)%7,un==4||un==3&&Gr(Pt.ab)||(Wt=1));else{Wt=52;var un=(Pt.Va+7-Pt.$a-1)%7;(un==4||un==5&&Gr(Pt.ab%400-1))&&Wt++}return Cn(Wt,2)},"%w":Pt=>Pt.Va,"%W":Pt=>Cn(Math.floor((Pt.$a+7-(Pt.Va+6)%7)/7),2),"%y":Pt=>(Pt.ab+1900).toString().substring(2),"%Y":Pt=>Pt.ab+1900,"%z":Pt=>{Pt=Pt.yb;var Wt=0<=Pt;return Pt=Math.abs(Pt)/60,(Wt?"+":"-")+("0000"+(Pt/60*100+Pt%60)).slice(-4)},"%Z":Pt=>Pt.Bb,"%%":()=>"%"},Vt=Vt.replace(/%%/g,"\0\0");for(jr in $r)Vt.includes(jr)&&(Vt=Vt.replace(new RegExp(jr,"g"),$r[jr](Jt)));return Vt=Vt.replace(/\0\0/g,"%"),jr=Sy(Vt),jr.length>Lt?0:(ln.set(jr,vt>>>0),jr.length-1)}for(var ky=Array(256),ry=0;256>ry;++ry)ky[ry]=String.fromCharCode(ry);Ro=ky,S0=h.BindingError=class extends Error{constructor(vt){super(vt),this.name="BindingError"}},h.InternalError=class extends Error{constructor(vt){super(vt),this.name="InternalError"}},Ir.push(0,1,void 0,1,null,1,!0,1,!1,1),h.count_emval_handles=()=>Ir.length/2-5-U0.length;var vy={ia:function(vt,Lt,Vt){return In(async()=>{await h.sb(vt,Lt,Vt)})},a:function(vt,Lt,Vt){vt>>>=0;var Jt=new j0(vt);throw Gt[Jt.hb+16>>>2>>>0]=0,Gt[Jt.hb+4>>>2>>>0]=Lt>>>0,Gt[Jt.hb+8>>>2>>>0]=Vt>>>0,O0=vt,O0},z:function(){return 0},ea:function(){},R:function(){},T:function(){},ga:function(){return 0},ca:function(){},Z:function(){},ba:function(){},G:function(){},S:function(){},P:function(){},da:function(){},Q:function(){},C:function(vt,Lt,Vt){Lt=C0(Lt>>>0),$0(vt>>>0,{name:Lt,fromWireType:Jt=>Jt,toWireType:function(Jt,_n){if(typeof _n!="bigint"&&typeof _n!="number")throw _n===null?_n="null":(Jt=typeof _n,_n=Jt==="object"||Jt==="array"||Jt==="function"?_n.toString():""+_n),new TypeError(`Cannot convert "${_n}" to ${this.name}`);return typeof _n=="number"&&(_n=BigInt(_n)),_n},argPackAdvance:8,readValueFromPointer:m0(Lt,Vt>>>0,Lt.indexOf("u")==-1),bb:null})},K:function(vt,Lt,Vt,Jt){Lt=C0(Lt>>>0),$0(vt>>>0,{name:Lt,fromWireType:function(_n){return!!_n},toWireType:function(_n,Cn){return Cn?Vt:Jt},argPackAdvance:8,readValueFromPointer:function(_n){return this.fromWireType(mn[_n>>>0])},bb:null})},J:function(vt){return $0(vt>>>0,n0)},B:function(vt,Lt,Vt){Lt=C0(Lt>>>0),$0(vt>>>0,{name:Lt,fromWireType:Jt=>Jt,toWireType:(Jt,_n)=>_n,argPackAdvance:8,readValueFromPointer:K0(Lt,Vt>>>0),bb:null})},s:function(vt,Lt,Vt,Jt,_n){if(vt>>>=0,Vt>>>=0,Lt=C0(Lt>>>0),_n===-1&&(_n=4294967295),_n=yr=>yr,Jt===0){var Cn=32-8*Vt;_n=yr=>yr<<Cn>>>Cn}var or=Lt.includes("unsigned")?function(yr,Cr){return Cr>>>0}:function(yr,Cr){return Cr};$0(vt,{name:Lt,fromWireType:_n,toWireType:or,argPackAdvance:8,readValueFromPointer:m0(Lt,Vt,Jt!==0),bb:null})},o:function(vt,Lt,Vt){function Jt(Cn){return new _n(ln.buffer,Gt[Cn+4>>>2>>>0],Gt[Cn>>>2>>>0])}var _n=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][Lt];Vt=C0(Vt>>>0),$0(vt>>>0,{name:Vt,fromWireType:Jt,argPackAdvance:8,readValueFromPointer:Jt},{nb:!0})},D:function(vt,Lt){Lt=C0(Lt>>>0);var Vt=Lt==="std::string";$0(vt>>>0,{name:Lt,fromWireType:function(Jt){var _n=Gt[Jt>>>2>>>0],Cn=Jt+4;if(Vt)for(var or=Cn,yr=0;yr<=_n;++yr){var Cr=Cn+yr;if(yr==_n||mn[Cr>>>0]==0){if(or=_i(or,Cr-or),$r===void 0)var $r=or;else $r+="\0",$r+=or;or=Cr+1}}else{for($r=Array(_n),yr=0;yr<_n;++yr)$r[yr]=String.fromCharCode(mn[Cn+yr>>>0]);$r=$r.join("")}return R0(Jt),$r},toWireType:function(Jt,_n){_n instanceof ArrayBuffer&&(_n=new Uint8Array(_n));var Cn=typeof _n=="string";if(!(Cn||_n instanceof Uint8Array||_n instanceof Uint8ClampedArray||_n instanceof Int8Array))throw new S0("Cannot pass non-string to std::string");var or=Vt&&Cn?x0(_n):_n.length,yr=iy(4+or+1),Cr=yr+4;if(Gt[yr>>>2>>>0]=or,Vt&&Cn)y0(_n,mn,Cr,or+1);else if(Cn)for(Cn=0;Cn<or;++Cn){var $r=_n.charCodeAt(Cn);if(255<$r)throw R0(Cr),new S0("String has UTF-16 code units that do not fit in 8 bits");mn[Cr+Cn>>>0]=$r}else for(Cn=0;Cn<or;++Cn)mn[Cr+Cn>>>0]=_n[Cn];return Jt!==null&&Jt.push(R0,yr),yr},argPackAdvance:8,readValueFromPointer:D0,bb(Jt){R0(Jt)}})},y:function(vt,Lt,Vt){if(Lt>>>=0,Vt>>>=0,Vt=C0(Vt),Lt===2)var Jt=Ur,_n=Yr,Cn=qr,or=yr=>pn[yr>>>1>>>0];else Lt===4&&(Jt=eo,_n=uy,Cn=Y0,or=yr=>Gt[yr>>>2>>>0]);$0(vt>>>0,{name:Vt,fromWireType:yr=>{for(var Cr=Gt[yr>>>2>>>0],$r,jr=yr+4,e0=0;e0<=Cr;++e0){var i0=yr+4+e0*Lt;(e0==Cr||or(i0)==0)&&(jr=Jt(jr,i0-jr),$r===void 0?$r=jr:($r+="\0",$r+=jr),jr=i0+Lt)}return R0(yr),$r},toWireType:(yr,Cr)=>{if(typeof Cr!="string")throw new S0(`Cannot pass non-string to C++ string type ${Vt}`);var $r=Cn(Cr),jr=iy(4+$r+Lt);return Gt[jr>>>2>>>0]=$r/Lt,_n(Cr,jr+4,$r+Lt),yr!==null&&yr.push(R0,jr),jr},argPackAdvance:8,readValueFromPointer:D0,bb(yr){R0(yr)}})},L:function(vt,Lt){Lt=C0(Lt>>>0),$0(vt>>>0,{ob:!0,name:Lt,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ha:()=>1,u:function(vt,Lt,Vt){return Lt>>>=0,Vt>>>=0,vt=Wo(vt>>>0),Lt=X0(Lt,"emval::as"),J0(Lt,Vt,vt)},x:function(vt){return vt>>>=0,In(()=>(vt=Wo(vt),vt.then(P0)))},n:function(vt,Lt,Vt,Jt){return Vt>>>=0,Jt>>>=0,vt=wr[vt>>>0],Lt=Wo(Lt>>>0),vt(null,Lt,Vt,Jt)},j:function(vt,Lt,Vt,Jt,_n){return Vt>>>=0,Jt>>>=0,_n>>>=0,vt=wr[vt>>>0],Lt=Wo(Lt>>>0),Vt=Tr(Vt),vt(Lt,Lt[Vt],Jt,_n)},b:V0,w:function(vt,Lt){return Lt>>>=0,vt=Wo(vt>>>0),Lt=Wo(Lt),vt==Lt},m:function(vt){return vt>>>=0,vt===0?P0(Wr()):(vt=Tr(vt),P0(Wr()[vt]))},i:function(vt,Lt,Vt){Lt=g0(vt,Lt>>>0);var Jt=Lt.shift();vt--;var _n=`return function (obj, func, destructorsRef, args) {
`,Cn=0,or=[];Vt===0&&or.push("obj");for(var yr=["retType"],Cr=[Jt],$r=0;$r<vt;++$r)or.push("arg"+$r),yr.push("argType"+$r),Cr.push(Lt[$r]),_n+=`  var arg${$r} = argType${$r}.readValueFromPointer(args${Cn?"+"+Cn:""});
`,Cn+=Lt[$r].argPackAdvance;return _n+=`  var rv = ${Vt===1?"new func":"func.call"}(${or.join(", ")});
`,Jt.ob||(yr.push("emval_returnValue"),Cr.push(J0),_n+=`  return emval_returnValue(retType, destructorsRef, rv);
`),yr.push(_n+`};
`),vt=er(yr)(...Cr),Vt=`methodCaller<(${Lt.map(jr=>jr.name).join(", ")}) => ${Jt.name}>`,r0(u0(Vt,vt))},r:function(vt,Lt){return Lt>>>=0,vt=Wo(vt>>>0),Lt=Wo(Lt),P0(vt[Lt])},e:function(vt){vt>>>=0,9<vt&&(Ir[vt+1]+=1)},t:function(){return P0([])},l:function(vt){vt=Wo(vt>>>0);for(var Lt=Array(vt.length),Vt=0;Vt<vt.length;Vt++)Lt[Vt]=vt[Vt];return P0(Lt)},f:function(vt){return P0(Tr(vt>>>0))},k:function(){return P0({})},h:function(vt){vt>>>=0;for(var Lt=Wo(vt);Lt.length;){var Vt=Lt.pop();Lt.pop()(Vt)}V0(vt)},g:function(vt,Lt,Vt){Lt>>>=0,Vt>>>=0,vt=Wo(vt>>>0),Lt=Wo(Lt),Vt=Wo(Vt),vt[Lt]=Vt},c:function(vt,Lt){return Lt>>>=0,vt=X0(vt>>>0,"_emval_take_value"),vt=vt.readValueFromPointer(Lt),P0(vt)},W:function(vt,Lt){vt=-9007199254740992>vt||9007199254740992<vt?NaN:Number(vt),Lt>>>=0,vt=new Date(1e3*vt),Ht[Lt>>>2>>>0]=vt.getUTCSeconds(),Ht[Lt+4>>>2>>>0]=vt.getUTCMinutes(),Ht[Lt+8>>>2>>>0]=vt.getUTCHours(),Ht[Lt+12>>>2>>>0]=vt.getUTCDate(),Ht[Lt+16>>>2>>>0]=vt.getUTCMonth(),Ht[Lt+20>>>2>>>0]=vt.getUTCFullYear()-1900,Ht[Lt+24>>>2>>>0]=vt.getUTCDay(),Ht[Lt+28>>>2>>>0]=(vt.getTime()-Date.UTC(vt.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},X:function(vt,Lt){vt=-9007199254740992>vt||9007199254740992<vt?NaN:Number(vt),Lt>>>=0,vt=new Date(1e3*vt),Ht[Lt>>>2>>>0]=vt.getSeconds(),Ht[Lt+4>>>2>>>0]=vt.getMinutes(),Ht[Lt+8>>>2>>>0]=vt.getHours(),Ht[Lt+12>>>2>>>0]=vt.getDate(),Ht[Lt+16>>>2>>>0]=vt.getMonth(),Ht[Lt+20>>>2>>>0]=vt.getFullYear()-1900,Ht[Lt+24>>>2>>>0]=vt.getDay(),Ht[Lt+28>>>2>>>0]=(Gr(vt.getFullYear())?s0:I0)[vt.getMonth()]+vt.getDate()-1|0,Ht[Lt+36>>>2>>>0]=-(60*vt.getTimezoneOffset());var Vt=new Date(vt.getFullYear(),6,1).getTimezoneOffset(),Jt=new Date(vt.getFullYear(),0,1).getTimezoneOffset();Ht[Lt+32>>>2>>>0]=(Vt!=Jt&&vt.getTimezoneOffset()==Math.min(Jt,Vt))|0},Y:function(vt){vt>>>=0;var Lt=new Date(Ht[vt+20>>>2>>>0]+1900,Ht[vt+16>>>2>>>0],Ht[vt+12>>>2>>>0],Ht[vt+8>>>2>>>0],Ht[vt+4>>>2>>>0],Ht[vt>>>2>>>0],0),Vt=Ht[vt+32>>>2>>>0],Jt=Lt.getTimezoneOffset(),_n=new Date(Lt.getFullYear(),6,1).getTimezoneOffset(),Cn=new Date(Lt.getFullYear(),0,1).getTimezoneOffset(),or=Math.min(Cn,_n);return 0>Vt?Ht[vt+32>>>2>>>0]=+(_n!=Cn&&or==Jt):0<Vt!=(or==Jt)&&(_n=Math.max(Cn,_n),Lt.setTime(Lt.getTime()+6e4*((0<Vt?or:_n)-Jt))),Ht[vt+24>>>2>>>0]=Lt.getDay(),Ht[vt+28>>>2>>>0]=(Gr(Lt.getFullYear())?s0:I0)[Lt.getMonth()]+Lt.getDate()-1|0,Ht[vt>>>2>>>0]=Lt.getSeconds(),Ht[vt+4>>>2>>>0]=Lt.getMinutes(),Ht[vt+8>>>2>>>0]=Lt.getHours(),Ht[vt+12>>>2>>>0]=Lt.getDate(),Ht[vt+16>>>2>>>0]=Lt.getMonth(),Ht[vt+20>>>2>>>0]=Lt.getYear(),vt=Lt.getTime(),BigInt(isNaN(vt)?-1:vt/1e3)},U:function(){return-52},V:function(){},N:function(vt,Lt,Vt,Jt){Vt>>>=0,Jt>>>=0;var _n=new Date().getFullYear(),Cn=new Date(_n,0,1),or=new Date(_n,6,1);_n=Cn.getTimezoneOffset();var yr=or.getTimezoneOffset();Gt[vt>>>0>>>2>>>0]=60*Math.max(_n,yr),Ht[Lt>>>0>>>2>>>0]=+(_n!=yr),vt=Cr=>Cr.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],Cn=vt(Cn),or=vt(or),yr<_n?(y0(Cn,mn,Vt,17),y0(or,mn,Jt,17)):(y0(Cn,mn,Jt,17),y0(or,mn,Vt,17))},v:()=>{Fr("")},d:function(vt,Lt,Vt){return vt>>>=0,Lt=dy(Lt>>>0,Vt>>>0),k0[vt](...Lt)},I:function(vt,Lt,Vt){return vt>>>=0,Lt=dy(Lt>>>0,Vt>>>0),k0[vt](...Lt)},H:()=>Date.now(),O:function(){return 4294901760},q:()=>performance.now(),M:function(vt){vt>>>=0;var Lt=mn.length;if(4294901760<vt)return!1;for(var Vt=1;4>=Vt;Vt*=2){var Jt=Lt*(1+.2/Vt);Jt=Math.min(Jt,vt+100663296);var _n=Math;Jt=Math.max(vt,Jt);e:{_n=(_n.min.call(_n,4294901760,Jt+(65536-Jt%65536)%65536)-Nt.buffer.byteLength+65535)/65536;try{Nt.grow(_n),gn();var Cn=1;break e}catch{}Cn=void 0}if(Cn)return!0}return!1},$:function(vt,Lt){vt>>>=0,Lt>>>=0;var Vt=0;return L0().forEach((Jt,_n)=>{var Cn=Lt+Vt;for(_n=Gt[vt+4*_n>>>2>>>0]=Cn,Cn=0;Cn<Jt.length;++Cn)ln[_n++>>>0]=Jt.charCodeAt(Cn);ln[_n>>>0]=0,Vt+=Jt.length+1}),0},aa:function(vt,Lt){vt>>>=0,Lt>>>=0;var Vt=L0();Gt[vt>>>2>>>0]=Vt.length;var Jt=0;return Vt.forEach(_n=>Jt+=_n.length+1),Gt[Lt>>>2>>>0]=Jt,0},A:()=>52,F:function(){return 52},_:function(){return 70},E:function(vt,Lt,Vt,Jt){Lt>>>=0,Vt>>>=0,Jt>>>=0;for(var _n=0,Cn=0;Cn<Vt;Cn++){var or=Gt[Lt>>>2>>>0],yr=Gt[Lt+4>>>2>>>0];Lt+=8;for(var Cr=0;Cr<yr;Cr++){var $r=mn[or+Cr>>>0],jr=gy[vt];$r===0||$r===10?((vt===1?$t:Tt)(A0(jr,0)),jr.length=0):jr.push($r)}_n+=yr}return Gt[Jt>>>2>>>0]=_n,0},fa:Ey,p:function(vt,Lt,Vt,Jt){return Ey(vt>>>0,Lt>>>0,Vt>>>0,Jt>>>0)}},Hr=function(){function vt(Vt){return Hr=Vt.exports,Hr=ly(),Hr=ns(),Nt=Hr.ja,gn(),_r.unshift(Hr.ka),xr--,xr==0&&Vr&&(Vt=Vr,Vr=null,Vt()),Hr}var Lt={a:vy};if(xr++,h.instantiateWasm)try{return h.instantiateWasm(Lt,vt)}catch(Vt){Tt(`Module.instantiateWasm callback failed with error: ${Vt}`),et(Vt)}return M0(Lt,function(Vt){vt(Vt.instance)}).catch(et),{}}(),by=vt=>(by=Hr.la)(vt);h._OrtInit=(vt,Lt)=>(h._OrtInit=Hr.ma)(vt,Lt),h._OrtGetLastError=(vt,Lt)=>(h._OrtGetLastError=Hr.na)(vt,Lt),h._OrtCreateSessionOptions=(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r)=>(h._OrtCreateSessionOptions=Hr.oa)(vt,Lt,Vt,Jt,_n,Cn,or,yr,Cr,$r),h._OrtAppendExecutionProvider=(vt,Lt)=>(h._OrtAppendExecutionProvider=Hr.pa)(vt,Lt),h._OrtAddFreeDimensionOverride=(vt,Lt,Vt)=>(h._OrtAddFreeDimensionOverride=Hr.qa)(vt,Lt,Vt),h._OrtAddSessionConfigEntry=(vt,Lt,Vt)=>(h._OrtAddSessionConfigEntry=Hr.ra)(vt,Lt,Vt),h._OrtReleaseSessionOptions=vt=>(h._OrtReleaseSessionOptions=Hr.sa)(vt),h._OrtCreateSession=(vt,Lt,Vt)=>(h._OrtCreateSession=Hr.ta)(vt,Lt,Vt),h._OrtReleaseSession=vt=>(h._OrtReleaseSession=Hr.ua)(vt),h._OrtGetInputOutputCount=(vt,Lt,Vt)=>(h._OrtGetInputOutputCount=Hr.va)(vt,Lt,Vt),h._OrtGetInputName=(vt,Lt)=>(h._OrtGetInputName=Hr.wa)(vt,Lt),h._OrtGetOutputName=(vt,Lt)=>(h._OrtGetOutputName=Hr.xa)(vt,Lt),h._OrtFree=vt=>(h._OrtFree=Hr.ya)(vt),h._OrtCreateTensor=(vt,Lt,Vt,Jt,_n,Cn)=>(h._OrtCreateTensor=Hr.za)(vt,Lt,Vt,Jt,_n,Cn),h._OrtGetTensorData=(vt,Lt,Vt,Jt,_n)=>(h._OrtGetTensorData=Hr.Aa)(vt,Lt,Vt,Jt,_n),h._OrtReleaseTensor=vt=>(h._OrtReleaseTensor=Hr.Ba)(vt),h._OrtCreateRunOptions=(vt,Lt,Vt,Jt)=>(h._OrtCreateRunOptions=Hr.Ca)(vt,Lt,Vt,Jt),h._OrtAddRunConfigEntry=(vt,Lt,Vt)=>(h._OrtAddRunConfigEntry=Hr.Da)(vt,Lt,Vt),h._OrtReleaseRunOptions=vt=>(h._OrtReleaseRunOptions=Hr.Ea)(vt),h._OrtCreateBinding=vt=>(h._OrtCreateBinding=Hr.Fa)(vt),h._OrtBindInput=(vt,Lt,Vt)=>(h._OrtBindInput=Hr.Ga)(vt,Lt,Vt),h._OrtBindOutput=(vt,Lt,Vt,Jt)=>(h._OrtBindOutput=Hr.Ha)(vt,Lt,Vt,Jt),h._OrtClearBoundOutputs=vt=>(h._OrtClearBoundOutputs=Hr.Ia)(vt),h._OrtReleaseBinding=vt=>(h._OrtReleaseBinding=Hr.Ja)(vt),h._OrtRunWithBinding=(vt,Lt,Vt,Jt,_n)=>(h._OrtRunWithBinding=Hr.Ka)(vt,Lt,Vt,Jt,_n),h._OrtRun=(vt,Lt,Vt,Jt,_n,Cn,or,yr)=>(h._OrtRun=Hr.La)(vt,Lt,Vt,Jt,_n,Cn,or,yr),h._OrtEndProfiling=vt=>(h._OrtEndProfiling=Hr.Ma)(vt),h._JsepOutput=(vt,Lt,Vt)=>(h._JsepOutput=Hr.Na)(vt,Lt,Vt),h._JsepGetNodeName=vt=>(h._JsepGetNodeName=Hr.Oa)(vt);var iy=h._malloc=vt=>(iy=h._malloc=Hr.Pa)(vt),R0=h._free=vt=>(R0=h._free=Hr.Qa)(vt),oy=vt=>(oy=Hr.Sa)(vt),fy=vt=>(fy=Hr.Ta)(vt),_y=()=>(_y=Hr.Ua)(),sy=vt=>(sy=Hr.Wa)(vt),xy=()=>(xy=Hr.Xa)(),Xr=vt=>(Xr=Hr.Ya)(vt),B0=()=>(B0=Hr.Za)();h.___start_em_js=837968,h.___stop_em_js=838129;function ns(){var vt=Hr;vt=Object.assign({},vt);var Lt=Vt=>Jt=>Vt(Jt)>>>0;return vt.la=Lt(vt.la),vt.Pa=Lt(vt.Pa),vt.Ta=Lt(vt.Ta),vt.Ua=(Vt=>()=>Vt()>>>0)(vt.Ua),vt}h.stackSave=()=>_y(),h.stackRestore=vt=>oy(vt),h.stackAlloc=vt=>fy(vt),h.UTF8ToString=_i,h.stringToUTF8=(vt,Lt,Vt)=>y0(vt,mn,Lt,Vt),h.lengthBytesUTF8=x0;var Zr;Vr=function vt(){Zr||hy(),Zr||(Vr=vt)};function hy(){if(!(0<xr)){if(h.preRun)for(typeof h.preRun=="function"&&(h.preRun=[h.preRun]);h.preRun.length;){var vt=h.preRun.shift();En.unshift(vt)}for(;0<En.length;)En.shift()(h);if(!(0<xr||Zr||(Zr=!0,h.calledRun=!0,Ct))){for(;0<_r.length;)_r.shift()(h);for(b(h);0<Sr.length;)Sr.shift()(h)}}}return hy(),st}})();typeof o=="object"&&typeof e=="object"?e.exports=s:typeof define=="function"&&define.amd&&define([],()=>s)}),Bo=Er(()=>{}),Do=Er(()=>{}),Mo={};kr(Mo,{cpus:()=>fc});var fc,Uo=j(()=>{fc=void 0}),Vo=Er((o,e)=>{var s=(()=>{var a=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(a||=__filename),function(d={}){function h(){return wn.buffer!=Sr.buffer&&xu(),Sr}function b(){return wn.buffer!=Sr.buffer&&xu(),xr}function et(){return wn.buffer!=Sr.buffer&&xu(),Vr}function st(){return wn.buffer!=Sr.buffer&&xu(),Fr}function $(){return wn.buffer!=Sr.buffer&&xu(),_f}function it(){return wn.buffer!=Sr.buffer&&xu(),h0}function g(){return wn.buffer!=Sr.buffer&&xu(),Po}function c(){return wn.buffer!=Sr.buffer&&xu(),t0}var _=d,ot,ct,dt=new Promise((wt,It)=>{ot=wt,ct=It});_.mountExternalData=(wt,It)=>{(_.Db||(_.Db=new Map)).set(wt,It)},_.unmountExternalData=()=>{delete _.Db};let pt=()=>{let wt=(jt,qt,hn)=>(...$n)=>{let ir=B0,ar=qt?.();$n=jt(...$n);let Mr=qt?.();return ar!==Mr&&(jt=Mr,hn(ar),qt=hn=null),B0!=ir?_n():$n},It=jt=>async(...qt)=>{try{if(_.Cb)throw Error("Session already started");let hn=_.Cb={ec:qt[0],errors:[]},$n=await jt(...qt);if(_.Cb!==hn)throw Error("Session mismatch");_.Kb?.flush();let ir=hn.errors;if(0<ir.length){let ar=await Promise.all(ir);if(ar=ar.filter(Mr=>Mr),0<ar.length)throw Error(ar.join(`
`))}return $n}finally{_.Cb=null}};_._OrtCreateSession=wt(_._OrtCreateSession,()=>_._OrtCreateSession,jt=>_._OrtCreateSession=jt),_._OrtRun=It(wt(_._OrtRun,()=>_._OrtRun,jt=>_._OrtRun=jt)),_._OrtRunWithBinding=It(wt(_._OrtRunWithBinding,()=>_._OrtRunWithBinding,jt=>_._OrtRunWithBinding=jt)),_._OrtBindInput=wt(_._OrtBindInput,()=>_._OrtBindInput,jt=>_._OrtBindInput=jt),pt=void 0};_.jsepInit=(wt,It)=>{if(pt?.(),wt==="webgpu"){[_.Kb,_.Wb,_.$b,_.Lb,_.Zb,_.ob,_.ac,_.cc,_.Xb,_.Yb,_.bc]=It;let jt=_.Kb;_.jsepRegisterBuffer=(qt,hn,$n,ir)=>jt.registerBuffer(qt,hn,$n,ir),_.jsepGetBuffer=qt=>jt.getBuffer(qt),_.jsepCreateDownloader=(qt,hn,$n)=>jt.createDownloader(qt,hn,$n),_.jsepOnReleaseSession=qt=>{jt.onReleaseSession(qt)},_.jsepOnRunStart=qt=>jt.onRunStart(qt)}};var ft=Object.assign({},_),ht="./this.program",bt=(wt,It)=>{throw It},mt=typeof window=="object",$t=typeof importScripts=="function",Tt=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",Nt=_.ENVIRONMENT_IS_PTHREAD||!1,Ct="";function Ft(wt){return _.locateFile?_.locateFile(wt,Ct):Ct+wt}var ln,mn,yn;if(Tt){var pn=(Mi(),sr(Di)),Ht=(Wi(),sr(Ui));Ct=$t?Ht.dirname(Ct)+"/":__dirname+"/",ln=(wt,It)=>(wt=y0(wt)?new URL(wt):Ht.normalize(wt),pn.readFileSync(wt,It?void 0:"utf8")),yn=wt=>(wt=ln(wt,!0),wt.buffer||(wt=new Uint8Array(wt)),wt),mn=(wt,It,jt,qt=!0)=>{wt=y0(wt)?new URL(wt):Ht.normalize(wt),pn.readFile(wt,qt?void 0:"utf8",(hn,$n)=>{hn?jt(hn):It(qt?$n.buffer:$n)})},!_.thisProgram&&1<process.argv.length&&(ht=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),bt=(wt,It)=>{throw process.exitCode=wt,It},global.Worker=Bo().Worker}else(mt||$t)&&($t?Ct=self.location.href:typeof document<"u"&&document.currentScript&&(Ct=document.currentScript.src),typeof a<"u"&&a&&(Ct=a),Ct.startsWith("blob:")?Ct="":Ct=Ct.substr(0,Ct.replace(/[?#].*/,"").lastIndexOf("/")+1),Tt||(ln=wt=>{var It=new XMLHttpRequest;return It.open("GET",wt,!1),It.send(null),It.responseText},$t&&(yn=wt=>{var It=new XMLHttpRequest;return It.open("GET",wt,!1),It.responseType="arraybuffer",It.send(null),new Uint8Array(It.response)}),mn=(wt,It,jt)=>{var qt=new XMLHttpRequest;qt.open("GET",wt,!0),qt.responseType="arraybuffer",qt.onload=()=>{qt.status==200||qt.status==0&&qt.response?It(qt.response):jt()},qt.onerror=jt,qt.send(null)}));Tt&&typeof performance>"u"&&(global.performance=Do().performance);var Gt=console.log.bind(console),cn=console.error.bind(console);Tt&&(Gt=(...wt)=>pn.writeSync(1,wt.join(" ")+`
`),cn=(...wt)=>pn.writeSync(2,wt.join(" ")+`
`));var xn=Gt,dn=cn;Object.assign(_,ft),ft=null;var wn,gn,En=!1,_r,Sr,xr,Vr,Fr,_f,h0,Po,No,o0,t0;function xu(){var wt=wn.buffer;_.HEAP8=Sr=new Int8Array(wt),_.HEAP16=Vr=new Int16Array(wt),_.HEAPU8=xr=new Uint8Array(wt),_.HEAPU16=Fr=new Uint16Array(wt),_.HEAP32=_f=new Int32Array(wt),_.HEAPU32=h0=new Uint32Array(wt),_.HEAPF32=Po=new Float32Array(wt),_.HEAPF64=t0=new Float64Array(wt),_.HEAP64=No=new BigInt64Array(wt),_.HEAPU64=o0=new BigUint64Array(wt)}var M0=16777216;if(Nt)wn=_.wasmMemory;else if(_.wasmMemory)wn=_.wasmMemory;else if(wn=new WebAssembly.Memory({initial:M0/65536,maximum:65536,shared:!0}),!(wn.buffer instanceof SharedArrayBuffer))throw dn("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Tt&&dn("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");xu(),M0=wn.buffer.byteLength;var k0=[],T0=[],j0=[],O0=0,v0=null;function A0(){if(O0--,O0==0&&v0){var wt=v0;v0=null,wt()}}function _i(wt){throw wt="Aborted("+wt+")",dn(wt),En=!0,_r=1,wt=new WebAssembly.RuntimeError(wt+". Build with -sASSERTIONS for more info."),ct(wt),wt}var x0=wt=>wt.startsWith("data:application/octet-stream;base64,"),y0=wt=>wt.startsWith("file://"),Ro;Ro="ort-wasm-simd-threaded.wasm",x0(Ro)||(Ro=Ft(Ro));function C0(wt){if(yn)return yn(wt);throw"both async and sync fetching of the wasm failed"}function H0(wt){if(mt||$t){if(typeof fetch=="function"&&!y0(wt))return fetch(wt,{credentials:"same-origin"}).then(It=>{if(!It.ok)throw`failed to load wasm binary file at '${wt}'`;return It.arrayBuffer()}).catch(()=>C0(wt));if(mn)return new Promise((It,jt)=>{mn(wt,qt=>It(new Uint8Array(qt)),jt)})}return Promise.resolve().then(()=>C0(wt))}function Z0(wt,It,jt){return H0(wt).then(qt=>WebAssembly.instantiate(qt,It)).then(jt,qt=>{dn(`failed to asynchronously prepare wasm: ${qt}`),_i(qt)})}function S0(wt,It){var jt=Ro;return typeof WebAssembly.instantiateStreaming!="function"||x0(jt)||y0(jt)||Tt||typeof fetch!="function"?Z0(jt,wt,It):fetch(jt,{credentials:"same-origin"}).then(qt=>WebAssembly.instantiateStreaming(qt,wt).then(It,function(hn){return dn(`wasm streaming compile failed: ${hn}`),dn("falling back to ArrayBuffer instantiation"),Z0(jt,wt,It)}))}var q0={826468:(wt,It,jt,qt)=>{if(typeof _>"u"||!_.Db)return 1;if(wt=d0(wt>>>0),wt.startsWith("./")&&(wt=wt.substring(2)),wt=_.Db.get(wt),!wt)return 2;if(It>>>=0,jt>>>=0,qt>>>=0,It+jt>wt.byteLength)return 3;try{return b().set(wt.subarray(It,It+jt),qt>>>0),0}catch{return 4}},826969:()=>{_.Xb()},827e3:()=>{_.Yb()},827029:()=>{_.bc()},827054:wt=>_.Wb(wt),827087:wt=>_.$b(wt),827119:(wt,It,jt)=>{_.Lb(wt,It,jt,!0)},827158:(wt,It,jt)=>{_.Lb(wt,It,jt)},827191:wt=>{_.ob("Abs",wt,void 0)},827242:wt=>{_.ob("Neg",wt,void 0)},827293:wt=>{_.ob("Floor",wt,void 0)},827346:wt=>{_.ob("Ceil",wt,void 0)},827398:wt=>{_.ob("Reciprocal",wt,void 0)},827456:wt=>{_.ob("Sqrt",wt,void 0)},827508:wt=>{_.ob("Exp",wt,void 0)},827559:wt=>{_.ob("Erf",wt,void 0)},827610:wt=>{_.ob("Sigmoid",wt,void 0)},827665:(wt,It,jt)=>{_.ob("HardSigmoid",wt,{alpha:It,beta:jt})},827744:wt=>{_.ob("Log",wt,void 0)},827795:wt=>{_.ob("Sin",wt,void 0)},827846:wt=>{_.ob("Cos",wt,void 0)},827897:wt=>{_.ob("Tan",wt,void 0)},827948:wt=>{_.ob("Asin",wt,void 0)},828e3:wt=>{_.ob("Acos",wt,void 0)},828052:wt=>{_.ob("Atan",wt,void 0)},828104:wt=>{_.ob("Sinh",wt,void 0)},828156:wt=>{_.ob("Cosh",wt,void 0)},828208:wt=>{_.ob("Asinh",wt,void 0)},828261:wt=>{_.ob("Acosh",wt,void 0)},828314:wt=>{_.ob("Atanh",wt,void 0)},828367:wt=>{_.ob("Tanh",wt,void 0)},828419:wt=>{_.ob("Not",wt,void 0)},828470:(wt,It,jt)=>{_.ob("Clip",wt,{min:It,max:jt})},828539:wt=>{_.ob("Clip",wt,void 0)},828591:(wt,It)=>{_.ob("Elu",wt,{alpha:It})},828649:wt=>{_.ob("Relu",wt,void 0)},828701:(wt,It)=>{_.ob("LeakyRelu",wt,{alpha:It})},828765:(wt,It)=>{_.ob("ThresholdedRelu",wt,{alpha:It})},828835:(wt,It)=>{_.ob("Cast",wt,{to:It})},828893:wt=>{_.ob("Add",wt,void 0)},828944:wt=>{_.ob("Sub",wt,void 0)},828995:wt=>{_.ob("Mul",wt,void 0)},829046:wt=>{_.ob("Div",wt,void 0)},829097:wt=>{_.ob("Pow",wt,void 0)},829148:wt=>{_.ob("Equal",wt,void 0)},829201:wt=>{_.ob("Greater",wt,void 0)},829256:wt=>{_.ob("GreaterOrEqual",wt,void 0)},829318:wt=>{_.ob("Less",wt,void 0)},829370:wt=>{_.ob("LessOrEqual",wt,void 0)},829429:(wt,It,jt,qt,hn)=>{_.ob("ReduceMean",wt,{keepDims:!!It,noopWithEmptyAxes:!!jt,axes:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},829588:(wt,It,jt,qt,hn)=>{_.ob("ReduceMax",wt,{keepDims:!!It,noopWithEmptyAxes:!!jt,axes:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},829746:(wt,It,jt,qt,hn)=>{_.ob("ReduceMin",wt,{keepDims:!!It,noopWithEmptyAxes:!!jt,axes:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},829904:(wt,It,jt,qt,hn)=>{_.ob("ReduceProd",wt,{keepDims:!!It,noopWithEmptyAxes:!!jt,axes:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},830063:(wt,It,jt,qt,hn)=>{_.ob("ReduceSum",wt,{keepDims:!!It,noopWithEmptyAxes:!!jt,axes:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},830221:(wt,It,jt,qt,hn)=>{_.ob("ReduceL1",wt,{keepDims:!!It,noopWithEmptyAxes:!!jt,axes:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},830378:(wt,It,jt,qt,hn)=>{_.ob("ReduceL2",wt,{keepDims:!!It,noopWithEmptyAxes:!!jt,axes:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},830535:(wt,It,jt,qt,hn)=>{_.ob("ReduceLogSum",wt,{keepDims:!!It,noopWithEmptyAxes:!!jt,axes:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},830696:(wt,It,jt,qt,hn)=>{_.ob("ReduceSumSquare",wt,{keepDims:!!It,noopWithEmptyAxes:!!jt,axes:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},830860:(wt,It,jt,qt,hn)=>{_.ob("ReduceLogSumExp",wt,{keepDims:!!It,noopWithEmptyAxes:!!jt,axes:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},831024:wt=>{_.ob("Where",wt,void 0)},831077:(wt,It,jt)=>{_.ob("Transpose",wt,{perm:It?Array.from($().subarray(It>>>0,jt>>>0)):[]})},831185:(wt,It,jt,qt)=>{_.ob("DepthToSpace",wt,{blocksize:It,mode:d0(jt),format:qt?"NHWC":"NCHW"})},831318:(wt,It,jt,qt)=>{_.ob("DepthToSpace",wt,{blocksize:It,mode:d0(jt),format:qt?"NHWC":"NCHW"})},831451:(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar,Kr,l0,c0,rr,bp)=>{_.ob("ConvTranspose",wt,{format:Mr?"NHWC":"NCHW",autoPad:It,dilations:[jt],group:qt,kernelShape:[hn],pads:[$n,ir],strides:[ar],wIsConst:()=>!!h()[Ar>>>0],outputPadding:Kr?Array.from($().subarray(Kr>>>0,l0>>>0)):[],outputShape:c0?Array.from($().subarray(c0>>>0,rr>>>0)):[],activation:d0(bp)})},831852:(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar,Kr,l0,c0,rr)=>{_.ob("ConvTranspose",wt,{format:ar?"NHWC":"NCHW",autoPad:It,dilations:Array.from($().subarray(jt>>>0,(jt>>>0)+2>>>0)),group:qt,kernelShape:Array.from($().subarray(hn>>>0,(hn>>>0)+2>>>0)),pads:Array.from($().subarray($n>>>0,($n>>>0)+4>>>0)),strides:Array.from($().subarray(ir>>>0,(ir>>>0)+2>>>0)),wIsConst:()=>!!h()[Mr>>>0],outputPadding:Ar?Array.from($().subarray(Ar>>>0,Kr>>>0)):[],outputShape:l0?Array.from($().subarray(l0>>>0,c0>>>0)):[],activation:d0(rr)})},832417:(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar,Kr,l0,c0,rr,bp)=>{_.ob("ConvTranspose",wt,{format:Mr?"NHWC":"NCHW",autoPad:It,dilations:[jt],group:qt,kernelShape:[hn],pads:[$n,ir],strides:[ar],wIsConst:()=>!!h()[Ar>>>0],outputPadding:Kr?Array.from($().subarray(Kr>>>0,l0>>>0)):[],outputShape:c0?Array.from($().subarray(c0>>>0,rr>>>0)):[],activation:d0(bp)})},832818:(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar,Kr,l0,c0,rr)=>{_.ob("ConvTranspose",wt,{format:ar?"NHWC":"NCHW",autoPad:It,dilations:Array.from($().subarray(jt>>>0,(jt>>>0)+2>>>0)),group:qt,kernelShape:Array.from($().subarray(hn>>>0,(hn>>>0)+2>>>0)),pads:Array.from($().subarray($n>>>0,($n>>>0)+4>>>0)),strides:Array.from($().subarray(ir>>>0,(ir>>>0)+2>>>0)),wIsConst:()=>!!h()[Mr>>>0],outputPadding:Ar?Array.from($().subarray(Ar>>>0,Kr>>>0)):[],outputShape:l0?Array.from($().subarray(l0>>>0,c0>>>0)):[],activation:d0(rr)})},833383:(wt,It)=>{_.ob("GlobalAveragePool",wt,{format:It?"NHWC":"NCHW"})},833474:(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar,Kr,l0,c0,rr,bp,a0)=>{_.ob("AveragePool",wt,{format:a0?"NHWC":"NCHW",auto_pad:It,ceil_mode:jt,count_include_pad:qt,storage_order:hn,dilations:[$n,ir],kernel_shape:[ar,Mr],pads:[Ar,Kr,l0,c0],strides:[rr,bp]})},833758:(wt,It)=>{_.ob("GlobalAveragePool",wt,{format:It?"NHWC":"NCHW"})},833849:(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar,Kr,l0,c0,rr,bp,a0)=>{_.ob("AveragePool",wt,{format:a0?"NHWC":"NCHW",auto_pad:It,ceil_mode:jt,count_include_pad:qt,storage_order:hn,dilations:[$n,ir],kernel_shape:[ar,Mr],pads:[Ar,Kr,l0,c0],strides:[rr,bp]})},834133:(wt,It)=>{_.ob("GlobalMaxPool",wt,{format:It?"NHWC":"NCHW"})},834220:(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar,Kr,l0,c0,rr,bp,a0)=>{_.ob("MaxPool",wt,{format:a0?"NHWC":"NCHW",auto_pad:It,ceil_mode:jt,count_include_pad:qt,storage_order:hn,dilations:[$n,ir],kernel_shape:[ar,Mr],pads:[Ar,Kr,l0,c0],strides:[rr,bp]})},834500:(wt,It)=>{_.ob("GlobalMaxPool",wt,{format:It?"NHWC":"NCHW"})},834587:(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar,Kr,l0,c0,rr,bp,a0)=>{_.ob("MaxPool",wt,{format:a0?"NHWC":"NCHW",auto_pad:It,ceil_mode:jt,count_include_pad:qt,storage_order:hn,dilations:[$n,ir],kernel_shape:[ar,Mr],pads:[Ar,Kr,l0,c0],strides:[rr,bp]})},834867:(wt,It,jt,qt,hn)=>{_.ob("Gemm",wt,{alpha:It,beta:jt,transA:qt,transB:hn})},834971:wt=>{_.ob("MatMul",wt,void 0)},835025:(wt,It,jt,qt)=>{_.ob("ArgMax",wt,{keepDims:!!It,selectLastIndex:!!jt,axis:qt})},835133:(wt,It,jt,qt)=>{_.ob("ArgMin",wt,{keepDims:!!It,selectLastIndex:!!jt,axis:qt})},835241:(wt,It)=>{_.ob("Softmax",wt,{axis:It})},835304:(wt,It)=>{_.ob("Concat",wt,{axis:It})},835364:(wt,It,jt,qt,hn)=>{_.ob("Split",wt,{axis:It,numOutputs:jt,splitSizes:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},835504:wt=>{_.ob("Expand",wt,void 0)},835558:(wt,It)=>{_.ob("Gather",wt,{axis:Number(It)})},835629:(wt,It)=>{_.ob("GatherElements",wt,{axis:Number(It)})},835708:(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar,Kr)=>{_.ob("Resize",wt,{antialias:It,axes:jt?Array.from($().subarray(jt>>>0,qt>>>0)):[],coordinateTransformMode:d0(hn),cubicCoeffA:$n,excludeOutside:ir,extrapolationValue:ar,keepAspectRatioPolicy:d0(Mr),mode:d0(Ar),nearestMode:d0(Kr)})},836054:(wt,It,jt,qt,hn,$n,ir)=>{_.ob("Slice",wt,{starts:It?Array.from($().subarray(It>>>0,jt>>>0)):[],ends:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[],axes:$n?Array.from($().subarray($n>>>0,ir>>>0)):[]})},836270:wt=>{_.ob("Tile",wt,void 0)},836322:(wt,It,jt,qt)=>{_.ob("LayerNormalization",wt,{axis:It,epsilon:jt,simplified:!!qt})},836433:(wt,It,jt)=>{_.ob("InstanceNormalization",wt,{epsilon:It,format:jt?"NHWC":"NCHW"})},836547:(wt,It,jt)=>{_.ob("InstanceNormalization",wt,{epsilon:It,format:jt?"NHWC":"NCHW"})},836661:wt=>{_.ob("Range",wt,void 0)},836714:(wt,It)=>{_.ob("Einsum",wt,{equation:d0(It)})},836795:(wt,It,jt,qt,hn)=>{_.ob("Pad",wt,{mode:It,value:jt,pads:qt?Array.from($().subarray(qt>>>0,hn>>>0)):[]})},836922:(wt,It,jt,qt,hn,$n)=>{_.ob("BatchNormalization",wt,{epsilon:It,momentum:jt,spatial:!!hn,trainingMode:!!qt,format:$n?"NHWC":"NCHW"})},837091:(wt,It,jt,qt,hn,$n)=>{_.ob("BatchNormalization",wt,{epsilon:It,momentum:jt,spatial:!!hn,trainingMode:!!qt,format:$n?"NHWC":"NCHW"})},837260:(wt,It,jt)=>{_.ob("CumSum",wt,{exclusive:Number(It),reverse:Number(jt)})},837357:(wt,It,jt,qt,hn,$n,ir,ar,Mr)=>{_.ob("Attention",wt,{numHeads:It,isUnidirectional:jt,maskFilterValue:qt,scale:hn,doRotary:$n,qkvHiddenSizes:ir?Array.from($().subarray(Number(ar)>>>0,Number(ar)+ir>>>0)):[],pastPresentShareBuffer:!!Mr})},837629:wt=>{_.ob("BiasAdd",wt,void 0)},837684:wt=>{_.ob("BiasSplitGelu",wt,void 0)},837745:wt=>{_.ob("FastGelu",wt,void 0)},837801:(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar,Kr,l0,c0)=>{_.ob("Conv",wt,{format:Mr?"NHWC":"NCHW",auto_pad:It,dilations:[jt],group:qt,kernel_shape:[hn],pads:$n?Array.from($().subarray($n>>>0,ir>>>0)):[],strides:[ar],w_is_const:()=>!!h()[Ar>>>0],activation:d0(Kr),activation_params:l0?Array.from(g().subarray(l0>>>0,c0>>>0)):[]})},838171:(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar,Kr,l0,c0,rr,bp,a0)=>{_.ob("Conv",wt,{format:l0?"NHWC":"NCHW",auto_pad:It,dilations:[jt,qt],group:hn,kernel_shape:[$n,ir],pads:ar?Array.from($().subarray(ar>>>0,Mr>>>0)):[],strides:[Ar,Kr],w_is_const:()=>!!h()[c0>>>0],activation:d0(rr),activation_params:bp?Array.from(g().subarray(bp>>>0,a0>>>0)):[]})},838562:wt=>{_.ob("Gelu",wt,void 0)},838614:(wt,It,jt,qt,hn,$n)=>{_.ob("MatMulNBits",wt,{k:It,n:jt,accuracyLevel:qt,bits:hn,blockSize:$n})},838741:(wt,It,jt,qt,hn,$n)=>{_.ob("MultiHeadAttention",wt,{numHeads:It,isUnidirectional:jt,maskFilterValue:qt,scale:hn,doRotary:$n})},838900:(wt,It,jt,qt,hn)=>{_.ob("RotaryEmbedding",wt,{interleaved:!!It,numHeads:jt,rotaryEmbeddingDim:qt,scale:hn})},839039:(wt,It,jt)=>{_.ob("SkipLayerNormalization",wt,{epsilon:It,simplified:!!jt})},839141:(wt,It,jt)=>{_.ob("SkipLayerNormalization",wt,{epsilon:It,simplified:!!jt})},839243:(wt,It,jt,qt)=>{_.ob("LayerNormalization",wt,{axis:It,epsilon:jt,simplified:!!qt})},839354:wt=>{_.ac(wt)},839388:(wt,It)=>_.cc(wt,It,_.Cb.ec,_.Cb.errors)};function $0(wt){this.name="ExitStatus",this.message=`Program terminated with exit(${wt})`,this.status=wt}var m0=wt=>{wt.terminate(),wt.onmessage=()=>{}},U0=wt=>{Ur.xb.length==0&&(K0(),Ur.Mb(Ur.xb[0]));var It=Ur.xb.pop();if(!It)return 6;Ur.yb.push(It),Ur.ub[wt.wb]=It,It.wb=wt.wb;var jt={cmd:"run",start_routine:wt.fc,arg:wt.Rb,pthread_ptr:wt.wb};return Tt&&It.unref(),It.postMessage(jt,wt.mc),0},Ir=0,V0=wt=>{var It=Ly();return wt=wt(),Iy(It),wt},Wo=(wt,It,...jt)=>V0(()=>{for(var qt=2*jt.length,hn=zy(8*qt),$n=hn>>>3,ir=0;ir<jt.length;ir++){var ar=jt[ir];typeof ar=="bigint"?(No[$n+2*ir]=1n,No[$n+2*ir+1]=ar):(No[$n+2*ir]=0n,c()[$n+2*ir+1>>>0]=ar)}return qy(wt,0,qt,hn,It)});function P0(wt){if(Nt)return Wo(0,1,wt);_r=wt,0<Ir||(Ur.hc(),_.onExit?.(wt),En=!0),bt(wt,new $0(wt))}var D0=wt=>{if(_r=wt,Nt)throw qr(wt),"unwind";P0(wt)};function n0(){for(var wt=_.numThreads;wt--;)K0();k0.unshift(()=>{O0++,ay(()=>A0())})}function K0(){var wt=Ft("ort-wasm-simd-threaded.worker.js");wt=new Worker(wt),Ur.xb.push(wt)}function ay(wt){Nt?wt():Promise.all(Ur.xb.map(Ur.Mb)).then(wt)}var Ur={xb:[],yb:[],Qb:[],ub:{},Gb(){Nt?(Ur.receiveObjectTransfer=Ur.dc,Ur.threadInitTLS=Ur.Pb,Ur.setExitStatus=Ur.Ob):n0()},Ob:wt=>_r=wt,pc:["$terminateWorker"],hc:()=>{for(var wt of Ur.yb)m0(wt);for(wt of Ur.xb)m0(wt);Ur.xb=[],Ur.yb=[],Ur.ub=[]},Nb:wt=>{var It=wt.wb;delete Ur.ub[It],Ur.xb.push(wt),Ur.yb.splice(Ur.yb.indexOf(wt),1),wt.wb=0,Dy(It)},dc(){},Pb(){Ur.Qb.forEach(wt=>wt())},Mb:wt=>new Promise(It=>{wt.onmessage=$n=>{$n=$n.data;var ir=$n.cmd;if($n.targetThread&&$n.targetThread!=Cy()){var ar=Ur.ub[$n.targetThread];ar?ar.postMessage($n,$n.transferList):dn(`Internal error! Worker sent a message "${ir}" to target pthread ${$n.targetThread}, but that thread no longer exists!`)}else ir==="checkMailbox"?R0():ir==="spawnThread"?U0($n):ir==="cleanupThread"?Ur.Nb(Ur.ub[$n.thread]):ir==="killThread"?($n=$n.thread,ir=Ur.ub[$n],delete Ur.ub[$n],m0(ir),Dy($n),Ur.yb.splice(Ur.yb.indexOf(ir),1),ir.wb=0):ir==="cancelThread"?Ur.ub[$n.thread].postMessage({cmd:"cancel"}):ir==="loaded"?(wt.loaded=!0,Tt&&!wt.wb&&wt.unref(),It(wt)):ir==="alert"?alert(`Thread ${$n.threadId}: ${$n.text}`):$n.target==="setimmediate"?wt.postMessage($n):ir==="callHandler"?_[$n.handler](...$n.args):ir&&dn(`worker sent an unknown command ${ir}`)},wt.onerror=$n=>{throw dn(`worker sent an error! ${$n.filename}:${$n.lineno}: ${$n.message}`),$n},Tt&&(wt.on("message",$n=>wt.onmessage({data:$n})),wt.on("error",$n=>wt.onerror($n)));var jt=[],qt=["onExit"],hn;for(hn of qt)_.hasOwnProperty(hn)&&jt.push(hn);wt.postMessage({cmd:"load",handlers:jt,urlOrBlob:_.mainScriptUrlOrBlob||a,wasmMemory:wn,wasmModule:gn})})};_.PThread=Ur;var Yr=wt=>{for(;0<wt.length;)wt.shift()(_)};_.establishStackSpace=()=>{var wt=Cy(),It=it()[wt+52>>>2>>>0];wt=it()[wt+56>>>2>>>0],Yy(It,It-wt),Iy(It)};function qr(wt){if(Nt)return Wo(1,0,wt);D0(wt)}_.invokeEntryPoint=(wt,It)=>{Ir=0,wt=Xy(wt,It),0<Ir?Ur.Ob(wt):Ny(wt)};class eo{constructor(It){this.Ib=It-24}Gb(It,jt){it()[this.Ib+16>>>2>>>0]=0,it()[this.Ib+4>>>2>>>0]=It,it()[this.Ib+8>>>2>>>0]=jt}}var uy=0;function Y0(wt,It,jt,qt){return Nt?Wo(2,1,wt,It,jt,qt):X0(wt,It,jt,qt)}function X0(wt,It,jt,qt){if(wt>>>=0,It>>>=0,jt>>>=0,qt>>>=0,typeof SharedArrayBuffer>"u")return dn("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var hn=[];return Nt&&hn.length===0?Y0(wt,It,jt,qt):(wt={fc:jt,wb:wt,Rb:qt,mc:hn},Nt?(wt.oc="spawnThread",postMessage(wt,hn),0):U0(wt))}var J0=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,G0=(wt,It,jt)=>{It>>>=0;var qt=It+jt;for(jt=It;wt[jt]&&!(jt>=qt);)++jt;if(16<jt-It&&wt.buffer&&J0)return J0.decode(wt.buffer instanceof SharedArrayBuffer?wt.slice(It,jt):wt.subarray(It,jt));for(qt="";It<jt;){var hn=wt[It++];if(hn&128){var $n=wt[It++]&63;if((hn&224)==192)qt+=String.fromCharCode((hn&31)<<6|$n);else{var ir=wt[It++]&63;hn=(hn&240)==224?(hn&15)<<12|$n<<6|ir:(hn&7)<<18|$n<<12|ir<<6|wt[It++]&63,65536>hn?qt+=String.fromCharCode(hn):(hn-=65536,qt+=String.fromCharCode(55296|hn>>10,56320|hn&1023))}}else qt+=String.fromCharCode(hn)}return qt},d0=(wt,It)=>(wt>>>=0)?G0(b(),wt,It):"";function ly(wt,It,jt){return Nt?Wo(3,1,wt,It,jt):0}function N0(wt,It){if(Nt)return Wo(4,1,wt,It)}var E0=wt=>{for(var It=0,jt=0;jt<wt.length;++jt){var qt=wt.charCodeAt(jt);127>=qt?It++:2047>=qt?It+=2:55296<=qt&&57343>=qt?(It+=4,++jt):It+=3}return It},ey=(wt,It,jt,qt)=>{if(jt>>>=0,!(0<qt))return 0;var hn=jt;qt=jt+qt-1;for(var $n=0;$n<wt.length;++$n){var ir=wt.charCodeAt($n);if(55296<=ir&&57343>=ir){var ar=wt.charCodeAt(++$n);ir=65536+((ir&1023)<<10)|ar&1023}if(127>=ir){if(jt>=qt)break;It[jt++>>>0]=ir}else{if(2047>=ir){if(jt+1>=qt)break;It[jt++>>>0]=192|ir>>6}else{if(65535>=ir){if(jt+2>=qt)break;It[jt++>>>0]=224|ir>>12}else{if(jt+3>=qt)break;It[jt++>>>0]=240|ir>>18,It[jt++>>>0]=128|ir>>12&63}It[jt++>>>0]=128|ir>>6&63}It[jt++>>>0]=128|ir&63}}return It[jt>>>0]=0,jt-hn},z0=(wt,It,jt)=>ey(wt,b(),It,jt);function ty(wt,It){if(Nt)return Wo(5,1,wt,It)}function ny(wt,It,jt){if(Nt)return Wo(6,1,wt,It,jt)}function cy(wt,It,jt){return Nt?Wo(7,1,wt,It,jt):0}function Qt(wt,It){if(Nt)return Wo(8,1,wt,It)}function fn(wt,It,jt){if(Nt)return Wo(9,1,wt,It,jt)}function vn(wt,It,jt,qt){if(Nt)return Wo(10,1,wt,It,jt,qt)}function Sn(wt,It,jt,qt){if(Nt)return Wo(11,1,wt,It,jt,qt)}function An(wt,It,jt,qt){if(Nt)return Wo(12,1,wt,It,jt,qt)}function In(wt){if(Nt)return Wo(13,1,wt)}function wr(wt,It){if(Nt)return Wo(14,1,wt,It)}function Dr(wt,It,jt){if(Nt)return Wo(15,1,wt,It,jt)}var Tr,Wr=wt=>{for(var It="";b()[wt>>>0];)It+=Tr[b()[wt++>>>0]];return It},r0={},g0={},u0;function er(wt,It,jt={}){var qt=It.name;if(!wt)throw new u0(`type "${qt}" must have a positive integer typeid pointer`);if(g0.hasOwnProperty(wt)){if(jt.Ub)return;throw new u0(`Cannot register type '${qt}' twice`)}g0[wt]=It,r0.hasOwnProperty(wt)&&(It=r0[wt],delete r0[wt],It.forEach(hn=>hn()))}function Gr(wt,It,jt={}){if(!("argPackAdvance"in It))throw new TypeError("registerType registeredInstance requires argPackAdvance");return er(wt,It,jt)}var s0=(wt,It,jt)=>{switch(It){case 1:return jt?qt=>h()[qt>>>0]:qt=>b()[qt>>>0];case 2:return jt?qt=>et()[qt>>>1>>>0]:qt=>st()[qt>>>1>>>0];case 4:return jt?qt=>$()[qt>>>2>>>0]:qt=>it()[qt>>>2>>>0];case 8:return jt?qt=>No[qt>>>3]:qt=>o0[qt>>>3];default:throw new TypeError(`invalid integer width (${It}): ${wt}`)}},I0=[],b0=[];function dy(wt){wt>>>=0,9<wt&&--b0[wt+1]===0&&(b0[wt]=void 0,I0.push(wt))}var _0=wt=>{if(!wt)throw new u0("Cannot use deleted val. handle = "+wt);return b0[wt]},L0=wt=>{switch(wt){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let It=I0.pop()||b0.length;return b0[It]=wt,b0[It+1]=1,It}};function w0(wt){return this.fromWireType(it()[wt>>>2>>>0])}var gy={name:"emscripten::val",fromWireType:wt=>{var It=_0(wt);return dy(wt),It},toWireType:(wt,It)=>L0(It),argPackAdvance:8,readValueFromPointer:w0,Bb:null},wy=(wt,It)=>{switch(It){case 4:return function(jt){return this.fromWireType(g()[jt>>>2>>>0])};case 8:return function(jt){return this.fromWireType(c()[jt>>>3>>>0])};default:throw new TypeError(`invalid float width (${It}): ${wt}`)}},yy=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Sy=(wt,It)=>{for(var jt=wt>>1,qt=jt+It/2;!(jt>=qt)&&st()[jt>>>0];)++jt;if(jt<<=1,32<jt-wt&&yy)return yy.decode(b().slice(wt,jt));for(jt="",qt=0;!(qt>=It/2);++qt){var hn=et()[wt+2*qt>>>1>>>0];if(hn==0)break;jt+=String.fromCharCode(hn)}return jt},Ey=(wt,It,jt)=>{if(jt??=2147483647,2>jt)return 0;jt-=2;var qt=It;jt=jt<2*wt.length?jt/2:wt.length;for(var hn=0;hn<jt;++hn){var $n=wt.charCodeAt(hn);et()[It>>>1>>>0]=$n,It+=2}return et()[It>>>1>>>0]=0,It-qt},ky=wt=>2*wt.length,ry=(wt,It)=>{for(var jt=0,qt="";!(jt>=It/4);){var hn=$()[wt+4*jt>>>2>>>0];if(hn==0)break;++jt,65536<=hn?(hn-=65536,qt+=String.fromCharCode(55296|hn>>10,56320|hn&1023)):qt+=String.fromCharCode(hn)}return qt},vy=(wt,It,jt)=>{if(It>>>=0,jt??=2147483647,4>jt)return 0;var qt=It;jt=qt+jt-4;for(var hn=0;hn<wt.length;++hn){var $n=wt.charCodeAt(hn);if(55296<=$n&&57343>=$n){var ir=wt.charCodeAt(++hn);$n=65536+(($n&1023)<<10)|ir&1023}if($()[It>>>2>>>0]=$n,It+=4,It+4>jt)break}return $()[It>>>2>>>0]=0,It-qt},Hr=wt=>{for(var It=0,jt=0;jt<wt.length;++jt){var qt=wt.charCodeAt(jt);55296<=qt&&57343>=qt&&++jt,It+=4}return It},by=wt=>{if(!En)try{if(wt(),!(0<Ir))try{Nt?Ny(_r):D0(_r)}catch(It){It instanceof $0||It=="unwind"||bt(1,It)}}catch(It){It instanceof $0||It=="unwind"||bt(1,It)}};function iy(wt){wt>>>=0,typeof Atomics.nc=="function"&&(Atomics.nc($(),wt>>>2,wt).value.then(R0),wt+=128,Atomics.store($(),wt>>>2,1))}_.__emscripten_thread_mailbox_await=iy;var R0=()=>{var wt=Cy();wt&&(iy(wt),by(Ky))};_.checkMailbox=R0;var oy=[],fy=(wt,It)=>{var jt=g0[wt];if(jt===void 0)throw wt=Gy(wt),jt=Wr(wt),py(wt),new u0(`${It} has unknown type ${jt}`);return jt},_y=(wt,It,jt)=>{var qt=[];return wt=wt.toWireType(qt,jt),qt.length&&(it()[It>>>2>>>0]=L0(qt)),wt},sy=wt=>{try{wt()}catch(It){_i(It)}};function xy(){var wt=Lr,It={};for(let[jt,qt]of Object.entries(wt))It[jt]=typeof qt=="function"?(...hn)=>{Zr.push(jt);try{return qt(...hn)}finally{En||(Zr.pop(),B0&&Xr===1&&Zr.length===0&&(Xr=0,Ir+=1,sy(Zy),typeof Fibers<"u"&&Fibers.rc()))}}:qt;return It}var Xr=0,B0=null,ns=0,Zr=[],hy={},vt={},Lt=0,Vt=null,Jt=[];function _n(){return new Promise((wt,It)=>{Vt={resolve:wt,reject:It}})}function Cn(){var wt=Py(65548),It=wt+12;it()[wt>>>2>>>0]=It,it()[wt+4>>>2>>>0]=It+65536,It=Zr[0];var jt=hy[It];return jt===void 0&&(jt=Lt++,hy[It]=jt,vt[jt]=It),It=jt,$()[wt+8>>>2>>>0]=It,wt}function or(){var wt=$()[B0+8>>>2>>>0];return wt=Lr[vt[wt]],--Ir,wt()}function yr(wt){if(!En){if(Xr===0){var It=!1,jt=!1;wt((qt=0)=>{if(!En&&(ns=qt,It=!0,jt)){Xr=2,sy(()=>Jy(B0)),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.resume(),qt=!1;try{var hn=or()}catch(ar){hn=ar,qt=!0}var $n=!1;if(!B0){var ir=Vt;ir&&(Vt=null,(qt?ir.reject:ir.resolve)(hn),$n=!0)}if(qt&&!$n)throw hn}}),jt=!0,It||(Xr=1,B0=Cn(),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.pause(),sy(()=>Qy(B0)))}else Xr===2?(Xr=0,sy(_b),py(B0),B0=null,Jt.forEach(by)):_i(`invalid state: ${Xr}`);return ns}}function Cr(wt){return yr(It=>{wt().then(It)})}var $r=[],jr={},e0=wt=>{var It=jr[wt];return It===void 0?Wr(wt):It},i0=()=>typeof globalThis=="object"?globalThis:Function("return this")(),Pt=wt=>{var It=$r.length;return $r.push(wt),It},Wt=(wt,It)=>{for(var jt=Array(wt),qt=0;qt<wt;++qt)jt[qt]=fy(it()[It+4*qt>>>2>>>0],"parameter "+qt);return jt},un=(wt,It)=>Object.defineProperty(It,"name",{value:wt});function bn(wt){var It=Function;if(!(It instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof It} which is not a function`);var jt=un(It.name||"unknownFunctionName",function(){});return jt.prototype=It.prototype,jt=new jt,wt=It.apply(jt,wt),wt instanceof Object?wt:jt}var Tn=wt=>wt%4===0&&(wt%100!==0||wt%400===0),tr=[0,31,60,91,121,152,182,213,244,274,305,335],vr=[0,31,59,90,120,151,181,212,243,273,304,334];function Nr(wt,It,jt,qt,hn,$n,ir){return Nt?Wo(16,1,wt,It,jt,qt,hn,$n,ir):-52}function _h(wt,It,jt,qt,hn,$n){if(Nt)return Wo(17,1,wt,It,jt,qt,hn,$n)}var vm=[],f0=(wt,It)=>{vm.length=0;for(var jt;jt=b()[wt++>>>0];){var qt=jt!=105;qt&=jt!=112,It+=qt&&It%8?4:0,vm.push(jt==112?it()[It>>>2>>>0]:jt==106?No[It>>>3]:jt==105?$()[It>>>2>>>0]:c()[It>>>3>>>0]),It+=qt?8:4}return vm},W0={},F0=()=>{if(!nr){var wt={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:ht||"./this.program"},It;for(It in W0)W0[It]===void 0?delete wt[It]:wt[It]=W0[It];var jt=[];for(It in wt)jt.push(`${It}=${wt[It]}`);nr=jt}return nr},nr;function _g(wt,It){if(Nt)return Wo(18,1,wt,It);wt>>>=0,It>>>=0;var jt=0;return F0().forEach((qt,hn)=>{var $n=It+jt;for(hn=it()[wt+4*hn>>>2>>>0]=$n,$n=0;$n<qt.length;++$n)h()[hn++>>>0]=qt.charCodeAt($n);h()[hn>>>0]=0,jt+=qt.length+1}),0}function p0(wt,It){if(Nt)return Wo(19,1,wt,It);wt>>>=0,It>>>=0;var jt=F0();it()[wt>>>2>>>0]=jt.length;var qt=0;return jt.forEach(hn=>qt+=hn.length+1),it()[It>>>2>>>0]=qt,0}function Q0(wt){return Nt?Wo(20,1,wt):52}function my(wt,It,jt,qt){return Nt?Wo(21,1,wt,It,jt,qt):52}function By(wt,It,jt,qt){return Nt?Wo(22,1,wt,It,jt,qt):70}var s_=[null,[],[]];function Fy(wt,It,jt,qt){if(Nt)return Wo(23,1,wt,It,jt,qt);It>>>=0,jt>>>=0,qt>>>=0;for(var hn=0,$n=0;$n<jt;$n++){var ir=it()[It>>>2>>>0],ar=it()[It+4>>>2>>>0];It+=8;for(var Mr=0;Mr<ar;Mr++){var Ar=b()[ir+Mr>>>0],Kr=s_[wt];Ar===0||Ar===10?((wt===1?xn:dn)(G0(Kr,0)),Kr.length=0):Kr.push(Ar)}hn+=ar}return it()[qt>>>2>>>0]=hn,0}var jy=[31,29,31,30,31,30,31,31,30,31,30,31],Uy=[31,28,31,30,31,30,31,31,30,31,30,31];function a_(wt){var It=Array(E0(wt)+1);return ey(wt,It,0,It.length),It}var u_=(wt,It)=>{h().set(wt,It>>>0)};function Vy(wt,It,jt,qt){function hn(rr,bp,a0){for(rr=typeof rr=="number"?rr.toString():rr||"";rr.length<bp;)rr=a0[0]+rr;return rr}function $n(rr,bp){return hn(rr,bp,"0")}function ir(rr,bp){function a0(t_){return 0>t_?-1:0<t_?1:0}var $y;return($y=a0(rr.getFullYear()-bp.getFullYear()))===0&&($y=a0(rr.getMonth()-bp.getMonth()))===0&&($y=a0(rr.getDate()-bp.getDate())),$y}function ar(rr){switch(rr.getDay()){case 0:return new Date(rr.getFullYear()-1,11,29);case 1:return rr;case 2:return new Date(rr.getFullYear(),0,3);case 3:return new Date(rr.getFullYear(),0,2);case 4:return new Date(rr.getFullYear(),0,1);case 5:return new Date(rr.getFullYear()-1,11,31);case 6:return new Date(rr.getFullYear()-1,11,30)}}function Mr(rr){var bp=rr.zb;for(rr=new Date(new Date(rr.Ab+1900,0,1).getTime());0<bp;){var a0=rr.getMonth(),$y=(Tn(rr.getFullYear())?jy:Uy)[a0];if(bp>$y-rr.getDate())bp-=$y-rr.getDate()+1,rr.setDate(1),11>a0?rr.setMonth(a0+1):(rr.setMonth(0),rr.setFullYear(rr.getFullYear()+1));else{rr.setDate(rr.getDate()+bp);break}}return a0=new Date(rr.getFullYear()+1,0,4),bp=ar(new Date(rr.getFullYear(),0,4)),a0=ar(a0),0>=ir(bp,rr)?0>=ir(a0,rr)?rr.getFullYear()+1:rr.getFullYear():rr.getFullYear()-1}wt>>>=0,It>>>=0,jt>>>=0,qt>>>=0;var Ar=it()[qt+40>>>2>>>0];qt={kc:$()[qt>>>2>>>0],jc:$()[qt+4>>>2>>>0],Eb:$()[qt+8>>>2>>>0],Jb:$()[qt+12>>>2>>>0],Fb:$()[qt+16>>>2>>>0],Ab:$()[qt+20>>>2>>>0],vb:$()[qt+24>>>2>>>0],zb:$()[qt+28>>>2>>>0],qc:$()[qt+32>>>2>>>0],ic:$()[qt+36>>>2>>>0],lc:Ar?d0(Ar):""},jt=d0(jt),Ar={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Kr in Ar)jt=jt.replace(new RegExp(Kr,"g"),Ar[Kr]);var l0="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),c0="January February March April May June July August September October November December".split(" ");Ar={"%a":rr=>l0[rr.vb].substring(0,3),"%A":rr=>l0[rr.vb],"%b":rr=>c0[rr.Fb].substring(0,3),"%B":rr=>c0[rr.Fb],"%C":rr=>$n((rr.Ab+1900)/100|0,2),"%d":rr=>$n(rr.Jb,2),"%e":rr=>hn(rr.Jb,2," "),"%g":rr=>Mr(rr).toString().substring(2),"%G":Mr,"%H":rr=>$n(rr.Eb,2),"%I":rr=>(rr=rr.Eb,rr==0?rr=12:12<rr&&(rr-=12),$n(rr,2)),"%j":rr=>{for(var bp=0,a0=0;a0<=rr.Fb-1;bp+=(Tn(rr.Ab+1900)?jy:Uy)[a0++]);return $n(rr.Jb+bp,3)},"%m":rr=>$n(rr.Fb+1,2),"%M":rr=>$n(rr.jc,2),"%n":()=>`
`,"%p":rr=>0<=rr.Eb&&12>rr.Eb?"AM":"PM","%S":rr=>$n(rr.kc,2),"%t":()=>"	","%u":rr=>rr.vb||7,"%U":rr=>$n(Math.floor((rr.zb+7-rr.vb)/7),2),"%V":rr=>{var bp=Math.floor((rr.zb+7-(rr.vb+6)%7)/7);if(2>=(rr.vb+371-rr.zb-2)%7&&bp++,bp)bp==53&&(a0=(rr.vb+371-rr.zb)%7,a0==4||a0==3&&Tn(rr.Ab)||(bp=1));else{bp=52;var a0=(rr.vb+7-rr.zb-1)%7;(a0==4||a0==5&&Tn(rr.Ab%400-1))&&bp++}return $n(bp,2)},"%w":rr=>rr.vb,"%W":rr=>$n(Math.floor((rr.zb+7-(rr.vb+6)%7)/7),2),"%y":rr=>(rr.Ab+1900).toString().substring(2),"%Y":rr=>rr.Ab+1900,"%z":rr=>{rr=rr.ic;var bp=0<=rr;return rr=Math.abs(rr)/60,(bp?"+":"-")+("0000"+(rr/60*100+rr%60)).slice(-4)},"%Z":rr=>rr.lc,"%%":()=>"%"},jt=jt.replace(/%%/g,"\0\0");for(Kr in Ar)jt.includes(Kr)&&(jt=jt.replace(new RegExp(Kr,"g"),Ar[Kr](qt)));return jt=jt.replace(/\0\0/g,"%"),Kr=a_(jt),Kr.length>It?0:(u_(Kr,wt),Kr.length-1)}Ur.Gb();for(var Wy=Array(256),Ay=0;256>Ay;++Ay)Wy[Ay]=String.fromCharCode(Ay);Tr=Wy,u0=_.BindingError=class extends Error{constructor(wt){super(wt),this.name="BindingError"}},_.InternalError=class extends Error{constructor(wt){super(wt),this.name="InternalError"}},b0.push(0,1,void 0,1,null,1,!0,1,!1,1),_.count_emval_handles=()=>b0.length/2-5-I0.length;var l_=[P0,qr,Y0,ly,N0,ty,ny,cy,Qt,fn,vn,Sn,An,In,wr,Dr,Nr,_h,_g,p0,Q0,my,By,Fy],c_={ua:function(wt,It,jt){return Cr(async()=>{await _.Zb(wt,It,jt)})},b:function(wt,It,jt){throw wt>>>=0,new eo(wt).Gb(It>>>0,jt>>>0),uy=wt,uy},ia:function(wt){Hy(wt>>>0,!$t,1,!mt,131072,!1),Ur.Pb()},G:function(wt){wt>>>=0,Nt?postMessage({cmd:"cleanupThread",thread:wt}):Ur.Nb(Ur.ub[wt])},_:X0,B:ly,pa:N0,W:ty,Y:ny,qa:cy,na:Qt,fa:fn,ma:vn,K:Sn,X:An,U:In,oa:wr,V:Dr,E:function(wt,It,jt){wt>>>=0,jt>>>=0,It=Wr(It>>>0),Gr(wt,{name:It,fromWireType:qt=>qt,toWireType:function(qt,hn){if(typeof hn!="bigint"&&typeof hn!="number")throw hn===null?hn="null":(qt=typeof hn,hn=qt==="object"||qt==="array"||qt==="function"?hn.toString():""+hn),new TypeError(`Cannot convert "${hn}" to ${this.name}`);return typeof hn=="number"&&(hn=BigInt(hn)),hn},argPackAdvance:8,readValueFromPointer:s0(It,jt,It.indexOf("u")==-1),Bb:null})},O:function(wt,It,jt,qt){wt>>>=0,It=Wr(It>>>0),Gr(wt,{name:It,fromWireType:function(hn){return!!hn},toWireType:function(hn,$n){return $n?jt:qt},argPackAdvance:8,readValueFromPointer:function(hn){return this.fromWireType(b()[hn>>>0])},Bb:null})},N:function(wt){return Gr(wt>>>0,gy)},D:function(wt,It,jt){wt>>>=0,jt>>>=0,It=Wr(It>>>0),Gr(wt,{name:It,fromWireType:qt=>qt,toWireType:(qt,hn)=>hn,argPackAdvance:8,readValueFromPointer:wy(It,jt),Bb:null})},t:function(wt,It,jt,qt,hn){if(wt>>>=0,jt>>>=0,It=Wr(It>>>0),hn===-1&&(hn=4294967295),hn=ar=>ar,qt===0){var $n=32-8*jt;hn=ar=>ar<<$n>>>$n}var ir=It.includes("unsigned")?function(ar,Mr){return Mr>>>0}:function(ar,Mr){return Mr};Gr(wt,{name:It,fromWireType:hn,toWireType:ir,argPackAdvance:8,readValueFromPointer:s0(It,jt,qt!==0),Bb:null})},p:function(wt,It,jt){function qt($n){var ir=it()[$n>>>2>>>0];return $n=it()[$n+4>>>2>>>0],new hn(h().buffer,$n,ir)}wt>>>=0;var hn=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][It];jt=Wr(jt>>>0),Gr(wt,{name:jt,fromWireType:qt,argPackAdvance:8,readValueFromPointer:qt},{Ub:!0})},F:function(wt,It){wt>>>=0,It=Wr(It>>>0);var jt=It==="std::string";Gr(wt,{name:It,fromWireType:function(qt){var hn=it()[qt>>>2>>>0],$n=qt+4;if(jt)for(var ir=$n,ar=0;ar<=hn;++ar){var Mr=$n+ar;if(ar==hn||b()[Mr>>>0]==0){if(ir=d0(ir,Mr-ir),Ar===void 0)var Ar=ir;else Ar+="\0",Ar+=ir;ir=Mr+1}}else{for(Ar=Array(hn),ar=0;ar<hn;++ar)Ar[ar]=String.fromCharCode(b()[$n+ar>>>0]);Ar=Ar.join("")}return py(qt),Ar},toWireType:function(qt,hn){hn instanceof ArrayBuffer&&(hn=new Uint8Array(hn));var $n=typeof hn=="string";if(!($n||hn instanceof Uint8Array||hn instanceof Uint8ClampedArray||hn instanceof Int8Array))throw new u0("Cannot pass non-string to std::string");var ir=jt&&$n?E0(hn):hn.length,ar=Py(4+ir+1),Mr=ar+4;if(it()[ar>>>2>>>0]=ir,jt&&$n)z0(hn,Mr,ir+1);else if($n)for($n=0;$n<ir;++$n){var Ar=hn.charCodeAt($n);if(255<Ar)throw py(Mr),new u0("String has UTF-16 code units that do not fit in 8 bits");b()[Mr+$n>>>0]=Ar}else for($n=0;$n<ir;++$n)b()[Mr+$n>>>0]=hn[$n];return qt!==null&&qt.push(py,ar),ar},argPackAdvance:8,readValueFromPointer:w0,Bb(qt){py(qt)}})},A:function(wt,It,jt){if(wt>>>=0,It>>>=0,jt>>>=0,jt=Wr(jt),It===2)var qt=Sy,hn=Ey,$n=ky,ir=ar=>st()[ar>>>1>>>0];else It===4&&(qt=ry,hn=vy,$n=Hr,ir=ar=>it()[ar>>>2>>>0]);Gr(wt,{name:jt,fromWireType:ar=>{for(var Mr=it()[ar>>>2>>>0],Ar,Kr=ar+4,l0=0;l0<=Mr;++l0){var c0=ar+4+l0*It;(l0==Mr||ir(c0)==0)&&(Kr=qt(Kr,c0-Kr),Ar===void 0?Ar=Kr:(Ar+="\0",Ar+=Kr),Kr=c0+It)}return py(ar),Ar},toWireType:(ar,Mr)=>{if(typeof Mr!="string")throw new u0(`Cannot pass non-string to C++ string type ${jt}`);var Ar=$n(Mr),Kr=Py(4+Ar+It);return it()[Kr>>>2>>>0]=Ar/It,hn(Mr,Kr+4,Ar+It),ar!==null&&ar.push(py,Kr),Kr},argPackAdvance:8,readValueFromPointer:w0,Bb(ar){py(ar)}})},P:function(wt,It){wt>>>=0,It=Wr(It>>>0),Gr(wt,{Vb:!0,name:It,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ta:()=>1,S:function(wt,It){wt>>>=0,wt==It>>>0?setTimeout(R0):Nt?postMessage({targetThread:wt,cmd:"checkMailbox"}):(wt=Ur.ub[wt])&&wt.postMessage({cmd:"checkMailbox"})},$:function(wt,It,jt,qt,hn){It>>>=0,jt>>>=0,qt/=2,oy.length=qt,hn=hn>>>0>>>3;for(var $n=0;$n<qt;$n++)oy[$n]=No[hn+2*$n]?No[hn+2*$n+1]:c()[hn+2*$n+1>>>0];return wt=It?q0[It]:l_[wt],Ur.Sb=jt,jt=wt(...oy),Ur.Sb=0,jt},ha:iy,sa:function(wt){Tt&&Ur.ub[wt>>>0].ref()},w:function(wt,It,jt){return It>>>=0,jt>>>=0,wt=_0(wt>>>0),It=fy(It,"emval::as"),_y(It,jt,wt)},z:function(wt){return wt>>>=0,Cr(()=>(wt=_0(wt),wt.then(L0)))},o:function(wt,It,jt,qt){return jt>>>=0,qt>>>=0,wt=$r[wt>>>0],It=_0(It>>>0),wt(null,It,jt,qt)},k:function(wt,It,jt,qt,hn){return jt>>>=0,qt>>>=0,hn>>>=0,wt=$r[wt>>>0],It=_0(It>>>0),jt=e0(jt),wt(It,It[jt],qt,hn)},c:dy,y:function(wt,It){return It>>>=0,wt=_0(wt>>>0),It=_0(It),wt==It},n:function(wt){return wt>>>=0,wt===0?L0(i0()):(wt=e0(wt),L0(i0()[wt]))},j:function(wt,It,jt){It=Wt(wt,It>>>0);var qt=It.shift();wt--;var hn=`return function (obj, func, destructorsRef, args) {
`,$n=0,ir=[];jt===0&&ir.push("obj");for(var ar=["retType"],Mr=[qt],Ar=0;Ar<wt;++Ar)ir.push("arg"+Ar),ar.push("argType"+Ar),Mr.push(It[Ar]),hn+=`  var arg${Ar} = argType${Ar}.readValueFromPointer(args${$n?"+"+$n:""});
`,$n+=It[Ar].argPackAdvance;return hn+=`  var rv = ${jt===1?"new func":"func.call"}(${ir.join(", ")});
`,qt.Vb||(ar.push("emval_returnValue"),Mr.push(_y),hn+=`  return emval_returnValue(retType, destructorsRef, rv);
`),ar.push(hn+`};
`),wt=bn(ar)(...Mr),jt=`methodCaller<(${It.map(Kr=>Kr.name).join(", ")}) => ${qt.name}>`,Pt(un(jt,wt))},s:function(wt,It){return It>>>=0,wt=_0(wt>>>0),It=_0(It),L0(wt[It])},d:function(wt){wt>>>=0,9<wt&&(b0[wt+1]+=1)},v:function(){return L0([])},m:function(wt){wt=_0(wt>>>0);for(var It=Array(wt.length),jt=0;jt<wt.length;jt++)It[jt]=wt[jt];return L0(It)},g:function(wt){return L0(e0(wt>>>0))},l:function(){return L0({})},i:function(wt){wt>>>=0;for(var It=_0(wt);It.length;){var jt=It.pop();It.pop()(jt)}dy(wt)},h:function(wt,It,jt){It>>>=0,jt>>>=0,wt=_0(wt>>>0),It=_0(It),jt=_0(jt),wt[It]=jt},e:function(wt,It){return It>>>=0,wt=fy(wt>>>0,"_emval_take_value"),wt=wt.readValueFromPointer(It),L0(wt)},ca:function(wt,It){wt=-9007199254740992>wt||9007199254740992<wt?NaN:Number(wt),It>>>=0,wt=new Date(1e3*wt),$()[It>>>2>>>0]=wt.getUTCSeconds(),$()[It+4>>>2>>>0]=wt.getUTCMinutes(),$()[It+8>>>2>>>0]=wt.getUTCHours(),$()[It+12>>>2>>>0]=wt.getUTCDate(),$()[It+16>>>2>>>0]=wt.getUTCMonth(),$()[It+20>>>2>>>0]=wt.getUTCFullYear()-1900,$()[It+24>>>2>>>0]=wt.getUTCDay(),wt=(wt.getTime()-Date.UTC(wt.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,$()[It+28>>>2>>>0]=wt},da:function(wt,It){wt=-9007199254740992>wt||9007199254740992<wt?NaN:Number(wt),It>>>=0,wt=new Date(1e3*wt),$()[It>>>2>>>0]=wt.getSeconds(),$()[It+4>>>2>>>0]=wt.getMinutes(),$()[It+8>>>2>>>0]=wt.getHours(),$()[It+12>>>2>>>0]=wt.getDate(),$()[It+16>>>2>>>0]=wt.getMonth(),$()[It+20>>>2>>>0]=wt.getFullYear()-1900,$()[It+24>>>2>>>0]=wt.getDay();var jt=(Tn(wt.getFullYear())?tr:vr)[wt.getMonth()]+wt.getDate()-1|0;$()[It+28>>>2>>>0]=jt,$()[It+36>>>2>>>0]=-(60*wt.getTimezoneOffset()),jt=new Date(wt.getFullYear(),6,1).getTimezoneOffset();var qt=new Date(wt.getFullYear(),0,1).getTimezoneOffset();wt=(jt!=qt&&wt.getTimezoneOffset()==Math.min(qt,jt))|0,$()[It+32>>>2>>>0]=wt},ea:function(wt){wt>>>=0;var It=new Date($()[wt+20>>>2>>>0]+1900,$()[wt+16>>>2>>>0],$()[wt+12>>>2>>>0],$()[wt+8>>>2>>>0],$()[wt+4>>>2>>>0],$()[wt>>>2>>>0],0),jt=$()[wt+32>>>2>>>0],qt=It.getTimezoneOffset(),hn=new Date(It.getFullYear(),6,1).getTimezoneOffset(),$n=new Date(It.getFullYear(),0,1).getTimezoneOffset(),ir=Math.min($n,hn);return 0>jt?$()[wt+32>>>2>>>0]=+(hn!=$n&&ir==qt):0<jt!=(ir==qt)&&(hn=Math.max($n,hn),It.setTime(It.getTime()+6e4*((0<jt?ir:hn)-qt))),$()[wt+24>>>2>>>0]=It.getDay(),jt=(Tn(It.getFullYear())?tr:vr)[It.getMonth()]+It.getDate()-1|0,$()[wt+28>>>2>>>0]=jt,$()[wt>>>2>>>0]=It.getSeconds(),$()[wt+4>>>2>>>0]=It.getMinutes(),$()[wt+8>>>2>>>0]=It.getHours(),$()[wt+12>>>2>>>0]=It.getDate(),$()[wt+16>>>2>>>0]=It.getMonth(),$()[wt+20>>>2>>>0]=It.getYear(),wt=It.getTime(),BigInt(isNaN(wt)?-1:wt/1e3)},aa:Nr,ba:_h,R:function(wt,It,jt,qt){wt>>>=0,It>>>=0,jt>>>=0,qt>>>=0;var hn=new Date().getFullYear(),$n=new Date(hn,0,1),ir=new Date(hn,6,1);hn=$n.getTimezoneOffset();var ar=ir.getTimezoneOffset(),Mr=Math.max(hn,ar);it()[wt>>>2>>>0]=60*Mr,$()[It>>>2>>>0]=+(hn!=ar),wt=Ar=>Ar.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],$n=wt($n),ir=wt(ir),ar<hn?(z0($n,jt,17),z0(ir,qt,17)):(z0($n,qt,17),z0(ir,jt,17))},q:()=>{_i("")},f:function(wt,It,jt){return wt>>>=0,It=f0(It>>>0,jt>>>0),q0[wt](...It)},M:function(wt,It,jt){return wt>>>=0,It=f0(It>>>0,jt>>>0),q0[wt](...It)},H:()=>{},L:()=>Date.now(),ra:()=>{throw Ir+=1,"unwind"},T:function(){return 4294901760},u:()=>performance.timeOrigin+performance.now(),x:()=>Tt?(Uo(),sr(Mo)).cpus().length:navigator.hardwareConcurrency,Q:function(wt){wt>>>=0;var It=b().length;if(wt<=It||4294901760<wt)return!1;for(var jt=1;4>=jt;jt*=2){var qt=It*(1+.2/jt);qt=Math.min(qt,wt+100663296);var hn=Math;qt=Math.max(wt,qt);e:{hn=(hn.min.call(hn,4294901760,qt+(65536-qt%65536)%65536)-wn.buffer.byteLength+65535)/65536;try{wn.grow(hn),xu();var $n=1;break e}catch{}$n=void 0}if($n)return!0}return!1},ja:_g,la:p0,Z:D0,C:Q0,J:my,ga:By,I:Fy,a:wn||_.wasmMemory,ka:Vy,r:function(wt,It,jt,qt){return Vy(wt>>>0,It>>>0,jt>>>0,qt>>>0)}},Lr=function(){function wt(jt,qt){return Lr=jt.exports,Lr=xy(),Lr=d_(),Ur.Qb.push(Lr.cb),T0.unshift(Lr.va),gn=qt,A0(),Lr}var It={a:c_};if(O0++,_.instantiateWasm)try{return _.instantiateWasm(It,wt)}catch(jt){dn(`Module.instantiateWasm callback failed with error: ${jt}`),ct(jt)}return S0(It,function(jt){wt(jt.instance,jt.module)}).catch(ct),{}}(),Gy=wt=>(Gy=Lr.wa)(wt);_.__embind_initialize_bindings=()=>(_.__embind_initialize_bindings=Lr.xa)(),_._OrtInit=(wt,It)=>(_._OrtInit=Lr.ya)(wt,It),_._OrtGetLastError=(wt,It)=>(_._OrtGetLastError=Lr.za)(wt,It),_._OrtCreateSessionOptions=(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar)=>(_._OrtCreateSessionOptions=Lr.Aa)(wt,It,jt,qt,hn,$n,ir,ar,Mr,Ar),_._OrtAppendExecutionProvider=(wt,It)=>(_._OrtAppendExecutionProvider=Lr.Ba)(wt,It),_._OrtAddFreeDimensionOverride=(wt,It,jt)=>(_._OrtAddFreeDimensionOverride=Lr.Ca)(wt,It,jt),_._OrtAddSessionConfigEntry=(wt,It,jt)=>(_._OrtAddSessionConfigEntry=Lr.Da)(wt,It,jt),_._OrtReleaseSessionOptions=wt=>(_._OrtReleaseSessionOptions=Lr.Ea)(wt),_._OrtCreateSession=(wt,It,jt)=>(_._OrtCreateSession=Lr.Fa)(wt,It,jt),_._OrtReleaseSession=wt=>(_._OrtReleaseSession=Lr.Ga)(wt),_._OrtGetInputOutputCount=(wt,It,jt)=>(_._OrtGetInputOutputCount=Lr.Ha)(wt,It,jt),_._OrtGetInputName=(wt,It)=>(_._OrtGetInputName=Lr.Ia)(wt,It),_._OrtGetOutputName=(wt,It)=>(_._OrtGetOutputName=Lr.Ja)(wt,It),_._OrtFree=wt=>(_._OrtFree=Lr.Ka)(wt),_._OrtCreateTensor=(wt,It,jt,qt,hn,$n)=>(_._OrtCreateTensor=Lr.La)(wt,It,jt,qt,hn,$n),_._OrtGetTensorData=(wt,It,jt,qt,hn)=>(_._OrtGetTensorData=Lr.Ma)(wt,It,jt,qt,hn),_._OrtReleaseTensor=wt=>(_._OrtReleaseTensor=Lr.Na)(wt),_._OrtCreateRunOptions=(wt,It,jt,qt)=>(_._OrtCreateRunOptions=Lr.Oa)(wt,It,jt,qt),_._OrtAddRunConfigEntry=(wt,It,jt)=>(_._OrtAddRunConfigEntry=Lr.Pa)(wt,It,jt),_._OrtReleaseRunOptions=wt=>(_._OrtReleaseRunOptions=Lr.Qa)(wt),_._OrtCreateBinding=wt=>(_._OrtCreateBinding=Lr.Ra)(wt),_._OrtBindInput=(wt,It,jt)=>(_._OrtBindInput=Lr.Sa)(wt,It,jt),_._OrtBindOutput=(wt,It,jt,qt)=>(_._OrtBindOutput=Lr.Ta)(wt,It,jt,qt),_._OrtClearBoundOutputs=wt=>(_._OrtClearBoundOutputs=Lr.Ua)(wt),_._OrtReleaseBinding=wt=>(_._OrtReleaseBinding=Lr.Va)(wt),_._OrtRunWithBinding=(wt,It,jt,qt,hn)=>(_._OrtRunWithBinding=Lr.Wa)(wt,It,jt,qt,hn),_._OrtRun=(wt,It,jt,qt,hn,$n,ir,ar)=>(_._OrtRun=Lr.Xa)(wt,It,jt,qt,hn,$n,ir,ar),_._OrtEndProfiling=wt=>(_._OrtEndProfiling=Lr.Ya)(wt),_._JsepOutput=(wt,It,jt)=>(_._JsepOutput=Lr.Za)(wt,It,jt),_._JsepGetNodeName=wt=>(_._JsepGetNodeName=Lr._a)(wt);var Cy=_._pthread_self=()=>(Cy=_._pthread_self=Lr.$a)(),Py=_._malloc=wt=>(Py=_._malloc=Lr.ab)(wt),py=_._free=wt=>(py=_._free=Lr.bb)(wt);_.__emscripten_tls_init=()=>(_.__emscripten_tls_init=Lr.cb)();var Hy=_.__emscripten_thread_init=(wt,It,jt,qt,hn,$n)=>(Hy=_.__emscripten_thread_init=Lr.eb)(wt,It,jt,qt,hn,$n);_.__emscripten_thread_crashed=()=>(_.__emscripten_thread_crashed=Lr.fb)();var qy=(wt,It,jt,qt,hn)=>(qy=Lr.gb)(wt,It,jt,qt,hn),Dy=wt=>(Dy=Lr.hb)(wt),Ny=_.__emscripten_thread_exit=wt=>(Ny=_.__emscripten_thread_exit=Lr.ib)(wt),Ky=()=>(Ky=Lr.jb)(),Yy=(wt,It)=>(Yy=Lr.kb)(wt,It),Iy=wt=>(Iy=Lr.lb)(wt),zy=wt=>(zy=Lr.mb)(wt),Ly=()=>(Ly=Lr.nb)(),Xy=_.dynCall_ii=(wt,It)=>(Xy=_.dynCall_ii=Lr.pb)(wt,It),Qy=wt=>(Qy=Lr.qb)(wt),Zy=()=>(Zy=Lr.rb)(),Jy=wt=>(Jy=Lr.sb)(wt),_b=()=>(_b=Lr.tb)();_.___start_em_js=839500,_.___stop_em_js=839661;function d_(){var wt=Lr;wt=Object.assign({},wt);var It=qt=>hn=>qt(hn)>>>0,jt=qt=>()=>qt()>>>0;return wt.wa=It(wt.wa),wt.$a=jt(wt.$a),wt.ab=It(wt.ab),wt.emscripten_main_runtime_thread_id=jt(wt.emscripten_main_runtime_thread_id),wt.mb=It(wt.mb),wt.nb=jt(wt.nb),wt}_.wasmMemory=wn,_.stackSave=()=>Ly(),_.stackRestore=wt=>Iy(wt),_.stackAlloc=wt=>zy(wt),_.keepRuntimeAlive=()=>0<Ir,_.UTF8ToString=d0,_.stringToUTF8=z0,_.lengthBytesUTF8=E0,_.ExitStatus=$0,_.PThread=Ur;var My;v0=function wt(){My||e_(),My||(v0=wt)};function e_(){if(!(0<O0))if(Nt)ot(_),Nt||Yr(T0),startWorker(_);else{if(_.preRun)for(typeof _.preRun=="function"&&(_.preRun=[_.preRun]);_.preRun.length;)k0.unshift(_.preRun.shift());Yr(k0),0<O0||My||(My=!0,_.calledRun=!0,En||(Nt||Yr(T0),ot(_),Nt||Yr(j0)))}}return e_(),dt}})();typeof o=="object"&&typeof e=="object"?e.exports=s:typeof define=="function"&&define.amd&&define([],()=>s)}),Ho=Er((o,e)=>{e.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(...e){var a=e.join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,a+`\n`);return}console.error(a)}function threadAlert(...e){var a=e.join(" ");postMessage({cmd:"alert",text:a,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,a)=>{var r=Module.wasmModule;Module.wasmModule=null;var t=new WebAssembly.Instance(r,e);return a(t)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let r=[];self.onmessage=t=>r.push(t),self.startWorker=t=>{Module=t,postMessage({cmd:"loaded"});for(let s of r)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const t of e.data.handlers)Module[t]=(...s)=>{postMessage({cmd:"callHandler",handler:t,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var a=URL.createObjectURL(e.data.urlOrBlob);importScripts(a),URL.revokeObjectURL(a)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(r){if(r!="unwind")throw r}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(r){throw Module.__emscripten_thread_crashed?.(),r}}self.onmessage=handleMessage;\n'}),Lo,gc,Hi,Gi,Un,Go,yc,bc,vc,Fo,Fe,Or=j(()=>{Lo=zo(),gc=Vo(),Gi=!1,Un=!1,Go=!1,yc=o=>{if(o===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+o+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+o+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},bc=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},vc=(o,e)=>o?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":e?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Fo=async o=>{if(Gi)return Promise.resolve();if(Un)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Go)throw new Error("previous call to 'initializeWebAssembly()' failed.");Un=!0;let e=o.initTimeout,s=o.numThreads,a=o.simd,d=yc(s),h=a&&bc(),b=o.wasmPaths,et=typeof b=="string"?b:void 0,st=vc(h,d),$=typeof b=="object"?b[st]:void 0,it=!1,g=[];if(e>0&&g.push(new Promise(c=>{setTimeout(()=>{it=!0,c()},e)})),g.push(new Promise((c,_)=>{let ot=d?gc:Lo,ct={locateFile:(dt,pt)=>{if(d&&dt.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Ho()],{type:"text/javascript"}));if(dt.endsWith(".wasm")){if($)return $;let ft=et??pt;return st==="ort-wasm-simd.wasm"?ft+"ort-wasm-simd.jsep.wasm":st==="ort-wasm-simd-threaded.wasm"?ft+"ort-wasm-simd-threaded.jsep.wasm":ft+st}return pt+dt}};if(d)if(ct.numThreads=s,typeof Blob>"u")ct.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let dt=`var ortWasmThreaded=${ot.toString()};`;ct.mainScriptUrlOrBlob=new Blob([dt],{type:"text/javascript"})}ot(ct).then(dt=>{Un=!1,Gi=!0,Hi=dt,c()},dt=>{Un=!1,Go=!0,_(dt)})})),await Promise.race(g),it)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},Fe=()=>{if(Gi&&Hi)return Hi;throw new Error("WebAssembly is not initialized yet.")}}),qe,Jr,We,Wn=j(()=>{Or(),qe=(o,e)=>{let s=Fe(),a=s.lengthBytesUTF8(o)+1,d=s._malloc(a);return s.stringToUTF8(o,d,a),e.push(d),d},Jr=(o,e,s,a)=>{if(typeof o=="object"&&o!==null){if(s.has(o))throw new Error("Circular reference in options");s.add(o)}Object.entries(o).forEach(([d,h])=>{let b=e?e+d:d;if(typeof h=="object")Jr(h,b+".",s,a);else if(typeof h=="string"||typeof h=="number")a(b,h.toString());else if(typeof h=="boolean")a(b,h?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof h}`)})},We=o=>{let e=Fe(),s=e.stackSave();try{let a=e.stackAlloc(8);e._OrtGetLastError(a,a+4);let d=e.HEAP32[a/4],h=e.HEAPU32[a/4+1],b=h?e.UTF8ToString(h):"";throw new Error(`${o} ERROR_CODE: ${d}, ERROR_MESSAGE: ${b}`)}finally{e.stackRestore(s)}}}),qo,jo=j(()=>{Or(),Wn(),qo=o=>{let e=Fe(),s=0,a=[],d=o||{};try{if(o?.logSeverityLevel===void 0)d.logSeverityLevel=2;else if(typeof o.logSeverityLevel!="number"||!Number.isInteger(o.logSeverityLevel)||o.logSeverityLevel<0||o.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${o.logSeverityLevel}`);if(o?.logVerbosityLevel===void 0)d.logVerbosityLevel=0;else if(typeof o.logVerbosityLevel!="number"||!Number.isInteger(o.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${o.logVerbosityLevel}`);o?.terminate===void 0&&(d.terminate=!1);let h=0;return o?.tag!==void 0&&(h=qe(o.tag,a)),s=e._OrtCreateRunOptions(d.logSeverityLevel,d.logVerbosityLevel,!!d.terminate,h),s===0&&We("Can't create run options."),o?.extra!==void 0&&Jr(o.extra,"",new WeakSet,(b,et)=>{let st=qe(b,a),$=qe(et,a);e._OrtAddRunConfigEntry(s,st,$)!==0&&We(`Can't set a run config entry: ${b} - ${et}.`)}),[s,a]}catch(h){throw s!==0&&e._OrtReleaseRunOptions(s),a.forEach(b=>e._free(b)),h}}}),wc,$c,_c,xc,Ko,Yo=j(()=>{Or(),Wn(),wc=o=>{switch(o){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${o}`)}},$c=o=>{switch(o){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${o}`)}},_c=o=>{o.extra||(o.extra={}),o.extra.session||(o.extra.session={});let e=o.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),o.executionProviders&&o.executionProviders.some(s=>(typeof s=="string"?s:s.name)==="webgpu")&&(o.enableMemPattern=!1)},xc=(o,e,s)=>{for(let a of e){let d=typeof a=="string"?a:a.name;switch(d){case"webnn":if(d="WEBNN",typeof a!="string"){let b=a;if(b?.deviceType){let et=qe("deviceType",s),st=qe(b.deviceType,s);Fe()._OrtAddSessionConfigEntry(o,et,st)!==0&&We(`Can't set a session config entry: 'deviceType' - ${b.deviceType}.`)}if(b?.numThreads){let et=b.numThreads;(typeof et!="number"||!Number.isInteger(et)||et<0)&&(et=0);let st=qe("numThreads",s),$=qe(et.toString(),s);Fe()._OrtAddSessionConfigEntry(o,st,$)!==0&&We(`Can't set a session config entry: 'numThreads' - ${b.numThreads}.`)}if(b?.powerPreference){let et=qe("powerPreference",s),st=qe(b.powerPreference,s);Fe()._OrtAddSessionConfigEntry(o,et,st)!==0&&We(`Can't set a session config entry: 'powerPreference' - ${b.powerPreference}.`)}}break;case"webgpu":if(d="JS",typeof a!="string"){let b=a;if(b?.preferredLayout){if(b.preferredLayout!=="NCHW"&&b.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${b.preferredLayout}`);let et=qe("preferredLayout",s),st=qe(b.preferredLayout,s);Fe()._OrtAddSessionConfigEntry(o,et,st)!==0&&We(`Can't set a session config entry: 'preferredLayout' - ${b.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${d}`)}let h=qe(d,s);Fe()._OrtAppendExecutionProvider(o,h)!==0&&We(`Can't append execution provider: ${d}.`)}},Ko=o=>{let e=Fe(),s=0,a=[],d=o||{};_c(d);try{let h=wc(d.graphOptimizationLevel??"all"),b=$c(d.executionMode??"sequential"),et=typeof d.logId=="string"?qe(d.logId,a):0,st=d.logSeverityLevel??2;if(!Number.isInteger(st)||st<0||st>4)throw new Error(`log serverity level is not valid: ${st}`);let $=d.logVerbosityLevel??0;if(!Number.isInteger($)||$<0||$>4)throw new Error(`log verbosity level is not valid: ${$}`);let it=typeof d.optimizedModelFilePath=="string"?qe(d.optimizedModelFilePath,a):0;if(s=e._OrtCreateSessionOptions(h,!!d.enableCpuMemArena,!!d.enableMemPattern,b,!!d.enableProfiling,0,et,st,$,it),s===0&&We("Can't create session options."),d.executionProviders&&xc(s,d.executionProviders,a),d.enableGraphCapture!==void 0){if(typeof d.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${d.enableGraphCapture}`);let g=qe("enableGraphCapture",a),c=qe(d.enableGraphCapture.toString(),a);e._OrtAddSessionConfigEntry(s,g,c)!==0&&We(`Can't set a session config entry: 'enableGraphCapture' - ${d.enableGraphCapture}.`)}if(d.freeDimensionOverrides)for(let[g,c]of Object.entries(d.freeDimensionOverrides)){if(typeof g!="string")throw new Error(`free dimension override name must be a string: ${g}`);if(typeof c!="number"||!Number.isInteger(c)||c<0)throw new Error(`free dimension override value must be a non-negative integer: ${c}`);let _=qe(g,a);e._OrtAddFreeDimensionOverride(s,_,c)!==0&&We(`Can't set a free dimension override: ${g} - ${c}.`)}return d.extra!==void 0&&Jr(d.extra,"",new WeakSet,(g,c)=>{let _=qe(g,a),ot=qe(c,a);e._OrtAddSessionConfigEntry(s,_,ot)!==0&&We(`Can't set a session config entry: ${g} - ${c}.`)}),[s,a]}catch(h){throw s!==0&&e._OrtReleaseSessionOptions(s),a.forEach(b=>e._free(b)),h}}}),Li,Kt,cr,Nn,en,Vn,Fi,ye=j(()=>{Li=o=>{switch(o){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${o}`)}},Kt=o=>{switch(o){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${o}`)}},cr=o=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][o],Nn=o=>{switch(o){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${o}`)}},en=o=>{switch(o){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${o}`)}},Vn=o=>o==="float32"||o==="float16"||o==="int32"||o==="int64"||o==="uint32"||o==="uint8"||o==="bool",Fi=o=>{switch(o){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${o}`)}}}),tn,qi=j(()=>{tn=async o=>{if(typeof o=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(o))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let s=(void 0)(o),a=[];for await(let d of s)a.push(d);return new Uint8Array(Buffer.concat(a))}throw e}else{let e=await fetch(o);if(!e.ok)throw new Error(`failed to load external data file: ${o}`);let s=e.headers.get("Content-Length"),a=s?parseInt(s,10):0;if(a<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${o}, no response body.`);let d=e.body.getReader(),h;try{h=new ArrayBuffer(a)}catch(et){if(et instanceof RangeError){let st=Math.ceil(a/65536);h=new WebAssembly.Memory({initial:st,maximum:st}).buffer}else throw et}let b=0;for(;;){let{done:et,value:st}=await d.read();if(et)break;let $=st.byteLength;new Uint8Array(h,b,$).set(st),b+=$}return new Uint8Array(h,0,a)}}else return o instanceof Blob?new Uint8Array(await o.arrayBuffer()):o instanceof Uint8Array?o:new Uint8Array(o)}}),Sc,Cc,Xo,Zo,Qo,Ic,Ne,Yt=j(()=>{ye(),Sc=["V","I","W","E","F"],Cc=(o,e)=>{console.log(`[${Sc[o]},${new Date().toISOString()}]${e}`)},Qo=(o,e)=>{Xo=o,Zo=e},Ic=(o,e)=>{let s=en(o),a=en(Xo);s>=a&&Cc(s,typeof e=="function"?e():e)},Ne=(...o)=>{Zo&&Ic(...o)}}),Jo,es=j(()=>{ye(),Jo=(o,e)=>new(Nn(e))(o)}),Hn=j(()=>{}),ts,ji,Ki,Tc,Ac,rs,Xi,Yi,is,as=j(()=>{Yt(),Hn(),ts=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),ji=[],Ki=o=>Math.ceil(o/16)*16,Tc=o=>{for(let e=0;e<ji.length;e++){let s=ji[e];if(o<=s)return s}return Math.ceil(o/16)*16},Ac=1,rs=()=>Ac++,Xi=async(o,e,s,a)=>{let d=Ki(s),h=o.device.createBuffer({size:d,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let b=o.getCommandEncoder();o.endComputePass(),b.copyBufferToBuffer(e,0,h,0,d),o.flush(),await h.mapAsync(GPUMapMode.READ);let et=h.getMappedRange();if(a){let st=a();return st.set(new Uint8Array(et,0,s)),st}else return new Uint8Array(et.slice(0,s))}finally{h.destroy()}},Yi=class{constructor(o){this.backend=o,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map,this.capturedPendingBuffers=new Map;for(let[e]of ts)ji.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[])}upload(o,e){let s=e.buffer,a=e.byteOffset,d=e.byteLength,h=Ki(d),b=this.storageCache.get(o);if(!b)throw new Error("gpu data for uploading does not exist");if(b.originalSize!==d)throw new Error(`inconsistent data size. gpu data size=${b.originalSize}, data size=${d}`);let et=this.backend.device.createBuffer({mappedAtCreation:!0,size:h,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),st=et.getMappedRange();new Uint8Array(st).set(new Uint8Array(s,a,d)),et.unmap();let $=this.backend.getCommandEncoder();this.backend.endComputePass(),$.copyBufferToBuffer(et,0,b.gpuData.buffer,0,h),Ne("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${o})`),this.buffersForUploadingPending.push(et)}memcpy(o,e){let s=this.storageCache.get(o);if(!s)throw new Error("source gpu data for memcpy does not exist");let a=this.storageCache.get(e);if(!a)throw new Error("destination gpu data for memcpy does not exist");if(s.originalSize!==a.originalSize)throw new Error("inconsistent source and destination gpu data size");let d=Ki(s.originalSize),h=this.backend.getCommandEncoder();this.backend.endComputePass(),h.copyBufferToBuffer(s.gpuData.buffer,0,a.gpuData.buffer,0,d)}registerExternalBuffer(o,e,s){let a;if(s){if(a=this.externalBuffers.get(s),a===void 0)throw new Error("previous buffer is not registered");if(o===s)return Ne("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${a}, buffer is the same, skip.`),a;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);this.externalBuffers.delete(s)}else a=rs();return this.storageCache.set(a,{gpuData:{id:a,type:0,buffer:o},originalSize:e}),this.externalBuffers.set(o,a),Ne("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${a}, registered.`),a}unregisterExternalBuffer(o){let e=this.externalBuffers.get(o);e!==void 0&&(this.storageCache.delete(e),this.externalBuffers.delete(o),Ne("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(o,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let s=Tc(o),a,d=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,h=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(d||h){let et=(d?this.freeBuffers:this.freeUniformBuffers).get(s);et?et.length>0?a=et.pop():a=this.backend.device.createBuffer({size:s,usage:e}):a=this.backend.device.createBuffer({size:s,usage:e})}else a=this.backend.device.createBuffer({size:s,usage:e});let b={id:rs(),type:0,buffer:a};return this.storageCache.set(b.id,{gpuData:b,originalSize:o}),Ne("verbose",()=>`[WebGPU] GpuDataManager.create(size=${o}) => id=${b.id}`),b}get(o){return this.storageCache.get(o)?.gpuData}release(o){let e=this.storageCache.get(o);if(!e)throw new Error("releasing data does not exist");return Ne("verbose",()=>`[WebGPU] GpuDataManager.release(id=${o}), gpuDataId=${e.gpuData.id}`),this.storageCache.delete(o),this.buffersPending.push(e.gpuData.buffer),e.originalSize}async download(o,e){let s=this.storageCache.get(o);if(!s)throw new Error("data does not exist");await Xi(this.backend,s.gpuData.buffer,s.originalSize,e)}refreshPendingBuffers(){for(let o of this.buffersForUploadingPending)o.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let o of this.buffersPending){let e=ts.get(o.size);if((o.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let s=this.freeBuffers.get(o.size)||[];e===void 0||s.length>=e?o.destroy():s.push(o)}else if((o.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let s=this.freeUniformBuffers.get(o.size)||[];e===void 0||s.length>=e?o.destroy():s.push(o)}else o.destroy()}this.buffersPending=[]}else{let o=this.capturedPendingBuffers.get(this.backend.currentSessionId);o||(o=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,o));for(let e of this.buffersPending)o.push(e);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(o=>{o.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(o=>{o.forEach(e=>{e.destroy()})}),this.storageCache.forEach(o=>{o.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(o=>{o.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(o){let e=this.capturedPendingBuffers.get(o);e&&(e.forEach(s=>{s.destroy()}),this.capturedPendingBuffers.delete(o))}},is=(...o)=>new Yi(...o)}),Zi,we,Ze=j(()=>{Zi=class{constructor(o){Object.assign(this,o)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(o=>`${this[o]}`).join(";")),this.key}},we=o=>new Zi(o)}),Qi,Rt,M,pr,Gn,Ln,Fn,xe=j(()=>{Qi=class{static calcMatMulShape(o,e){return o[1]!==e[0]?void 0:[o[0],e[1]]}},Rt=class{static calcShape(o,e,s=!1){let a=o.length,d=e.length;if(a===0)return e;if(d===0)return o;let h=Math.max(o.length,e.length),b=new Array(h);if(s){if(a<2||d<2)return;let et=Qi.calcMatMulShape([o[a-2],o[a-1]],[e[d-2],e[d-1]]);if(et===void 0)return;[b[h-2],b[h-1]]=et}for(let et=s?3:1;et<=h;et++){let st=a-et<0?1:o[a-et],$=d-et<0?1:e[d-et];if(st!==$&&st>1&&$>1)return;let it=Math.max(st,$);if(st&&$)b[h-et]=Math.max(st,$);else{if(it>1)return;b[h-et]=0}}return b}static isValidBroadcast(o,e){let s=o.length,a=e.length;if(s>a)return!1;for(let d=1;d<=s;d++)if(o[s-d]!==1&&o[s-d]!==e[a-d])return!1;return!0}},M=class Ry{static size(e){return Ry.getSizeFromDimensionRange(e,0,e.length)}static convertShape(e,s=4){let a=e.length;if(a===0)return[];let d=new Array(a),h=a-1;for(;h>=0;){if(e[h]%s===0){d[h]=e[h]/s;break}if(s%e[h]!==0)throw new Error("cannot convert shape");d[h]=1,s/=e[h],h--}for(h--;h>=0;h--)d[h]=e[h];return d}static sizeFromDimension(e,s){if(s<0||s>e.length)throw new Error(`invalid dimension of ${s} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return Ry.getSizeFromDimensionRange(e,s,e.length)}static sizeToDimension(e,s){if(s<0||s>e.length)throw new Error(`invalid dimension of ${s} for sizeToDimension as Tensor has ${e.length} dimensions.`);return Ry.getSizeFromDimensionRange(e,0,s)}static getSizeFromDimensionRange(e,s,a){let d=1;for(let h=s;h<a;h++){if(e[h]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");d*=e[h]}return d}static computeStrides(e){let s=e.length;if(s===0)return[];if(s===1)return[1];let a=new Array(s);a[s-1]=1,a[s-2]=e[s-1];for(let d=s-3;d>=0;--d)a[d]=a[d+1]*e[d+1];return a}static normalizeAxis(e,s){if(e<-s&&e>=s)throw new Error("unsupported axis for this operation.");return e<0?e+s:e}static normalizeAxes(e,s){return e.map(a=>this.normalizeAxis(a,s??e.length))}static sortBasedOnPerm(e,s){return s?s.map(a=>e[a]):e.slice().reverse()}static padShape(e,s){let a=e.length;return e.map((d,h)=>d+s[h]+s[h+a])}static areEqual(e,s){return e.length!==s.length?!1:e.every((a,d)=>a===s[d])}},pr=class Oy{static adjustPoolAttributes(e,s,a,d,h,b){if(!e&&a.length!==s.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let et=0;et<s.length-2;et++)et>=a.length?a.push(s[et+2]):a[et]=s[et+2];for(let et=0;et<a.length;et++)if(et<d.length){if(d[et]<0)throw new Error("strides should be greater than or equal to 1")}else d.push(1);for(let et=0;et<a.length;et++)if(et<h.length){if(h[et]<0)throw new Error("dilations should be greater than or equal to 1")}else h.push(1);for(let et=0;et<a.length*2;et++)if(et<b.length){if(b[et]<0)throw new Error("pad should be greater than or equal to 1")}else b.push(0);for(let et=0;et<a.length;et++){if(a[et]<=0)throw new Error("kernel shapes need to be greater than 0");if(b[et]>=a[et]||b[et+a.length]>=a[et])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,s,a,d,h,b,et){if(et){if(h.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(s.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(d.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let st=0;st<e.length-2;st++)Oy.adjustPadAndReturnShape(e[st+(b?1:2)],s[st],a[st],d[st],h,st,st+e.length-2,et)}}static computePoolOutputShape(e,s,a,d,h,b,et){if(s.length<=0)throw new Error("input shape must be of size greater than 0");let st=[s[0],s[1]];return Oy.computeShapeHelper(e,s,st,a,d,h,b,et),st}static computeConvOutputShape(e,s,a,d,h,b,et){if(e.length<=0||s.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let st=[e[0],s[0]];return Oy.computeShapeHelper(!1,e,st,a,d,h,b,et),st}static computeShapeHelper(e,s,a,d,h,b,et,st){if(e)for(let $=0;$<s.length-2;$++)a.push(1);else for(let $=0;$<s.length-2;$++)a.push(Oy.adjustPadAndReturnShape(s[$+2],d[$],h[$],b[$],et,$,$+s.length-2,st))}static adjustPadAndReturnShape(e,s,a,d,h,b,et,st){let $=a*(d-1)+1;if(st&&st!=="NOTSET")switch(st){case"VALID":return h[b]=0,h[et]=0,Math.floor((e-$)/s+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let it=((e+s-1)/s-1)*s+d-e;return h[b]=Math.floor(st==="SAME_LOWER"?(it+1)/2:it/2),h[et]=it-h[b],Math.floor((e+it-d)/s+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+h[b]+h[et]-$)/s+1)}},Gn=class{static getShapeOfGemmResult(o,e,s,a,d){if(o.length!==2||s.length!==2)throw new Error("shape need to be of size 2");let h,b,et;e?(h=o[1],b=o[0]):(h=o[0],b=o[1]);let st=-1;if(a?(et=s[0],st=1):(et=s[1],st=0),s[st]!==b)throw new Error("dimension mismatch");if(h<=0||et<=0||b<=0)throw new Error("invalid shape specified");if(d&&!Rt.isValidBroadcast(d,[h,et]))throw new Error("gemm: invalid bias shape for broadcast");return[h,et,b]}},Ln=-34028234663852886e22,Fn=34028234663852886e22}),mr,ea,Be,rt,X$1,Ue,Xt,fr,At,fe,ta,U,K,qn,Ji,os,Pr,_e=j(()=>{ye(),xe(),mr=64,ea=(o,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(o){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${o}`)}},Be=(o,e=1)=>{let s=ea(o,e);return typeof s=="string"?s:s[0]},rt=(o,e=1)=>{let s=ea(o,e);return typeof s=="string"?s:s[1]},X$1=(...o)=>{let e=[];return o.forEach(s=>{s.length!==0&&e.push({type:12,data:s},{type:12,data:M.computeStrides(s)})}),e},Ue=o=>o%4===0?4:o%2===0?2:1,Xt=(o="f32",e,s="0")=>!e||e===1?`${o}(${s})`:`vec${e}<${o}>(${s})`,fr=(o,e,s)=>o==="f32"?s:e===1?`f32(${s})`:`vec${e}<f32>(${s})`,At=(o,e)=>e===4?`(${o}.x + ${o}.y + ${o}.z + ${o}.w)`:e===2?`(${o}.x + ${o}.y)`:e===3?`(${o}.x + ${o}.y + ${o}.z)`:o,fe=(o,e,s,a)=>o.startsWith("uniforms.")&&s>4?typeof e=="string"?a==="f16"?`${o}[(${e}) / 8][(${e}) % 8 / 4][(${e}) % 8 % 4]`:`${o}[(${e}) / 4][(${e}) % 4]`:a==="f16"?`${o}[${Math.floor(e/8)}][${Math.floor(e%8/4)}][${e%8%4}]`:`${o}[${Math.floor(e/4)}][${e%4}]`:s>1?`${o}[${e}]`:o,ta=(o,e,s,a,d)=>{let h=typeof s=="number",b=h?s:s.length,et=[...new Array(b).keys()],st=b<2?"u32":b<=4?`vec${b}<u32>`:`array<u32, ${b}>`,$=ea(e,d),it=typeof $=="string"?$:$[1],g=typeof $=="string"?$:$[0],c={indices:st,value:it,storage:g,tensor:e},_=gn=>typeof gn=="string"?gn:`${gn}u`,ot={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},ct=h?"uniforms.":"",dt=`${ct}${o}_shape`,pt=`${ct}${o}_strides`,ft="";for(let gn=0;gn<b-1;gn++)ft+=`
    let dim${gn} = current / ${fe(pt,gn,b)};
    let rest${gn} = current % ${fe(pt,gn,b)};
    indices[${gn}] = dim${gn};
    current = rest${gn};
    `;ft+=`indices[${b-1}] = current;`;let ht=b<2?"":`
  fn o2i_${o}(offset: u32) -> ${c.indices} {
    var indices: ${c.indices};
    var current = offset;
    ${ft}
    return indices;
  }`,bt=gn=>(ot.offsetToIndices=!0,b<2?gn:`o2i_${o}(${gn})`),mt=[];if(b>=2)for(let gn=b-1;gn>=0;gn--)mt.push(`${fe(pt,gn,b)} * (indices[${gn}])`);let $t=b<2?"":`
  fn i2o_${o}(indices: ${c.indices}) -> u32 {
    return ${mt.join("+")};
  }`,Tt=gn=>(ot.indicesToOffset=!0,b<2?gn:`i2o_${o}(${gn})`),Nt=(...gn)=>b===0?"0u":`${c.indices}(${gn.map(_).join(",")})`,Ct=(gn,En)=>b<2?`${gn}`:`${fe(gn,En,b)}`,Ft=(gn,En,_r)=>b<2?`${gn}=${_r};`:`${fe(gn,En,b)}=${_r};`,ln={},mn=(gn,En)=>{ot.broadcastedIndicesToOffset=!0;let _r=`${En.name}broadcastedIndicesTo${o}Offset`;if(_r in ln)return`${_r}(${gn})`;let Sr=[];for(let xr=b-1;xr>=0;xr--){let Vr=En.indicesGet("outputIndices",xr+En.rank-b);Sr.push(`${Ct(pt,xr)} * (${Vr} % ${Ct(dt,xr)})`)}return ln[_r]=`fn ${_r}(outputIndices: ${En.type.indices}) -> u32 {
             return ${Sr.length>0?Sr.join("+"):"0u"};
           }`,`${_r}(${gn})`},yn=(gn,En)=>(()=>{if(c.storage===c.value)return`${o}[${gn}]=${En};`;if(c.storage==="vec2<u32>"&&c.value==="i32")return`${o}[${gn}]=vec2<u32>(u32(${En}), select(0u, 0xFFFFFFFFu, ${En} < 0));`;if(c.storage==="vec2<u32>"&&c.value==="u32")return`${o}[${gn}]=vec2<u32>(u32(${En}), 0u);`;if(c.storage==="u32"&&c.value==="vec4<bool>")return`${o}[${gn}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${En}));`;throw new Error(`not supported combination of storage type ${c.storage} and value type ${c.value} yet`)})(),pn=gn=>(()=>{if(c.storage===c.value)return`${o}[${gn}]`;if(c.storage==="vec2<u32>"&&c.value==="i32")return`i32(${o}[${gn}].x)`;if(c.storage==="vec2<u32>"&&c.value==="u32")return`u32(${o}[${gn}].x)`;if(c.storage==="u32"&&c.value==="vec4<bool>")return`vec4<bool>(bool(${o}[${gn}] & 0xFFu), bool(${o}[${gn}] & 0xFF00u), bool(${o}[${gn}] & 0xFF0000u), bool(${o}[${gn}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${c.storage} and value type ${c.value} yet`)})(),Ht=b<2?"":`
  fn get_${o}ByIndices(indices: ${c.indices}) -> ${it} {
    return ${pn(`i2o_${o}(indices)`)};
  }`,Gt=b<2?"":(()=>{let gn=et.map(_r=>`d${_r}: u32`).join(", "),En=et.map(_r=>`d${_r}`).join(", ");return`
  fn get_${o}(${gn}) -> ${it} {
    return get_${o}ByIndices(${Nt(En)});
  }`})(),cn=(...gn)=>{if(gn.length!==b)throw new Error(`indices length must be ${b}`);let En=gn.map(_).join(",");return b===0?pn("0u"):b===1?pn(En[0]):(ot.get=!0,ot.getByIndices=!0,ot.indicesToOffset=!0,`get_${o}(${En})`)},xn=gn=>b<2?pn(gn):(ot.getByIndices=!0,ot.indicesToOffset=!0,`get_${o}ByIndices(${gn})`),dn=b<2?"":`
  fn set_${o}ByIndices(indices: ${c.indices}, value: ${it}) {
    ${yn(`i2o_${o}(indices)`,"value")}
  }`,wn=b<2?"":(()=>{let gn=et.map(_r=>`d${_r}: u32`).join(", "),En=et.map(_r=>`d${_r}`).join(", ");return`
  fn set_${o}(${gn}, value: ${it}) {
    set_${o}ByIndices(${Nt(En)}, value);
  }`})();return{impl:()=>{let gn=[],En=!1;return ot.offsetToIndices&&(gn.push(ht),En=!0),ot.indicesToOffset&&(gn.push($t),En=!0),ot.broadcastedIndicesToOffset&&(Object.values(ln).forEach(_r=>gn.push(_r)),En=!0),ot.set&&(gn.push(wn),En=!0),ot.setByIndices&&(gn.push(dn),En=!0),ot.get&&(gn.push(Gt),En=!0),ot.getByIndices&&(gn.push(Ht),En=!0),!h&&En&&gn.unshift(`const ${dt} = ${c.indices}(${s.join(",")});`,`const ${pt} = ${c.indices}(${M.computeStrides(s).join(",")});`),gn.join(`
`)},type:c,offsetToIndices:bt,indicesToOffset:Tt,broadcastedIndicesToOffset:mn,indices:Nt,indicesGet:Ct,indicesSet:Ft,set:(...gn)=>{if(gn.length!==b+1)throw new Error(`indices length must be ${b}`);let En=gn[b];if(typeof En!="string")throw new Error("value must be string");let _r=gn.slice(0,b).map(_).join(",");return b===0?yn("0u",En):b===1?yn(_r[0],En):(ot.set=!0,ot.setByIndices=!0,ot.indicesToOffset=!0,`set_${o}(${_r}, ${En})`)},setByOffset:yn,setByIndices:(gn,En)=>b<2?yn(gn,En):(ot.setByIndices=!0,ot.indicesToOffset=!0,`set_${o}ByIndices(${gn}, ${En});`),get:cn,getByOffset:pn,getByIndices:xn,usage:a,name:o,strides:pt,shape:dt,rank:b}},U=(o,e,s,a=1)=>ta(o,e,s,"input",a),K=(o,e,s,a=1)=>ta(o,e,s,"output",a),qn=(o,e,s,a=1)=>ta(o,e,s,"internal",a),Ji=class{constructor(o,e){this.normalizedDispatchGroup=o,this.limits=e,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(o){return`if (global_idx >= ${typeof o=="number"?`${o}u`:o}) { return; }`}mainStart(o=mr){let e=typeof o=="number"?o:o[0],s=typeof o=="number"?1:o[1],a=typeof o=="number"?1:o[2];if(e>this.limits.maxComputeWorkgroupSizeX||s>this.limits.maxComputeWorkgroupSizeY||a>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${e}, ${s}, ${a}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(e*s*a>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${e}, ${s}, ${a}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let d=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,h=d?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,b=d?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${e*s*a}u + local_idx;`;return`@compute @workgroup_size(${e}, ${s}, ${a})
  fn main(${h}) {
    ${b}
  `}appendVariableUniforms(o){o.rank!==0&&(o.shape.startsWith("uniforms.")&&this.uniforms.push({name:o.shape.replace("uniforms.",""),type:"u32",length:o.rank}),o.strides.startsWith("uniforms.")&&this.uniforms.push({name:o.strides.replace("uniforms.",""),type:"u32",length:o.rank}))}declareVariable(o,e){if(o.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(o),this.appendVariableUniforms(o);let s=o.usage==="input"?"read":"read_write",a=o.type.storage;return`@group(0) @binding(${e}) var<storage, ${s}> ${o.name}: array<${a}>;`}declareVariables(...o){return o.map(e=>this.declareVariable(e,this.variableIndex++)).join(`
`)}registerInternalVariable(o){if(o.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(o),this.appendVariableUniforms(o)}registerInternalVariables(...o){return o.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(o,e,s=1){return this.uniforms.push({name:o,type:e,length:s}),this}registerUniforms(o){return this.uniforms=this.uniforms.concat(o),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let o=[];for(let{name:e,type:s,length:a}of this.uniforms)if(a&&a>4)s==="f16"?o.push(`@align(16) ${e}:array<mat2x4<${s}>, ${Math.ceil(a/8)}>`):o.push(`${e}:array<vec4<${s}>, ${Math.ceil(a/4)}>`);else{let d=a==null||a===1?s:`vec${a}<${s}>`;o.push(`${e}:${d}`)}return`
      struct Uniforms { ${o.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(o=>o.impl()).join(`
`)+this.internalVariables.map(o=>o.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let o=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map(e=>[o(e.type),e.length??1])}},os=(o,e)=>new Ji(o,e),Pr=(o,e)=>{let s=o.length,a=[];for(let d=0;d<s;d++){let h=s-1-d,b=o[h]||1;(e[e.length-1-d]||1)>1&&b===1&&a.unshift(h)}return a}}),Ec,ss,kc,Oc,xt,us,ls,Rr=j(()=>{ye(),xe(),Ze(),_e(),Ec=o=>{if(!o||o.length!==1)throw new Error("Transpose requires 1 input.")},ss=(o,e)=>e&&e.length!==o?[...new Array(o).keys()].reverse():e,kc=(o,e)=>M.sortBasedOnPerm(o,ss(o.length,e)),Oc=(o,e,s,a)=>{let d=[];d.push(`fn perm(i: ${a.type.indices}) -> ${s.type.indices} {
    var a: ${s.type.indices};`);for(let h=0;h<e;++h)d.push(s.indicesSet("a",o[h],`i[${h}]`));return d.push("return a;}"),d.join(`
`)},xt=(o,e)=>{let s=o.dataType,a=o.dims.length,d=ss(a,e),h=kc(o.dims,d),b=K("output",s,h.length),et=U("a",s,a),st=$=>`
  ${$.registerUniform("output_size","u32").declareVariables(et,b)}

  ${Oc(d,a,et,b)}

  ${$.mainStart()}
    ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${b.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${b.setByOffset("global_idx",et.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:$=>{let it=M.size(h);return{outputs:[{dims:h,dataType:$[0].dataType}],dispatchGroup:{x:Math.ceil(it/64)},programUniforms:[{type:12,data:it},...X$1($[0].dims,h)]}},getShaderSource:st}},us=(o,e)=>{Ec(o.inputs),o.compute(xt(o.inputs[0],e.perm))},ls=o=>we({perm:o.perm})}),Pc,Rc,zc,Bc,Dc,Mc,Uc,Wc,Nc,Vc,zt,ds,cs,ps,ms,fs,hs,gs,ys,bs,vs,ws=j(()=>{ye(),xe(),_e(),jn(),Rr(),Pc={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Rc={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},zc={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Bc={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Dc=(o,e)=>{let s=[];for(let a=e-o;a<e;++a)s.push(a);return s},Mc=(o,e)=>{let s=[],a=o.length;for(let h=0;h<a;h++)e.indexOf(h)===-1&&s.push(o[h]);let d=e.map(h=>o[h]);return[s,d]},Uc=(o,e)=>{let s=o.length+e.length,a=[],d=0;for(let h=0;h<s;h++)e.indexOf(h)===-1?a.push(o[d++]):a.push(1);return a},Wc=(o,e)=>{for(let s=0;s<o.length;++s)if(o[o.length-s-1]!==e-1-s)return!1;return!0},Nc=(o,e)=>{let s=[];if(!Wc(o,e)){for(let a=0;a<e;++a)o.indexOf(a)===-1&&s.push(a);o.forEach(a=>s.push(a))}return s},Vc=(o,e,s,a,d,h,b)=>{let et=s[0].dims,st=M.size(h),$=M.size(b),it=U("_A",s[0].dataType,et),g=K("output",d,h),c=32,_=`
          var<workgroup> aBestValues : array<f32, ${c}>;
       `;return{name:o,shaderCache:e,getShaderSource:ot=>`
        ${ot.registerUniform("reduceSize","u32").declareVariables(it,g)}
        ${_}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${ot.mainStart(c)}

          let outputIndex = global_idx / ${c};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${zc[a]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${c}) {
           let candidate = f32(${it.getByOffset("offset + k")});
           bestValue = ${Pc[a]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${c}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Rc[a]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${g.setByOffset("outputIndex",`${a==="mean"?`${g.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${g.type.storage}(${Bc[a]})`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:h,dataType:d}],dispatchGroup:{x:st},programUniforms:[{type:12,data:$}]})}},zt=(o,e,s,a)=>{let d=o.inputs.length===1?s:ra(o.inputs,s),h=d.axes;h.length===0&&!d.noopWithEmptyAxes&&(h=o.inputs[0].dims.map((_,ot)=>ot));let b=M.normalizeAxes(h,o.inputs[0].dims.length),et=b,st=o.inputs[0],$=Nc(et,o.inputs[0].dims.length);$.length>0&&(st=o.compute(xt(o.inputs[0],$),{inputs:[0],outputs:[-1]})[0],et=Dc(et.length,st.dims.length));let[it,g]=Mc(st.dims,et),c=it;d.keepDims&&(c=Uc(it,b)),o.compute(Vc(e,{hint:d.cacheKey,inputDependencies:["type"]},[st],a,o.inputs[0].dataType,c,g),{inputs:[st]})},ds=(o,e)=>{zt(o,"ReduceMeanShared",e,"mean")},cs=(o,e)=>{zt(o,"ReduceL1Shared",e,"l1")},ps=(o,e)=>{zt(o,"ReduceL2Shared",e,"l2")},ms=(o,e)=>{zt(o,"ReduceLogSumExpShared",e,"logSumExp")},fs=(o,e)=>{zt(o,"ReduceMaxShared",e,"max")},hs=(o,e)=>{zt(o,"ReduceMinShared",e,"min")},gs=(o,e)=>{zt(o,"ReduceProdShared",e,"prod")},ys=(o,e)=>{zt(o,"ReduceSumShared",e,"sum")},bs=(o,e)=>{zt(o,"ReduceSumSquareShared",e,"sumSquare")},vs=(o,e)=>{zt(o,"ReduceLogSumShared",e,"logSum")}}),Bt,Hc,Kn,ra,Dt,Gc,Lc,Fc,qc,jc,Kc,Yc,Xc,Zc,Qc,Mt,$s,_s,xs,Ss,Cs,Is,Ts,As,Es,ks,jn=j(()=>{ye(),xe(),Ze(),_e(),ws(),Bt=o=>{if(!o||o.length===0||o.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(o.length===2&&o[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Hc=o=>["","",`var value = ${o.getByIndices("input_indices")};`,""],Kn=(o,e,s,a,d,h,b=!1,et=!1)=>{let st=[],$=s[0].dims,it=$.length,g=M.normalizeAxes(d,it),c=!et&&g.length===0;$.forEach((ct,dt)=>{c||g.indexOf(dt)>=0?b&&st.push(1):st.push(ct)});let _=st.length,ot=M.size(st);return{name:o,shaderCache:e,getShaderSource:ct=>{let dt=[],pt=U("_A",s[0].dataType,it),ft=K("output",h,_),ht=a(pt,ft,g),bt=ht[2];for(let mt=0,$t=0;mt<it;mt++)c||g.indexOf(mt)>=0?(b&&$t++,bt=`for(var j${mt}: u32 = 0; j${mt} < ${$[mt]}; j${mt}++) {
                  ${ht[2].includes("last_index")?`let last_index = j${mt};`:""}
                  ${pt.indicesSet("input_indices",mt,`j${mt}`)}
                  ${bt}
                }`):(dt.push(`${pt.indicesSet("input_indices",mt,ft.indicesGet("output_indices",$t))};`),$t++);return`

        ${ct.registerUniform("output_size","u32").declareVariables(pt,ft)}

        ${ct.mainStart()}
          ${ct.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${pt.type.indices};
          let output_indices = ${ft.offsetToIndices("global_idx")};

          ${dt.join(`
`)}
          ${ht[0]}       // init ops for reduce max/min
          ${ht[1]}
          ${bt}
          ${ht[3]}
          ${ht.length===4?ft.setByOffset("global_idx","value"):ht.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:st,dataType:h}],dispatchGroup:{x:Math.ceil(ot/64)},programUniforms:[{type:12,data:ot},...X$1($,st)]})}},ra=(o,e)=>{let s=[];return o[1].dims[0]>0&&o[1].getBigInt64Array().forEach(a=>s.push(Number(a))),we({axes:s,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},Dt=(o,e,s,a)=>{let d=o.inputs,h=d.length===1?s:ra(d,s);o.compute(Kn(e,{hint:h.cacheKey,inputDependencies:["rank"]},[d[0]],h.noopWithEmptyAxes&&h.axes.length===0?Hc:a,h.axes,d[0].dataType,h.keepDims,h.noopWithEmptyAxes),{inputs:[0]})},Gc=(o,e)=>{Bt(o.inputs),Dt(o,"ReduceLogSum",e,(s,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${s.getByIndices("input_indices")};`,"value = log(value);"])},Lc=(o,e)=>{Bt(o.inputs),Dt(o,"ReduceL1",e,(s,a)=>[`var value = ${a.type.storage}(0);`,"",`value += abs(${s.getByIndices("input_indices")});`,""])},Fc=(o,e)=>{Bt(o.inputs),Dt(o,"ReduceL2",e,(s,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${s.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},qc=(o,e)=>{Bt(o.inputs),Dt(o,"ReduceLogSumExp",e,(s,a)=>[`var value = ${a.type.storage}(0);`,"",`value += exp(${s.getByIndices("input_indices")});`,"value = log(value);"])},jc=(o,e)=>{Bt(o.inputs),Dt(o,"ReduceMax",e,(s,a,d)=>{let h=[];for(let b=0;b<s.rank;b++)(d.indexOf(b)>=0||d.length===0)&&h.push(s.indicesSet("input_indices",b,0));return[`${h.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};`,`value = max(value, ${s.getByIndices("input_indices")});`,""]})},Kc=(o,e)=>{Bt(o.inputs),Dt(o,"ReduceMean",e,(s,a,d)=>{let h=1;for(let b=0;b<s.rank;b++)(d.indexOf(b)>=0||d.length===0)&&(h*=o.inputs[0].dims[b]);return["var sum = f32(0);","",`sum += f32(${s.getByIndices("input_indices")});`,`let value = ${a.type.value}(sum / ${h});`]})},Yc=(o,e)=>{Bt(o.inputs),Dt(o,"ReduceMin",e,(s,a,d)=>{let h=[];for(let b=0;b<s.rank;b++)(d.indexOf(b)>=0||d.length===0)&&h.push(`input_indices[${b}] = 0;`);return[`${h.join(`
`)}`,`var value = ${s.getByIndices("input_indices")};`,`value = min(value, ${s.getByIndices("input_indices")});`,""]})},Xc=(o,e)=>{Bt(o.inputs),Dt(o,"ReduceProd",e,(s,a)=>[`var value = ${a.type.storage}(1);`,"",`value *= ${s.getByIndices("input_indices")};`,""])},Zc=(o,e)=>{Bt(o.inputs),Dt(o,"ReduceSum",e,(s,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${s.getByIndices("input_indices")};`,""])},Qc=(o,e)=>{Bt(o.inputs),Dt(o,"ReduceSumSquare",e,(s,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${s.getByIndices("input_indices")}; value += t * t;`,""])},Mt=(o,e,s)=>{if(e.length===0)return s;let a=1,d=1;for(let h=0;h<e.length;h++)e.indexOf(h)===-1?a*=o[h]:d*=o[h];return d<32&&a>1024},$s=(o,e)=>{Mt(o.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Kc(o,e):ds(o,e)},_s=(o,e)=>{Mt(o.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Lc(o,e):cs(o,e)},xs=(o,e)=>{Mt(o.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Fc(o,e):ps(o,e)},Ss=(o,e)=>{Mt(o.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?qc(o,e):ms(o,e)},Cs=(o,e)=>{Mt(o.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?jc(o,e):fs(o,e)},Is=(o,e)=>{Mt(o.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Yc(o,e):hs(o,e)},Ts=(o,e)=>{Mt(o.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Xc(o,e):gs(o,e)},As=(o,e)=>{Mt(o.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Zc(o,e):ys(o,e)},Es=(o,e)=>{Mt(o.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Qc(o,e):bs(o,e)},ks=(o,e)=>{Mt(o.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Gc(o,e):vs(o,e)}}),Os,Ps,Rs,na,zs=j(()=>{ye(),Ze(),jn(),Os=o=>{if(!o||o.length===0||o.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(o[0].dataType!==1)throw new Error("Invalid input type.")},Ps=(o,e)=>{Os(o.inputs);let s=(a,d,h)=>{let b=[];for(let et=0;et<a.rank;et++)(h.indexOf(et)>=0||h.length===0)&&b.push(`input_indices[${et}] = 0;`);return[`${b.join(`
`)}`,`var value = ${a.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${a.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${a.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",d.setByOffset("global_idx","best_index")]};o.compute(Kn("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[o.inputs[0]],s,[e.axis],7,e.keepDims),{inputs:[0]})},Rs=(o,e)=>{Os(o.inputs);let s=(a,d,h)=>{let b=[];for(let et=0;et<a.rank;et++)(h.indexOf(et)>=0||h.length===0)&&b.push(`input_indices[${et}] = 0;`);return[`${b.join(`
`)}`,`var value = ${a.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${a.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${a.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",d.setByOffset("global_idx","best_index")]};o.compute(Kn("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[o.inputs[0]],s,[e.axis],7,e.keepDims),{inputs:[0]})},na=o=>we(o)}),Jc,ep,tp,Yn,Bs,Ds,ia=j(()=>{ye(),xe(),Ze(),_e(),Jc=(o,e)=>{if(!o||o.length<1)throw new Error("too few inputs");let s=0,a=o[s],d=a.dataType,h=a.dims.length;o.forEach((b,et)=>{if(et!==s){if(b.dataType!==d)throw new Error("input tensors should be one type");if(b.dims.length!==h)throw new Error("input tensors should have the same shape");b.dims.forEach((st,$)=>{if($!==e&&st!==a.dims[$])throw new Error("non concat dimensions must match")})}})},ep=(o,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${o}u>(${e});
    for (var i: u32 = 0u; i < ${o}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${o}u;
  }`,tp=(o,e)=>{let s=o.length,a=[];for(let d=0;d<s;++d){let h=e.setByOffset("global_idx",o[d].getByIndices("indices"));s===1?a.push(h):d===0?a.push(`if (inputIndex == ${d}u) { ${h} }`):d===s-1?a.push(`else { ${h} }`):a.push(`else if (inputIndex == ${d}) { ${h} }`)}return a.join(`
`)},Yn=(o,e,s,a)=>{let d=M.size(s),h=new Array(o.length),b=new Array(o.length),et=0,st=[],$=[],it=[{type:12,data:d}];for(let ct=0;ct<o.length;++ct)et+=o[ct].dims[e],h[ct]=et,$.push(o[ct].dims.length),b[ct]=U(`input${ct}`,a,$[ct]),st.push("rank"),it.push({type:12,data:h[ct]});for(let ct=0;ct<o.length;++ct)it.push(...X$1(o[ct].dims));it.push(...X$1(s));let g=K("output",a,s.length),c=g.indicesGet("indices",e),_=Array.from(Array(h.length).keys()).map(ct=>`uniforms.sizeInConcatAxis${ct}`).join(","),ot=ct=>`

  ${(()=>{ct.registerUniform("outputSize","u32");for(let dt=0;dt<o.length;dt++)ct.registerUniform(`sizeInConcatAxis${dt}`,"u32");return ct.declareVariables(...b,g)})()}

  ${ep(h.length,_)}

  ${ct.mainStart()}
    ${ct.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${g.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${c});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${h.length}u>(${_});
      ${c} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${tp(b,g)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:st},getRunData:()=>({outputs:[{dims:s,dataType:a}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:it}),getShaderSource:ot}},Bs=(o,e)=>{let s=o.inputs,a=s[0].dims,d=M.normalizeAxis(e.axis,a.length);Jc(s,d);let h=a.slice();h[d]=s.reduce((et,st)=>et+(st.dims.length>d?st.dims[d]:0),0);let b=s.filter(et=>M.size(et.dims)>0);o.compute(Yn(b,d,h,s[0].dataType),{inputs:b})},Ds=o=>we({axis:o.axis})}),rp,np,ip,ap,Xn,op,Ms,aa=j(()=>{ye(),Hn(),_e(),ia(),rp=(o,e)=>{let s=o[0],a=o[1],d=o[2],h=o[3],b=o[4],et=o[5];if(b&&et)throw new Error("Attention cannot have both past and relative_position_bias");if(s.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let st=s.dims[0],$=s.dims[1],it=s.dims[2];if(d.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(a.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(a.dims[0]!==it)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(d.dims[0]!==a.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let g=d.dims[0]/3,c=g,_=c;if(e.qkvHiddenSizes.length>0){if(e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let ht of e.qkvHiddenSizes)if(ht%e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");g=e.qkvHiddenSizes[0],c=e.qkvHiddenSizes[1],_=e.qkvHiddenSizes[2]}let ot=$;if(g!==c)throw new Error("qkv_hidden_sizes first element should be same as the second");if(d.dims[0]!==g+c+_)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let ct=0;if(b){if(c!==_)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(b.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(b.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(b.dims[1]!==st)throw new Error('Input "past" second dimension must be batch_size');if(b.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(b.dims[4]!==c/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(ct=b.dims[3])}let dt=ot+ct,pt=-1,ft=0;if(h)throw new Error("Mask not supported");if(b)throw new Error("past is not supported");return{batchSize:st,sequenceLength:$,pastSequenceLength:ct,kvSequenceLength:ot,totalSequenceLength:dt,maxSequenceLength:pt,inputHiddenSize:it,hiddenSize:g,vHiddenSize:_,headSize:Math.floor(g/e.numHeads),vHeadSize:Math.floor(_/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:ft,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},np=(o,e,s,a)=>{let d=Ue(a),h=64,b=a/d;b<h?h=1:b/8<64&&(h=Math.ceil(b/8));let et=Math.ceil(a/d/h),st=[{type:e.dataType,data:1/a},{type:12,data:b},{type:12,data:et}],$=Be(e.dataType,d),it=rt(1,d),g=c=>{let _=K("x",e.dataType,e.dims,d),ot=[{name:"d_inv",type:rt(e.dataType)},{name:"d_comp",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${h}>;
  var<workgroup> thread_sum: array<f32, ${h}>;
  ${c.registerUniforms(ot).declareVariables(_)}
  ${c.mainStart([h,1,1])}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = workgroup_id.x * uniforms.d_comp + local_offset;

    var thread_max_vector = ${it}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      thread_max_vector = max(${it}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(d){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${d}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${h}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${it}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      sum_vector += exp(${it}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(d){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${d}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${h}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        x[offset + i] = ${_.type.value}(uniforms.d_inv);
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        var f32input = ${it}(x[offset + i]);
        x[offset + i] = ${_.type.value}(exp(f32input - max_value) / sum);
      }
    }
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${h};${$};${d}`},getShaderSource:g,getRunData:()=>({outputs:[],dispatchGroup:{x:s},programUniforms:st})}},ip=(o,e,s,a,d,h,b)=>{let et=b+d.kvSequenceLength,st=[d.batchSize,d.numHeads,d.sequenceLength,et],$=h.scale===0?1/Math.sqrt(d.headSize):h.scale,it=Ue(d.headSize),g=d.headSize/it,c=12,_={x:Math.ceil(et/c),y:Math.ceil(d.sequenceLength/c),z:d.batchSize*d.numHeads},ot=[{type:12,data:d.sequenceLength},{type:12,data:g},{type:12,data:et},{type:12,data:d.numHeads},{type:1,data:$}],ct=a?["type","type","type"]:["type","type"],dt=pt=>{let ft=U("q",e.dataType,e.dims,it),ht=U("key",s.dataType,s.dims,it),bt=[ft,ht];a&&bt.push(U("relative_position_bias",a.dataType,a.dims));let mt=K("output",e.dataType,st),$t=rt(1,it),Tt=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"alpha",type:"f32"}];return`
  const TILE_SIZE = ${c}u;

  var<workgroup> tileQ: array<${ft.type.storage}, ${c*c}>;
  var<workgroup> tileK: array<${ft.type.storage}, ${c*c}>;
  ${pt.registerUniforms(Tt).declareVariables(...bt,mt)}
  ${pt.mainStart([c,c,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;

    var value = ${$t}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
        value += ${$t}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(it){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${it}`)}})()};
        output[outputIdx] = ${mt.type.value} (sum * uniforms.alpha) + ${a?"relative_position_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${it}`,inputDependencies:ct},getRunData:()=>({outputs:[{dims:st,dataType:e.dataType,gpuDataType:0}],dispatchGroup:_,programUniforms:ot}),getShaderSource:dt}},ap=(o,e,s,a,d)=>{let h=d+a.kvSequenceLength,b=[a.batchSize,a.sequenceLength,a.vHiddenSize],et=12,st={x:Math.ceil(a.vHeadSize/et),y:Math.ceil(a.sequenceLength/et),z:a.batchSize*a.numHeads},$=[{type:12,data:a.sequenceLength},{type:12,data:h},{type:12,data:a.vHeadSize},{type:12,data:a.numHeads},{type:12,data:a.vHiddenSize}];return{name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:b,dataType:e.dataType,gpuDataType:0}],dispatchGroup:st,programUniforms:$}),getShaderSource:it=>{let g=U("probs",e.dataType,e.dims),c=U("v",s.dataType,s.dims),_=K("output",e.dataType,b),ot=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}];return`
  const TILE_SIZE = ${et}u;
  var<workgroup> tileQ: array<${g.type.value}, ${et*et}>;
  var<workgroup> tileK: array<${g.type.value}, ${et*et}>;
  ${it.registerUniforms(ot).declareVariables(g,c,_)}
  ${it.mainStart([et,et,1])}
   let headIdx = workgroup_id.z;
   let m = global_id.y;
   let n = global_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;

   var value = ${g.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
     if (m < uniforms.M && w + local_id.x < uniforms.K) {
       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
     }
     if (n < uniforms.N && w + local_id.y < uniforms.K) {
       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];
     }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`}}},Xn=(o,e,s,a,d,h,b,et,st,$,it)=>{let g=o.outputCount>1,c=o.outputCount>2,_=g&&c?$.pastSequenceLength:0,ot=_+$.kvSequenceLength,ct=[$.batchSize,$.numHeads,ot,$.headSize],dt=b?[b,s]:[s],pt=g?o.compute(Yn(dt,2,ct,s.dataType),{inputs:dt,outputs:[1]})[0]:s,ft=[$.batchSize,$.numHeads,ot,$.headSize],ht=et?[et,a]:[a],bt=c?o.compute(Yn(ht,2,ft,a.dataType),{inputs:ht,outputs:[2]})[0]:a,mt=[e,pt];st&&mt.push(st);let $t=o.compute(ip(o,e,pt,st,$,it,_),{inputs:mt,outputs:[-1]})[0];o.compute(np(o,$t,$.batchSize*$.numHeads*$.sequenceLength,ot),{inputs:[$t],outputs:[]});let Tt=[$t,bt];o.compute(ap(o,$t,bt,$,_),{inputs:Tt,outputs:[0]})},op=(o,e)=>{let s=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],a=e.sequenceLength,d=e.inputHiddenSize,h=e.headSize,b=12,et={x:Math.ceil(e.headSize/b),y:Math.ceil(e.sequenceLength/b),z:e.batchSize*e.numHeads},st=[o.inputs[0],o.inputs[1],o.inputs[2]],$=[{type:12,data:a},{type:12,data:d},{type:12,data:h},{type:12,data:e.numHeads},{type:12,data:e.headSize},{type:12,data:e.hiddenSize},{type:12,data:e.hiddenSize+e.hiddenSize+e.vHiddenSize}],it=g=>{let c=K("output_q",st[0].dataType,s),_=K("output_k",st[0].dataType,s),ot=K("output_v",st[0].dataType,s),ct=U("input",st[0].dataType,st[0].dims),dt=U("weight",st[1].dataType,st[1].dims),pt=U("bias",st[2].dataType,st[2].dims),ft=ct.type.storage,ht=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${b}u;
  var<workgroup> tileInput: array<${ft}, ${b*b}>;
  var<workgroup> tileWeightQ: array<${ft}, ${b*b}>;
  var<workgroup> tileWeightK: array<${ft}, ${b*b}>;
  var<workgroup> tileWeightV: array<${ft}, ${b*b}>;
  ${g.registerUniforms(ht).declareVariables(ct,dt,pt,c,_,ot)}
  ${g.mainStart([b,b,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${ft}(0);
    var valueK = ${ft}(0);
    var valueV = ${ft}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return o.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:o.inputs[0].dataType,gpuDataType:0},{dims:s,dataType:o.inputs[0].dataType,gpuDataType:0},{dims:s,dataType:o.inputs[0].dataType,gpuDataType:0}],dispatchGroup:et,programUniforms:$}),getShaderSource:it},{inputs:st,outputs:[-1,-1,-1]})},Ms=(o,e)=>{let s=rp(o.inputs,e),[a,d,h]=op(o,s);return Xn(o,a,d,h,o.inputs[4],void 0,void 0,void 0,o.inputs[5],s,e)}}),sp,up,lp,Us,Ws=j(()=>{_t(),ye(),xe(),Ze(),_e(),sp=(o,e)=>{if(!o||o.length!==5)throw new Error("BatchNormalization requires 5 inputs");let s=(a,d,h)=>{let b=d.length;if(b!==a.length)throw new Error(`${h}: num dimensions != ${b}`);d.forEach((et,st)=>{if(et!==a[st])throw new Error(`${h}: dim[${st}] do not match`)})};if(o[0].dims.length>1){let a=e.format==="NHWC"?e.spatial?o[0].dims.slice(-1):o[0].dims.slice(-1).concat(o[0].dims.slice(1,o[0].dims.length-1)):o[0].dims.slice(1,e.spatial?2:void 0);s(o[1].dims,a,"Invalid input scale"),s(o[2].dims,a,"Invalid input B"),s(o[3].dims,a,"Invalid input mean"),s(o[4].dims,a,"Invalid input var")}else s(o[1].dims,[1],"Invalid input scale"),s(o[2].dims,[1],"Invalid input B"),s(o[3].dims,[1],"Invalid input mean"),s(o[4].dims,[1],"Invalid input var")},up=(o,e)=>{let{epsilon:s,spatial:a,format:d}=e,h=o[0].dims,b=a?Ue(h[h.length-1]):1,et=d==="NHWC"&&h.length>1?b:1,st=M.size(h)/b,$=a,it=$?h.length:h,g=U("x",o[0].dataType,o[0].dims,b),c=U("scale",o[1].dataType,o[1].dims,et),_=U("bias",o[2].dataType,o[2].dims,et),ot=U("inputMean",o[3].dataType,o[3].dims,et),ct=U("inputVar",o[4].dataType,o[4].dims,et),dt=K("y",o[0].dataType,it,b),pt=()=>{let ht="";if(a)ht=`let cOffset = ${h.length===1?"0u":d==="NHWC"?`outputIndices[${h.length-1}] / ${b}`:"outputIndices[1]"};`;else if(d==="NCHW")ht=`
            ${dt.indicesSet("outputIndices","0","0")}
            let cOffset = ${dt.indicesToOffset("outputIndices")};`;else{ht=`var cIndices = ${c.type.indices}(0);
                       cIndices[0] = outputIndices[${h.length-1}];`;for(let bt=1;bt<c.rank;bt++)ht+=`cIndices[${bt}] = outputIndices[${bt}];`;ht+=`let cOffset = ${c.indicesToOffset("cIndices")};`}return ht},ft=ht=>`
  const epsilon = ${s};
  ${ht.registerUniform("outputSize","u32").declareVariables(g,c,_,ot,ct,dt)}
  ${ht.mainStart()}
  ${ht.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${dt.offsetToIndices(`global_idx * ${b}`)};
    ${pt()}
    let scale = ${c.getByOffset("cOffset")};
    let bias = ${_.getByOffset("cOffset")};
    let inputMean = ${ot.getByOffset("cOffset")};
    let inputVar = ${ct.getByOffset("cOffset")};
    let x = ${g.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${dt.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${a}_${b}`,inputDependencies:$?["rank","type","type","type","type"]:void 0},getShaderSource:ft,getRunData:()=>({outputs:[{dims:o[0].dims,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(st/64)},programUniforms:$?[{type:12,data:st},...X$1(h)]:[{type:12,data:st}]})}},lp=o=>we(o),Us=(o,e)=>{let{inputs:s,outputCount:a}=o,d=lp({...e,outputCount:a});if(ke.webgpu.validateInputContent&&sp(s,d),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");o.compute(up(s,d))}}),dp,cp,Ns,Vs=j(()=>{xe(),_e(),dp=o=>{if(o[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(o[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(o[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(o[0].dims[2]!==o[1].dims[0])throw new Error("last dimension of input and bias are not the same")},cp=o=>{let e=o[0].dims,s=o[0].dims[2],a=M.size(e)/4,d=o[0].dataType,h=U("input",d,e,4),b=U("bias",d,[s],4),et=U("residual",d,e,4),st=K("output",d,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:$=>`
  const channels = ${s}u / 4;
  ${$.declareVariables(h,b,et,st)}

  ${$.mainStart()}
    ${$.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let value = ${h.getByOffset("global_idx")}
      + ${b.getByOffset("global_idx % channels")} + ${et.getByOffset("global_idx")};
    ${st.setByOffset("global_idx","value")}
  }`}},Ns=o=>{dp(o.inputs),o.compute(cp(o.inputs))}}),pp,Pe,Hs,Gs,Ls,Fs,qs,js,Ks,Ys,Xs,mp,Zs,Qs,Js,eu,Zn,tu,Qn,ru,nu,iu,au,ou,su,uu,lu,du,cu,pu,mu,fu,hu,gu,yu,bu,vu,oa,sa,wu,$u,_u,Jn=j(()=>{ye(),xe(),Ze(),_e(),pp=(o,e,s,a,d,h)=>{let b=Math.ceil(e/4),et="";typeof d=="string"?et=`${d}(a)`:et=d("a");let st=U("inputData",s,[b],4),$=K("outputData",a,[b],4);return`
      ${o.registerUniform("vec_size","u32").declareVariables(st,$)}

  ${h??""}

  ${o.mainStart()}
    ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${st.getByOffset("global_idx")};
    ${$.setByOffset("global_idx",et)}
  }`},Pe=(o,e,s,a,d,h=o.dataType)=>({name:e,shaderCache:{hint:d,inputDependencies:["type"]},getShaderSource:b=>pp(b,M.size(o.dims),o.dataType,h,s,a),getRunData:b=>({outputs:[{dims:o.dims,dataType:h}],dispatchGroup:{x:Math.ceil(M.size(b[0].dims)/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(o.dims)/4)}]})}),Hs=o=>{o.compute(Pe(o.inputs[0],"Abs","abs"))},Gs=o=>{o.compute(Pe(o.inputs[0],"Acos","acos"))},Ls=o=>{o.compute(Pe(o.inputs[0],"Acosh","acosh"))},Fs=o=>{o.compute(Pe(o.inputs[0],"Asin","asin"))},qs=o=>{o.compute(Pe(o.inputs[0],"Asinh","asinh"))},js=o=>{o.compute(Pe(o.inputs[0],"Atan","atan"))},Ks=o=>{o.compute(Pe(o.inputs[0],"Atanh","atanh"))},Ys=o=>we(o),Xs=(o,e)=>{let s;switch(e.to){case 10:s="vec4<f16>";break;case 1:s="vec4<f32>";break;case 12:s="vec4<u32>";break;case 6:s="vec4<i32>";break;case 9:s="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}o.compute(Pe(o.inputs[0],"Cast",s,void 0,e.cacheKey,e.to))},mp=o=>{let e=o.length>=2&&o[1].data!==0?o[1].getFloat32Array()[0]:Ln,s=o.length>=3&&o[2].data!==0?o[2].getFloat32Array()[0]:Fn;return we({min:e,max:s})},Zs=(o,e)=>{let s=o.inputs.length===1?e:mp(o.inputs),a=rt(o.inputs[0].dataType);o.compute(Pe(o.inputs[0],"Clip",d=>`clamp(${d}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${a}> = vec4(${a}(${s.min}));
    const clip_max_: vec4<${a}> = vec4(${a}(${s.max}));
`,s.cacheKey),{inputs:[0]})},Qs=o=>{o.compute(Pe(o.inputs[0],"Ceil","ceil"))},Js=o=>{o.compute(Pe(o.inputs[0],"Cos","cos"))},eu=o=>{o.compute(Pe(o.inputs[0],"Cosh","cosh"))},Zn=o=>we(o),tu=(o,e)=>{let s=rt(o.inputs[0].dataType);o.compute(Pe(o.inputs[0],"Elu",a=>`elu_vf32(${a})`,`
  const elu_alpha_ = ${s}(${e.alpha});

  fn elu_f32(a: ${s}) -> ${s} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${s}>) -> vec4<${s}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},Qn=(o="f32")=>`
const r0: ${o} = 0.3275911;
const r1: ${o} = 0.254829592;
const r2: ${o} = -0.284496736;
const r3: ${o} = 1.421413741;
const r4: ${o} = -1.453152027;
const r5: ${o} = 1.061405429;

fn erf_vf32(v: vec4<${o}>) -> vec4<${o}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,ru=o=>{let e=rt(o.inputs[0].dataType);o.compute(Pe(o.inputs[0],"Erf",s=>`erf_vf32(${s})`,Qn(e)))},nu=o=>{o.compute(Pe(o.inputs[0],"Exp","exp"))},iu=o=>{o.compute(Pe(o.inputs[0],"Floor","floor"))},au=o=>{let e=rt(o.inputs[0].dataType);o.compute(Pe(o.inputs[0],"Gelu",s=>`0.5 * ${s} * (1.0 + erf_vf32(${s} * 0.7071067811865475))`,Qn(e)))},ou=(o,e)=>{let s=rt(o.inputs[0].dataType);o.compute(Pe(o.inputs[0],"LeakyRelu",a=>`select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${s}>(0.0))`,`const leaky_relu_alpha_ = ${s}(${e.alpha});`,e.cacheKey))},su=o=>{o.compute(Pe(o.inputs[0],"Not",e=>`!${e}`))},uu=o=>{o.compute(Pe(o.inputs[0],"Neg",e=>`-${e}`))},lu=o=>{o.compute(Pe(o.inputs[0],"Reciprocal",e=>`1.0/${e}`))},du=o=>{let e=rt(o.inputs[0].dataType);o.compute(Pe(o.inputs[0],"Relu",s=>`select(vec4<${e}>(0.0), ${s}, ${s} > vec4<${e}>(0.0))`))},cu=o=>{o.compute(Pe(o.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},pu=o=>we(o),mu=(o,e)=>{let s=rt(o.inputs[0].dataType);o.compute(Pe(o.inputs[0],"HardSigmoid",a=>`max(vec4<${s}>(0.0), min(vec4<${s}>(1.0), ${e.alpha} * ${a} + vec4<${s}>(${e.beta})))`,void 0,e.cacheKey))},fu=o=>{o.compute(Pe(o.inputs[0],"Sin","sin"))},hu=o=>{o.compute(Pe(o.inputs[0],"Sinh","sinh"))},gu=o=>{o.compute(Pe(o.inputs[0],"Sqrt","sqrt"))},yu=o=>{o.compute(Pe(o.inputs[0],"Tan","tan"))},bu=o=>`sign(${o}) * (1 - exp(-2 * abs(${o}))) / (1 + exp(-2 * abs(${o})))`,vu=o=>{o.compute(Pe(o.inputs[0],"Tanh",bu))},oa=(o="f32")=>`
const fast_gelu_a: ${o} = 0.5;
const fast_gelu_b: ${o} = 0.7978845608028654;
const fast_gelu_c: ${o} = 0.035677408136300125;

fn tanh_v(v: vec4<${o}>) -> vec4<${o}> {
  return ${bu("v")};
}
`,sa=o=>`(fast_gelu_a + fast_gelu_a * tanh_v(${o} * (fast_gelu_c * ${o} * ${o} + fast_gelu_b))) * ${o}`,wu=o=>{let e=rt(o.inputs[0].dataType);o.compute(Pe(o.inputs[0],"FastGelu",sa,oa(e),void 0,o.inputs[0].dataType))},$u=(o,e)=>{let s=rt(o.inputs[0].dataType);return o.compute(Pe(o.inputs[0],"ThresholdedRelu",a=>`select(vec4<${s}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${s}>(${e.alpha});`,e.cacheKey)),0},_u=o=>{o.compute(Pe(o.inputs[0],"Log","log"))}}),fp,hp,Su,Cu=j(()=>{xe(),_e(),Jn(),fp=o=>{if(o[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(o[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(o[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(o[0].dims[2]!==o[1].dims[0])throw new Error("last dimension of input and bias are not the same")},hp=o=>{let e=o[0].dims.slice();e[2]=e[2]/2;let s=U("input",o[0].dataType,o[0].dims,4),a=U("bias",o[0].dataType,[o[0].dims[2]],4),d=K("output",o[0].dataType,e,4),h=M.size(e)/4,b=Be(o[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)}}),getShaderSource:et=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${o[0].dims[2]/4/2}u;

  ${et.declareVariables(s,a,d)}

  ${Qn(b)}

  ${et.mainStart()}
    ${et.guardAgainstOutOfBoundsWorkgroupSizes(h)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${d.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Su=o=>{fp(o.inputs),o.compute(hp(o.inputs))}}),gp,yp,Ut,Iu,Tu,Au,Eu,ku,Ou,Pu,Ru,zu,Bu,Du=j(()=>{ye(),xe(),_e(),gp=(o,e,s,a,d,h,b,et,st,$,it,g)=>{let c,_;typeof et=="string"?c=_=(ft,ht)=>`${et}((${ft}),(${ht}))`:typeof et=="function"?c=_=et:(c=et.scalar,_=et.vector);let ot=K("outputData",it,a.length,4),ct=U("aData",st,e.length,4),dt=U("bData",$,s.length,4),pt;if(d)if(h){let ft=M.size(e)===1,ht=M.size(s)===1,bt=e.length>0&&e[e.length-1]%4===0,mt=s.length>0&&s[s.length-1]%4===0;ft||ht?pt=ot.setByOffset("global_idx",_(ft?`${ct.type.value}(${ct.getByOffset("0")}.x)`:ct.getByOffset("global_idx"),ht?`${dt.type.value}(${dt.getByOffset("0")}.x)`:dt.getByOffset("global_idx"))):pt=`
            let outputIndices = ${ot.offsetToIndices("global_idx * 4u")};
            let offsetA = ${ct.broadcastedIndicesToOffset("outputIndices",ot)};
            let offsetB = ${dt.broadcastedIndicesToOffset("outputIndices",ot)};
            ${ot.setByOffset("global_idx",_(b||bt?ct.getByOffset("offsetA / 4u"):`${ct.type.value}(${ct.getByOffset("offsetA / 4u")}[offsetA % 4u])`,b||mt?dt.getByOffset("offsetB / 4u"):`${dt.type.value}(${dt.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else pt=ot.setByOffset("global_idx",_(ct.getByOffset("global_idx"),dt.getByOffset("global_idx")));else{if(!h)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let ft=(ht,bt,mt="")=>{let $t=`aData[indexA${bt}][componentA${bt}]`,Tt=`bData[indexB${bt}][componentB${bt}]`;return`
            let outputIndices${bt} = ${ot.offsetToIndices(`global_idx * 4u + ${bt}u`)};
            let offsetA${bt} = ${ct.broadcastedIndicesToOffset(`outputIndices${bt}`,ot)};
            let offsetB${bt} = ${dt.broadcastedIndicesToOffset(`outputIndices${bt}`,ot)};
            let indexA${bt} = offsetA${bt} / 4u;
            let indexB${bt} = offsetB${bt} / 4u;
            let componentA${bt} = offsetA${bt} % 4u;
            let componentB${bt} = offsetB${bt} % 4u;
            ${ht}[${bt}] = ${mt}(${c($t,Tt)});
          `};it===9?pt=`
            var data = vec4<u32>(0);
            ${ft("data",0,"u32")}
            ${ft("data",1,"u32")}
            ${ft("data",2,"u32")}
            ${ft("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:pt=`
            ${ft("outputData[global_idx]",0)}
            ${ft("outputData[global_idx]",1)}
            ${ft("outputData[global_idx]",2)}
            ${ft("outputData[global_idx]",3)}
          `}return`
        ${o.registerUniform("vec_size","u32").declareVariables(ct,dt,ot)}

        ${g??""}

        ${o.mainStart()}
        ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${pt}
      }`},yp=(o,e,s,a,d,h,b=s.dataType)=>{let et=!M.areEqual(s.dims,a.dims),st=s.dims,$=M.size(s.dims),it=!1,g=!1,c=[et];if(et){let _=Rt.calcShape(s.dims,a.dims,!1);if(!_)throw new Error("Can't perform binary op on the given tensors");st=_,$=M.size(st);let ot=M.size(s.dims)===1,ct=M.size(a.dims)===1,dt=s.dims.length>0&&s.dims[s.dims.length-1]%4===0,pt=a.dims.length>0&&a.dims[a.dims.length-1]%4===0;c.push(ot),c.push(ct),c.push(dt),c.push(pt);let ft=1;for(let ht=1;ht<st.length;ht++){let bt=s.dims[s.dims.length-ht]??1,mt=a.dims[a.dims.length-ht]??1;if(bt===mt)ft*=bt;else break}ft%4===0?(g=!0,it=!0):(ot||ct||dt||pt)&&(it=!0)}else it=!0;return c.push(it),{name:o,shaderCache:{hint:e+c.map(_=>_.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:_=>gp(_,s.dims,a.dims,st,it,et,g,d,s.dataType,a.dataType,b,h),getRunData:()=>({outputs:[{dims:st,dataType:b}],dispatchGroup:{x:Math.ceil($/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(st)/4)},...X$1(s.dims,a.dims,st)]})}},Ut=(o,e,s,a,d,h)=>{o.compute(yp(e,d??"",o.inputs[0],o.inputs[1],s,a,h))},Iu=o=>{Ut(o,"Add",(e,s)=>`${e}+${s}`)},Tu=o=>{Ut(o,"Div",(e,s)=>`${e}/${s}`)},Au=o=>{Ut(o,"Equal",{scalar:(e,s)=>`u32(${e}==${s})`,vector:(e,s)=>`vec4<u32>(${e}==${s})`},void 0,void 0,9)},Eu=o=>{Ut(o,"Mul",(e,s)=>`${e}*${s}`)},ku=o=>{let e=U("input",o.inputs[0].dataType,o.inputs[0].dims).type.value;Ut(o,"Pow",{scalar:(s,a)=>`pow_custom(${s},${a})`,vector:(s,a)=>`pow_vector_custom(${s},${a})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Ou=o=>{Ut(o,"Sub",(e,s)=>`${e}-${s}`)},Pu=o=>{Ut(o,"Greater",{scalar:(e,s)=>`u32(${e}>${s})`,vector:(e,s)=>`vec4<u32>(${e}>${s})`},void 0,void 0,9)},Ru=o=>{Ut(o,"Less",{scalar:(e,s)=>`u32(${e}<${s})`,vector:(e,s)=>`vec4<u32>(${e}<${s})`},void 0,void 0,9)},zu=o=>{Ut(o,"GreaterOrEqual",{scalar:(e,s)=>`u32(${e}>=${s})`,vector:(e,s)=>`vec4<u32>(${e}>=${s})`},void 0,void 0,9)},Bu=o=>{Ut(o,"LessOrEqual",{scalar:(e,s)=>`u32(${e}<=${s})`,vector:(e,s)=>`vec4<u32>(${e}<=${s})`},void 0,void 0,9)}}),Et,kt,Ot,ei,Zt=j(()=>{ye(),xe(),Et=(o,e,s="f32")=>{switch(o.activation){case"Relu":return`value = max(value, ${e}(0.0));`;case"Sigmoid":return`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${e}(${s}(uniforms.clip_min)), ${e}(${s}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${e}(0.0), min(${e}(1.0), ${s}(uniforms.alpha) * value + ${s}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${s}(uniforms.alpha) * value, value, value >= ${e}(0.0));`;case"":return"";default:throw new Error(`Unsupported activation ${o.activation}`)}},kt=(o,e)=>{o.activation==="Clip"?e.push({type:1,data:o.clipMax},{type:1,data:o.clipMin}):o.activation==="HardSigmoid"?e.push({type:1,data:o.alpha},{type:1,data:o.beta}):o.activation==="LeakyRelu"&&e.push({type:1,data:o.alpha})},Ot=(o,e)=>{o.activation==="Clip"?e.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):o.activation==="HardSigmoid"?e.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):o.activation==="LeakyRelu"&&e.push({name:"alpha",type:"f32"})},ei=o=>{let e=o?.activation||"";if(e==="HardSigmoid"){let[s,a]=o?.activation_params||[.2,.5];return{activation:e,alpha:s,beta:a}}else if(e==="Clip"){let[s,a]=o?.activation_params||[Ln,Fn];return{activation:e,clipMax:a,clipMin:s}}else if(e==="LeakyRelu"){let[s]=o?.activation_params||[.01];return{activation:e,alpha:s}}return{activation:e}}}),nt,ti,ri=j(()=>{nt=(o,e)=>{switch(o){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${o}-component is not supported.`)}},ti=o=>`
      ${o?"value = value + getBiasByOutputCoords(coords);":""}
      `}),ni,ua=j(()=>{ni=o=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${o}.x), i32(${o}.y), i32(${o}.z), 1));
}
`}),vp,wp,rn,Mu,$p,nn,_p,ii,an=j(()=>{ye(),xe(),_e(),Zt(),ri(),vp=(o,e)=>o?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,wp=(o,e)=>o?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,rn=(o,e,s="f32",a,d=!1,h=32,b=!1,et=32)=>{let st=e[1]*o[1],$=e[0]*o[0],it=d?st:h,g=d?h:st,c=it/e[0],_=h/e[1];if(!((d&&c===4&&o[1]===4||!d&&(c===3||c===4))&&it%e[0]===0&&h%e[1]===0&&o[0]===4))throw new Error(`If transposeA ${d} is true, innerElementSize ${c} and workPerThread[1] ${o[1]} must be 4.
      Otherwise, innerElementSize ${c} must be 3 or 4.
  tileAWidth ${it} must be divisible by workgroupSize[0]${e[0]}. tileInner ${h} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${o[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${c}<${s}>, ${it/c}>, ${g}>;
var<workgroup> mm_Bsub: array<array<vec4<${s}>, ${$/o[0]}>, ${h}>;

const rowPerThread = ${o[1]};
const colPerThread = ${o[0]};
const innerElementSize = ${c};
const tileInner = ${h};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${b?"0":"i32(globalId.z)"};
  ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${st};

  let num_tiles = ${b?`${Math.ceil(et/h)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${b?`i32(globalId.z) * ${et}`:"0"};

  var acc: array<vec4<${s}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${_};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${vp(d,a)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${a?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${c===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${wp(d,c)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Mu=(o,e)=>o?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,$p=o=>o?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",nn=(o,e,s="f32",a,d=!1,h=32,b=!1,et=32,st=!1)=>{let $=o[1]*e[1],it=o[0]*e[0],g=d?$:h,c=d?h:$;if(!(c%e[1]===0&&g%e[0]===0&&h%e[1]===0))throw new Error(`tileAHight ${c} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${g} must be divisible by workgroupSize[0]${e[0]}, tileInner ${h} must be divisible by workgroupSize[1]${e[1]}`);let _=c/e[1],ot=g/e[0],ct=h/e[1],dt=st?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${$};
    let globalColStart = i32(workgroupId.x) * ${it};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${c}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${e[0]}) {
          ${Mu(d,a)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${it}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${a?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${s}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${d?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${$};

let tileRowA = i32(localId.y) * ${_};
let tileColA = i32(localId.x) * ${ot};
let tileRowB = i32(localId.y) * ${ct};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${ot}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Mu(d,a)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${ct}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${a?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${s}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${$p(d)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${s}, ${g}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<${s}, ${it}>, ${h}>;
  const rowPerThread = ${o[1]};
  const colPerThread = ${o[0]};
  const tileInner = ${h};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${b?"0":"i32(globalId.z)"};
    ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${b?`${Math.ceil(et/h)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${b?`i32(globalId.z) * ${et}`:"0"};

    var acc : array<array<${s}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${dt}
  }
`},_p=(o,e,s,a,d,h=!1)=>{let[b,et,st]=d,[$,it,g,c]=a,_=Pr(b,st),ot=Pr(et,st),ct=Be(a[0].type.tensor),dt=()=>{let ft=it.rank,ht=$.rank,bt=`var aIndices: ${it.type.indices};`;for(let mt=ft-2-1,$t=ht-1;mt>=0;mt--,$t--)bt+=`
aIndices[${mt}] = ${ht>1?`batchIndices[${$t}]`:"batchIndices"};`;return _.forEach(mt=>{bt+=`
aIndices[${mt}] = 0;`}),bt+=`
aIndices[${ft-2}] = u32(row);
                   aIndices[${ft-1}] = u32(colIn);`,bt},pt=()=>{let ft=g.rank,ht=$.rank,bt=`var bIndices: ${g.type.indices};`;for(let mt=ft-2-1,$t=ht-1;mt>=0;mt--,$t--)bt+=`
bIndices[${mt}] = ${ht>1?`batchIndices[${$t}]`:"batchIndices"};`;return ot.forEach(mt=>{bt+=`
bIndices[${mt}] = 0;`}),bt+=`
bIndices[${ft-2}] = u32(row);
                   bIndices[${ft-1}] = u32(colIn);`,bt};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${$.type.indices}) -> ${nt(o,ct)} {
      var value = ${nt(o,ct)}(0.0);
      let col = colIn * ${o};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${dt()}
        value = ${it.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${$.type.indices}) -> ${nt(o,ct)} {
      var value = ${nt(o,ct)}(0.0);
      let col = colIn * ${o};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${pt()}
        value = ${g.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${nt(o,ct)}) {
      let col = colIn * ${o};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${h?"bias[colIn]":`${nt(o,ct)}(bias[row])`};`:""}
        ${s}
        ${c.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},ii=(o,e,s,a,d=!1)=>{let h=o[0].dims,b=o[1].dims,et=h.slice(0,-2),st=b.slice(0,-2),$=a?a.slice(0,-2):s.slice(0,-2),it=M.size($),g=h[h.length-2],c=h[h.length-1],_=b[b.length-1],ot=c%4===0&&_%4===0,ct=g<=8?[4,1,1]:[4,4,1],dt=[8,8,1],pt=[Math.ceil(_/dt[0]/ct[0]),Math.ceil(g/dt[1]/ct[1]),Math.ceil(it/dt[2]/ct[2])],ft=ot?4:1,ht=[...et,g,c/ft],bt=ht.length,mt=[...st,c,_/ft],$t=mt.length,Tt=[it,g,_/ft],Nt=[{type:6,data:g},{type:6,data:_},{type:6,data:c}];kt(e,Nt),Nt.push(...X$1($,ht,mt));let Ct=["rank","rank"],Ft=o.length>2;Ft&&(Nt.push(...X$1(o[2].dims)),Ct.push("rank")),Nt.push(...X$1(Tt));let ln=mn=>{let yn=$.length,pn=qn("batchDims",o[0].dataType,yn,1),Ht=Be(o[0].dataType),Gt=U("a",o[0].dataType,bt,ft),cn=U("b",o[1].dataType,$t,ft),xn=K("result",o[0].dataType,Tt.length,ft),dn=[Gt,cn];if(Ft){let Sr=d?ft:1;dn.push(U("bias",o[2].dataType,o[2].dims.length,Sr))}let wn=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Ot(e,wn);let gn=Be(xn.type.tensor),En=Et(e,xn.type.value,gn),_r=_p(ft,Ft,En,[pn,Gt,cn,xn],[et,st,$],d);return`
  ${mn.registerUniforms(wn).registerInternalVariables(pn).declareVariables(...dn,xn)}
  ${_r}
  ${ot?rn(ct,dt,Ht,pn):nn(ct,dt,Ht,pn)}
                   `};return{name:"MatMul",shaderCache:{hint:`${ct};${e.activation};${ot};${d}`,inputDependencies:Ct},getRunData:()=>({outputs:[{dims:s,dataType:o[0].dataType}],dispatchGroup:{x:pt[0],y:pt[1],z:pt[2]},programUniforms:Nt}),getShaderSource:ln}}}),xp,Uu,Wu=j(()=>{ye(),Yt(),_e(),Zt(),ri(),ua(),an(),xp=(o,e,s,a,d=!1,h,b=4,et=4,st=4,$="f32")=>{let it=Ct=>{switch(Ct){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${$}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Ct} is not supported.`)}},g=Ct=>{switch(Ct){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${Ct} is not supported.`)}},c=o?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,_=o?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,ot=o?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",ct=o?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",dt=o?"row":"col",pt=o?"col":"row",ft=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${o?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${dt} / outWidth;
    let outCol = ${dt} % outWidth;

    let WRow = ${pt} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${pt} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${pt} % inChannels;
    var resData = ${nt(b,$)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${ot} && xCol >= 0 && xCol < ${ct}) {
      ${c}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${it(b)}
    }
    return resData;`,ht=o?e&&a?`
    let col = colIn * ${b};
    ${ft}`:`
    let col = colIn * ${b};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${ft}
    }
    return ${nt(b,$)}(0.0);`:a&&s?`
    let col = colIn * ${b};
    ${ft}`:`
    let col = colIn * ${b};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${ft}
    }
    return ${nt(b,$)}(0.0);`,bt=`${g(et)}`,mt=nt(st,$),$t=nt(o?b:et,$),Tt=nt(o?et:b,$),Nt=Et(h,mt,$);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${$t} {
      ${o?ht:bt}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Tt} {
      ${o?bt:ht}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${mt}) {
      let col = colIn * ${st};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${o?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${_}
      ${ti(d)}
      ${Nt}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Uu=(o,e,s,a,d,h,b,et)=>{let st=e.format==="NHWC",$=st?o[0].dims[3]:o[0].dims[1],it=s[0],g=st?s[2]:s[3],c=st?s[1]:s[2],_=st?s[3]:s[1],ot=st&&($%4===0||$%3===0)&&_%4===0,ct=st?_:g*c,dt=st?g*c:_,pt=[8,8,1],ft=a<=8?[4,1,1]:[4,4,1],ht=[Math.ceil(ct/pt[0]/ft[0]),Math.ceil(dt/pt[1]/ft[1]),Math.ceil(it/pt[2]/ft[2])];Ne("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${ht}`);let bt=ot?st&&$%4!==0?3:4:1,mt=pt[1]*ft[1],$t=pt[0]*ft[0],Tt=Math.max(pt[0]*bt,pt[1]),Nt=a%mt===0,Ct=d%$t===0,Ft=h%Tt===0,ln=ot?[bt,4,4]:[1,1,1],mn=[{type:6,data:a},{type:6,data:d},{type:6,data:h},{type:6,data:[e.pads[0],e.pads[1]]},{type:6,data:e.strides},{type:6,data:e.dilations}];kt(e,mn),mn.push(...X$1(o[0].dims,o[1].dims));let yn=["rank","rank"];b&&(mn.push(...X$1(o[2].dims)),yn.push("rank")),mn.push(...X$1(s));let pn=Ht=>{let Gt=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Ot(e,Gt);let cn=ot?4:1,xn=Be(o[0].dataType),dn=`
      fn setOutputAtIndex(flatIndex : i32, value : ${ot?`vec4<${xn}>`:xn}) {
        result[flatIndex] = ${ot?`vec4<${xn}>`:xn}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${ot?`vec4<${xn}>`:xn}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${ot?"/ 4":""}, value);
      }`,wn=U("x",o[0].dataType,o[0].dims.length,bt===3?1:bt),gn=U("w",o[1].dataType,o[1].dims.length,cn),En=[wn,gn],_r=K("result",o[0].dataType,s.length,cn);if(b){let Sr=U("bias",o[2].dataType,o[2].dims.length,cn);En.push(Sr),dn+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${ot?`vec4<${xn}>`:xn} {
          return bias[coords.${st?"w":"y"}${ot?"/ 4":""}];
        }`}return`
        ${ni("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Ht.registerUniforms(Gt).declareVariables(...En,_r)}
        ${dn}
        ${xp(st,Nt,Ct,Ft,b,e,ln[0],ln[1],ln[2],xn)}
        ${ot?rn(ft,pt,xn,void 0,!st,Tt):nn(ft,pt,xn,void 0,!st,Tt,!1,void 0,et)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${e.cacheKey};${bt};${ot};${Nt};${Ct};${Ft};${mt};${$t};${Tt}`,inputDependencies:yn},getRunData:()=>({outputs:[{dims:s,dataType:o[0].dataType}],dispatchGroup:{x:ht[0],y:ht[1],z:ht[2]},programUniforms:mn}),getShaderSource:pn}}}),la,Nu,Vu=j(()=>{ye(),xe(),_e(),da(),Zt(),la=(o,e,s)=>{let a=o.length>2,d=a?"value += b[output_channel];":"",h=o[0].dims,b=o[1].dims,et=b[0]/e.group,st=e.format==="NHWC",$=ai(h,b,e.dilations,e.pads,e.strides,st),it=M.size($),g=[{type:12,data:it},{type:12,data:e.dilations},{type:12,data:[e.strides[0],e.strides[1]]},{type:12,data:[e.pads[0],e.pads[1]]},{type:12,data:et}];kt(e,g),g.push(...X$1(h,b));let c=["rank","rank"];a&&(g.push(...X$1(o[2].dims)),c.push("rank")),g.push(...X$1($));let _=ot=>{let ct=K("output",o[0].dataType,$.length),dt=Be(ct.type.tensor),pt=Et(e,ct.type.value,dt),ft=U("x",o[0].dataType,h.length),ht=U("w",o[1].dataType,b.length),bt=[ft,ht];a&&bt.push(U("b",o[2].dataType,o[2].dims.length));let mt=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:e.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];return Ot(e,mt),`
  ${ot.registerUniforms(mt).declareVariables(...bt,ct)}

  ${ot.mainStart()}
    ${ot.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${ct.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${st?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${st?1:2}], outputIndices[${st?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel / uniforms.output_channels_per_group;

    var value: ${ct.type.value} = ${ct.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[${st?1:2}]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[${st?2:3}]) {
            continue;
          }

          let xVal = ${st?ft.get("batch","xHeight","xWidth","input_channel"):ft.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${ht.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${d}
    ${pt}
    ${ct.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:e.cacheKey,inputDependencies:c},getRunData:()=>({outputs:[{dims:s?s($):$,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(it/64)},programUniforms:g}),getShaderSource:_}},Nu=(o,e,s)=>{let a=o.length>2,d=Ue(s[3]),h=Ue(s[2]),b=M.size(s)/d/h,et=[o[0].dims[0],o[0].dims[1],o[0].dims[2],o[0].dims[3]/d],st=[o[1].dims[0],o[1].dims[1],o[1].dims[2],o[1].dims[3]/d],$=[s[0],s[1],s[2],s[3]/d],it=[{type:12,data:b},{type:6,data:[e.strides[0],e.strides[1]]},{type:6,data:[e.pads[0],e.pads[1]]}];kt(e,it),it.push(...X$1(et,st,$));let g=(h-1)*e.strides[1]+st[1],c=_=>{let ot=K("output",o[0].dataType,$.length,d),ct=Be(ot.type.tensor),dt=Et(e,ot.type.value,ct),pt=U("x",o[0].dataType,et.length,d),ft=U("w",o[1].dataType,st.length,d),ht=[pt,ft];a&&ht.push(U("b",o[2].dataType,o[2].dims,d));let bt=a?"value += b[output_channel];":"",mt=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Ot(e,mt),`
  ${_.registerUniforms(mt).declareVariables(...ht,ot)}
  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${h}u;
    let col = (index1 % width1) * ${h}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${pt.type.value}, ${g}>;
    var values: array<${ot.type.value}, ${h}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${st[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${g}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${pt.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${pt.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${st[1]}; w_width++) {
          let w_val = ${ft.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${h}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${h}u; i++) {
      var value = values[i];
      ${bt}
      ${dt}
      ${ot.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${e.cacheKey};${d};${h};${g};${st[0]};${st[1]}`,inputDependencies:a?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:it}),getShaderSource:c}}}),ca,Sp,Hu,pa=j(()=>{ye(),xe(),an(),_e(),Zt(),ca=(o,e,s,a,d=!1)=>{let h=o[0].dims,b=o[1].dims,et=h[h.length-2],st=b[b.length-1],$=h[h.length-1],it=Ue(st),g=Ue($),c=Ue(et),_=M.size(s)/it/c,ot=o.length>2,ct=a?a.slice(0,-2):s.slice(0,-2),dt=[M.size(ct),et,st],pt=[{type:12,data:_},{type:12,data:et},{type:12,data:st},{type:12,data:$}];kt(e,pt),pt.push(...X$1(ct,h,b)),ot&&pt.push(...X$1(o[2].dims)),pt.push(...X$1(dt));let ft=ht=>{let bt=qn("batch_dims",o[0].dataType,ct.length),mt=U("a",o[0].dataType,h.length,g),$t=U("b",o[1].dataType,b.length,it),Tt=K("output",o[0].dataType,dt.length,it),Nt=Be(Tt.type.tensor),Ct=Et(e,Tt.type.value,Nt),Ft=[mt,$t],ln="";if(ot){let dn=d?it:1;Ft.push(U("bias",o[2].dataType,o[2].dims.length,dn)),ln=`${d?`value += bias[col / ${dn}];`:`value += ${Tt.type.value}(bias[row + i]);`}`}let mn=h.slice(0,-2),yn=b.slice(0,-2),pn=Pr(mn,ct),Ht=Pr(yn,ct),Gt=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Ot(e,Gt);let cn=(dn,wn)=>{let gn=dn.rank,En=dn.name;if(gn===2)return`var ${En}_indices = ${dn.type.indices}(0u, 0u);`;let _r=bt.rank,Sr=`var ${En}_indices: ${dn.type.indices};`;for(let xr=gn-2-1,Vr=_r-1;xr>=0;xr--,Vr--)Sr+=`
${En}_indices[${xr}] = ${_r>1?`batch_indices[${Vr}]`:"batch_indices"};`;return wn.forEach(xr=>{Sr+=`
${En}_indices[${xr}] = 0;`}),Sr+=`${En}_indices[${gn-2}] = 0u;
                     ${En}_indices[${gn-1}] = 0u;`,Sr},xn=()=>{let dn=`var a_data: ${mt.type.value};`;for(let wn=0;wn<g;wn++)dn+=`
              let b_data${wn} = b[(b_offset + (k + ${wn}) * uniforms.N + col) / ${it}];`;for(let wn=0;wn<c;wn++){dn+=`a_data = a[(a_offset + (row + ${wn}) * uniforms.K + k) / ${g}];`;for(let gn=0;gn<g;gn++)dn+=`
            values[${wn}] = fma(${$t.type.value}(a_data${g===1?"":`[${gn}]`}), b_data${gn}, values[${wn}]);
`}return dn};return`
  ${ht.registerUniforms(Gt).registerInternalVariables(bt).declareVariables(...Ft,Tt)}
  ${ht.mainStart()}
    ${ht.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${it})) * ${it};
    var index1 = global_idx / (uniforms.N / ${it});
    let stride1 = uniforms.M / ${c};
    let row = (index1 % stride1) * ${c};
    let batch = index1 / stride1;

    ${s.length===2?"":`let batch_indices = ${bt.offsetToIndices("batch")};`}
    ${cn(mt,pn)}
    let a_offset = ${mt.indicesToOffset("a_indices")};
    ${cn($t,Ht)}
    let b_offset = ${$t.indicesToOffset("b_indices")};
    var values: array<${Tt.type.value}, ${c}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${g}) {
      ${xn()}
    }
    for (var i = 0u; i < ${c}u; i++) {
      var value = values[i];
      ${ln}
      ${Ct}
      let cur_indices = ${Tt.type.indices}(batch, row + i, col);
      let offset = ${Tt.indicesToOffset("cur_indices")};
      ${Tt.setByOffset(`offset / ${it}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${e.activation};${it};${g};${c};${d}`,inputDependencies:ot?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:pt}),getShaderSource:ft}},Sp=o=>{if(!o||o.length!==2)throw new Error("MatMul requires 2 inputs.");if(o[0].dims[o[0].dims.length-1]!==o[1].dims[o[1].dims.length-2])throw new Error("shared dimension does not match.")},Hu=o=>{Sp(o.inputs);let e=Rt.calcShape(o.inputs[0].dims,o.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");let s=e[e.length-1],a=o.inputs[0].dims[o.inputs[0].dims.length-1];s<8&&a<8?o.compute(ca(o.inputs,{activation:""},e)):o.compute(ii(o.inputs,{activation:""},e))}}),ai,ma,Cp,Gu,fa,Ip,Tp,ha,da=j(()=>{xe(),Wu(),an(),Vu(),Zt(),pa(),Rr(),ai=(o,e,s,a,d,h)=>{let b=o[0],et=o.slice(h?1:2,h?3:4),st=et.length,$=e[0],it=e.slice(2).map((c,_)=>c+(c-1)*(s[_]-1)),g=et.map((c,_)=>c+a[_]+a[_+st]).map((c,_)=>Math.floor((c-it[_]+d[_])/d[_]));return g.splice(0,0,b),g.splice(h?3:1,0,$),g},ma=[2,3,1,0],Cp=(o,e)=>{if(!o||o.length!==2&&o.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(o[0].dims.length!==4&&o[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(o[0].dims.length!==o[1].dims.length)throw new Error("filter does not have same dimension as input");let s=o[0].dims[e.format==="NHWC"?o[0].dims.length-1:1],a=o[1].dims[1]*e.group;if(s!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(o.length===3&&(o[2].dims.length!==1||o[1].dims[0]!==o[2].dims[0]))throw new Error("invalid bias");let d=o[0].dims.length-2;if(e.dilations.length!==d)throw new Error(`dilations should be ${d}D`);if(e.strides.length!==d)throw new Error(`strides should be ${d}D`);if(e.pads.length!==d*2)throw new Error(`pads should be ${d*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==o[1].dims.length-2)throw new Error("invalid kernel shape")},Gu=(o,e)=>{let s=o.kernelShape.slice();for(let h=2;h<e[1].dims.length;++h)s[h-2]===0&&(s[h-2]=e[1].dims[h]);let a=o.pads.slice();pr.adjustPadsBasedOnAutoPad(e[0].dims,o.strides,o.dilations,s,a,o.format==="NHWC",o.autoPad);let d=Object.assign({},o);return Object.assign(d,{kernelShape:s,pads:a}),d},fa=o=>{let e=ei(o),s=o.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][o.auto_pad],d=o.dilations,h=o.group,b=o.kernel_shape,et=o.pads,st=o.strides,$=o.w_is_const();return{autoPad:a,format:s,dilations:d,group:h,kernelShape:b,pads:et,strides:st,wIsConst:$,...e,cacheKey:`${o.format};${e.activation};`}},Ip=(o,e,s)=>{let a=Gu(s,e),d=s.format==="NHWC";if(s.group!==1){if(!o.adapterInfo.isArchitecture("ampere")&&d&&e[1].dims[0]===s.group&&e[1].dims[1]===1&&s.dilations[0]===1&&s.dilations[1]===1){let $t=ai(e[0].dims,e[1].dims,s.dilations,a.pads,s.strides,d),Tt=o.kernelCustomData.wT??o.compute(xt(e[1],ma),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!o.kernelCustomData.wT&&(o.kernelCustomData.wT=Tt);let Nt=[e[0],Tt];e.length===3&&Nt.push(e[2]),o.compute(Nu(Nt,a,$t),{inputs:Nt})}else o.compute(la(e,a));return}let h=e.length===3,b=e[0].dims[d?1:2],et=e[0].dims[d?2:3],st=e[0].dims[d?3:1],$=e[1].dims[2],it=e[1].dims[3],g=ai(e[0].dims,e[1].dims,s.dilations,a.pads,s.strides,d),c=g[d?1:2],_=g[d?2:3],ot=g[d?3:1],ct=d&&$===b&&it===et&&s.pads[0]===0&&s.pads[1]===0;if(ct||$===1&&it===1&&s.dilations[0]===1&&s.dilations[1]===1&&s.strides[0]===1&&s.strides[1]===1&&s.pads[0]===0&&s.pads[1]===0){let $t=g[0],Tt,Nt,Ct,Ft=[];if(d){let yn=o.kernelCustomData.wT??o.compute(xt(e[1],ma),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];if(s.wIsConst&&!o.kernelCustomData.wT&&(o.kernelCustomData.wT=yn),ct){let pn=b*et*st;Tt=e[0].reshape([1,$t,pn]),Nt=yn.reshape([1,pn,ot]),Ct=[1,$t,ot]}else Tt=e[0].reshape([$t,b*et,st]),Nt=yn.reshape([1,st,ot]),Ct=[$t,c*_,ot];Ft.push(Tt),Ft.push(Nt)}else Tt=e[0].reshape([$t,st,b*et]),Nt=e[1].reshape([1,ot,st]),Ct=[$t,ot,c*_],Ft.push(Nt),Ft.push(Tt);h&&Ft.push(e[2]);let ln=Ct[2],mn=Ft[0].dims[Ft[0].dims.length-1];ln<8&&mn<8?o.compute(ca(Ft,a,g,Ct,d),{inputs:Ft}):o.compute(ii(Ft,a,g,Ct,d),{inputs:Ft});return}let dt=!0,pt=o.kernelCustomData.wT??o.compute(xt(e[1],ma),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!o.kernelCustomData.wT&&(o.kernelCustomData.wT=pt);let ft=[e[0],pt];h&&ft.push(e[2]);let ht=d?c*_:ot,bt=d?ot:c*_,mt=$*it*st;o.compute(Uu(ft,a,g,ht,bt,mt,h,dt),{inputs:ft})},Tp=(o,e)=>{let s=e.format==="NHWC",a=[o.inputs[0].reshape(s?[o.inputs[0].dims[0],1,o.inputs[0].dims[1],o.inputs[0].dims[2]]:[o.inputs[0].dims[0],o.inputs[0].dims[1],1,o.inputs[0].dims[2]]),o.inputs[1].reshape([o.inputs[1].dims[0],o.inputs[1].dims[1],1,o.inputs[1].dims[2]])];o.inputs.length===3&&a.push(o.inputs[2]);let d=[0,e.pads[0],0,e.pads[1]],h=[1].concat(e.strides),b=[1].concat(e.dilations),et=[1].concat(e.kernelShape),st=Gu({...e,pads:d,strides:h,dilations:b,kernelShape:et},a);o.compute(la(a,st,$=>s?[$[0],$[2],$[3]]:[]))},ha=(o,e)=>{Cp(o.inputs,e),o.inputs[0].dims.length===3?Tp(o,e):Ip(o,o.inputs,e)}}),Ap,Lu,Fu=j(()=>{ye(),Yt(),_e(),Zt(),ri(),ua(),an(),Ap=(o,e=!1,s,a,d=4)=>{let h=dt=>{switch(dt){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${a}(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${dt} is not supported.`)}},b=o?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,et=o?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,st=o?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",$=o?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",it=o?"row":"col",g=o?"col":"row",c=`
      let inChannels = ${o?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let outWidth = ${o?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${it} / outWidth;
      let outCol = ${it} % outWidth;

      let WRow = ${g} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${g} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${st}) || fract(xR) > 0.0) {
        return ${a}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${$}) || fract(xC) > 0.0) {
        return ${a}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${g} % inChannels;
      ${b}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${d}];`,_=o?`
      let col = colIn * ${d};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${c}
      }
      return ${a}(0.0);`:`
      let col = colIn * ${d};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${c}
      }
      return ${a}(0.0);`,ot=`
      let col = colIn * ${d};
      let inChannels = ${o?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${o?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${h(d)}
      }
      return ${a}(0.0);
      `,ct=Et(s,a);return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${a} {
    ${o?_:ot}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${a} {
    ${o?ot:_}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${a}) {
    let col = colIn * ${d};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${o?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${et}
      ${ti(e)}
      ${ct}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${d}] = value;
    }
  }`},Lu=(o,e,s,a,d,h,b,et)=>{let st=e.format==="NHWC",$=st?o[0].dims[3]:o[0].dims[1],it=s[0],g=st?s[2]:s[3],c=st?s[1]:s[2],_=st?s[3]:s[1],ot=st&&$%4===0&&$%3&&_%4===0,ct=st?_:g*c,dt=st?g*c:_,pt=[8,8,1],ft=a<=8?[4,1,1]:[4,4,1],ht=[Math.ceil(ct/pt[0]/ft[0]),Math.ceil(dt/pt[1]/ft[1]),Math.ceil(it/pt[2]/ft[2])];Ne("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${ht}`);let bt=ot?4:1,mt=Math.max(pt[0]*bt,pt[1]),$t=ot?4:1,Tt=[e.kernelShape[st?1:2],e.kernelShape[st?2:3]],Nt=[Tt[0]+(e.dilations[0]<=1?0:(Tt[0]-1)*(e.dilations[0]-1)),Tt[1]+(e.dilations[1]<=1?0:(Tt[1]-1)*(e.dilations[1]-1))],Ct=[Nt[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),Nt[1]-1-Math.floor((e.pads[1]+e.pads[3])/2)],Ft=[{type:6,data:a},{type:6,data:d},{type:6,data:h},{type:6,data:e.strides},{type:6,data:e.dilations},{type:6,data:Tt},{type:6,data:Ct}];kt(e,Ft),Ft.push(...X$1(o[0].dims,o[1].dims));let ln=["rank","rank"];b&&(Ft.push(...X$1(o[2].dims)),ln.push("rank")),Ft.push(...X$1(s));let mn=yn=>{let pn=U("x",o[0].dataType,o[0].dims.length,$t),Ht=U("w",o[1].dataType,o[1].dims.length,1),Gt=K("result",o[0].dataType,s.length,$t),cn=[pn,Ht],xn="";if(b){let gn=U("bias",o[2].dataType,o[2].dims.length,$t);cn.push(gn),xn+=`
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${gn.type.value} {
            return bias[coords.${st?"w":"y"}${ot?"/ 4":""}];
          }`}let dn=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:Tt.length},{name:"pads",type:"i32",length:Ct.length}];Ot(e,dn);let wn=Be(o[0].dataType,1);if(wn!=="f16"&&wn!=="f32")throw new Error(`elemType ${wn} is not supported.`);return`
        ${ni("uniforms.result_strides")}
        ${yn.registerUniforms(dn).declareVariables(...cn,Gt)};
        ${xn}
        ${Ap(st,b,e,pn.type.value,bt)}
        ${ot?rn(ft,pt,wn,void 0,!st,mt):nn(ft,pt,wn,void 0,!st,mt,!1,void 0,et)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${e.cacheKey};${ft};${pt};${ot}`,inputDependencies:ln},getRunData:()=>({outputs:[{dims:s,dataType:o[0].dataType}],dispatchGroup:{x:ht[0],y:ht[1],z:ht[2]},programUniforms:Ft}),getShaderSource:mn}}}),Ep,ga,qu=j(()=>{ye(),Yt(),xe(),_e(),Ep=(o,e,s,a,d,h=!1,b,et,st=!1)=>{let $=st?1:2,it=st?2:3,g=st?3:1,c=h?2:1,_=`
  fn setOutputAtIndex(flatIndex : u32, value : ${h?`vec4<${b}>`:b}) {
    result[flatIndex] = ${h?`vec4<${b}>`:b}(value);
  }`;a&&(_+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${h?`vec4<${b}>`:b} {
      return bias[coords.${st?"w":"y"}${h?"/ 4":""}];
    }`);let ot=h?4:1,ct=U("W",e[1].dataType,e[1].dims.length,ot),dt=U("Dy",e[0].dataType,e[0].dims.length,ot),pt=[dt,ct];a&&pt.push(U("bias",e[2].dataType,[s[g]].length,ot));let ft=K("result",e[0].dataType,s.length,ot),ht=`{
        let batch: u32 = ${d?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${d?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${d?"global_id.y":"workgroup_id.y"} * ${c};
        let d1: u32 = ${d?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${b}>, ${c}>;
        for (var i = 0; i < ${c}; i++) {
          dotProd[i] = vec4<${b}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${b}(dyCorner.x) + ${b}(wR)) / ${b}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${b}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${b}(dyCorner.y) + ${b}(wC)) / ${b}(uniforms.strides.y);
            let dyC2 = (${b}(dyCorner.y) + 1.0 + ${b}(wC)) / ${b}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${b}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${b}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${dt.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${b}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${dt.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${b}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${g}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${dt.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${b}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${ct.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${dt.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${b}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${c}; i = i + 1) {
          let value = dotProd[i] + ${a?"bias[c+i]":`vec4<${b}>(0.0)`};
          ${ft.set("batch","r","c + i","d1","value")};
        }
      }`,bt=`
          let outputIndices = ${ft.offsetToIndices("global_idx")};
          let batch = ${ft.indicesGet("outputIndices",0)};
          let d1 = ${ft.indicesGet("outputIndices",g)};
          let r = ${ft.indicesGet("outputIndices",$)};
          let c = ${ft.indicesGet("outputIndices",it)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${b}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${b}(dyRCorner) + ${b}(wR)) / ${b}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${b}(uniforms.Dy_shape[${$}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${b}(dyCCorner) + ${b}(wC)) / ${b}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${b}(uniforms.Dy_shape[${it}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${st?dt.get("batch","idyR","idyC","inputChannel"):dt.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${ct.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${a?"bias[d1]":`${b}(0.0)`};
          ${ft.setByOffset("global_idx","value")};
        `;return`
  ${o.registerUniforms(et).declareVariables(...pt,ft)}
  ${_}

    ${o.mainStart()}
    ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${h?ht:bt}}`},ga=(o,e,s)=>{let a=o.length>2,d=e.outputShape,h=M.size(d),b=[Math.ceil(h/64),1,1];Ne("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${b}`);let et=e.format==="NHWC",st=["rank","rank"],$=[e.strides[0],e.strides[1]],it=[e.kernelShape[et?1:2],e.kernelShape[et?2:3]],g=[e.dilations[0],e.dilations[1]],c=[it[0]+(e.dilations[0]<=1?0:(e.kernelShape[et?1:2]-1)*(e.dilations[0]-1)),it[1]+(e.dilations[1]<=1?0:(e.kernelShape[et?2:3]-1)*(e.dilations[1]-1))],_=[c[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),c[1]-1-Math.floor(e.pads[1]+e.pads[3])/2],ot=!1,ct=e.group,dt=o[1].dims,pt=dt[0]/ct,ft=dt[1],ht=[{type:12,data:h},{type:12,data:$},{type:12,data:it},{type:12,data:g},{type:12,data:c},{type:6,data:_},{type:12,data:pt},{type:12,data:ft},...X$1(o[0].dims,o[1].dims)];a&&(ht.push(...X$1(o[2].dims)),st.push("rank")),ht.push(...X$1(d));let bt=b[1]===1&&b[2]===1,mt=$t=>{let Tt=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:$.length},{name:"filter_dims",type:"u32",length:it.length},{name:"dilations",type:"u32",length:it.length},{name:"effective_filter_dims",type:"u32",length:c.length},{name:"pads",type:"i32",length:_.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],Nt=Be(o[0].dataType);return`${Ep($t,o,d,a,bt,ot,Nt,Tt,et)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${e.cacheKey};`,inputDependencies:st},getRunData:()=>({dispatchGroup:{x:b[0],y:b[1],z:b[2]},outputs:[{dims:s?s(d):d,dataType:o[0].dataType}],programUniforms:ht}),getShaderSource:mt}}}),kp,Op,Pp,ju,Ku,Rp,zp,Bp,Dp,Yu,Xu=j(()=>{Fu(),qu(),Zt(),Rr(),kp=(o,e,s,a,d,h)=>(o-1)*e+s+(a-1)*d+1-h,Op=(o,e,s,a,d)=>{let h=Math.floor(o/2);e==="SAME_UPPER"?(s[a]=h,s[d]=o-h):e==="SAME_LOWER"&&(s[a]=o-h,s[d]=h)},Pp=(o,e,s,a,d,h,b,et,st,$)=>{let it=o.length-2,g=$.length===0;if(st.length===0)for(let ot=0;ot<it;++ot)st.push(0);let c=o[0],_=e[et?3:1]*d;for(let ot=0,ct=o.length-it-(et?1:0);ot<it;++ot,++ct){let dt=o[ct],pt=g?dt*b[ot]:$[ot],ft=kp(dt,b[ot],h[ot],e[ct],s[ot],pt);Op(ft,a,h,ot,ot+it),g&&$.push(b[ot]*(dt-1)+st[ot]+(e[ct]-1)*s[ot]+1-h[ot]-h[ot+it])}$.splice(0,0,c),$.splice(et?3:1,0,_)},ju=(o,e)=>{let s=o.kernelShape.slice();if(o.kernelShape.length===0||o.kernelShape.reduce((g,c)=>g*c,1)===0){s.length=0;for(let g=2;g<e[1].dims.length;++g)s.push(e[1].dims[g])}let a=o.format==="NHWC";s.splice(0,0,e[1].dims[0]),s.splice(a?3:1,0,e[1].dims[1]);let d=o.pads.slice(),h=o.outputShape.slice(),b=o.outputPadding.slice(),et=e[0].dims,st=o.dilations.slice();if(st.reduce((g,c)=>g+c,0)===0){let g=e[0].dims.length-2;st=new Array(g).fill(1)}let $=o.strides.slice();if($.reduce((g,c)=>g+c,0)===0){let g=e[0].dims.length-2;$=new Array(g).fill(1)}Pp(et,s,st,o.autoPad,o.group,d,$,a,b,h);let it=Object.assign({},o);return Object.assign(it,{kernelShape:s,pads:d,outputPadding:b,outputShape:h,dilations:st,strides:$}),it},Ku=o=>{let e=ei(o),s=o.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof o.autoPad>"u"?0:o.autoPad],d=o.dilations,h=o.group,b=o.kernelShape,et=o.pads,st=o.strides,$=o.wIsConst(),it=o.outputPadding,g=o.outputShape;return{autoPad:a,format:s,dilations:d,group:h,kernelShape:b,outputPadding:it,outputShape:g,pads:et,strides:st,wIsConst:$,...e,cacheKey:`${o.format};${e.activation};`}},Rp=(o,e)=>{if(!o||o.length!==2&&o.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(o[0].dims.length!==4&&o[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(o[0].dims.length!==o[1].dims.length)throw new Error("filter does not have same dimension as input");let s=o[0].dims[e.format==="NHWC"?o[0].dims.length-1:1],a=o[1].dims[0];if(s!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let d=o[1].dims[1]*e.group;if(o.length===3&&(o[2].dims.length!==1||o[2].dims[0]!==d))throw new Error("invalid bias");let h=o[0].dims.length-2;if(e.dilations.reduce((b,et)=>b+et,0)>0&&e.dilations.length!==h)throw new Error(`dilations should be ${h}D`);if(e.strides.reduce((b,et)=>b+et,0)>0&&e.strides.length!==h)throw new Error(`strides should be ${h}D`);if(e.pads.reduce((b,et)=>b+et,0)>0&&e.pads.length!==h*2)throw new Error(`pads should be ${h*2}D`);if(e.outputPadding.length!==h&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${h}D`);if(e.kernelShape.reduce((b,et)=>b+et,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==o[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==o[0].dims.length-2)throw new Error("invalid output shape")},zp=[2,3,1,0],Bp=(o,e,s)=>{let a=ju(s,e),d=s.format==="NHWC",h=a.outputShape,b=h[d?3:1],et=e[0].dims[d?3:1];if(a.group!==1||b===1&&et===1){o.compute(ga(e,a));return}let st=h[d?1:2],$=h[d?2:3],it=e[1].dims[2],g=e[1].dims[3],c=d?st*$:b,_=d?b:st*$,ot=it*g*et,ct=!0,dt=o.kernelCustomData.wT??o.compute(xt(e[1],zp),{inputs:[1],outputs:[s.wIsConst?-2:-1]})[0];s.wIsConst&&!o.kernelCustomData.wT&&(o.kernelCustomData.wT=dt);let pt=[e[0],dt],ft=e.length===3;ft&&(!d&&e[2].dims.length===1?pt.push(e[2].reshape([e[2].dims[0],1,1])):pt.push(e[2])),o.compute(Lu(pt,a,h,c,_,ot,ft,ct),{inputs:pt})},Dp=(o,e)=>{let s=e.format==="NHWC",a=[o.inputs[0].reshape(s?[o.inputs[0].dims[0],1,o.inputs[0].dims[1],o.inputs[0].dims[2]]:[o.inputs[0].dims[0],o.inputs[0].dims[1],1,o.inputs[0].dims[2]]),o.inputs[1].reshape([o.inputs[1].dims[0],o.inputs[1].dims[1],1,o.inputs[1].dims[2]])];o.inputs.length===3&&a.push(o.inputs[2]);let d=e.kernelShape;(d.length===0||d[0]===0)&&(d=[o.inputs[1].dims[2]]);let h=e.dilations;(h.length===0||h[0]===0)&&(h=[1]);let b=e.strides;(b.length===0||b[0]===0)&&(b=[1]);let et=e.pads;et.length===0&&(et=[0,0]),et=[0,et[0],0,et[1]],b=[1].concat(b),h=[1].concat(h),d=[1].concat(d);let st=ju({...e,pads:et,strides:b,dilations:h,kernelShape:d},a);o.compute(ga(a,st,$=>s?[$[0],$[2],$[3]]:[$[0],$[1],$[3]]))},Yu=(o,e)=>{Rp(o.inputs,e),o.inputs[0].dims.length===3?Dp(o,e):Bp(o,o.inputs,e)}}),Mp,Zu,Qu,Ju=j(()=>{ye(),xe(),Ze(),_e(),Mp=(o,e,s,a)=>{let d=M.size(e),h=e.length,b=U("input",o,h),et=K("output",o,h),st=s.dataType===6?s.getInt32Array()[0]:Number(s.getBigInt64Array()[0]),$=M.normalizeAxis(st,h),it=g=>{let c=` i32(${b.indicesGet("inputIndices","uniforms.axis")}) `,_=fe("uniforms.input_shape","uniforms.axis",h),ot=a.reverse?c+(a.exclusive?" + 1":""):"0",ct=a.reverse?_:c+(a.exclusive?"":" + 1");return`
                ${g.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(b,et)}
                ${g.mainStart()}
                  ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${et.offsetToIndices("global_idx")};
                  var sum = ${et.type.value}(0);
                  let first : i32 = ${ot};
                  let last : i32 = ${ct};
                  for (var i : i32 = first; i < last; i++) {
                    ${b.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${b.getByIndices("inputIndices")};
                  }
                  ${et.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:a.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:o}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},{type:12,data:$},...X$1(e,e)]}),getShaderSource:it}},Zu=(o,e)=>{let s=o.inputs[0].dims,a=o.inputs[0].dataType,d=o.inputs[1];o.compute(Mp(a,s,d,e),{inputs:[0]})},Qu=o=>{let e=o.exclusive===1,s=o.reverse===1;return we({exclusive:e,reverse:s})}}),Up,Wp,Np,el,tl,rl=j(()=>{ye(),xe(),Ze(),_e(),Up=o=>{if(!o||o.length!==1)throw new Error("DepthToSpace requires 1 input.");if(o[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},Wp=(o,e,s,a)=>{let d=[];d.push(`fn perm(i: ${a.type.indices}) -> ${s.type.indices} {
    var a: ${s.type.indices};`);for(let h=0;h<e;++h)d.push(s.indicesSet("a",o[h],`i[${h}]`));return d.push("return a;}"),d.join(`
`)},Np=(o,e)=>{let s,a,d,h,b,et,st=e.format==="NHWC",$=e.blocksize,it=e.mode==="DCR";st?([s,a,d,h]=o.dims,b=it?[s,a,d,$,$,h/$**2]:[s,a,d,h/$**2,$,$],et=it?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([s,a,d,h]=[o.dims[0],o.dims[2],o.dims[3],o.dims[1]],b=it?[s,$,$,h/$**2,a,d]:[s,h/$**2,$,$,a,d],et=it?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let g=o.reshape(b),c=g.dims.length,_=o.dataType,ot=U("a",_,c),ct=K("output",_,c),dt=pt=>`
  ${pt.registerUniform("output_size","u32").declareVariables(ot,ct)}

  ${Wp(et,c,ot,ct)}

  ${pt.mainStart()}
    ${pt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${ct.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${ct.setByOffset("global_idx",ot.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${o.dims};${e.blocksize};${e.mode}`,inputDependencies:["rank"]},getRunData:pt=>{let ft=st?[s,a*$,d*$,h/$**2]:[s,h/$**2,a*$,d*$],ht=M.size(ft),bt=g.dims,mt=M.sortBasedOnPerm(bt,et);return{outputs:[{dims:ft,dataType:pt[0].dataType}],dispatchGroup:{x:Math.ceil(ht/64)},programUniforms:[{type:12,data:ht},...X$1(bt,mt)]}},getShaderSource:dt}},el=(o,e)=>{Up(o.inputs),o.compute(Np(o.inputs[0],e))},tl=o=>we({blocksize:o.blocksize,mode:o.mode,format:o.format})}),ya,oi,nl,Vp,Hp,ba,va,il,Gp,al,ol,sl=j(()=>{ye(),xe(),Ze(),_e(),ya="[a-zA-Z]|\\.\\.\\.",oi="("+ya+")+",nl="^"+oi+"$",Vp="("+oi+",)*"+oi,Hp="^"+Vp+"$",ba=class{constructor(o=-1){this.symbolToIndices=new Map,this.inputIndex=o}addSymbol(o,e){let s=this.symbolToIndices.get(o);s===void 0?s=[e]:s.push(e),this.symbolToIndices.set(o,s)}},va=class{constructor(o,e){this.equation=e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[s,a]=e.includes("->")?e.split("->",2):[e,""];if(!s.match(RegExp(Hp)))throw new Error("Invalid LHS term");if(s.split(",").forEach((d,h)=>{let b=o[h].dims.slice();if(!d.match(RegExp(nl)))throw new Error("Invalid LHS term");let et=this.processTerm(d,!0,b,h);this.lhs.push(et)}),a==="")a+=[...this.symbolToInfo.entries()].filter(([d,h])=>h.count===1||d==="...").map(([d])=>d).join("");else if(!a.match(RegExp(oi)))throw new Error("Invalid RHS");a.match(RegExp(ya,"g"))?.forEach(d=>{if(d==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let h=this.symbolToInfo.get(d);if(h===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(h.dimValue)}}),this.rhs=this.processTerm(a,!1,this.outputDims)}addSymbol(o,e,s){let a=this.symbolToInfo.get(o);if(a!==void 0){if(a.dimValue!==e&&a.count!==1)throw new Error("Dimension mismatch");a.count++,a.inputIndices.push(s)}else a={count:1,dimValue:e,inputIndices:[s]};this.symbolToInfo.set(o,a)}processTerm(o,e,s,a=-1){let d=s.length,h=!1,b=[],et=0;if(!o.match(RegExp(nl))&&!e&&o!=="")throw new Error("Invalid LHS term");let st=o.match(RegExp(ya,"g")),$=new ba(a);return st?.forEach((it,g)=>{if(it==="..."){if(h)throw new Error("Only one ellipsis is allowed per input term");h=!0;let c=d-st.length+1;if(c<0)throw new Error("Ellipsis out of bounds");if(b=s.slice(et,et+c),this.hasEllipsis){if(this.ellipsisDims.length!==b.length||this.ellipsisDims.toString()!==b.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=b;else throw new Error("Ellipsis must be specified in the LHS");for(let _=0;_<b.length;_++){let ot=String.fromCharCode(48+_);$.addSymbol(ot,g+_),this.addSymbol(ot,s[et++],a)}}else $.addSymbol(it,g+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(it,s[et++],a)}),$}},il=o=>o+"_max",Gp=(o,e,s,a)=>{let d=o.map($=>$.length).map(($,it)=>U(`input${it}`,e,$)),h=M.size(a),b=K("output",e,a.length),et=[...s.symbolToInfo.keys()].filter($=>!s.rhs.symbolToIndices.has($)),st=$=>{let it=[],g="var prod = 1.0;",c="var sum = 0.0;",_="sum += prod;",ot=[],ct=[],dt=[],pt=[],ft=s.symbolToInfo.size===s.rhs.symbolToIndices.size;s.symbolToInfo.forEach((bt,mt)=>{if(s.rhs.symbolToIndices.has(mt)){let $t=s.rhs.symbolToIndices.get(mt)?.[0];$t!==void 0&&s.lhs.forEach((Tt,Nt)=>{if(bt.inputIndices.includes(Nt)){let Ct=Tt.symbolToIndices.get(mt);if(Ct===void 0)throw new Error("Invalid symbol error");Ct.forEach(Ft=>{it.push(`${d[Nt].indicesSet(`input${Nt}Indices`,Ft,b.indicesGet("outputIndices",$t))}`)})}})}else s.lhs.forEach(($t,Tt)=>{if(bt.inputIndices.includes(Tt)){let Nt=$t.symbolToIndices.get(mt);if(Nt===void 0)throw new Error("Invalid symbol error");Nt.forEach(Ct=>{ot.push(`${d[Tt].indicesSet(`input${Tt}Indices`,Ct,`${mt}`)}`)}),pt.push(`prod *= ${d[Tt].getByIndices(`input${Tt}Indices`)};`)}}),ct.push(`for(var ${mt}: u32 = 0; ${mt} < uniforms.${il(mt)}; ${mt}++) {`),dt.push("}")});let ht=ft?[...it,`let sum = ${d.map((bt,mt)=>bt.getByIndices(`input${mt}Indices`)).join(" * ")};`]:[...it,c,...ct,...ot,g,...pt,_,...dt];return`
            ${$.registerUniforms(et.map(bt=>({name:`${il(bt)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...d,b)}

            ${$.mainStart()}
            ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${b.offsetToIndices("global_idx")};
            ${d.map((bt,mt)=>`var input${mt}Indices: ${d[mt].type.indices};`).join(`
`)}
            ${ht.join(`
`)};
            ${b.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:s.equation,inputDependencies:o.map(()=>"rank")},getRunData:()=>{let $=et.filter(g=>s.symbolToInfo.has(g)).map(g=>({type:12,data:s.symbolToInfo.get(g)?.dimValue||0}));$.push({type:12,data:h});let it=o.map((g,c)=>[...X$1(g)]).reduce((g,c)=>g.concat(c),$);return it.push(...X$1(a)),{outputs:[{dims:a,dataType:e}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:it}},getShaderSource:st}},al=(o,e)=>{let s=new va(o.inputs,e.equation),a=s.outputDims,d=o.inputs.map((h,b)=>h.dims);o.compute(Gp(d,o.inputs[0].dataType,s,a))},ol=o=>{let e=o.equation.replace(/\s+/g,"");return we({equation:e})}}),Lp,ul,Fp,qp,ll,dl=j(()=>{ye(),xe(),_e(),Lp=o=>{if(!o||o.length!==2)throw new Error("Expand requires 2 input.");let e=o[0].dims,s=Array.from(o[1].getBigInt64Array(),Number),a=s.length<e.length?0:s.length-e.length,d=e.length<s.length?0:e.length-s.length;for(;a<s.length&&d<e.length;++a,++d)if(s[a]!==e[d]&&s[a]!==1&&e[d]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ul=(o,e)=>{let s=o.length-e.length,a=[];for(let d=0;d<s;++d)a.push(o[d]);for(let d=0;d<e.length;++d)a.push(e[d]===1?o[d+s]:e[d]);return a},Fp=(o,e)=>o.length>e.length?ul(o,e):ul(e,o),qp=o=>{let e=o[0].dims,s=Array.from(o[1].getBigInt64Array(),Number),a=Fp(e,s),d=o[0].dataType,h=d===9?4:1,b=Math.ceil(M.size(a)/h),et=$=>{let it=U("input",d,e.length,h),g=K("output",d,a.length,h),c;if(d===9){let _=(ot,ct,dt="")=>`
          let outputIndices${ct} = ${g.offsetToIndices(`outputOffset + ${ct}u`)};
          let offset${ct} = ${it.broadcastedIndicesToOffset(`outputIndices${ct}`,g)};
          let index${ct} = offset${ct} / 4u;
          let component${ct} = offset${ct} % 4u;
          ${ot}[${ct}] = ${dt}(${it.getByOffset(`index${ct}`)}[component${ct}]);
        `;c=`
        let outputOffset = global_idx * ${h};
        var data = vec4<u32>(0);
        ${_("data",0,"u32")}
        ${_("data",1,"u32")}
        ${_("data",2,"u32")}
        ${_("data",3,"u32")}
        ${g.setByOffset("global_idx","data")}
      }`}else c=`
        let outputIndices = ${g.offsetToIndices("global_idx")};
        let inputOffset = ${it.broadcastedIndicesToOffset("outputIndices",g)};
        ${g.setByOffset("global_idx",it.getByOffset("inputOffset"))}
      }`;return`
    ${$.registerUniform("vec_size","u32").declareVariables(it,g)}
    ${$.mainStart()}
    ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${c}`},st=[{type:12,data:b},...X$1(e,a)];return{name:"Expand",shaderCache:{hint:`${a.length}`,inputDependencies:["rank"]},getShaderSource:et,getRunData:()=>({outputs:[{dims:a,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:st})}},ll=o=>{Lp(o.inputs),o.compute(qp(o.inputs),{inputs:[0]})}}),jp,cl,pl=j(()=>{ye(),xe(),_e(),Jn(),jp=o=>{let e=o[0].dataType,s=M.size(o[0].dims),a=M.size(o[1].dims),d=a%4===0,h=b=>{let et=U("x",e,[1],4),st=U("bias",e,[1],4),$=K("y",e,[1],4),it=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],g=_=>`
      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;
      let bias${_} = ${st.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,c=d?`
      let bias = ${st.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${g(0)}${g(1)}${g(2)}${g(3)}
      let bias = ${et.type.value}(bias0, bias1, bias2, bias3);`;return`${b.registerUniforms(it).declareVariables(et,st,$)}

    ${oa(rt(e))}

    ${b.mainStart(mr)}
      ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${et.getByOffset("global_idx")};
      ${c}
      let x_in = x + bias;
      ${$.setByOffset("global_idx",sa("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${d}`,inputDependencies:["type","type"]},getShaderSource:h,getRunData:b=>({outputs:[{dims:b[0].dims,dataType:b[0].dataType}],programUniforms:[{type:12,data:Math.ceil(s/4)},{type:12,data:a}],dispatchGroup:{x:Math.ceil(s/mr/4)}})}},cl=o=>{o.inputs.length<2||M.size(o.inputs[1].dims)===0?wu(o):o.compute(jp(o.inputs))}}),Kp,Yp,ml,fl,hl=j(()=>{ye(),xe(),Ze(),_e(),Kp=o=>{if(!o||o.length!==2)throw new Error("Gather requires 2 inputs.")},Yp=(o,e)=>{let s=o[0].dims,a=o[1].dims,d=s.length,h=M.normalizeAxis(e.axis,d),b=s.slice(0);b.splice(h,1,...a);let et=s[h],st=o[0].dataType===9?4:1,$=Math.ceil(M.size(b)/st),it=[{type:12,data:$},{type:6,data:et},{type:12,data:h},...X$1(o[0].dims,o[1].dims,b)],g=c=>{let _=U("data",o[0].dataType,o[0].dims.length,st),ot=U("inputIndices",o[1].dataType,o[1].dims.length),ct=K("output",o[0].dataType,b.length,st),dt=ft=>{let ht=a.length,bt=`var indicesIndices${ft}  = ${ot.type.indices}(0);`;for(let mt=0;mt<ht;mt++)bt+=`${ht>1?`indicesIndices${ft}[${mt}]`:`indicesIndices${ft}`} = ${b.length>1?`outputIndices${ft}[uniforms.axis + ${mt}]`:`outputIndices${ft}`};`;bt+=`
          var idx${ft} = ${ot.getByIndices(`indicesIndices${ft}`)};
          if (idx${ft} < 0) {
            idx${ft} = idx${ft} + uniforms.axisDimLimit;
          }
          var dataIndices${ft} : ${_.type.indices};
        `;for(let mt=0,$t=0;mt<d;mt++)mt===h?(bt+=`${d>1?`dataIndices${ft}[${mt}]`:`dataIndices${ft}`} = u32(idx${ft});`,$t+=ht):(bt+=`${d>1?`dataIndices${ft}[${mt}]`:`dataIndices${ft}`} = ${b.length>1?`outputIndices${ft}[${$t}]`:`outputIndices${ft}`};`,$t++);return bt},pt;if(o[0].dataType===9){let ft=(ht,bt,mt="")=>`
          let outputIndices${bt} = ${ct.offsetToIndices(`outputOffset + ${bt}u`)};
          ${dt(bt)};
          let offset${bt} = ${_.indicesToOffset(`dataIndices${bt}`)};
          let index${bt} = offset${bt} / 4u;
          let component${bt} = offset${bt} % 4u;
          ${ht}[${bt}] = ${mt}(${_.getByOffset(`index${bt}`)}[component${bt}]);
        `;pt=`
        let outputOffset = global_idx * ${st};
        var value = vec4<u32>(0);
        ${ft("value",0,"u32")}
        ${ft("value",1,"u32")}
        ${ft("value",2,"u32")}
        ${ft("value",3,"u32")}
        ${ct.setByOffset("global_idx","value")}
      `}else pt=`
      let outputIndices = ${ct.offsetToIndices("global_idx")};
      ${dt("")};
      let value = ${_.getByIndices("dataIndices")};
      ${ct.setByOffset("global_idx","value")};
      `;return`
      ${c.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(_,ot,ct)}
      ${c.mainStart()}
        ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${pt}
      }`};return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:b,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:it}),getShaderSource:g}},ml=o=>we({axis:o.axis}),fl=(o,e)=>{let s=o.inputs;Kp(s),o.compute(Yp(o.inputs,e))}}),Xp,Zp,gl,yl,bl=j(()=>{ye(),xe(),Ze(),_e(),Xp=o=>{if(!o||o.length!==2)throw new Error("GatherElements requires 2 inputs.");if(o[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(o[0].dims.length!==o[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Zp=(o,e)=>{let s=o[0].dims,a=o[0].dataType,d=s.length,h=o[1].dims,b=o[1].dataType,et=M.normalizeAxis(e.axis,d),st=s[et],$=h.slice(0),it=M.size($),g=U("input",a,d),c=U("indicesInput",b,h.length),_=K("output",a,$.length),ot=[{type:12,data:it},{type:6,data:st},{type:12,data:et}];return ot.push(...X$1(s,h,$)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:$,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(it/64)},programUniforms:ot}),getShaderSource:ct=>`
      ${ct.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(g,c,_)}
      ${ct.mainStart()}
      ${ct.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${_.offsetToIndices("global_idx")};

      var idx = ${c.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${g.type.indices}(outputIndices);
      ${g.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${g.getByIndices("inputIndices")};

      ${_.setByOffset("global_idx","value")};
  }`}},gl=o=>we({axis:o.axis}),yl=(o,e)=>{let s=o.inputs;Xp(s),o.compute(Zp(o.inputs,e))}}),Qp,Jp,vl,wl,$l=j(()=>{ye(),xe(),_e(),Qp=o=>{if(!o)throw new Error("Input is missing");if(o.length<2||o.length>3)throw new Error("Invaid input number.");if(o.length===3&&o[2].dims.length>2)throw new Error("Invalid input shape of C");if(o[0].dataType!==o[1].dataType||o.length===3&&o[0].dataType!==o[2].dataType)throw new Error("Input types are mismatched")},Jp=(o,e)=>{let s=o[0].dims.slice(),a=o[1].dims.slice(),[d,h,b]=Gn.getShapeOfGemmResult(s,e.transA,a,e.transB,o.length===3?o[2].dims:void 0),et=[d,h];if(!et)throw new Error("Can't use gemm on the given tensors");let st=M.size(et),$=[{type:12,data:st},{type:12,data:d},{type:12,data:h},{type:12,data:b},{type:1,data:e.alpha},{type:1,data:e.beta}],it=["type","type"];o.length===3&&($.push(...X$1(o[2].dims)),it.push("rank")),$.push(...X$1(et));let g=c=>{let _="";e.transA&&e.transB?_="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":e.transA&&!e.transB?_="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!e.transA&&e.transB?_="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!e.transA&&!e.transB&&(_="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let ot=e.alpha===1?"":"value *= uniforms.alpha;",ct=U("a",o[0].dataType,o[0].dims),dt=U("b",o[1].dataType,o[1].dims),pt=ct.type.value,ft=null,ht=[ct,dt];o.length===3&&(ft=U("c",o[2].dataType,o[2].dims.length),ht.push(ft));let bt=K("output",o[0].dataType,et.length);ht.push(bt);let mt=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${c.registerUniforms(mt).declareVariables(...ht)}

  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${pt}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${_}
    }

    ${ot}
    ${ft!=null?`let cOffset = ${ft.broadcastedIndicesToOffset("vec2(m, n)",bt)}; value += ${pt}(uniforms.beta) * ${ft.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`};return{name:"Gemm",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:it},getRunData:()=>({outputs:[{dims:et,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(st/64)},programUniforms:$}),getShaderSource:g}},vl=o=>{let e=o.transA,s=o.transB,a=o.alpha,d=o.beta;return{transA:e,transB:s,alpha:a,beta:d,cacheKey:`${o.transA};${o.transB};${o.alpha===1}`}},wl=(o,e)=>{Qp(o.inputs),o.compute(Jp(o.inputs,e))}}),em,tm,rm,_l,xl=j(()=>{ye(),xe(),_e(),em=(o,e)=>{let s=o[0].dims,a=s,d=2,h=M.sizeToDimension(s,d),b=M.sizeFromDimension(s,d),et=Ue(b),st=b/et,$=[s[0],s[1],st],it=["rank","type","type"],g=[{type:12,data:b},{type:12,data:st}];g.push(...X$1($,$));let c=_=>{let ot=U("x",o[0].dataType,$.length,et),ct=U("scale",o[1].dataType,o[1].dims),dt=U("bias",o[2].dataType,o[2].dims),pt=K("output",o[0].dataType,$.length,et),ft=[ot,ct,dt,pt],ht=ot.type.value,bt=et===1?"f32":`vec${et}<f32>`,mt=64,$t=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${bt}, ${mt}>;
  const workgroupSize = ${mt}u;
  ${_.registerUniforms($t).declareVariables(...ft)}
  ${_.mainStart(mt)}
    let norm = global_idx / workgroupSize;
    let batch = norm / uniforms.x_shape[1];
    let channel = norm % uniforms.x_shape[1];
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${bt}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      initial = initial + ${bt}(${ot.get("batch","channel","h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${At("workgroupShared[0]",et)} / f32(uniforms.normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${bt}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let deviation =  ${bt}(${ot.get("batch","channel","h")}) - ${bt}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${At("workgroupShared[0]",et)};
    }
    workgroupBarrier();

    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${e.epsilon}));
    let channelScale = invStdDev * f32(${ct.getByOffset("channel")});
    let channelShift = f32(${dt.getByOffset("channel")}) - meanShared * channelScale;
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let value = ${ot.get("batch","channel","h")} * ${ht}(${bt}(channelScale)) + ${ht}(${bt}(channelShift));
      ${pt.set("batch","channel","h","value")};
    }
  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${e.epsilon};${et}`,inputDependencies:it},getRunData:()=>({outputs:[{dims:a,dataType:o[0].dataType}],dispatchGroup:{x:h},programUniforms:g}),getShaderSource:c}},tm=(o,e,s,a,d,h,b,et)=>{let st=Ue(b),$=64,it=st===1?"vec2f":`mat2x${st}f`,g=st===1?"f32":`vec${st}f`,c=($t,Tt)=>`${it}(${$t}, ${Tt})`,_=d*b/st,ot=Math.ceil(h/$),ct=["type"],dt=[{type:12,data:ot},{type:12,data:h},{type:12,data:Math.floor(b/st)},{type:12,data:Math.floor(h*b/st)}],pt=$t=>{let Tt=U("input",e.dataType,e.dims,st);return`
  ${$t.declareVariables(Tt)}
  @group(0) @binding(1) var<storage, read_write> output : array<${it}>;
  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};
  @group(0) @binding(2) var<uniform> uniforms: Uniforms;

  ${$t.mainStart($)}
    let currentImageNumber = global_idx / ${$} / uniforms.C;
    let currentChannelNumber = (global_idx / ${$}) % uniforms.C;
    let wgOffset = local_id.x * uniforms.wg_size;
    if (wgOffset >= uniforms.H) {
        return;
    }
    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);

    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;
    var sum = ${Xt("f32",st)};
    var squaredSum = ${Xt("f32",st)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${g}(input[offset + i * uniforms.C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${c("sum","squaredSum")};
  }`},ft=o.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${st}`,inputDependencies:ct},getRunData:()=>({outputs:[{dims:[d,b,$,2],dataType:1}],dispatchGroup:{x:d*b/st},programUniforms:dt}),getShaderSource:pt},{inputs:[e],outputs:[-1]})[0],ht=[{type:12,data:_},{type:12,data:h},{type:12,data:Math.floor(b/st)},{type:12,data:Math.floor($*b/st)}],bt=["type","type","type"],mt=$t=>{let Tt=U("scale",s.dataType,s.dims,st),Nt=U("bias",a.dataType,a.dims,st);return`
  @group(0) @binding(0) var<storage, read> input : array<${it}>;
  @group(0) @binding(1) var<storage, read> scale : array<${Tt.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${Nt.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${it}>;
  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};
  @group(0) @binding(4) var<uniform> uniforms: Uniforms;

  ${$t.mainStart()}
    ${$t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}
    let currentImageNumber = global_idx / uniforms.C;
    let currentChannelNumber = global_idx % uniforms.C;

    let offset = currentImageNumber * uniforms.image_size;
    var sum = ${Xt("f32",st)};
    var squaredSum = ${Xt("f32",st)};
    for (var i: u32 = 0; i < min(${$}, uniforms.H); i++) {
        let value = input[offset + i + currentChannelNumber * ${$}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(uniforms.H);
    squaredSum = squaredSum / f32(uniforms.H);
    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${et}));
    let channelScale = invStdDev * ${g}(scale[currentChannelNumber]);
    let channelShift = ${g}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${c("channelScale","channelShift")};
  }`};return o.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${st};${et}`,inputDependencies:bt},getRunData:()=>({outputs:[{dims:[d,b,2],dataType:1}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:ht}),getShaderSource:mt},{inputs:[ft,s,a],outputs:[-1]})[0]},rm=(o,e,s)=>{let a=e[0].dims,d=a,h=a[0],b=a[a.length-1],et=M.sizeFromDimension(a,1)/b,st=Ue(b),$=M.size(d)/st,it=[{type:12,data:et},{type:12,data:Math.floor(b/st)}],g=["type","type"],c=tm(o,e[0],e[1],e[2],h,et,b,s.epsilon),_=ot=>{let ct=Be(e[0].dataType),dt=st===1?"vec2f":`mat2x${st}f`,pt=st===1?ct:`vec${st}<${ct}>`,ft=U("input",e[0].dataType,e[0].dims,st),ht=K("output",e[0].dataType,d,st);return`
  @group(0) @binding(0) var<storage, read> input : array<${ft.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${dt}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${ht.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${ot.mainStart()}
    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);
    let currentChannelNumber = global_idx % uniforms.C;

    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${pt}(scale[0]), ${pt}(scale[1]));
  }`};o.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${st}`,inputDependencies:g},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:it}),getShaderSource:_},{inputs:[e[0],c]})},_l=(o,e)=>{e.format==="NHWC"?rm(o,o.inputs,e):o.compute(em(o.inputs,e))}}),nm,im,Sl,Cl=j(()=>{ye(),xe(),_e(),nm=o=>{if(!o||o.length<2)throw new Error("layerNorm requires at least 2 inputs.")},im=(o,e,s)=>{let a=e.simplified,d=o[0].dims,h=o[1],b=!a&&o[2],et=d,st=M.normalizeAxis(e.axis,d.length),$=M.sizeToDimension(d,st),it=M.sizeFromDimension(d,st),g=M.size(h.dims),c=b?M.size(b.dims):0;if(g!==it||b&&c!==it)throw new Error(`Size of X.shape()[axis:] == ${it}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${g} and bias size of ${c}`);let _=[];for(let mt=0;mt<d.length;++mt)mt<st?_.push(d[mt]):_.push(1);let ot=Ue(it),ct=["type","type"],dt=[{type:12,data:$},{type:1,data:it},{type:12,data:Math.floor(it/ot)},{type:1,data:e.epsilon}];b&&ct.push("type");let pt=s>1,ft=s>2,ht=mt=>{let $t=Be(o[0].dataType),Tt=[U("x",o[0].dataType,o[0].dims,ot),U("scale",h.dataType,h.dims,ot)];b&&Tt.push(U("bias",b.dataType,b.dims,ot)),Tt.push(K("output",o[0].dataType,et,ot)),pt&&Tt.push(K("mean_data_output",1,_)),ft&&Tt.push(K("inv_std_output",1,_));let Nt=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${mt.registerUniforms(Nt).declareVariables(...Tt)}
  ${mt.mainStart()}
    ${mt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Xt("f32",ot)};
    var mean_square_vector = ${Xt("f32",ot)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${fr($t,ot,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${At("mean_vector",ot)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${At("mean_square_vector",ot)} / uniforms.norm_size ${a?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${fr($t,ot,"x[j + offset]")};
      let f32scale = ${fr($t,ot,"scale[j]")};
      output[j + offset] = ${Tt[0].type.value}((f32input ${a?"":"- mean"}) * inv_std_dev * f32scale
        ${b?`+ ${fr($t,ot,"bias[j]")}`:""}
      );
    }

    ${pt?"mean_data_output[global_idx] = mean":""};
    ${ft?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},bt=[{dims:et,dataType:o[0].dataType}];return pt&&bt.push({dims:_,dataType:1}),ft&&bt.push({dims:_,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${ot};${s};${a}`,inputDependencies:ct},getRunData:()=>({outputs:bt,dispatchGroup:{x:Math.ceil($/64)},programUniforms:dt}),getShaderSource:ht}},Sl=(o,e)=>{nm(o.inputs),o.compute(im(o.inputs,e,o.outputCount))}}),am,om,Il,Tl,Al=j(()=>{ye(),xe(),Ze(),_e(),am=(o,e)=>{if(o.length<3||o.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let s=o[0],a=s.dims.length;if(s.dims[a-1]!==e.k)throw new Error("The last dim of input shape does not match the k value");let d=Math.floor((e.k+e.blockSize-1)/e.blockSize),h=e.blockSize/8*e.bits,b=o[1];if(!M.areEqual(b.dims,[e.n,d,h]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let et=o[2].dims;if(M.size(et)!==e.n*d)throw new Error("scales input size error.");if(o.length===4){let st=o[3].dims,$=e.bits>4?e.n*d:e.n*Math.floor((d+1)/2);if(M.size(st)!==$)throw new Error("zeroPoints input size error.")}},om=(o,e,s,a)=>{let d=o[0].dims,h=d.length,b=Math.floor((e.k+e.blockSize-1)/e.blockSize),et=d[h-2],st=e.k,$=e.n,it=d.slice(0,h-2),g=M.size(it),c=e.blockSize/8*e.bits/4,_=o[0].dataType,ot=Ue(et),ct=Ue(e.k),dt=Ue(c),pt=cr(_),ft=et*b*pt,ht=Math.floor(a/ft),bt=b<=s[0]&&ht>0,mt=!bt||ht>=4?Ue($):ht>=2&&Ue($)>=2?2:1,$t=it.concat([et,$]),Tt=M.size($t)/mt/ot,Nt=bt?[]:[{type:12,data:Tt},{type:12,data:e.blockSize}],Ct=[g,et,st/ct],Ft=M.convertShape(o[1].dims).slice();Ft.splice(-1,1,c/dt),Nt.push(...X$1(Ct)),Nt.push(...X$1(Ft)),Nt.push(...X$1(o[2].dims)),o.length===4&&Nt.push(...X$1(M.convertShape(o[3].dims)));let ln=[g,et,$/mt];Nt.push(...X$1(ln));let mn=yn=>{let pn=Ct.length,Ht=U("a",o[0].dataType,pn,ct),Gt=U("b",12,Ft.length,dt),cn=U("scales",o[2].dataType,o[2].dims.length),xn=[Ht,Gt,cn],dn=o.length===4?U("zero_points",12,o[3].dims.length):void 0;dn&&xn.push(dn);let wn=ln.length,gn=K("output",o[0].dataType,wn,mt),En=[{name:"output_size",type:"u32"},{name:"block_size",type:"u32"}],_r=Be(o[0].dataType),Sr=(()=>{switch(ct){case 1:return`array<${_r}, 8>`;case 2:return`mat4x2<${_r}>`;case 4:return`mat2x4<${_r}>`;default:throw new Error(`${ct}-component is not supported.`)}})(),xr=`
        for (var word: u32 = 0; word < ${c}; word += ${dt}) {
          ${Gt.indicesSet("b_indices","2","word")};
          let b_data = ${Gt.getByIndices("b_indices")};
          for (var i: u32 = 0; i < ${dt}; i++) {
            let b_value: u32 = ${dt===1?"b_data":"b_data[word + i]"};
            let b_mask: u32 = 0x0F0F0F0Fu;
            let b_value_lower: vec4<u32> = unpack4xU8(b_value & b_mask);
            let b_value_upper: vec4<u32> = unpack4xU8((b_value >> 4) & b_mask);
            let b_quantized_values = ${Sr}(${Array.from({length:4},(Fr,_f)=>`${_r}(b_value_lower[${_f}]), ${_r}(b_value_upper[${_f}])`).join(", ")});
            let b_dequantized_values = ${ct===1?`${Sr}(${Array.from({length:8},(Fr,_f)=>`(b_quantized_values[${_f}] - zero_point) * scale`).join(", ")});`:`(b_quantized_values - ${Sr}(${Array(8).fill("zero_point").join(",")})) * scale;`};
            // Number of B elements per 32-bit word is 32/bits = 32/4 = 8
            for (var m: u32 = 0; m < ${bt?et:ot}u; m++) {
              ${Ht.indicesSet("a_indices",pn-2,bt?"m":`row * ${ot} + m`)};
              ${Ht.indicesSet("a_indices",pn-1,"word_offset")};
              var input_offset = ${Ht.indicesToOffset("a_indices")};
              var a_data: ${Sr};
              for (var j: u32 = 0; j < ${8/ct}; j++) {
                a_data[j] = ${Ht.getByOffset("input_offset")};
                input_offset++;
              }
              ${bt?"workgroup_shared[workgroup_shared_offset + m]":"output_values[m]"}${mt>1?"[c]":""} += ${Array.from({length:8/ct},(Fr,_f)=>`${ct===1?`a_data[${_f}] * b_dequantized_values[${_f}]`:`dot(a_data[${_f}], b_dequantized_values[${_f}])`}`).join(" + ")};
            }
            word_offset += ${8/ct};
          }
        }`,Vr=dn?`
          zero_point_offset += 4;
          if (zero_point_offset == 32) {
            zero_point_offset = 0;
            zero_point_index++;
            zero_point_word = ${dn.getByOffset("zero_point_index")};
          }`:"";return bt?`
        var<workgroup> workgroup_shared: array<${gn.type.value}, ${et*b}>;
        ${yn.declareVariables(...xn,gn)}
        ${yn.mainStart([b,1,1])}
          var a_indices: ${Ht.type.indices};
          var block = local_id.x;
          var col = workgroup_id.y;
          var batch = workgroup_id.z;
          ${Ht.indicesSet("a_indices","0","batch")};
          // Two zero points are packed into one byte when uniforms.bits is 4.
          for (var c: u32 = 0; c < ${mt}; c++) {
            let col_times_components_plus_c = col * ${mt} + c;
              ${dn?`
            var zero_point_bytes_per_col: u32 = (${b} + 1) / 2;
            var zero_point_byte_count: u32 = col_times_components_plus_c * zero_point_bytes_per_col + (block >> 0x1u);
            var zero_point_word_index: u32 = zero_point_byte_count >> 0x2u;
            var zero_point_byte_offset: u32 = zero_point_byte_count & 0x3u;
            var zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32 = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            var zero_point_word: u32 = ${dn.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;`:""}
            var b_indices: ${Gt.type.indices};
            ${Gt.indicesSet("b_indices","0","col_times_components_plus_c")};
            // The scale and zero points are computed per block.
            var scales_index = col_times_components_plus_c * ${b} + block;
            let scale = ${cn.getByOffset("scales_index")};
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${_r}(${dn?"(zero_point_word) & 0xFu":8});
            ${Gt.indicesSet("b_indices","1","block")};
            var word_offset: u32 = block * ${e.blockSize/ct};
            var workgroup_shared_offset: u32 = block * ${et};
            ${xr}
          }
          workgroupBarrier();
          var output_indices: ${gn.type.indices};
          var elements_per_thread: u32 = ${Math.ceil(et/b)};
          ${gn.indicesSet("output_indices","0","batch")};
          ${gn.indicesSet("output_indices",wn-1,"col")};
          ${gn.indicesSet("output_indices",wn-2,"local_id.x * elements_per_thread")};
          var output_offset = ${gn.indicesToOffset("output_indices")};
          for (var m: u32 = 0u; m < elements_per_thread; m++) {
            var row = m + local_id.x * elements_per_thread;
            if (row < ${et}) {
              var output_value: ${gn.type.value} = ${gn.type.value}(0);
              var workgroup_shared_offset: u32 = row;
              for (var b: u32 = 0u; b < ${b}u; b++) {
                output_value += workgroup_shared[workgroup_shared_offset];
                workgroup_shared_offset += ${et};
              }
              ${gn.setByOffset("output_offset","output_value")};
              output_offset += ${$/mt};
            }
          }
        }`:`
        ${yn.registerUniforms(En).declareVariables(...xn,gn)}
        ${yn.mainStart()}
          ${yn.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var output_values: array<${gn.type.value}, ${ot}>;
          var output_indices = ${gn.offsetToIndices("global_idx")};
          var col = ${gn.indicesGet("output_indices",wn-1)};
          var row = ${gn.indicesGet("output_indices",wn-2)};
          var a_indices: ${Ht.type.indices} = output_indices;
          // Two zero points are packed into one byte because uniforms.bits <= 4.
          // zero_point_offset is either 0 or 4. It is bit offset within one byte.
          // TODO support zero_point_offset for bits > 4
          ${dn?`
          var zero_point_abs_offset = col * ${mt} * ((${b} + 1) / 2);
          var zero_point_index: u32 = zero_point_abs_offset / 4;
          var zero_point_word: u32 = ${dn.getByOffset("zero_point_index")};
          var zero_point_offset: u32 = (zero_point_abs_offset % 4) * 8;`:""}
          var scale_index = col * ${b*mt};
          var b_indices: ${Gt.type.indices};
          for (var c: u32 = 0; c < ${mt}; c++) {
            ${Gt.indicesSet("b_indices","0",`col * ${mt} + c`)};
            var block_offset: u32 = 0;
            for (var block: u32 = 0; block < ${b}; block++) {
              // The scale and zero points are computed per block.
              let scale = ${cn.getByOffset("scale_index")};
              // The default zero point is 8 for unsigned 4-bit quantization.
              let zero_point = ${_r}(${dn?"extractBits(zero_point_word, zero_point_offset, 4)":8});
              ${Gt.indicesSet("b_indices","1","block")};
              var word_offset: u32 = block_offset;
              ${xr}
              scale_index++;
              ${Vr}
              block_offset += uniforms.block_size / ${ct};
            }
            // Drop the trailing 4 bits if the zero_poit_offset is not a byte boundary to align with the next byte.
            ${dn?`if (zero_point_offset % 8 > 0) {
                ${Vr}
              }`:""}
            }
            for (var k: u32 = 0u; k < ${ot}u; k++) {
              ${gn.indicesSet("output_indices",wn-2,`${ot} * row + k`)};
              ${gn.setByIndices("output_indices","output_values[k]")}
            }
        }`};return{name:bt?"BlockwiseMatMulNBits":"MatMulNBits",shaderCache:{hint:`${e.cacheKey};${et};${_};${o.length}`,inputDependencies:Array(o.length).fill("rank")},getRunData:()=>({outputs:[{dims:$t,dataType:_}],name:bt?"BlockwiseMatMulNBits":"MatMulNBits",dispatchGroup:bt?{x:1,y:Math.ceil($/mt),z:g}:{x:Math.ceil(Tt/64)},programUniforms:Nt}),getShaderSource:mn}},Il=(o,e)=>{am(o.inputs,e);let s=o.getMaxComputeWorkgroupSizes(),a=o.getMaxComputeWorkgroupStoragesize();o.compute(om(o.inputs,e,s,a))},Tl=o=>we(o)}),lt,sm,kl,El,um,wa,Ol,Pl=j(()=>{ye(),xe(),Ze(),Hn(),aa(),_e(),Rr(),lt=(o,e)=>o.length>e&&o[e].dims.length>0&&M.size(o[e].dims)>0?o[e]:void 0,sm=(o,e)=>{let s=o[0],a=lt(o,1),d=lt(o,2),h=lt(o,3),b=lt(o,4),et=lt(o,5),st=lt(o,6),$=lt(o,7);if(s.dims.length!==3&&s.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let it=!1,g=s.dims[0],c=s.dims[1],_=s.dims.length===3?it?s.dims[2]/3:s.dims[2]:e.numHeads*s.dims[4],ot=c,ct=0,dt=0,pt=Math.floor(_/e.numHeads);if(st&&$){if(st.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(st.dims[0]!==g||st.dims[1]!==e.numHeads||st.dims[3]!==pt)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if($.dims[0]!==g||$.dims[1]!==e.numHeads||$.dims[3]!==pt)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(st.dims[2]!==$.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if($.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');ct=st.dims[2],dt=st.dims[2]}else if(st||$)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let ft;if(a){if(s.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(a.dims.length<3||a.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(s.dims[0]!==a.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(a.dims.length===3){if(a.dims[2]!==s.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');ft=2,ot=a.dims[1]}else if(a.dims.length===5){if(a.dims[2]!==e.numHeads||a.dims[3]!==2||a.dims[4]!==pt)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(d)throw new Error('Expect "value" be none when "key" has packed kv format.');ft=5,ot=a.dims[1]}else{if(a.dims[1]!==e.numHeads||a.dims[3]!==pt)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');ft=0,ot=a.dims[2]}}else{if(s.dims.length!==3&&s.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(s.dims.length===5&&(s.dims[2]!==e.numHeads||s.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');ft=3}if(h){if(h.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(d&&s.dims.length===5&&s.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let ht=0;if(b){ht=8;let Nt=b.dims;throw Nt.length===1?Nt[0]===g?ht=1:Nt[0]===3*g+2&&(ht=3):Nt.length===2&&Nt[0]===g&&Nt[1]===ot&&(ht=5),ht===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)'):new Error("Mask not supported")}let bt=!1,mt=_;if(d){if(d.dims.length!==3&&d.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(s.dims[0]!==d.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(d.dims.length===3){if(ot!==d.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');mt=d.dims[2]}else{if(ot!==d.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');mt=d.dims[1]*d.dims[3],bt=!0}}let $t=ct+ot,Tt=!1;if(b)throw new Error("Key padding mask is not supported");if(et){if(et.dims.length!==4)throw new Error('Input "relative_position_bias" is expected to have 4 dimensions');if(et.dims[0]!==g&&et.dims[0]!==1||et.dims[1]!==e.numHeads||et.dims[2]!==c||et.dims[3]!==$t)throw new Error('Input "relative_position_bias" shape (batch_size, 1, sequence_length, kv_sequence_length)')}return{batchSize:g,sequenceLength:c,pastSequenceLength:ct,kvSequenceLength:ot,totalSequenceLength:$t,maxSequenceLength:dt,inputHiddenSize:0,hiddenSize:_,vHiddenSize:mt,headSize:pt,vHeadSize:Math.floor(mt/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:ht,scale:e.scale,broadcastResPosBias:Tt,passPastInKv:bt,qkvFormat:ft}},kl=o=>we({...o}),El=we({perm:[0,2,1,3]}),um=(o,e,s,a,d,h,b)=>{let et=[a,d,h],st=M.size(et),$=[{type:12,data:st},{type:12,data:b},{type:12,data:h}],it=g=>{let c=K("qkv_with_bias",e.dataType,et),_=U("qkv",e.dataType,et),ot=U("bias",s.dataType,et),ct=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${g.registerUniforms(ct).declareVariables(_,ot,c)}
  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return o.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:et,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(st/64)},programUniforms:$}),getShaderSource:it},{inputs:[e,s],outputs:[-1]})[0]},wa=(o,e,s,a,d,h,b,et)=>{let st=h;if(b){if(a===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return st=um(o,h,b,e,a,s*d,et),st=st.reshape([e,a,s,d]),o.compute(xt(st,El.perm),{inputs:[st],outputs:[-1]})[0]}else return h.dims.length===3&&(st=h.reshape([e,a,s,d])),o.compute(xt(st,El.perm),{inputs:[st],outputs:[-1]})[0]},Ol=(o,e)=>{let s=sm(o.inputs,e),a=o.inputs[0],d=lt(o.inputs,1),h=lt(o.inputs,2),b=lt(o.inputs,3),et=lt(o.inputs,4),st=lt(o.inputs,5),$=lt(o.inputs,6),it=lt(o.inputs,7);if(a.dims.length===5)throw new Error("Packed QKV is not implemented");if(d?.dims.length===5)throw new Error("Packed KV is not implemented");let g=d&&h&&d.dims.length===4&&h.dims.length===4,c=wa(o,s.batchSize,s.numHeads,s.sequenceLength,s.headSize,a,b,0);if(g)return Xn(o,c,d,h,et,void 0,$,it,st,s,e);if(!d||!h)throw new Error("key and value must be provided");let _=wa(o,s.batchSize,s.numHeads,s.kvSequenceLength,s.headSize,d,b,s.hiddenSize),ot=wa(o,s.batchSize,s.numHeads,s.kvSequenceLength,s.vHeadSize,h,b,2*s.hiddenSize);Xn(o,c,_,ot,et,void 0,$,it,st,s,e)}}),lm,dm,cm,pm,mm,fm,hm,gm,Rl,zl=j(()=>{ye(),xe(),_e(),lm=o=>{if(!o||o.length<1)throw new Error("Too few inputs");if(o[0].dataType!==1&&o[0].dataType!==10)throw new Error("Input type must be float or float16.");if(o.length>=2){let e=o[0].dims.length*2===o[1].dims[0];if(o.length===4&&(e=o[3].dims[0]*2===o[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},dm=(o,e,s)=>{let a="";for(let d=e-1;d>=0;--d)a+=`
            k = i32(${o.indicesGet("indices",d)}) - ${fe("uniforms.pads",d,s)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${fe("uniforms.x_shape",d,e)})) {
              break;
            }
            offset += k * i32(${fe("uniforms.x_strides",d,e)});
        `;return`
          value = ${o.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${a}
            value = x[offset];
          }
      `},cm=(o,e,s)=>{let a="";for(let d=e-1;d>=0;--d)a+=`
                k = i32(${o.indicesGet("indices",d)}) - ${fe("uniforms.pads",d,s)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${fe("uniforms.x_shape",d,e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${fe("uniforms.x_shape",d,e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${fe("uniforms.x_strides",d,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${a}
              value = x[offset];
          `},pm=(o,e,s)=>{let a="";for(let d=e-1;d>=0;--d)a+=`
                k = i32(${o.indicesGet("indices",d)}) - ${fe("uniforms.pads",d,s)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${fe("uniforms.x_shape",d,e)})) {
                  k = i32(${fe("uniforms.x_shape",d,e)}) - 1;
                }
                offset += k * i32(${fe("uniforms.x_strides",d,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${a}
              value = x[offset];
          `},mm=(o,e,s)=>{let a="";for(let d=e-1;d>=0;--d)a+=`
                k = i32(${o.indicesGet("indices",d)}) - ${fe("uniforms.pads",d,s)};
                if (k < 0)  {
                  k += i32(${fe("uniforms.x_shape",d,e)}]);
                }
                if (k >= i32(${fe("uniforms.x_shape",d,e)})) {
                  k -= i32(${fe("uniforms.x_shape",d,e)});
                }
                offset += k * i32(${fe("uniforms.x_strides",d,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${a}
              value = x[offset];
          `},fm=(o,e,s)=>{switch(s.mode){case 0:return dm(o,e,s.pads.length);case 1:return cm(o,e,s.pads.length);case 2:return pm(o,e,s.pads.length);case 3:return mm(o,e,s.pads.length);default:throw new Error("Invalid mode")}},hm=(o,e)=>{let s=M.padShape(o[0].dims.slice(),e.pads),a=o[0].dims,d=M.size(s),h=[{type:12,data:d},{type:6,data:e.pads}];e.mode===0&&h.push({type:o[0].dataType,data:e.value}),h.push(...X$1(o[0].dims,s));let b=["rank"],et=st=>{let $=K("output",o[0].dataType,s.length),it=U("x",o[0].dataType,a.length),g=it.type.value,c=fm($,a.length,e),_=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:e.pads.length}];return e.mode===0&&_.push({name:"constant_value",type:g}),`
            ${st.registerUniforms(_).declareVariables(it,$)}
            ${st.mainStart()}
            ${st.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${$.offsetToIndices("global_idx")};

            var value = ${g}(0);
            ${c}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${e.mode}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:s,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(s)/64)},programUniforms:h}),getShaderSource:et}},gm=(o,e)=>{if(o.length>1){let s=o[1].getBigInt64Array(),a=o.length>=3&&o[2].data?o[2].getFloat32Array()[0]:0,d=o[0].dims.length,h=new Int32Array(2*d).fill(0);if(o.length>=4){let et=o[3].getBigInt64Array();for(let st=0;st<et.length;st++)h[Number(et[st])]=Number(s[st]),h[Number(et[st])+d]=Number(s[st+et.length])}else s.forEach((et,st)=>h[Number(st)]=Number(et));let b=[];return h.forEach(et=>b.push(et)),{mode:e.mode,value:a,pads:b}}else return e},Rl=(o,e)=>{lm(o.inputs);let s=gm(o.inputs,e);o.compute(hm(o.inputs,s),{inputs:[0]})}}),si,Bl,Dl,Ml,Ul,ym,bm,Wl,Nl,Vl,Hl,Gl,Ll,Fl,ql,jl,Kl,Yl,Xl,Zl=j(()=>{_t(),ye(),xe(),_e(),si=o=>{if(ke.webgpu.validateInputContent&&(!o||o.length!==1))throw new Error("Pool ops requires 1 input.")},Bl=(o,e,s)=>{let a=e.format==="NHWC",d=o.dims.slice();a&&d.splice(1,0,d.pop());let h=Object.hasOwnProperty.call(e,"dilations"),b=e.kernelShape.slice(),et=e.strides.slice(),st=h?e.dilations.slice():[],$=e.pads.slice();pr.adjustPoolAttributes(s,d,b,et,st,$);let it=pr.computePoolOutputShape(s,d,et,st,b,$,e.autoPad),g=Object.assign({},e);h?Object.assign(g,{kernelShape:b,strides:et,pads:$,dilations:st,cacheKey:e.cacheKey}):Object.assign(g,{kernelShape:b,strides:et,pads:$,cacheKey:e.cacheKey});let c=it.slice();return c.push(c.splice(1,1)[0]),[g,a?c:it]},Dl=(o,e)=>{let s=e.format==="NHWC",a=M.size(o),d=M.size(e.kernelShape),h=[{type:12,data:a},{type:12,data:d}],b=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){let et=e.kernelShape[e.kernelShape.length-1],st=e.strides[e.strides.length-1],$=e.pads[e.pads.length/2-1],it=e.pads[e.pads.length-1],g=!!($+it);h.push({type:12,data:et},{type:12,data:st},{type:12,data:$},{type:12,data:it}),b.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let c=!1;if(e.kernelShape.length===2){let _=e.kernelShape[e.kernelShape.length-2],ot=e.strides[e.strides.length-2],ct=e.pads[e.pads.length/2-2],dt=e.pads[e.pads.length-2];c=!!(ct+dt),h.push({type:12,data:_},{type:12,data:ot},{type:12,data:ct},{type:12,data:dt}),b.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[h,b,!0,g,c]}else{if(s)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let et=M.computeStrides(e.kernelShape);h.push({type:12,data:et},{type:12,data:e.pads},{type:12,data:e.strides}),b.push({name:"kernelStrides",type:"u32",length:et.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});let st=e.pads.reduce(($,it)=>$+it);return[h,b,!!st,!1,!1]}},Ml=(o,e,s,a,d,h,b,et,st,$,it,g)=>{let c=d.format==="NHWC",_=e.type.value,ot=K("output",e.type.tensor,a);if(d.kernelShape.length<=2){let ct="",dt="",pt="",ft=s-(c?2:1);if(it?ct=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${ft}] = indices[${ft}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${ft}] < 0 || xIndices[${ft}]
                      >= uniforms.x_shape[${ft}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${h}
                }`:ct=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${ft}] = indices[${ft}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${h}
                }`,d.kernelShape.length===2){let ht=s-(c?3:2);g?dt=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${ht}] = indices[${ht}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${ht}] < 0 || xIndices[${ht}] >= uniforms.x_shape[${ht}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:dt=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${ht}] = indices[${ht}] * uniforms.sh - uniforms.phStart + j;
                `,pt=`
              }
            `}return`
            ${o.registerUniforms(st).declareVariables(e,ot)}

            ${o.mainStart()}
              ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${ot.offsetToIndices("global_idx")};
              var xIndices = ${ot.offsetToIndices("global_idx")};

              var value = ${_}(${et});
              var pad = 0;
              ${dt}
              ${ct}
              ${pt}
              ${b}

              output[global_idx] = value;
            }`}else{if(c)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let ct=d.kernelShape.length,dt=d.pads.length,pt="";return $?pt=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${h}
              }`:pt=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${h}
            `,`
            ${o.registerUniforms(st).declareVariables(e,ot)}

            ${o.mainStart()}
              ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${ot.offsetToIndices("global_idx")};
              var xIndices = ${ot.offsetToIndices("global_idx")};

              var offsets: array<u32, ${ct}>;

              var value = ${_}(${et});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${ct-1}u; j++) {
                  offsets[j] = offset / ${fe("uniforms.kernelStrides","j",ct)};
                  offset -= offsets[j] * ${fe("uniforms.kernelStrides","j",ct)};
                }
                offsets[${ct-1}] = offset;

                isPad = false;
                for (var j = ${s-ct}u; j < ${s}u; j++) {
                  xIndices[j] = indices[j] * ${fe("uniforms.strides",`j - ${s-ct}u`,ct)}
                    + offsets[j - ${s-ct}u] - ${fe("uniforms.pads","j - 2u",dt)};
                  ${pt}
              }
              ${b}

              output[global_idx] = value;
            }`}},Ul=o=>`${o.format};${o.ceilMode};${o.autoPad};${o.kernelShape.length}`,ym=o=>`${Ul(o)};${o.countIncludePad}`,bm=o=>`${Ul(o)};${o.storageOrder};${o.dilations}`,Wl=o=>({format:o.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][o.auto_pad],ceilMode:o.ceil_mode,kernelShape:o.kernel_shape,strides:o.strides,pads:o.pads}),Nl=(o,e,s,a)=>{let[d,h]=Bl(e,a,s),b=U("x",e.dataType,e.dims.length),et=b.type.value,st="value += x_val;",$="";d.countIncludePad?$+=`value /= ${et}(uniforms.kernelSize);`:$+=`value /= ${et}(i32(uniforms.kernelSize) - pad);`;let[it,g,c,_,ot]=Dl(h,d);it.push(...X$1(e.dims,h));let ct=["rank"];return{name:o,shaderCache:{hint:`${a.cacheKey};${c};${_};${ot}`,inputDependencies:ct},getRunData:()=>({outputs:[{dims:h,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(M.size(h)/64)},programUniforms:it}),getShaderSource:dt=>Ml(dt,b,e.dims.length,h.length,d,st,$,0,g,c,_,ot)}},Vl=o=>{let e=o.count_include_pad!==0,s=Wl(o);if(s.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let a={countIncludePad:e,...s,cacheKey:""};return{...a,cacheKey:ym(a)}},Hl=(o,e)=>{si(o.inputs),o.compute(Nl("AveragePool",o.inputs[0],!1,e))},Gl={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Ll=o=>{let e=o.format;return{format:e,...Gl,cacheKey:e}},Fl=(o,e)=>{si(o.inputs),o.compute(Nl("GlobalAveragePool",o.inputs[0],!0,e))},ql=(o,e,s,a)=>{let[d,h]=Bl(e,a,s),b=`
      value = max(x_val, value);
    `,et="",st=U("x",e.dataType,e.dims.length),$=["rank"],[it,g,c,_,ot]=Dl(h,d);return it.push(...X$1(e.dims,h)),{name:o,shaderCache:{hint:`${a.cacheKey};${c};${_};${ot}`,inputDependencies:$},getRunData:()=>({outputs:[{dims:h,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(M.size(h)/64)},programUniforms:it}),getShaderSource:ct=>Ml(ct,st,e.dims.length,h.length,d,b,et,e.dataType===10?-65504:-1e5,g,c,_,ot)}},jl=(o,e)=>{si(o.inputs),o.compute(ql("MaxPool",o.inputs[0],!1,e))},Kl=o=>{let e=o.storage_order,s=o.dilations,a=Wl(o);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(a.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let d={storageOrder:e,dilations:s,...a,cacheKey:""};return{...d,cacheKey:bm(d)}},Yl=o=>{let e=o.format;return{format:e,...Gl,cacheKey:e}},Xl=(o,e)=>{si(o.inputs),o.compute(ql("GlobalMaxPool",o.inputs[0],!0,e))}}),wm,$m,Ql,Jl=j(()=>{_t(),ye(),_e(),wm=(o,e,s)=>{let a=o===e,d=o<e&&s<0,h=o>e&&s>0;if(a||d||h)throw new Error("Range these inputs' contents are invalid.")},$m=(o,e,s,a)=>{let d=Math.abs(Math.ceil((e-o)/s)),h=[d],b=d,et=[{type:12,data:b},{type:a,data:o},{type:a,data:s},...X$1(h)],st=$=>{let it=K("output",a,h.length),g=it.type.value,c=[{name:"outputSize",type:"u32"},{name:"start",type:g},{name:"delta",type:g}];return`
        ${$.registerUniforms(c).declareVariables(it)}
        ${$.mainStart()}
        ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${g}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${a}`},getShaderSource:st,getRunData:()=>({outputs:[{dims:h,dataType:a}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:et})}},Ql=o=>{let e=0,s=0,a=0;o.inputs[0].dataType===6?(e=o.inputs[0].getInt32Array()[0],s=o.inputs[1].getInt32Array()[0],a=o.inputs[2].getInt32Array()[0]):o.inputs[0].dataType===1&&(e=o.inputs[0].getFloat32Array()[0],s=o.inputs[1].getFloat32Array()[0],a=o.inputs[2].getFloat32Array()[0]),ke.webgpu.validateInputContent&&wm(e,s,a),o.compute($m(e,s,a,o.inputs[0].dataType),{inputs:[]})}}),_m,xm,Sm,Cm,Im,Tm,Am,Em,km,Om,Pm,ed,Rm,zm,Bm,Dm,Mm,td,rd,nd=j(()=>{ye(),xe(),Ze(),_e(),_m=(o,e)=>{if(o.every(s=>s>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),o.length>0){if(e.mode==="linear"){if(!(o.length===2||o.length===3||o.length===4&&o[0]===1&&o[1]===1||o.length===4&&o[0]===1&&o[3]===1||o.length===5&&o[0]===1&&o[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(e.mode==="cubic"&&!(o.length===2||o.length===4&&o[0]===1&&o[1]===1||o.length===4&&o[0]===1&&o[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},xm=(o,e,s)=>{e.every(d=>d>=0&&d<s||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let a=new Array(s).fill(1);return e.forEach((d,h)=>a[d]=o[h]),a},Sm=(o,e,s,a,d,h)=>{let[b,et,st]=s>10?[1,2,3]:[-1,o.length>1?1:-1,-1],$=o[0].dims.length;if(b>0&&o.length>b&&o[b].dims.length>0)o[b].getFloat32Array().forEach(it=>h.push(it));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(et>0&&o.length>et&&o[et].dims.length>0){if(o[et].getFloat32Array().forEach(it=>a.push(it)),a.length!==0&&a.length!==$&&s>=18&&a.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");_m(a,e),e.axes.length>0&&xm(a,e.axes,$).forEach((it,g)=>a[g]=it)}if(st>0&&o.length>st&&(o[st].getBigInt64Array().forEach(it=>d.push(Number(it))),d.length!==$||s>=18&&d.length===e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(a.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(d.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof a<"u"&&typeof d<"u"&&a.length>0&&d.length>$)throw new Error("Resize requires only of scales or sizes to be specified")},Cm=(o,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { `+(()=>{switch(o){case"asymmetric":return`return ${e}(xResized) / ${e}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${e}(xResized) + 0.5) / ${e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${e}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${e}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${e}(lengthResized - 1);
                    return whole + fract;
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${o} is not supported`)}})()+"}",Im=(o,e,s)=>`fn getNearestPixelFromOriginal(xOriginal: ${s}, isDownSample: bool) -> ${s} {`+(()=>{switch(o){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${o} is not supported`)}})()+"}",Tm=(o,e,s)=>{let a=new Array(s).fill(0).concat(new Array(s).fill(1)),d=o.length===0?a:o.slice();return e.length>0?(e.forEach((h,b)=>{a[h]=d[b],a[b+s]=d[e.length+b]}),a):d},Am=(o,e,s,a)=>{let d=[];if(s.length>0)if(a.length>0){if(o.forEach(h=>d.push(h)),Math.max(...a)>o.length)throw new Error("axes is out of bound");a.forEach((h,b)=>d[h]=s[b])}else s.forEach(h=>d.push(h));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");d=o.map((h,b)=>Math.round(h*e[b]))}return d},Em=(o,e,s)=>{let a=(()=>{switch(s.keepAspectRatioPolicy){case"not_larger":return s.axes.length>0?Math.min(...s.axes.map(h=>e[h]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return s.axes.length>0?Math.max(...s.axes.map(h=>e[h]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${s.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let d=o.slice();return s.axes.length>0?(s.axes.forEach(h=>e[h]=a),s.axes.forEach(h=>d[h]=Math.round(o[h]*e[h]))):(e.fill(a,0,e.length),d.forEach((h,b)=>d[b]=Math.round(h*e[b]))),d},km=(o,e,s,a,d)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${o.type.indices}) -> array<${o.type.value}, ${s.length}> {
      var original_indices: array<${o.type.value}, ${s.length}>;
      for (var i:u32 = 0; i < ${s.length}; i++) {
        var output_index = ${o.indicesGet("output_indices","i")};
        var scale = ${fe("uniforms.scales","i",a)};
        var roi_low = ${fe("uniforms.roi","i",d)};
        var roi_hi = ${fe("uniforms.roi",`i + ${e.length}`,d)};
        if (scale == 1.0) {
          original_indices[i] = ${o.type.value}(output_index);
        } else {
          var input_shape_i = ${fe("uniforms.input_shape","i",e.length)};
          var output_shape_i = ${fe("uniforms.output_shape","i",s.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,Om=(o,e,s,a,d,h,b)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${o.type.indices} {
      var input_indices: ${o.type.indices};
      for (var i:u32 = 0; i < ${a.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${fe("uniforms.scales","i",d)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${fe("uniforms.roi","i",h)};
          var roi_hi = ${fe("uniforms.roi",`i + ${s.length}`,h)};
          var input_shape_i = ${fe("uniforms.input_shape","i",s.length)};
          var output_shape_i = ${fe("uniforms.output_shape","i",a.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${b} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${o.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,Pm=(o,e)=>`
    fn checkInputIndices(input_indices: ${o.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${o.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${fe("uniforms.input_shape","i",e.length)}) {
          return false;
        }
      }
      return true;
    }`,ed=(o,e,s,a)=>o.rank>a?`
    ${o.indicesSet("input_indices",e,"channel")};
    ${o.indicesSet("input_indices",s,"batch")};
`:"",Rm=(o,e,s,a,d)=>{let[h,b,et,st]=s.length===2?[-1,0,1,-1]:[0,2,3,1],$=o.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${$} {
      var input_indices: ${o.type.indices};
      ${o.indicesSet("input_indices",b,`max(0, min(row, ${s[b]} - 1))`)};
      ${o.indicesSet("input_indices",et,`max(0, min(col, ${s[et]} - 1))`)};
      ${ed(o,st,h,2)}
      return ${o.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${$} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${$} = originalIndices[${b}];
      var col:${$} = originalIndices[${et}];
      ${a?`if (row < 0 || row > (${s[b]} - 1) || col < 0 || col > (${s[et]} - 1)) {
        return ${d};
      }`:""};
      row = max(0, min(row, ${s[b]} - 1));
      col = max(0, min(col, ${s[et]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${s.length>2?`u32(originalIndices[${st}])`:"0"};
      var batch: u32 =  ${s.length>2?`u32(originalIndices[${h}])`:"0"};
      var x11: ${$} = getInputValue(batch, channel, row1, col1);
      var x12: ${$} = getInputValue(batch, channel, row1, col2);
      var x21: ${$} = getInputValue(batch, channel, row2, col1);
      var x22: ${$} = getInputValue(batch, channel, row2, col2);
      var dx1: ${$} = abs(row - ${$}(row1));
      var dx2: ${$} = abs(${$}(row2) - row);
      var dy1: ${$} = abs(col - ${$}(col1));
      var dy2: ${$} = abs(${$}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},zm=(o,e,s,a,d,h,b,et,st,$)=>{let it=s.length===2,[g,c]=it?[0,1]:[2,3],_=o.type.value,ot=ct=>{let dt=ct===g?"row":"col";return`
      fn ${dt}CubicInterpolation(input_indices: ${o.type.indices}, output_indices: ${e.type.indices}) -> ${_} {
        var output_index = ${e.indicesGet("output_indices",ct)};
        var originalIdx: ${_} = getOriginalCoordinateFromResizedCoordinate(output_index, ${d[ct]},
        ${a[ct]}, ${s[ct]}, ${h[ct]}, ${h[ct]} + ${s.length});
        var fractOriginalIdx: ${_} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${et} && (originalIdx < 0 || originalIdx > (${s[ct]} - 1))) {
          return ${st};
        }
        var data: array<${_}, 4> = array<${_}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${dt}: ${_} = originalIdx + ${_}(i);
          if (${dt} < 0 || ${dt} >= ${s[ct]}) {
            ${$?`coefs[i + 1] = 0.0;
                        continue;`:et?`return ${st};`:`${dt} = max(0, min(${dt}, ${s[ct]} - 1));`};
          }
        var input_indices_copy: ${o.type.indices} = input_indices;
          ${o.indicesSet("input_indices_copy",ct,`u32(${dt})`)};
          data[i + 1] = ${ct===g?o.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${ot(g)};
    ${ot(c)};
  fn getCubicInterpolationCoefs(s: ${_}) -> array<${_}, 4> {
    var absS = abs(s);
    var coeffs: array<${_}, 4> = array<${_}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${_} = 1.0 - absS;
    var twoMinusAbsS: ${_} = 2.0 - absS;
    var onePlusAbsS: ${_} = 1.0 + absS;
    coeffs[0] = ((${b} * onePlusAbsS - 5 * ${b}) * onePlusAbsS + 8 * ${b}) * onePlusAbsS - 4 * ${b};
    coeffs[1] = ((${b} + 2) * absS - (${b} + 3)) * absS * absS + 1;
    coeffs[2] = ((${b} + 2) * oneMinusAbsS - (${b} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${b} * twoMinusAbsS - 5 * ${b}) * twoMinusAbsS + 8 * ${b}) * twoMinusAbsS - 4 * ${b};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${_}, 4>, coefs: array<${_}, 4>) -> ${_} {
    var coefsSum: ${_} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${_} {
    var input_indices: ${o.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},Bm=(o,e,s,a,d)=>{let[h,b,et,st,$]=s.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],it=o.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${it} {
      var input_indices: ${o.type.indices};
      ${o.indicesSet("input_indices",b,`max(0, min(depth, ${s[b]} - 1))`)};
      ${o.indicesSet("input_indices",et,`max(0, min(height, ${s[et]} - 1))`)};
      ${o.indicesSet("input_indices",st,`max(0, min(width, ${s[st]} - 1))`)};
      ${ed(o,$,h,3)}
      return ${o.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${it} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${it} = originalIndices[${b}];
      var height:${it} = originalIndices[${et}];
      var width:${it} = originalIndices[${st}];
      ${a?`if (depth < 0 || depth > (${s[b]} - 1) || height < 0 || height > (${s[et]} - 1) || width < 0 || (width > ${s[st]} - 1)) {
      return ${d};
        }`:""};

    depth = max(0, min(depth, ${s[b]} - 1));
      height = max(0, min(height, ${s[et]} - 1));
      width = max(0, min(width, ${s[st]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${s.length>3?`u32(originalIndices[${$}])`:"0"};
      var batch: u32 =  ${s.length>3?`u32(originalIndices[${h}])`:"0"};

      var x111: ${it} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${it} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${it} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${it} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${it} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${it} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${it} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${it} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${it} = abs(depth - ${it}(depth1));
      var dx2: ${it} = abs(${it}(depth2) - depth);
      var dy1: ${it} = abs(height - ${it}(height1));
      var dy2: ${it} = abs(${it}(height2) - height);
      var dz1: ${it} = abs(width - ${it}(width1));
      var dz2: ${it} = abs(${it}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},Dm=(o,e,s,a,d,h)=>{let b=o.dims,et=Tm(h,e.axes,b.length),st=Am(b,a,d,e.axes),$=a.slice();a.length===0&&($=b.map((ft,ht)=>ft===0?1:st[ht]/ft),e.keepAspectRatioPolicy!=="stretch"&&(st=Em(b,$,e)));let it=K("output",o.dataType,st.length),g=U("input",o.dataType,b.length),c=M.size(st),_=b.length===st.length&&b.every((ft,ht)=>ft===st[ht]),ot=e.coordinateTransformMode==="tf_crop_and_resize",ct=e.extrapolationValue,dt=g.type.value,pt=ft=>`
      ${_?"":`
      ${Cm(e.coordinateTransformMode,dt)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${Pm(g,b)};
              ${Im(e.nearestMode,s,dt)};
              ${Om(g,it,b,st,$.length,et.length,ot)};
              `;case"linear":return`
              ${km(it,b,st,$.length,et.length)};
              ${(()=>{if(b.length===2||b.length===4)return`${Rm(g,it,b,ot,ct)}`;if(b.length===3||b.length===5)return`${Bm(g,it,b,ot,ct)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(b.length===2||b.length===4)return`${zm(g,it,b,st,$,et,e.cubicCoeffA,ot,e.extrapolationValue,e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${ft.registerUniform("output_size","u32").registerUniform("scales","f32",$.length).registerUniform("roi","f32",et.length).declareVariables(g,it)}
      ${ft.mainStart()}
        ${ft.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${_?"output[global_idx] = input[global_idx];":`
        let output_indices = ${it.offsetToIndices("global_idx")};
        var input_indices: ${g.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${g.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${b.length===2||b.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${s}|${$.length>0?$:""}|${d.length>0?d:""}|${et.length>0?et:""}|${_}|${b}`,inputDependencies:["rank"]},getShaderSource:pt,getRunData:()=>({outputs:[{dims:st,dataType:o.dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:[{type:12,data:c},{type:1,data:$},{type:1,data:et},...X$1(b,st)]})}},Mm=o=>{let e=o.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},td=(o,e)=>{let s=[],a=[],d=[],h=Mm(o);if(e.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");Sm(o.inputs,e,h,s,a,d),o.compute(Dm(o.inputs[0],e,h,s,a,d),{inputs:[0]})},rd=o=>{let e=o.antialias,s=o.axes,a=o.coordinateTransformMode,d=o.cubicCoeffA,h=o.excludeOutside!==0,b=o.extrapolationValue,et=o.keepAspectRatioPolicy,st=o.mode,$=o.nearestMode===""?"simple":o.nearestMode;return we({antialias:e,axes:s,coordinateTransformMode:a,cubicCoeffA:d,excludeOutside:h,extrapolationValue:b,keepAspectRatioPolicy:et,mode:st,nearestMode:$})}}),Um,Wm,id,ad=j(()=>{ye(),xe(),Ze(),_e(),Um=(o,e)=>{let[s,a,d,h]=o,{numHeads:b,rotaryEmbeddingDim:et}=e;if(s.dims.length!==3&&s.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${s.dims.length}`);if(!M.areEqual(a.dims,[])&&!M.areEqual(a.dims,[1])&&a.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${a.dims.length}`);if(d.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${d.dims.length}`);if(h.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${h.dims.length}`);if(!M.areEqual(d.dims,h.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(et>0&&b===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let st=s.dims[0],$=s.dims[s.dims.length-2],it=d.dims[0],g=M.sizeFromDimension(s.dims,1)/$,c=et===0?d.dims[1]*2:g/b;if(et>c)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(a.dims.length===2){if(st!==a.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${a.dims[0]}`);if($!==a.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${a.dims[1]}`)}if(c/2!==d.dims[1]&&et/2!==d.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${d.dims[1]}`);if($>it)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},Wm=(o,e)=>{let{interleaved:s,numHeads:a,rotaryEmbeddingDim:d,scale:h}=e,b=o[0].dims[0],et=M.sizeFromDimension(o[0].dims,1),st=o[0].dims[o[0].dims.length-2],$=et/st,it=o[2].dims[1],g=d===0?it*2:$/a,c=new Array(b,st,$/g,g-it),_=M.computeStrides(c),ot=[{type:1,data:h},{type:12,data:c},{type:12,data:_},...o[0].dims.length===3?new Array({type:12,data:[et,$,g,1]}):[],...o[0].dims.length===4?new Array({type:12,data:[et,g,st*g,1]}):[],...X$1(o[0].dims,o[1].dims,o[2].dims,o[3].dims,o[0].dims)],ct=dt=>{let pt=U("input",o[0].dataType,o[0].dims.length),ft=U("position_ids",o[1].dataType,o[1].dims.length),ht=U("cos_cache",o[2].dataType,o[2].dims.length),bt=U("sin_cache",o[3].dataType,o[3].dims.length),mt=K("output",o[0].dataType,o[0].dims.length);return dt.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:c.length},{name:"global_strides",type:"u32",length:_.length},{name:"input_output_strides",type:"u32",length:_.length}]),`
        ${dt.declareVariables(pt,ft,ht,bt,mt)}

        ${dt.mainStart(mr)}
          let half_rotary_emb_dim = uniforms.${ht.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${dt.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${ft.broadcastedIndicesToOffset("bsnh.xy",K("",ft.type.tensor,2))};
            let position_id =
                u32(${ft.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${s});
            let j = i + select(half_rotary_emb_dim, 1, ${s});
            let re = ${pt.getByOffset("i")} * ${ht.get("position_id","bsnh[3]")} -
                ${pt.getByOffset("j")} * ${bt.get("position_id","bsnh[3]")};
            ${mt.setByOffset("i","re")}
            let im = ${pt.getByOffset("i")} * ${bt.get("position_id","bsnh[3]")} +
                ${pt.getByOffset("j")} * ${ht.get("position_id","bsnh[3]")};
            ${mt.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${mt.setByOffset("k",pt.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:we({interleaved:s}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:ct,getRunData:()=>({outputs:[{dims:o[0].dims,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(c)/mr)},programUniforms:ot})}},id=(o,e)=>{Um(o.inputs,e),o.compute(Wm(o.inputs,e))}}),Nm,Vm,od,sd=j(()=>{ye(),xe(),_e(),Nm=o=>{if(!o||o.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=o[0],s=o[1],a=o[2];if(e.dataType!==s.dataType||e.dataType!==a.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(s.dims.length!==3&&s.dims.length!==2)throw new Error("Skip must be 2D or 3D");let d=e.dims[e.dims.length-1],h=e.dims[e.dims.length-2];if(s.dims[s.dims.length-1]!==d)throw new Error("Skip must have the same hidden size as input");if(s.dims[s.dims.length-2]!==h)throw new Error("Skip must have the same sequence length as input");if(a.dims.length!==1)throw new Error("Gamma must be 1D");if(a.dims[a.dims.length-1]!==d)throw new Error("Gamma must have the same hidden size as input");if(o.length>3){let b=o[3];if(b.dims.length!==1)throw new Error("Beta must be 1D");if(b.dims[b.dims.length-1]!==d)throw new Error("Beta must have the same hidden size as input")}if(o.length>4){let b=o[4];if(b.dims.length!==1)throw new Error("Bias must be 1D");if(b.dims[b.dims.length-1]!==d)throw new Error("Bias must have the same hidden size as input")}},Vm=(o,e,s,a)=>{let d=e.simplified,h=o[0].dims,b=M.size(h),et=h,st=b,$=h.slice(-1)[0],it=a?h.slice(0,-1).concat(1):[],g=!d&&o.length>3,c=o.length>4,_=a&&s>1,ot=a&&s>2,ct=s>3,dt=64,pt=Ue($),ft=[{type:12,data:st},{type:12,data:pt},{type:12,data:$},{type:1,data:e.epsilon}],ht=mt=>{let $t=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],Tt=[U("x",o[0].dataType,o[0].dims,pt),U("skip",o[1].dataType,o[1].dims,pt),U("gamma",o[2].dataType,o[2].dims,pt)];g&&Tt.push(U("beta",o[3].dataType,o[3].dims,pt)),c&&Tt.push(U("bias",o[4].dataType,o[4].dims,pt)),Tt.push(K("output",o[0].dataType,et,pt)),_&&Tt.push(K("mean_output",1,it)),ot&&Tt.push(K("inv_std_output",1,it)),ct&&Tt.push(K("input_skip_bias_sum",o[0].dataType,et,pt));let Nt=Be(o[0].dataType),Ct=Be(1,pt);return`

      ${mt.registerUniforms($t).declareVariables(...Tt)}
      var<workgroup> sum_shared : array<${Ct}, ${dt}>;
      var<workgroup> sum_squared_shared : array<${Ct}, ${dt}>;

      ${mt.mainStart([dt,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${dt};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${dt};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${dt-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${c?"bias[offset1d + i]":Nt+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${ct?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${fr(Nt,pt,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${dt};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${At("sum",pt)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${At("square_sum",pt)} / f32(uniforms.hidden_size) ${d?"":"- mean * mean"} + uniforms.epsilon);
        ${_?"mean_output[global_idx] = mean;":""}
        ${ot?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${d?"":`- ${Nt}(mean)`}) *
            ${Nt}(inv_std_dev) * gamma[offset1d + i]
            ${g?"+ beta[offset1d + i]":""};
        }
      }`},bt=[{dims:et,dataType:o[0].dataType}];return s>1&&bt.push({dims:it,dataType:1}),s>2&&bt.push({dims:it,dataType:1}),s>3&&bt.push({dims:h,dataType:o[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${pt};${_};${ot};${ct}`,inputDependencies:o.map((mt,$t)=>"type")},getShaderSource:ht,getRunData:()=>({outputs:bt,dispatchGroup:{x:Math.ceil(st/$)},programUniforms:ft})}},od=(o,e)=>{Nm(o.inputs);let s=[0];o.outputCount>1&&s.push(-3),o.outputCount>2&&s.push(-3),o.outputCount>3&&s.push(3),o.compute(Vm(o.inputs,e,o.outputCount,!1),{outputs:s})}}),Hm,ui,Gm,ud,Lm,Fm,ld,dd,cd=j(()=>{ye(),xe(),Ze(),_e(),Hm=(o,e)=>{if(!o||o.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");o.slice(1).forEach((s,a)=>{if(o[a+1].dataType!==6&&o[a+1].dataType!==7)throw new Error(`Input ${a} must be an array of int32 or int64`)})},ui=(o,e)=>{let s=[];if(o.length>e)if(o[e].dataType===7)o[e].getBigInt64Array().forEach(a=>s.push(Number(a)));else if(o[e].dataType===6)o[e].getInt32Array().forEach(a=>s.push(Number(a)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return s},Gm=(o,e)=>{if(o.length>1){let s=ui(o,1),a=ui(o,2),d=ui(o,3);return d.length===0&&(d=[...Array(o[0].dims.length).keys()]),we({starts:s,ends:a,axes:d})}else return e},ud=(o,e,s,a,d)=>{let h=o;return o<0&&(h+=s[a[e]]),d[e]<0?Math.max(0,Math.min(h,s[a[e]]-1)):Math.max(0,Math.min(h,s[a[e]]))},Lm=(o,e,s)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${o.type.indices} {
          var input_indices: ${o.type.indices};
          var carry = 0u;
          for (var i = ${s.length}; i >= 0; i--) {
            let input_shape_i = ${fe("uniforms.input_shape","i",s.length)};
            let steps_i = ${fe("uniforms.steps","i",s.length)};
            let signs_i = ${fe("uniforms.signs","i",s.length)};
            let starts_i = ${fe("uniforms.starts","i",s.length)};
            var output_index = ${e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${o.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,Fm=(o,e)=>{let s=o[0].dims,a=M.size(s),d=e.axes.length>0?M.normalizeAxes(e.axes,s.length):[...Array(s.length).keys()],h=ui(o,4);h.forEach(pt=>pt!==0||(()=>{throw new Error("step cannot be 0")})),h.length===0&&(h=Array(d.length).fill(1));let b=e.starts.map((pt,ft)=>ud(pt,ft,s,d,h)),et=e.ends.map((pt,ft)=>ud(pt,ft,s,d,h));if(d.length!==b.length||d.length!==et.length)throw new Error("start, ends and axes should have the same number of elements");if(d.length!==s.length)for(let pt=0;pt<s.length;++pt)d.includes(pt)||(b.splice(pt,0,0),et.splice(pt,0,s[pt]),h.splice(pt,0,1));let st=h.map(pt=>Math.sign(pt));h.forEach((pt,ft,ht)=>{if(pt<0){let bt=(et[ft]-b[ft])/pt,mt=b[ft],$t=mt+bt*h[ft];b[ft]=$t,et[ft]=mt,ht[ft]=-pt}});let $=s.slice(0);d.forEach((pt,ft)=>{$[pt]=Math.ceil((et[pt]-b[pt])/h[pt])});let it={dims:$,dataType:o[0].dataType},g=K("output",o[0].dataType,$.length),c=U("input",o[0].dataType,o[0].dims.length),_=M.size($),ot=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:b.length},{name:"signs",type:"i32",length:st.length},{name:"steps",type:"u32",length:h.length}],ct=[{type:12,data:_},{type:12,data:b},{type:6,data:st},{type:12,data:h},...X$1(o[0].dims,$)],dt=pt=>`
      ${pt.registerUniforms(ot).declareVariables(c,g)}
        ${Lm(c,g,s)}
        ${pt.mainStart()}
          ${pt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${g.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${g.setByOffset("global_idx",c.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${st.length}_${b.length}_${h.length}`,inputDependencies:["rank"]},getShaderSource:dt,getRunData:()=>({outputs:[it],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:ct})}},ld=(o,e)=>{Hm(o.inputs,e);let s=Gm(o.inputs,e);o.compute(Fm(o.inputs,s),{inputs:[0]})},dd=o=>{let e=o.starts,s=o.ends,a=o.axes;return we({starts:e,ends:s,axes:a})}}),qm,jm,pd,md,fd=j(()=>{ye(),xe(),Ze(),_e(),qm=o=>{if(!o||o.length!==1)throw new Error("Softmax op requires 1 input.")},jm=(o,e)=>{let s=o.dims,a=M.size(s),d=64,h=e.axis;if(h<0&&(h=s.length+h),h<s.length-1)throw new Error("softmax only supports last axis for now.");let b=s[h],et=a/b,st=Ue(b),$=b/st,it=(dt,pt)=>pt===4?`max(max(${dt}.x, ${dt}.y), max(${dt}.z, ${dt}.w))`:pt===2?`max(${dt}.x, ${dt}.y)`:pt===3?`max(max(${dt}.x, ${dt}.y), ${dt}.z)`:dt,g=U("x",o.dataType,o.dims,st),c=K("result",o.dataType,o.dims,st),_=g.type.value,ot=Be(o.dataType)==="f32"?`var threadMax = ${_}(-3.402823e+38f);`:`var threadMax = ${_}(-65504.0h);`,ct=dt=>`
      var<workgroup> rowMaxShared : ${_};
      var<workgroup> rowSumShared : ${_};
      var<workgroup> threadShared : array<${_}, ${d}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${_} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${_}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${dt.registerUniform("packedCols","i32").declareVariables(g,c)}
      ${dt.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${d};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${ot}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${_}(${it("threadShared[0]",st)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${_}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${_}(${At("threadShared[0]",st)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${st}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:s,dataType:o.dataType}],dispatchGroup:{x:et},programUniforms:[{type:6,data:$}]}),getShaderSource:ct}},pd=(o,e)=>{qm(o.inputs),o.compute(jm(o.inputs[0],e))},md=o=>we({axis:o.axis})}),Km,Ym,Xm,Zm,Qm,hd,gd,yd=j(()=>{ye(),xe(),Ze(),_e(),Km=o=>{if(!o||o.length<1)throw new Error("too few inputs")},Ym=(o,e)=>{let s=[],a=e.numOutputs;return o[1].dims[0]>0&&(o[1].getBigInt64Array().forEach(d=>s.push(Number(d))),a=s.length),we({numOutputs:a,axis:e.axis,splitSizes:s})},Xm=o=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${o}u; i += 1u ) {
    if (index < ${fe("uniforms.size_in_split_axis","i",o)}) {
        return i;
    }
    }
    return ${o}u;
}`,Zm=o=>{let e=o.length,s=[];for(let a=0;a<e;++a){let d=o[a].setByIndices("indices","input[global_idx]");e===1?s.push(d):a===0?s.push(`if (output_number == ${a}u) { ${d} }`):a===e-1?s.push(`else { ${d} }`):s.push(`else if (output_number == ${a}) { ${d} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${o[0].type.indices}, global_idx: u32) {
        ${s.join(`
`)}
      }`},Qm=(o,e)=>{let s=o[0].dims,a=M.size(s),d=o[0].dataType,h=M.normalizeAxis(e.axis,s.length),b=new Array(e.numOutputs),et=U("input",d,s.length),st=new Array(e.numOutputs),$=[],it=[],g=0,c=[{type:12,data:a}];for(let ot=0;ot<e.numOutputs;ot++){g+=e.splitSizes[ot],st[ot]=g;let ct=s.slice();ct[e.axis]=e.splitSizes[ot],it.push(ct),b[ot]=K(`output${ot}`,d,ct.length),$.push({dims:it[ot],dataType:o[0].dataType})}c.push({type:12,data:st},...X$1(s,...it));let _=ot=>`
  ${ot.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",st.length).declareVariables(et,...b)}
  ${Xm(st.length)}
  ${Zm(b)}

  ${ot.mainStart()}
    ${ot.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${et.offsetToIndices("global_idx")};
    var index = ${et.indicesGet("indices",h)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${fe("uniforms.size_in_split_axis","output_number - 1u",st.length)};
      ${et.indicesSet("indices",h,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:_,getRunData:()=>({outputs:$,dispatchGroup:{x:Math.ceil(a/64)},programUniforms:c})}},hd=(o,e)=>{Km(o.inputs);let s=o.inputs.length===1?e:Ym(o.inputs,e);o.compute(Qm(o.inputs,s),{inputs:[0]})},gd=o=>{let e=o.axis,s=o.splitSizes,a=o.numOutputs<0?s.length:o.numOutputs;if(a!==s.length)throw new Error("numOutputs and splitSizes lengh must be equal");return we({axis:e,numOutputs:a,splitSizes:s})}}),bd,Jm,ef,tf,vd,wd=j(()=>{ye(),xe(),_e(),bd=o=>Array.from(o.getBigInt64Array(),Number),Jm=o=>{if(!o||o.length!==2)throw new Error("Tile requires 2 inputs.");if(o[0].dataType!==1&&o[0].dataType!==6&&o[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(o[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(o[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(bd(o[1]).length!==o[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ef=(o,e)=>{let s=[];for(let a=0;a<o.length;++a)s.push(o[a]*e[a]);return s},tf=o=>{let e=o[0].dims,s=bd(o[1]),a=ef(e,s),d=M.size(a),h=o[0].dataType,b=U("input",h,e.length),et=K("output",h,a.length),st=$=>`
      const inputShape = ${b.indices(...e)};
      ${$.registerUniform("output_size","u32").declareVariables(b,et)}
      ${$.mainStart()}
      ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${et.offsetToIndices("global_idx")};
      var input_indices: ${b.type.indices};
      for (var i = 0; i < ${e.length}; i++) {
        let input_dim_i = ${b.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${et.indicesGet("output_indices","i")}  % input_dim_i;

        ${b.indicesSet("input_indices","i","input_dim_value")}
      }
      ${et.setByOffset("global_idx",b.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${s}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:o[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},...X$1(o[0].dims,a)]}),getShaderSource:st}},vd=o=>{Jm(o.inputs),o.compute(tf(o.inputs),{inputs:[0]})}}),rf,nf,$d,_d=j(()=>{ye(),xe(),_e(),rf=(o,e,s,a,d)=>{let h=K("output_data",d,s.length,4),b=U("a_data",e[1].dataType,e[1].dims.length,4),et=U("b_data",e[2].dataType,e[2].dims.length,4),st=U("c_data",e[0].dataType,e[0].dims.length,4),$,it=(g,c,_)=>`select(${c}, ${g}, ${_})`;if(!a)$=h.setByOffset("global_idx",it(b.getByOffset("global_idx"),et.getByOffset("global_idx"),st.getByOffset("global_idx")));else{let g=(c,_,ot="")=>{let ct=`a_data[index_a${_}][component_a${_}]`,dt=`b_data[index_b${_}][component_b${_}]`,pt=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`
            let output_indices${_} = ${h.offsetToIndices(`global_idx * 4u + ${_}u`)};
            let offset_a${_} = ${b.broadcastedIndicesToOffset(`output_indices${_}`,h)};
            let offset_b${_} = ${et.broadcastedIndicesToOffset(`output_indices${_}`,h)};
            let offset_c${_} = ${st.broadcastedIndicesToOffset(`output_indices${_}`,h)};
            let index_a${_} = offset_a${_} / 4u;
            let index_b${_} = offset_b${_} / 4u;
            let index_c${_} = offset_c${_} / 4u;
            let component_a${_} = offset_a${_} % 4u;
            let component_b${_} = offset_b${_} % 4u;
            let component_c${_} = offset_c${_} % 4u;
            ${c}[${_}] = ${ot}(${it(ct,dt,pt)});
          `};d===9?$=`
            var data = vec4<u32>(0);
            ${g("data",0,"u32")}
            ${g("data",1,"u32")}
            ${g("data",2,"u32")}
            ${g("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:$=`
            ${g("output_data[global_idx]",0)}
            ${g("output_data[global_idx]",1)}
            ${g("output_data[global_idx]",2)}
            ${g("output_data[global_idx]",3)}
          `}return`
        ${o.registerUniform("vec_size","u32").declareVariables(st,b,et,h)}
        ${o.mainStart()}
        ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${$}
      }`},nf=o=>{let e=o[1].dims,s=o[2].dims,a=o[0].dims,d=o[1].dataType,h=!(M.areEqual(e,s)&&M.areEqual(s,a)),b=e,et=M.size(e);if(h){let $=Rt.calcShape(Rt.calcShape(e,s,!1),a,!1);if(!$)throw new Error("Can't perform where op on the given tensors");b=$,et=M.size(b)}let st=Math.ceil(et/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:$=>rf($,o,b,h,d),getRunData:()=>({outputs:[{dims:b,dataType:d}],dispatchGroup:{x:Math.ceil(et/64/4)},programUniforms:[{type:12,data:st},...X$1(a,e,s,b)]})}},$d=o=>{o.compute(nf(o.inputs))}}),xd,Sd=j(()=>{zs(),aa(),Ws(),Vs(),Cu(),Du(),ia(),da(),Xu(),Ju(),rl(),sl(),dl(),pl(),hl(),bl(),$l(),xl(),Cl(),pa(),Al(),Pl(),zl(),Zl(),Jl(),jn(),nd(),ad(),sd(),cd(),fd(),yd(),wd(),Rr(),Jn(),_d(),xd=new Map([["Abs",[Hs]],["Acos",[Gs]],["Acosh",[Ls]],["Add",[Iu]],["ArgMax",[Rs,na]],["ArgMin",[Ps,na]],["Asin",[Fs]],["Asinh",[qs]],["Atan",[js]],["Atanh",[Ks]],["Attention",[Ms]],["AveragePool",[Hl,Vl]],["BatchNormalization",[Us]],["BiasAdd",[Ns]],["BiasSplitGelu",[Su]],["Cast",[Xs,Ys]],["Ceil",[Qs]],["Clip",[Zs]],["Concat",[Bs,Ds]],["Conv",[ha,fa]],["ConvTranspose",[Yu,Ku]],["Cos",[Js]],["Cosh",[eu]],["CumSum",[Zu,Qu]],["DepthToSpace",[el,tl]],["Div",[Tu]],["Einsum",[al,ol]],["Elu",[tu,Zn]],["Equal",[Au]],["Erf",[ru]],["Exp",[nu]],["Expand",[ll]],["FastGelu",[cl]],["Floor",[iu]],["FusedConv",[ha,fa]],["Gather",[fl,ml]],["GatherElements",[yl,gl]],["Gelu",[au]],["Gemm",[wl,vl]],["GlobalAveragePool",[Fl,Ll]],["GlobalMaxPool",[Xl,Yl]],["Greater",[Pu]],["GreaterOrEqual",[zu]],["HardSigmoid",[mu,pu]],["InstanceNormalization",[_l]],["LayerNormalization",[Sl]],["LeakyRelu",[ou,Zn]],["Less",[Ru]],["LessOrEqual",[Bu]],["Log",[_u]],["MatMul",[Hu]],["MatMulNBits",[Il,Tl]],["MaxPool",[jl,Kl]],["Mul",[Eu]],["MultiHeadAttention",[Ol,kl]],["Neg",[uu]],["Not",[su]],["Pad",[Rl]],["Pow",[ku]],["Range",[Ql]],["Reciprocal",[lu]],["ReduceMin",[Is]],["ReduceMean",[$s]],["ReduceMax",[Cs]],["ReduceSum",[As]],["ReduceProd",[Ts]],["ReduceL1",[_s]],["ReduceL2",[xs]],["ReduceLogSum",[ks]],["ReduceLogSumExp",[Ss]],["ReduceSumSquare",[Es]],["Relu",[du]],["Resize",[td,rd]],["RotaryEmbedding",[id]],["Sigmoid",[cu]],["Sin",[fu]],["Sinh",[hu]],["Slice",[ld,dd]],["SkipLayerNormalization",[od]],["Split",[hd,gd]],["Sqrt",[gu]],["Softmax",[pd,md]],["Sub",[Ou]],["Tan",[yu]],["Tanh",[vu]],["ThresholdedRelu",[$u,Zn]],["Tile",[vd]],["Transpose",[us,ls]],["Where",[$d]]])}),li,Cd=j(()=>{_t(),Yt(),_e(),li=class{constructor(o){this.backend=o,this.repo=new Map,this.attributesBound=!1}getArtifact(o){return this.repo.get(o)}setArtifact(o,e){this.repo.set(o,e)}run(o,e,s,a,d){yt(o.programInfo.name);let h=this.backend.device,b=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let et=[];for(let $ of e)et.push({binding:et.length,resource:{buffer:$.buffer}});for(let $ of s)et.push({binding:et.length,resource:{buffer:$.buffer}});d&&et.push({binding:et.length,resource:d});let st=h.createBindGroup({layout:o.computePipeline.getBindGroupLayout(0),entries:et,label:o.programInfo.name});if(this.backend.sessionStatus==="capturing"){let $={kernelId:this.backend.currentKernelId,computePipeline:o.computePipeline,bindGroup:st,dispatchGroup:a};this.backend.capturedCommandList.get(this.backend.currentSessionId).push($)}b.setPipeline(o.computePipeline),b.setBindGroup(0,st),b.dispatchWorkgroups(...a),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),ut(o.programInfo.name)}dispose(){}build(o,e){yt(o.name);let s=this.backend.device,a=[];s.features.has("shader-f16")&&a.push("enable f16;");let d=os(e,this.backend.device.limits),h=o.getShaderSource(d),b=`${a.join(`
`)}
${d.additionalImplementations}
${h}`,et=s.createShaderModule({code:b,label:o.name});Ne("verbose",()=>`[WebGPU] ${o.name} shader code: ${b}`);let st=s.createComputePipeline({compute:{module:et,entryPoint:"main"},layout:"auto",label:o.name});return ut(o.name),{programInfo:o,computePipeline:st,uniformVariablesInfo:d.variablesInfo}}normalizeDispatchGroupSize(o){let e=typeof o=="number"?o:o.x,s=typeof o=="number"?1:o.y||1,a=typeof o=="number"?1:o.z||1,d=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=d&&s<=d&&a<=d)return[e,s,a];let h=e*s*a,b=Math.ceil(Math.sqrt(h));if(b>d){if(b=Math.ceil(Math.cbrt(h)),b>d)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[b,b,b]}else return[b,b,1]}}}),af,of,$a,di,Id=j(()=>{_t(),ye(),Yt(),es(),as(),Sd(),Cd(),af=(o,e)=>{if(e.length!==o.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${o.length}.`);let s=[];for(let a=0;a<o.length;++a){let d=o[a].dataType;switch(e[a]){case"none":{s.push("");break}case"type":{s.push(`${d}`);break}case"rank":{let h=o[a].dims.length;s.push(`${d};${h}`);break}case"dims":{let h=o[a].dims.join(",");s.push(`${d};${h}`);break}default:throw new Error(`unsupported input dependency: ${e[a]}`)}}return s.join("|")},of=(o,e,s)=>{let a=o.name;return o.shaderCache?.hint&&(a+="["+o.shaderCache.hint+"]"),a+=":"+s+`:${af(e,o.shaderCache?.inputDependencies??new Array(e.length).fill("dims"))}`,a},$a=class{constructor(o){o&&(this.architecture=o.architecture,this.vendor=o.vendor)}isArchitecture(o){return this.architecture===o}isVendor(o){return this.vendor===o}},di=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let o=this.kernelCustomData.get(this.currentKernelId);return o||(o={},this.kernelCustomData.set(this.currentKernelId,o)),o}async initialize(o,e){this.env=o;let s=[],a={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:s};e.features.has("chromium-experimental-timestamp-query-inside-passes")?s.push("chromium-experimental-timestamp-query-inside-passes"):e.features.has("timestamp-query")&&s.push("timestamp-query"),e.features.has("shader-f16")&&s.push("shader-f16"),this.device=await e.requestDevice(a),this.adapterInfo=new $a(await e.requestAdapterInfo()),this.gpuDataManager=is(this),this.programManager=new li(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Qo(o.logLevel,!!o.debug),this.device.onuncapturederror=d=>{d.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${d.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:e,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let o=this.getCommandEncoder(),e={};this.queryType==="at-passes"&&(e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=o.beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;yt(),this.endComputePass();let o;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),o=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(o,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,o,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&o.mapAsync(GPUMapMode.READ).then(()=>{let e=new BigUint64Array(o.getMappedRange()),s=this.pendingQueries.get(o);for(let a=0;a<e.length/2;a++){let d=s[a],h=d.kernelId,b=this.kernels.get(h),et=b.kernelType,st=b.kernelName,$=d.programName,it=d.inputTensorViews,g=d.outputTensorViews,c=e[a*2],_=e[a*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=c);let ot=Number(c-this.queryTimeBase),ct=Number(_-this.queryTimeBase);if(!Number.isSafeInteger(ot)||!Number.isSafeInteger(ct))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:it.map(dt=>({dims:dt.dims,dataType:Kt(dt.dataType)})),outputsMetadata:g.map(dt=>({dims:dt.dims,dataType:Kt(dt.dataType)})),kernelId:h,kernelType:et,kernelName:st,programName:$,startTime:ot,endTime:ct});else{let dt="";it.forEach((ft,ht)=>{dt+=`input[${ht}]: [${ft.dims}] | ${Kt(ft.dataType)}, `});let pt="";g.forEach((ft,ht)=>{pt+=`output[${ht}]: [${ft.dims}] | ${Kt(ft.dataType)}, `}),console.log(`[profiling] kernel "${h}|${et}|${st}|${$}" ${dt}${pt}execution time: ${ct-ot} ns`)}Bn("GPU",`${$}::${c}::${_}`)}o.unmap(),this.pendingQueries.delete(o)}),ut()}run(o,e,s,a,d,h){yt(o.name);let b=[];for(let ft=0;ft<e.length;++ft){let ht=e[ft].data;if(ht===0)continue;let bt=this.gpuDataManager.get(ht);if(!bt)throw new Error(`no GPU data for input: ${ht}`);b.push(bt)}let{outputs:et,dispatchGroup:st,programUniforms:$}=o.getRunData(e),it=s.length===0?et.map((ft,ht)=>ht):s;if(it.length!==et.length)throw new Error(`Output size ${it.length} must be equal to ${et.length}.`);let g=[],c=[];for(let ft=0;ft<et.length;++ft){if(!Number.isInteger(it[ft])||it[ft]<-3||it[ft]>=h)throw new Error(`Invalid output index: ${it[ft]}`);if(it[ft]===-3)continue;let ht=it[ft]===-1,bt=it[ft]===-2,mt=ht||bt?d(et[ft].dataType,et[ft].dims):a(it[ft],et[ft].dataType,et[ft].dims);if(g.push(mt),mt.data===0)continue;let $t=this.gpuDataManager.get(mt.data);if(!$t)throw new Error(`no GPU data for output: ${mt.data}`);if(ht&&this.temporaryData.push($t),bt){let Tt=this.kernelPersistentData.get(this.currentKernelId);Tt||(Tt=[],this.kernelPersistentData.set(this.currentKernelId,Tt)),Tt.push($t)}c.push($t)}if(b.length!==e.length||c.length!==g.length){if(c.length===0)return ut(o.name),g;throw new Error(`Program ${o.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let _;if($){let ft=0,ht=[];$.forEach(Tt=>{let Nt=typeof Tt.data=="number"?[Tt.data]:Tt.data;if(Nt.length===0)return;let Ct=Tt.type===10?2:4,Ft,ln;Tt.type===10?(ln=Nt.length>4?16:Nt.length>2?8:Nt.length*Ct,Ft=Nt.length>4?16:Ct*Nt.length):(ln=Nt.length<=2?Nt.length*Ct:16,Ft=16),ft=Math.ceil(ft/ln)*ln,ht.push(ft);let mn=Tt.type===10?8:4;ft+=Nt.length>4?Math.ceil(Nt.length/mn)*Ft:Nt.length*Ct});let bt=16;ft=Math.ceil(ft/bt)*bt;let mt=new ArrayBuffer(ft);$.forEach((Tt,Nt)=>{let Ct=ht[Nt],Ft=typeof Tt.data=="number"?[Tt.data]:Tt.data;if(Tt.type===6)new Int32Array(mt,Ct,Ft.length).set(Ft);else if(Tt.type===12)new Uint32Array(mt,Ct,Ft.length).set(Ft);else if(Tt.type===10)new Uint16Array(mt,Ct,Ft.length).set(Ft);else if(Tt.type===1)new Float32Array(mt,Ct,Ft.length).set(Ft);else throw new Error(`Unsupported uniform type: ${Kt(Tt.type)}`)});let $t=this.gpuDataManager.create(ft,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer($t.buffer,0,mt,0,ft),this.gpuDataManager.release($t.id),_={offset:0,size:ft,buffer:$t.buffer}}let ot=this.programManager.normalizeDispatchGroupSize(st),ct=ot[1]===1&&ot[2]===1,dt=of(o,e,ct),pt=this.programManager.getArtifact(dt);if(pt||(pt=this.programManager.build(o,ot),this.programManager.setArtifact(dt,pt),Ne("info",()=>`[artifact] key: ${dt}, programName: ${o.name}`)),$&&pt.uniformVariablesInfo){if($.length!==pt.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${pt.uniformVariablesInfo.length}, got ${$.length} in program "${pt.programInfo.name}".`);for(let ft=0;ft<$.length;ft++){let ht=$[ft],bt=ht.type,mt=typeof ht.data=="number"?1:ht.data.length,[$t,Tt]=pt.uniformVariablesInfo[ft];if(bt!==$t||mt!==Tt)throw new Error(`Uniform variable ${ft} mismatch: expect type ${$t} with size ${Tt}, got type ${bt} with size ${mt} in program "${pt.programInfo.name}".`)}}if(Ne("info",()=>`[ProgramManager] run "${o.name}" (key=${dt}) with ${ot[0]}x${ot[1]}x${ot[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let ft={kernelId:this.currentKernelId,programName:pt.programInfo.name,inputTensorViews:e,outputTensorViews:g};this.pendingKernels.push(ft),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(ft)}return this.programManager.run(pt,b,c,ot,_),ut(o.name),g}upload(o,e){this.gpuDataManager.upload(o,e)}memcpy(o,e){this.gpuDataManager.memcpy(o,e)}async download(o,e){await this.gpuDataManager.download(o,e)}alloc(o){return this.gpuDataManager.create(o).id}free(o){return this.gpuDataManager.release(o)}createKernel(o,e,s,a){let d=xd.get(o);if(!d)throw new Error(`kernel not implemented: ${o}`);let h={kernelType:o,kernelName:a,kernelEntry:d[0],attributes:[d[1],s]};this.kernels.set(e,h)}releaseKernel(o){let e=this.kernelPersistentData.get(o);if(e){for(let s of e)this.gpuDataManager.release(s.id);this.kernelPersistentData.delete(o)}this.kernelCustomData.delete(o),this.kernels.delete(o)}computeKernel(o,e,s){let a=this.kernels.get(o);if(!a)throw new Error(`kernel not created: ${o}`);let d=a.kernelType,h=a.kernelName,b=a.kernelEntry,et=a.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${d}] ${h}" is not allowed to be called recursively`);this.currentKernelId=o,et[0]&&(et[1]=et[0](et[1]),et[0]=void 0),Ne("info",()=>`[WebGPU] Start to run kernel "[${d}] ${h}"...`);let st=this.env.debug;this.temporaryData=[];try{return st&&this.device.pushErrorScope("validation"),b(e,et[1]),0}catch($){return s.push(Promise.resolve(`[WebGPU] Kernel "[${d}] ${h}" failed. ${$}`)),1}finally{st&&s.push(this.device.popErrorScope().then($=>$?`GPU validation error for kernel "[${d}] ${h}": ${$.message}`:null));for(let $ of this.temporaryData)this.gpuDataManager.release($.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(o,e,s,a){let d=this.sessionExternalDataMapping.get(o);d||(d=new Map,this.sessionExternalDataMapping.set(o,d));let h=d.get(e),b=this.gpuDataManager.registerExternalBuffer(s,a,h?.[1]);return d.set(e,[b,s]),b}unregisterBuffers(o){let e=this.sessionExternalDataMapping.get(o);e&&(e.forEach(s=>this.gpuDataManager.unregisterExternalBuffer(s[1])),this.sessionExternalDataMapping.delete(o))}getBuffer(o){let e=this.gpuDataManager.get(o);if(!e)throw new Error(`no GPU data for buffer: ${o}`);return e.buffer}createDownloader(o,e,s){return async()=>{let a=await Xi(this,o,e);return Jo(a.buffer,s)}}writeTimestamp(o){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,o)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Ne("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Ne("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Ne("info","replay"),this.sessionStatus="replaying";let o=this.capturedCommandList.get(this.currentSessionId),e=this.capturedPendingKernels.get(this.currentSessionId),s=o.length;this.pendingKernels=[];for(let a=0;a<s;a++){let d=this.getComputePassEncoder(),h=o[a];this.writeTimestamp(this.pendingDispatchNumber*2),d.setPipeline(h.computePipeline),d.setBindGroup(0,h.bindGroup),d.dispatchWorkgroups(...h.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(e[a]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(o){this.unregisterBuffers(o),this.capturedCommandList.has(o)&&this.capturedCommandList.delete(o),this.capturedPendingKernels.has(o)&&this.capturedPendingKernels.delete(o),this.gpuDataManager.onReleaseSession(o)}onRunStart(o){this.currentSessionId=o,this.setQueryType()}}}),Td={};kr(Td,{init:()=>sf});var on,_a,sf,Ad=j(()=>{ye(),Id(),Yt(),xe(),on=class o_{constructor(e,s,a,d){this.module=e,this.dataType=s,this.data=a,this.dims=d}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=M.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=M.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=M.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(M.size(e)!==M.size(this.dims))throw new Error("Invalid new shape");return new o_(this.module,this.dataType,this.data,e)}},_a=class{constructor(o,e,s){this.module=o,this.backend=e,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=e.adapterInfo;let a=o.HEAPU32,d=s>>>2;this.opKernelContext=a[d++];let h=a[d++];this.outputCount=a[d++],this.customDataOffset=a[d++],this.customDataSize=a[d++];let b=[];for(let et=0;et<h;et++){let st=a[d++],$=a[d++],it=a[d++],g=[];for(let c=0;c<it;c++)g.push(a[d++]);b.push(new on(o,st,$,g))}this.inputs=b}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(o,e){let s=e?.inputs?.map(b=>typeof b=="number"?this.inputs[b]:b)??this.inputs,a=e?.outputs??[],d=(b,et,st)=>new on(this.module,et,this.output(b,st),st),h=(b,et)=>{let st=cr(b);if(!st)throw new Error(`Unsupported data type: ${b}`);let $=st*M.size(et),it=$>0?this.backend.gpuDataManager.create($).id:0;return new on(this.module,b,it,et)};return this.backend.run(o,s,a,d,h,this.outputCount)}output(o,e){let s=this.module.stackSave();try{let a=this.module.stackAlloc((1+e.length)*4),d=a>>2;this.module.HEAPU32[d++]=e.length;for(let h=0;h<e.length;h++)this.module.HEAPU32[d++]=e[h];return this.module._JsepOutput(this.opKernelContext,o,a)}catch(a){throw new Error(`Failed to generate kernel's output[${o}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${a}`)}finally{this.module.stackRestore(s)}}},sf=async(o,e,s,a)=>{let d=e.jsepInit;if(!d)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(o==="webgpu"){let h=new di;await h.initialize(s,a),d("webgpu",[h,b=>h.alloc(b),b=>h.free(b),(b,et,st,$=!1)=>{if($)Ne("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${b}, dst=${et}, size=${st}`),h.memcpy(b,et);else{Ne("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${b}, gpuDataId=${et}, size=${st}`);let it=e.HEAPU8.subarray(b>>>0,(b>>>0)+st);h.upload(et,it)}},async(b,et,st)=>{Ne("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${b}, dataOffset=${et}, size=${st}`),await h.download(b,()=>e.HEAPU8.subarray(et>>>0,(et>>>0)+st))},(b,et,st)=>h.createKernel(b,et,st,e.UTF8ToString(e._JsepGetNodeName(et))),b=>h.releaseKernel(b),(b,et,st,$)=>{Ne("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${st}, kernel=${b}, contextDataOffset=${et}`);let it=new _a(e,h,et);return h.computeKernel(b,it,$)},()=>h.captureBegin(),()=>h.captureEnd(),()=>h.replay()])}else d("webnn")}}),uf,kd,Od,hr,lf,xa,Pd,Rd,Ed,zd,Bd,Dd,Md=j(()=>{jo(),Yo(),ye(),Or(),Wn(),qi(),uf=(o,e)=>{Fe()._OrtInit(o,e)!==0&&We("Can't initialize onnxruntime.")},kd=async o=>{uf(o.wasm.numThreads,en(o.logLevel))},Od=async(o,e)=>{{let s=(Ad(),sr(Td)).init;if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let a=o.webgpu.adapter;if(a){if(typeof a.limits!="object"||typeof a.features!="object"||typeof a.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let d=o.webgpu.powerPreference;if(d!==void 0&&d!=="low-power"&&d!=="high-performance")throw new Error(`Invalid powerPreference setting: "${d}"`);let h=o.webgpu.forceFallbackAdapter;if(h!==void 0&&typeof h!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${h}"`);if(a=await navigator.gpu.requestAdapter({powerPreference:d,forceFallbackAdapter:h}),!a)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}if(!o.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");await s("webgpu",Fe(),o,a)}if(e==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await s("webnn",Fe(),o)}}},hr=new Map,lf=o=>{let e=Fe(),s=e.stackSave();try{let a=e.stackAlloc(8);return e._OrtGetInputOutputCount(o,a,a+4)!==0&&We("Can't get session input/output count."),[e.HEAP32[a/4],e.HEAP32[a/4+1]]}finally{e.stackRestore(s)}},xa=o=>{let e=Fe(),s=e._malloc(o.byteLength);if(s===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${o.byteLength}.`);return e.HEAPU8.set(o,s),[s,o.byteLength]},Pd=async(o,e)=>{let s,a,d=Fe();Array.isArray(o)?[s,a]=o:o.buffer===d.HEAPU8.buffer?[s,a]=[o.byteOffset,o.byteLength]:[s,a]=xa(o);let h=0,b=0,et=0,st=[],$=[],it=[];try{if([b,st]=Ko(e),e?.externalData&&d.mountExternalData){let ft=[];for(let ht of e.externalData){let bt=typeof ht=="string"?ht:ht.path;ft.push(tn(typeof ht=="string"?ht:ht.data).then(mt=>{d.mountExternalData(bt,mt)}))}await Promise.all(ft)}h=await d._OrtCreateSession(s,a,b),h===0&&We("Can't create a session.");let[g,c]=lf(h),_=!!e?.enableGraphCapture,ot=[],ct=[],dt=[];for(let ft=0;ft<g;ft++){let ht=d._OrtGetInputName(h,ft);ht===0&&We("Can't get an input name."),$.push(ht),ot.push(d.UTF8ToString(ht))}for(let ft=0;ft<c;ft++){let ht=d._OrtGetOutputName(h,ft);ht===0&&We("Can't get an output name."),it.push(ht);let bt=d.UTF8ToString(ht);ct.push(bt);{if(_&&e?.preferredOutputLocation===void 0){dt.push("gpu-buffer");continue}let mt=typeof e?.preferredOutputLocation=="string"?e.preferredOutputLocation:e?.preferredOutputLocation?.[bt]??"cpu";if(mt!=="cpu"&&mt!=="cpu-pinned"&&mt!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${mt}.`);if(_&&mt!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${mt}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);dt.push(mt)}}let pt=null;return dt.some(ft=>ft==="gpu-buffer")&&(et=d._OrtCreateBinding(h),et===0&&We("Can't create IO binding."),pt={handle:et,outputPreferredLocations:dt,outputPreferredLocationsEncoded:dt.map(ft=>Fi(ft))}),hr.set(h,[h,$,it,pt,_,!1]),[h,ot,ct]}catch(g){throw $.forEach(c=>d._OrtFree(c)),it.forEach(c=>d._OrtFree(c)),et!==0&&d._OrtReleaseBinding(et),h!==0&&d._OrtReleaseSession(h),g}finally{d._free(s),b!==0&&d._OrtReleaseSessionOptions(b),st.forEach(g=>d._free(g)),d.unmountExternalData?.()}},Rd=o=>{let e=Fe(),s=hr.get(o);if(!s)throw new Error(`cannot release session. invalid session id: ${o}`);let[a,d,h,b,et]=s;b&&(et&&e._OrtClearBoundOutputs(b.handle),e._OrtReleaseBinding(b.handle)),e.jsepOnReleaseSession?.(o),d.forEach(st=>e._OrtFree(st)),h.forEach(st=>e._OrtFree(st)),e._OrtReleaseSession(a),hr.delete(o)},Ed=(o,e,s,a,d,h=!1)=>{if(!o){e.push(0);return}let b=Fe(),et=o[0],st=o[1],$=o[3],it,g;if(et==="string"&&$==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(h&&$!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${d} when enableGraphCapture is true.`);if($==="gpu-buffer"){let ot=o[2].gpuBuffer,ct=cr(Li(et));g=st.reduce((pt,ft)=>pt*ft,1)*ct;let dt=b.jsepRegisterBuffer;if(!dt)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');it=dt(a,d,ot,g)}else{let ot=o[2];if(Array.isArray(ot)){g=4*ot.length,it=b._malloc(g),s.push(it);let ct=it/4;for(let dt=0;dt<ot.length;dt++){if(typeof ot[dt]!="string")throw new TypeError(`tensor data at index ${dt} is not a string`);b.HEAPU32[ct++]=qe(ot[dt],s)}}else g=ot.byteLength,it=b._malloc(g),s.push(it),b.HEAPU8.set(new Uint8Array(ot.buffer,ot.byteOffset,g),it)}let c=b.stackSave(),_=b.stackAlloc(4*st.length);try{let ot=_/4;st.forEach(dt=>b.HEAP32[ot++]=dt);let ct=b._OrtCreateTensor(Li(et),it,g,_,st.length,Fi($));ct===0&&We(`Can't create tensor for input/output. session=${a}, index=${d}.`),e.push(ct)}finally{b.stackRestore(c)}},zd=async(o,e,s,a,d,h)=>{let b=Fe(),et=hr.get(o);if(!et)throw new Error(`cannot run inference. invalid session id: ${o}`);let st=et[0],$=et[1],it=et[2],g=et[3],c=et[4],_=et[5],ot=e.length,ct=a.length,dt=0,pt=[],ft=[],ht=[],bt=[],mt=b.stackSave(),$t=b.stackAlloc(ot*4),Tt=b.stackAlloc(ot*4),Nt=b.stackAlloc(ct*4),Ct=b.stackAlloc(ct*4);try{[dt,pt]=qo(h);for(let Gt=0;Gt<ot;Gt++)Ed(s[Gt],ft,bt,o,e[Gt],c);for(let Gt=0;Gt<ct;Gt++)Ed(d[Gt],ht,bt,o,ot+a[Gt],c);let Ft=$t/4,ln=Tt/4,mn=Nt/4,yn=Ct/4;for(let Gt=0;Gt<ot;Gt++)b.HEAPU32[Ft++]=ft[Gt],b.HEAPU32[ln++]=$[e[Gt]];for(let Gt=0;Gt<ct;Gt++)b.HEAPU32[mn++]=ht[Gt],b.HEAPU32[yn++]=it[a[Gt]];if(g&&!_){let{handle:Gt,outputPreferredLocations:cn,outputPreferredLocationsEncoded:xn}=g;if($.length!==ot)throw new Error(`input count from feeds (${ot}) is expected to be always equal to model's input count (${$.length}).`);for(let dn=0;dn<ot;dn++){let wn=e[dn];await b._OrtBindInput(Gt,$[wn],ft[dn])!==0&&We(`Can't bind input[${dn}] for session=${o}.`)}for(let dn=0;dn<ct;dn++){let wn=a[dn];d[dn]?.[3]?b._OrtBindOutput(Gt,it[wn],ht[dn],0)!==0&&We(`Can't bind pre-allocated output[${dn}] for session=${o}.`):b._OrtBindOutput(Gt,it[wn],0,xn[wn])!==0&&We(`Can't bind output[${dn}] to ${cn[dn]} for session=${o}.`)}hr.set(o,[st,$,it,g,c,!0])}b.jsepOnRunStart?.(st);let pn;g?pn=await b._OrtRunWithBinding(st,g.handle,ct,Nt,dt):pn=await b._OrtRun(st,Tt,$t,ot,Ct,ct,Nt,dt),pn!==0&&We("failed to call OrtRun().");let Ht=[];for(let Gt=0;Gt<ct;Gt++){let cn=b.HEAPU32[Nt/4+Gt];if(cn===ht[Gt]){Ht.push(d[Gt]);continue}let xn=b.stackSave(),dn=b.stackAlloc(4*4),wn=!1,gn,En=0;try{b._OrtGetTensorData(cn,dn,dn+4,dn+8,dn+12)!==0&&We(`Can't access output tensor data on index ${Gt}.`);let _r=dn/4,Sr=b.HEAPU32[_r++];En=b.HEAPU32[_r++];let xr=b.HEAPU32[_r++],Vr=b.HEAPU32[_r++],Fr=[];for(let Po=0;Po<Vr;Po++)Fr.push(b.HEAPU32[xr/4+Po]);b._OrtFree(xr);let _f=Fr.reduce((Po,No)=>Po*No,1);gn=Kt(Sr);let h0=g?.outputPreferredLocations[a[Gt]];if(gn==="string"){if(h0==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Po=[],No=En/4;for(let o0=0;o0<_f;o0++){let t0=b.HEAPU32[No++],xu=o0===_f-1?void 0:b.HEAPU32[No]-t0;Po.push(b.UTF8ToString(t0,xu))}Ht.push([gn,Fr,Po,"cpu"])}else if(h0==="gpu-buffer"&&_f>0){let Po=b.jsepGetBuffer;if(!Po)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let No=Po(En),o0=cr(Sr);if(o0===void 0||!Vn(gn))throw new Error(`Unsupported data type: ${gn}`);wn=!0,Ht.push([gn,Fr,{gpuBuffer:No,download:b.jsepCreateDownloader(No,_f*o0,gn),dispose:()=>{b._OrtReleaseTensor(cn)}},"gpu-buffer"])}else{let Po=Nn(gn),No=new Po(_f);new Uint8Array(No.buffer,No.byteOffset,No.byteLength).set(b.HEAPU8.subarray(En,En+No.byteLength)),Ht.push([gn,Fr,No,"cpu"])}}finally{b.stackRestore(xn),gn==="string"&&En&&b._free(En),wn||b._OrtReleaseTensor(cn)}}return g&&!c&&(b._OrtClearBoundOutputs(g.handle),hr.set(o,[st,$,it,g,c,!1])),Ht}finally{b.stackRestore(mt),ft.forEach(Ft=>b._OrtReleaseTensor(Ft)),ht.forEach(Ft=>b._OrtReleaseTensor(Ft)),bt.forEach(Ft=>b._free(Ft)),dt!==0&&b._OrtReleaseRunOptions(dt),pt.forEach(Ft=>b._free(Ft))}},Bd=o=>{let e=Fe(),s=hr.get(o);if(!s)throw new Error("invalid session id");let a=s[0],d=e._OrtEndProfiling(a);d===0&&We("Can't get an profile file name."),e._OrtFree(d)},Dd=o=>{let e=[];for(let s of o){let a=s[2];!Array.isArray(a)&&"buffer"in a&&e.push(a.buffer)}return e}}),Ud=Er((o,e)=>{e.exports='/*!\n * ONNX Runtime Web v1.19.0-dev.20240509-69cfcba38a\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var ao=Object.defineProperty;var nl=Object.getOwnPropertyDescriptor;var ol=Object.getOwnPropertyNames;var il=Object.prototype.hasOwnProperty;var Y=(e,t)=>()=>(e&&(t=e(e=0)),t);var Wr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),gn=(e,t)=>{for(var r in t)ao(e,r,{get:t[r],enumerable:!0})},al=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of ol(t))!il.call(e,i)&&i!==r&&ao(e,i,{get:()=>t[i],enumerable:!(o=nl(t,i))||o.enumerable});return e};var wr=e=>al(ao({},"__esModule",{value:!0}),e);var so={};gn(so,{createReadStream:()=>Ai,readFile:()=>sl,readFileSync:()=>ul});var sl,ul,Ai,uo=Y(()=>{sl=void 0,ul=void 0,Ai=void 0});var lo={};gn(lo,{join:()=>dl});var dl,co=Y(()=>{dl=void 0});var Ei=Wr((Ti,po)=>{"use strict";var Ii=(()=>{var e=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(e||=__filename),function(t={}){var r=t,o,i,u=new Promise((s,m)=>{o=s,i=m});r.mountExternalData=(s,m)=>{(r.eb||(r.eb=new Map)).set(s,m)},r.unmountExternalData=()=>{delete r.eb};let a=()=>{let s=(g,$,T)=>(...B)=>{let L=dt,q=$?.();B=g(...B);let te=$?.();return q!==te&&(g=te,T(q),$=T=null),dt!=L?tn():B},m=g=>async(...$)=>{try{if(r.cb)throw Error("Session already started");let T=r.cb={xb:$[0],errors:[]},B=await g(...$);if(r.cb!==T)throw Error("Session mismatch");r.kb?.flush();let L=T.errors;if(0<L.length){let q=await Promise.all(L);if(q=q.filter(te=>te),0<q.length)throw Error(q.join(`\n`))}return B}finally{r.cb=null}};r._OrtCreateSession=s(r._OrtCreateSession,()=>r._OrtCreateSession,g=>r._OrtCreateSession=g),r._OrtRun=m(s(r._OrtRun,()=>r._OrtRun,g=>r._OrtRun=g)),r._OrtRunWithBinding=m(s(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,g=>r._OrtRunWithBinding=g)),r._OrtBindInput=s(r._OrtBindInput,()=>r._OrtBindInput,g=>r._OrtBindInput=g),a=void 0};r.jsepInit=(s,m)=>{if(a?.(),s==="webgpu"){[r.kb,r.pb,r.tb,r.lb,r.sb,r.Ra,r.ub,r.wb,r.qb,r.rb,r.vb]=m;let g=r.kb;r.jsepRegisterBuffer=($,T,B,L)=>g.registerBuffer($,T,B,L),r.jsepGetBuffer=$=>g.getBuffer($),r.jsepCreateDownloader=($,T,B)=>g.createDownloader($,T,B),r.jsepOnReleaseSession=$=>{g.onReleaseSession($)},r.jsepOnRunStart=$=>g.onRunStart($)}};var c=Object.assign({},r),p="./this.program",h=(s,m)=>{throw m},d=typeof window=="object",y=typeof importScripts=="function",w=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",_="",v,S,I;if(w){var A=(uo(),wr(so)),x=(co(),wr(lo));_=y?x.dirname(_)+"/":__dirname+"/",v=(s,m)=>(s=Ke(s)?new URL(s):x.normalize(s),A.readFileSync(s,m?void 0:"utf8")),I=s=>(s=v(s,!0),s.buffer||(s=new Uint8Array(s)),s),S=(s,m,g,$=!0)=>{s=Ke(s)?new URL(s):x.normalize(s),A.readFile(s,$?void 0:"utf8",(T,B)=>{T?g(T):m($?B.buffer:B)})},!r.thisProgram&&1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),h=(s,m)=>{throw process.exitCode=s,m}}else(d||y)&&(y?_=self.location.href:typeof document<"u"&&document.currentScript&&(_=document.currentScript.src),e&&(_=e),_.startsWith("blob:")?_="":_=_.substr(0,_.replace(/[?#].*/,"").lastIndexOf("/")+1),v=s=>{var m=new XMLHttpRequest;return m.open("GET",s,!1),m.send(null),m.responseText},y&&(I=s=>{var m=new XMLHttpRequest;return m.open("GET",s,!1),m.responseType="arraybuffer",m.send(null),new Uint8Array(m.response)}),S=(s,m,g)=>{var $=new XMLHttpRequest;$.open("GET",s,!0),$.responseType="arraybuffer",$.onload=()=>{$.status==200||$.status==0&&$.response?m($.response):g()},$.onerror=g,$.send(null)});var E=console.log.bind(console),P=console.error.bind(console);Object.assign(r,c),c=null;var O,R=!1,H,N,K,Q,he,W,se,Ce,We,ee,ae;function Ae(){var s=O.buffer;r.HEAP8=N=new Int8Array(s),r.HEAP16=Q=new Int16Array(s),r.HEAPU8=K=new Uint8Array(s),r.HEAPU16=he=new Uint16Array(s),r.HEAP32=W=new Int32Array(s),r.HEAPU32=se=new Uint32Array(s),r.HEAPF32=Ce=new Float32Array(s),r.HEAPF64=ae=new Float64Array(s),r.HEAP64=We=new BigInt64Array(s),r.HEAPU64=ee=new BigUint64Array(s)}var me=[],ie=[],ue=[],le=0,qe=null,G=null;function ne(s){throw s="Aborted("+s+")",P(s),R=!0,H=1,s=new WebAssembly.RuntimeError(s+". Build with -sASSERTIONS for more info."),i(s),s}var xe=s=>s.startsWith("data:application/octet-stream;base64,"),Ke=s=>s.startsWith("file://"),De;if(De="ort-wasm-simd.wasm",!xe(De)){var Ge=De;De=r.locateFile?r.locateFile(Ge,_):_+Ge}function Mt(s){if(I)return I(s);throw"both async and sync fetching of the wasm failed"}function Ne(s){if(d||y){if(typeof fetch=="function"&&!Ke(s))return fetch(s,{credentials:"same-origin"}).then(m=>{if(!m.ok)throw`failed to load wasm binary file at \'${s}\'`;return m.arrayBuffer()}).catch(()=>Mt(s));if(S)return new Promise((m,g)=>{S(s,$=>m(new Uint8Array($)),g)})}return Promise.resolve().then(()=>Mt(s))}function Ye(s,m,g){return Ne(s).then($=>WebAssembly.instantiate($,m)).then(g,$=>{P(`failed to asynchronously prepare wasm: ${$}`),ne($)})}function mt(s,m){var g=De;return typeof WebAssembly.instantiateStreaming!="function"||xe(g)||Ke(g)||w||typeof fetch!="function"?Ye(g,s,m):fetch(g,{credentials:"same-origin"}).then($=>WebAssembly.instantiateStreaming($,s).then(m,function(T){return P(`wasm streaming compile failed: ${T}`),P("falling back to ArrayBuffer instantiation"),Ye(g,s,m)}))}var Ot={824936:(s,m,g,$)=>{if(typeof r>"u"||!r.eb)return 1;if(s=je(s>>>0),s.startsWith("./")&&(s=s.substring(2)),s=r.eb.get(s),!s)return 2;if(m>>>=0,g>>>=0,m+g>s.byteLength)return 3;try{return K.set(s.subarray(m,m+g),$>>>0>>>0),0}catch{return 4}},825437:()=>{r.qb()},825468:()=>{r.rb()},825497:()=>{r.vb()},825522:s=>r.pb(s),825555:s=>r.tb(s),825587:(s,m,g)=>{r.lb(s,m,g,!0)},825626:(s,m,g)=>{r.lb(s,m,g)},825659:s=>{r.Ra("Abs",s,void 0)},825710:s=>{r.Ra("Neg",s,void 0)},825761:s=>{r.Ra("Floor",s,void 0)},825814:s=>{r.Ra("Ceil",s,void 0)},825866:s=>{r.Ra("Reciprocal",s,void 0)},825924:s=>{r.Ra("Sqrt",s,void 0)},825976:s=>{r.Ra("Exp",s,void 0)},826027:s=>{r.Ra("Erf",s,void 0)},826078:s=>{r.Ra("Sigmoid",s,void 0)},826133:(s,m,g)=>{r.Ra("HardSigmoid",s,{alpha:m,beta:g})},826212:s=>{r.Ra("Log",s,void 0)},826263:s=>{r.Ra("Sin",s,void 0)},826314:s=>{r.Ra("Cos",s,void 0)},826365:s=>{r.Ra("Tan",s,void 0)},826416:s=>{r.Ra("Asin",s,void 0)},826468:s=>{r.Ra("Acos",s,void 0)},826520:s=>{r.Ra("Atan",s,void 0)},826572:s=>{r.Ra("Sinh",s,void 0)},826624:s=>{r.Ra("Cosh",s,void 0)},826676:s=>{r.Ra("Asinh",s,void 0)},826729:s=>{r.Ra("Acosh",s,void 0)},826782:s=>{r.Ra("Atanh",s,void 0)},826835:s=>{r.Ra("Tanh",s,void 0)},826887:s=>{r.Ra("Not",s,void 0)},826938:(s,m,g)=>{r.Ra("Clip",s,{min:m,max:g})},827007:s=>{r.Ra("Clip",s,void 0)},827059:(s,m)=>{r.Ra("Elu",s,{alpha:m})},827117:s=>{r.Ra("Relu",s,void 0)},827169:(s,m)=>{r.Ra("LeakyRelu",s,{alpha:m})},827233:(s,m)=>{r.Ra("ThresholdedRelu",s,{alpha:m})},827303:(s,m)=>{r.Ra("Cast",s,{to:m})},827361:s=>{r.Ra("Add",s,void 0)},827412:s=>{r.Ra("Sub",s,void 0)},827463:s=>{r.Ra("Mul",s,void 0)},827514:s=>{r.Ra("Div",s,void 0)},827565:s=>{r.Ra("Pow",s,void 0)},827616:s=>{r.Ra("Equal",s,void 0)},827669:s=>{r.Ra("Greater",s,void 0)},827724:s=>{r.Ra("GreaterOrEqual",s,void 0)},827786:s=>{r.Ra("Less",s,void 0)},827838:s=>{r.Ra("LessOrEqual",s,void 0)},827897:(s,m,g,$,T)=>{r.Ra("ReduceMean",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828056:(s,m,g,$,T)=>{r.Ra("ReduceMax",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828214:(s,m,g,$,T)=>{r.Ra("ReduceMin",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828372:(s,m,g,$,T)=>{r.Ra("ReduceProd",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828531:(s,m,g,$,T)=>{r.Ra("ReduceSum",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828689:(s,m,g,$,T)=>{r.Ra("ReduceL1",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828846:(s,m,g,$,T)=>{r.Ra("ReduceL2",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},829003:(s,m,g,$,T)=>{r.Ra("ReduceLogSum",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},829164:(s,m,g,$,T)=>{r.Ra("ReduceSumSquare",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},829328:(s,m,g,$,T)=>{r.Ra("ReduceLogSumExp",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},829492:s=>{r.Ra("Where",s,void 0)},829545:(s,m,g)=>{r.Ra("Transpose",s,{perm:m?Array.from(W.subarray(m>>>0,g>>>0)):[]})},829653:(s,m,g,$)=>{r.Ra("DepthToSpace",s,{blocksize:m,mode:je(g),format:$?"NHWC":"NCHW"})},829786:(s,m,g,$)=>{r.Ra("DepthToSpace",s,{blocksize:m,mode:je(g),format:$?"NHWC":"NCHW"})},829919:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be)=>{r.Ra("ConvTranspose",s,{format:te?"NHWC":"NCHW",autoPad:m,dilations:[g],group:$,kernelShape:[T],pads:[B,L],strides:[q],wIsConst:()=>!!N[X>>>0],outputPadding:de?Array.from(W.subarray(de>>>0,Ee>>>0)):[],outputShape:Oe?Array.from(W.subarray(Oe>>>0,D>>>0)):[],activation:je(be)})},830320:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D)=>{r.Ra("ConvTranspose",s,{format:q?"NHWC":"NCHW",autoPad:m,dilations:Array.from(W.subarray(g>>>0,(g>>>0)+2>>>0)),group:$,kernelShape:Array.from(W.subarray(T>>>0,(T>>>0)+2>>>0)),pads:Array.from(W.subarray(B>>>0,(B>>>0)+4>>>0)),strides:Array.from(W.subarray(L>>>0,(L>>>0)+2>>>0)),wIsConst:()=>!!N[te>>>0],outputPadding:X?Array.from(W.subarray(X>>>0,de>>>0)):[],outputShape:Ee?Array.from(W.subarray(Ee>>>0,Oe>>>0)):[],activation:je(D)})},830885:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be)=>{r.Ra("ConvTranspose",s,{format:te?"NHWC":"NCHW",autoPad:m,dilations:[g],group:$,kernelShape:[T],pads:[B,L],strides:[q],wIsConst:()=>!!N[X>>>0],outputPadding:de?Array.from(W.subarray(de>>>0,Ee>>>0)):[],outputShape:Oe?Array.from(W.subarray(Oe>>>0,D>>>0)):[],activation:je(be)})},831286:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D)=>{r.Ra("ConvTranspose",s,{format:q?"NHWC":"NCHW",autoPad:m,dilations:Array.from(W.subarray(g>>>0,(g>>>0)+2>>>0)),group:$,kernelShape:Array.from(W.subarray(T>>>0,(T>>>0)+2>>>0)),pads:Array.from(W.subarray(B>>>0,(B>>>0)+4>>>0)),strides:Array.from(W.subarray(L>>>0,(L>>>0)+2>>>0)),wIsConst:()=>!!N[te>>>0],outputPadding:X?Array.from(W.subarray(X>>>0,de>>>0)):[],outputShape:Ee?Array.from(W.subarray(Ee>>>0,Oe>>>0)):[],activation:je(D)})},831851:(s,m)=>{r.Ra("GlobalAveragePool",s,{format:m?"NHWC":"NCHW"})},831942:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("AveragePool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,L],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},832226:(s,m)=>{r.Ra("GlobalAveragePool",s,{format:m?"NHWC":"NCHW"})},832317:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("AveragePool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,L],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},832601:(s,m)=>{r.Ra("GlobalMaxPool",s,{format:m?"NHWC":"NCHW"})},832688:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("MaxPool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,L],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},832968:(s,m)=>{r.Ra("GlobalMaxPool",s,{format:m?"NHWC":"NCHW"})},833055:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("MaxPool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,L],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},833335:(s,m,g,$,T)=>{r.Ra("Gemm",s,{alpha:m,beta:g,transA:$,transB:T})},833439:s=>{r.Ra("MatMul",s,void 0)},833493:(s,m,g,$)=>{r.Ra("ArgMax",s,{keepDims:!!m,selectLastIndex:!!g,axis:$})},833601:(s,m,g,$)=>{r.Ra("ArgMin",s,{keepDims:!!m,selectLastIndex:!!g,axis:$})},833709:(s,m)=>{r.Ra("Softmax",s,{axis:m})},833772:(s,m)=>{r.Ra("Concat",s,{axis:m})},833832:(s,m,g,$,T)=>{r.Ra("Split",s,{axis:m,numOutputs:g,splitSizes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},833972:s=>{r.Ra("Expand",s,void 0)},834026:(s,m)=>{r.Ra("Gather",s,{axis:Number(m)})},834097:(s,m)=>{r.Ra("GatherElements",s,{axis:Number(m)})},834176:(s,m,g,$,T,B,L,q,te,X,de)=>{r.Ra("Resize",s,{antialias:m,axes:g?Array.from(W.subarray(g>>>0,$>>>0)):[],coordinateTransformMode:je(T),cubicCoeffA:B,excludeOutside:L,extrapolationValue:q,keepAspectRatioPolicy:je(te),mode:je(X),nearestMode:je(de)})},834522:(s,m,g,$,T,B,L)=>{r.Ra("Slice",s,{starts:m?Array.from(W.subarray(m>>>0,g>>>0)):[],ends:$?Array.from(W.subarray($>>>0,T>>>0)):[],axes:B?Array.from(W.subarray(B>>>0,L>>>0)):[]})},834738:s=>{r.Ra("Tile",s,void 0)},834790:(s,m,g,$)=>{r.Ra("LayerNormalization",s,{axis:m,epsilon:g,simplified:!!$})},834901:(s,m,g)=>{r.Ra("InstanceNormalization",s,{epsilon:m,format:g?"NHWC":"NCHW"})},835015:(s,m,g)=>{r.Ra("InstanceNormalization",s,{epsilon:m,format:g?"NHWC":"NCHW"})},835129:s=>{r.Ra("Range",s,void 0)},835182:(s,m)=>{r.Ra("Einsum",s,{equation:je(m)})},835263:(s,m,g,$,T)=>{r.Ra("Pad",s,{mode:m,value:g,pads:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},835390:(s,m,g,$,T,B)=>{r.Ra("BatchNormalization",s,{epsilon:m,momentum:g,spatial:!!T,trainingMode:!!$,format:B?"NHWC":"NCHW"})},835559:(s,m,g,$,T,B)=>{r.Ra("BatchNormalization",s,{epsilon:m,momentum:g,spatial:!!T,trainingMode:!!$,format:B?"NHWC":"NCHW"})},835728:(s,m,g)=>{r.Ra("CumSum",s,{exclusive:Number(m),reverse:Number(g)})},835825:(s,m,g,$,T,B,L,q,te)=>{r.Ra("Attention",s,{numHeads:m,isUnidirectional:g,maskFilterValue:$,scale:T,doRotary:B,qkvHiddenSizes:L?Array.from(W.subarray(Number(q)>>>0,Number(q)+L>>>0)):[],pastPresentShareBuffer:!!te})},836097:s=>{r.Ra("BiasAdd",s,void 0)},836152:s=>{r.Ra("BiasSplitGelu",s,void 0)},836213:s=>{r.Ra("FastGelu",s,void 0)},836269:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe)=>{r.Ra("Conv",s,{format:te?"NHWC":"NCHW",auto_pad:m,dilations:[g],group:$,kernel_shape:[T],pads:B?Array.from(W.subarray(B>>>0,L>>>0)):[],strides:[q],w_is_const:()=>!!N[X>>>0],activation:je(de),activation_params:Ee?Array.from(Ce.subarray(Ee>>>0,Oe>>>0)):[]})},836639:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("Conv",s,{format:Ee?"NHWC":"NCHW",auto_pad:m,dilations:[g,$],group:T,kernel_shape:[B,L],pads:q?Array.from(W.subarray(q>>>0,te>>>0)):[],strides:[X,de],w_is_const:()=>!!N[Oe>>>0],activation:je(D),activation_params:be?Array.from(Ce.subarray(be>>>0,Ie>>>0)):[]})},837030:s=>{r.Ra("Gelu",s,void 0)},837082:(s,m,g,$,T,B)=>{r.Ra("MatMulNBits",s,{k:m,n:g,accuracyLevel:$,bits:T,blockSize:B})},837209:(s,m,g,$,T,B)=>{r.Ra("MultiHeadAttention",s,{numHeads:m,isUnidirectional:g,maskFilterValue:$,scale:T,doRotary:B})},837368:(s,m,g,$,T)=>{r.Ra("RotaryEmbedding",s,{interleaved:!!m,numHeads:g,rotaryEmbeddingDim:$,scale:T})},837507:(s,m,g)=>{r.Ra("SkipLayerNormalization",s,{epsilon:m,simplified:!!g})},837609:(s,m,g)=>{r.Ra("SkipLayerNormalization",s,{epsilon:m,simplified:!!g})},837711:(s,m,g,$)=>{r.Ra("LayerNormalization",s,{axis:m,epsilon:g,simplified:!!$})},837822:s=>{r.ub(s)},837856:(s,m)=>r.wb(s,m,r.cb.xb,r.cb.errors)};function qt(s){this.name="ExitStatus",this.message=`Program terminated with exit(${s})`,this.status=s}class Ut{constructor(m){this.hb=m-24}}var sr=0,jt=0,xr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Kt=(s,m,g)=>{m>>>=0;var $=m+g;for(g=m;s[g]&&!(g>=$);)++g;if(16<g-m&&s.buffer&&xr)return xr.decode(s.subarray(m,g));for($="";m<g;){var T=s[m++];if(T&128){var B=s[m++]&63;if((T&224)==192)$+=String.fromCharCode((T&31)<<6|B);else{var L=s[m++]&63;T=(T&240)==224?(T&15)<<12|B<<6|L:(T&7)<<18|B<<12|L<<6|s[m++]&63,65536>T?$+=String.fromCharCode(T):(T-=65536,$+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else $+=String.fromCharCode(T)}return $},je=(s,m)=>(s>>>=0)?Kt(K,s,m):"",Vt=s=>{for(var m=0,g=0;g<s.length;++g){var $=s.charCodeAt(g);127>=$?m++:2047>=$?m+=2:55296<=$&&57343>=$?(m+=4,++g):m+=3}return m},at=(s,m,g,$)=>{if(g>>>=0,!(0<$))return 0;var T=g;$=g+$-1;for(var B=0;B<s.length;++B){var L=s.charCodeAt(B);if(55296<=L&&57343>=L){var q=s.charCodeAt(++B);L=65536+((L&1023)<<10)|q&1023}if(127>=L){if(g>=$)break;m[g++>>>0]=L}else{if(2047>=L){if(g+1>=$)break;m[g++>>>0]=192|L>>6}else{if(65535>=L){if(g+2>=$)break;m[g++>>>0]=224|L>>12}else{if(g+3>=$)break;m[g++>>>0]=240|L>>18,m[g++>>>0]=128|L>>12&63}m[g++>>>0]=128|L>>6&63}m[g++>>>0]=128|L&63}}return m[g>>>0]=0,g-T},Cr,ft=s=>{for(var m="";K[s>>>0];)m+=Cr[K[s++>>>0]];return m},ur={},Ar={},Ir={},st;function Tr(s,m,g={}){var $=m.name;if(!s)throw new st(`type "${$}" must have a positive integer typeid pointer`);if(Ar.hasOwnProperty(s)){if(g.nb)return;throw new st(`Cannot register type \'${$}\' twice`)}Ar[s]=m,delete Ir[s],ur.hasOwnProperty(s)&&(m=ur[s],delete ur[s],m.forEach(T=>T()))}function ht(s,m,g={}){if(!("argPackAdvance"in m))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Tr(s,m,g)}var bt=(s,m,g)=>{switch(m){case 1:return g?$=>N[$>>>0]:$=>K[$>>>0];case 2:return g?$=>Q[$>>>1>>>0]:$=>he[$>>>1>>>0];case 4:return g?$=>W[$>>>2>>>0]:$=>se[$>>>2>>>0];case 8:return g?$=>We[$>>>3]:$=>ee[$>>>3];default:throw new TypeError(`invalid integer width (${m}): ${s}`)}},Er=[],Te=[];function dr(s){s>>>=0,9<s&&--Te[s+1]===0&&(Te[s]=void 0,Er.push(s))}var Xe=s=>{if(!s)throw new st("Cannot use deleted val. handle = "+s);return Te[s]},ut=s=>{switch(s){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let m=Er.pop()||Te.length;return Te[m]=s,Te[m+1]=1,m}};function lr(s){return this.fromWireType(se[s>>>2>>>0])}var Fn={name:"emscripten::val",fromWireType:s=>{var m=Xe(s);return dr(s),m},toWireType:(s,m)=>ut(m),argPackAdvance:8,readValueFromPointer:lr,bb:null},ge=(s,m)=>{switch(m){case 4:return function(g){return this.fromWireType(Ce[g>>>2>>>0])};case 8:return function(g){return this.fromWireType(ae[g>>>3>>>0])};default:throw new TypeError(`invalid float width (${m}): ${s}`)}},Yt=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,jr=(s,m)=>{for(var g=s>>1,$=g+m/2;!(g>=$)&&he[g>>>0];)++g;if(g<<=1,32<g-s&&Yt)return Yt.decode(K.subarray(s>>>0,g>>>0));for(g="",$=0;!($>=m/2);++$){var T=Q[s+2*$>>>1>>>0];if(T==0)break;g+=String.fromCharCode(T)}return g},qn=(s,m,g)=>{if(g??=2147483647,2>g)return 0;g-=2;var $=m;g=g<2*s.length?g/2:s.length;for(var T=0;T<g;++T)Q[m>>>1>>>0]=s.charCodeAt(T),m+=2;return Q[m>>>1>>>0]=0,m-$},Kr=s=>2*s.length,jn=(s,m)=>{for(var g=0,$="";!(g>=m/4);){var T=W[s+4*g>>>2>>>0];if(T==0)break;++g,65536<=T?(T-=65536,$+=String.fromCharCode(55296|T>>10,56320|T&1023)):$+=String.fromCharCode(T)}return $},Yr=(s,m,g)=>{if(m>>>=0,g??=2147483647,4>g)return 0;var $=m;g=$+g-4;for(var T=0;T<s.length;++T){var B=s.charCodeAt(T);if(55296<=B&&57343>=B){var L=s.charCodeAt(++T);B=65536+((B&1023)<<10)|L&1023}if(W[m>>>2>>>0]=B,m+=4,m+4>g)break}return W[m>>>2>>>0]=0,m-$},Zr=s=>{for(var m=0,g=0;g<s.length;++g){var $=s.charCodeAt(g);55296<=$&&57343>=$&&++g,m+=4}return m},cr=(s,m)=>{var g=Ar[s];if(g===void 0)throw s=Mr(s),g=ft(s),rt(s),new st(`${m} has unknown type ${g}`);return g},Pr=(s,m,g)=>{var $=[];return s=s.toWireType($,g),$.length&&(se[m>>>2>>>0]=ut($)),s},He=s=>{try{s()}catch(m){ne(m)}},Xr=s=>{if(!R)try{s();try{H=H=s=H,r.onExit?.(s),R=!0,h(s,new qt(s))}catch(m){m instanceof qt||m=="unwind"||h(1,m)}}catch(m){m instanceof qt||m=="unwind"||h(1,m)}};function Qr(){var s=pe,m={};for(let[g,$]of Object.entries(s))m[g]=typeof $=="function"?(...T)=>{Zt.push(g);try{return $(...T)}finally{R||(Zt.pop(),dt&&gt===1&&Zt.length===0&&(gt=0,He(dn),typeof Fibers<"u"&&Fibers.Db()))}}:$;return m}var gt=0,dt=null,Rt=0,Zt=[],kr={},Or={},Jr=0,pr=null,en=[];function tn(){return new Promise((s,m)=>{pr={resolve:s,reject:m}})}function rn(){var s=Wt(65548),m=s+12;se[s>>>2>>>0]=m,se[s+4>>>2>>>0]=m+65536,m=Zt[0];var g=kr[m];return g===void 0&&(g=Jr++,kr[m]=g,Or[g]=m),W[s+8>>>2>>>0]=g,s}function nn(s){if(!R){if(gt===0){var m=!1,g=!1;s(($=0)=>{if(!R&&(Rt=$,m=!0,g)){gt=2,He(()=>vt(dt)),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.resume(),$=!1;try{var T=(0,pe[Or[W[dt+8>>>2>>>0]]])()}catch(q){T=q,$=!0}var B=!1;if(!dt){var L=pr;L&&(pr=null,($?L.reject:L.resolve)(T),B=!0)}if($&&!B)throw T}}),g=!0,m||(gt=1,dt=rn(),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.pause(),He(()=>Jt(dt)))}else gt===2?(gt=0,He(ct),rt(dt),dt=null,en.forEach(Xr)):ne(`invalid state: ${gt}`);return Rt}}function Rr(s){return nn(m=>{s().then(m)})}var Xt=[],on={},nt=s=>{var m=on[s];return m===void 0?ft(s):m},mr=()=>typeof globalThis=="object"?globalThis:Function("return this")(),Br=s=>{var m=Xt.length;return Xt.push(s),m},Kn=(s,m)=>{for(var g=Array(s),$=0;$<s;++$)g[$]=cr(se[m+4*$>>>2>>>0],"parameter "+$);return g},wt=(s,m)=>Object.defineProperty(m,"name",{value:s});function Yn(s){var m=Function;if(!(m instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof m} which is not a function`);var g=wt(m.name||"unknownFunctionName",function(){});return g.prototype=m.prototype,g=new g,s=m.apply(g,s),s instanceof Object?s:g}var Je=s=>s%4===0&&(s%100!==0||s%400===0),Dr=[0,31,60,91,121,152,182,213,244,274,305,335],fr=[0,31,59,90,120,151,181,212,243,273,304,334],lt=[],hr=(s,m)=>{lt.length=0;for(var g;g=K[s++>>>0];){var $=g!=105;$&=g!=112,m+=$&&m%8?4:0,lt.push(g==112?se[m>>>2>>>0]:g==106?We[m>>>3]:g==105?W[m>>>2>>>0]:ae[m>>>3>>>0]),m+=$?8:4}return lt},Qe={},ot=()=>{if(!Qt){var s={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"},m;for(m in Qe)Qe[m]===void 0?delete s[m]:s[m]=Qe[m];var g=[];for(m in s)g.push(`${m}=${s[m]}`);Qt=g}return Qt},Qt,Zn=[null,[],[]],an=[31,29,31,30,31,30,31,31,30,31,30,31],zr=[31,28,31,30,31,30,31,31,30,31,30,31];function Xn(s){var m=Array(Vt(s)+1);return at(s,m,0,m.length),m}function sn(s,m,g,$){function T(D,be,Ie){for(D=typeof D=="number"?D.toString():D||"";D.length<be;)D=Ie[0]+D;return D}function B(D,be){return T(D,be,"0")}function L(D,be){function Ie(zt){return 0>zt?-1:0<zt?1:0}var Dt;return(Dt=Ie(D.getFullYear()-be.getFullYear()))===0&&(Dt=Ie(D.getMonth()-be.getMonth()))===0&&(Dt=Ie(D.getDate()-be.getDate())),Dt}function q(D){switch(D.getDay()){case 0:return new Date(D.getFullYear()-1,11,29);case 1:return D;case 2:return new Date(D.getFullYear(),0,3);case 3:return new Date(D.getFullYear(),0,2);case 4:return new Date(D.getFullYear(),0,1);case 5:return new Date(D.getFullYear()-1,11,31);case 6:return new Date(D.getFullYear()-1,11,30)}}function te(D){var be=D.$a;for(D=new Date(new Date(D.ab+1900,0,1).getTime());0<be;){var Ie=D.getMonth(),Dt=(Je(D.getFullYear())?an:zr)[Ie];if(be>Dt-D.getDate())be-=Dt-D.getDate()+1,D.setDate(1),11>Ie?D.setMonth(Ie+1):(D.setMonth(0),D.setFullYear(D.getFullYear()+1));else{D.setDate(D.getDate()+be);break}}return Ie=new Date(D.getFullYear()+1,0,4),be=q(new Date(D.getFullYear(),0,4)),Ie=q(Ie),0>=L(be,D)?0>=L(Ie,D)?D.getFullYear()+1:D.getFullYear():D.getFullYear()-1}s>>>=0,m>>>=0,g>>>=0,$>>>=0;var X=se[$+40>>>2>>>0];$={Ab:W[$>>>2>>>0],zb:W[$+4>>>2>>>0],fb:W[$+8>>>2>>>0],jb:W[$+12>>>2>>>0],gb:W[$+16>>>2>>>0],ab:W[$+20>>>2>>>0],Va:W[$+24>>>2>>>0],$a:W[$+28>>>2>>>0],Cb:W[$+32>>>2>>>0],yb:W[$+36>>>2>>>0],Bb:X?je(X):""},g=je(g),X={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var de in X)g=g.replace(new RegExp(de,"g"),X[de]);var Ee="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Oe="January February March April May June July August September October November December".split(" ");X={"%a":D=>Ee[D.Va].substring(0,3),"%A":D=>Ee[D.Va],"%b":D=>Oe[D.gb].substring(0,3),"%B":D=>Oe[D.gb],"%C":D=>B((D.ab+1900)/100|0,2),"%d":D=>B(D.jb,2),"%e":D=>T(D.jb,2," "),"%g":D=>te(D).toString().substring(2),"%G":te,"%H":D=>B(D.fb,2),"%I":D=>(D=D.fb,D==0?D=12:12<D&&(D-=12),B(D,2)),"%j":D=>{for(var be=0,Ie=0;Ie<=D.gb-1;be+=(Je(D.ab+1900)?an:zr)[Ie++]);return B(D.jb+be,3)},"%m":D=>B(D.gb+1,2),"%M":D=>B(D.zb,2),"%n":()=>`\n`,"%p":D=>0<=D.fb&&12>D.fb?"AM":"PM","%S":D=>B(D.Ab,2),"%t":()=>"	","%u":D=>D.Va||7,"%U":D=>B(Math.floor((D.$a+7-D.Va)/7),2),"%V":D=>{var be=Math.floor((D.$a+7-(D.Va+6)%7)/7);if(2>=(D.Va+371-D.$a-2)%7&&be++,be)be==53&&(Ie=(D.Va+371-D.$a)%7,Ie==4||Ie==3&&Je(D.ab)||(be=1));else{be=52;var Ie=(D.Va+7-D.$a-1)%7;(Ie==4||Ie==5&&Je(D.ab%400-1))&&be++}return B(be,2)},"%w":D=>D.Va,"%W":D=>B(Math.floor((D.$a+7-(D.Va+6)%7)/7),2),"%y":D=>(D.ab+1900).toString().substring(2),"%Y":D=>D.ab+1900,"%z":D=>{D=D.yb;var be=0<=D;return D=Math.abs(D)/60,(be?"+":"-")+("0000"+(D/60*100+D%60)).slice(-4)},"%Z":D=>D.Bb,"%%":()=>"%"},g=g.replace(/%%/g,"\\0\\0");for(de in X)g.includes(de)&&(g=g.replace(new RegExp(de,"g"),X[de]($)));return g=g.replace(/\\0\\0/g,"%"),de=Xn(g),de.length>m?0:(N.set(de,s>>>0),de.length-1)}for(var un=Array(256),gr=0;256>gr;++gr)un[gr]=String.fromCharCode(gr);Cr=un,st=r.BindingError=class extends Error{constructor(s){super(s),this.name="BindingError"}},r.InternalError=class extends Error{constructor(s){super(s),this.name="InternalError"}},Te.push(0,1,void 0,1,null,1,!0,1,!1,1),r.count_emval_handles=()=>Te.length/2-5-Er.length;var Qn={ia:function(s,m,g){return Rr(async()=>{await r.sb(s,m,g)})},a:function(s,m,g){s>>>=0;var $=new Ut(s);throw se[$.hb+16>>>2>>>0]=0,se[$.hb+4>>>2>>>0]=m>>>0,se[$.hb+8>>>2>>>0]=g>>>0,sr=s,jt++,sr},z:function(){return 0},ea:function(){},R:function(){},T:function(){},ga:function(){return 0},ca:function(){},Z:function(){},ba:function(){},G:function(){},S:function(){},P:function(){},da:function(){},Q:function(){},C:function(s,m,g){m=ft(m>>>0),ht(s>>>0,{name:m,fromWireType:$=>$,toWireType:function($,T){if(typeof T!="bigint"&&typeof T!="number")throw T===null?T="null":($=typeof T,T=$==="object"||$==="array"||$==="function"?T.toString():""+T),new TypeError(`Cannot convert "${T}" to ${this.name}`);return typeof T=="number"&&(T=BigInt(T)),T},argPackAdvance:8,readValueFromPointer:bt(m,g>>>0,m.indexOf("u")==-1),bb:null})},K:function(s,m,g,$){m=ft(m>>>0),ht(s>>>0,{name:m,fromWireType:function(T){return!!T},toWireType:function(T,B){return B?g:$},argPackAdvance:8,readValueFromPointer:function(T){return this.fromWireType(K[T>>>0])},bb:null})},J:function(s){return ht(s>>>0,Fn)},B:function(s,m,g){m=ft(m>>>0),ht(s>>>0,{name:m,fromWireType:$=>$,toWireType:($,T)=>T,argPackAdvance:8,readValueFromPointer:ge(m,g>>>0),bb:null})},s:function(s,m,g,$,T){if(s>>>=0,g>>>=0,m=ft(m>>>0),T===-1&&(T=4294967295),T=q=>q,$===0){var B=32-8*g;T=q=>q<<B>>>B}var L=m.includes("unsigned")?function(q,te){return te>>>0}:function(q,te){return te};ht(s,{name:m,fromWireType:T,toWireType:L,argPackAdvance:8,readValueFromPointer:bt(m,g,$!==0),bb:null})},o:function(s,m,g){function $(B){return new T(N.buffer,se[B+4>>>2>>>0],se[B>>>2>>>0])}var T=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][m];g=ft(g>>>0),ht(s>>>0,{name:g,fromWireType:$,argPackAdvance:8,readValueFromPointer:$},{nb:!0})},D:function(s,m){m=ft(m>>>0);var g=m==="std::string";ht(s>>>0,{name:m,fromWireType:function($){var T=se[$>>>2>>>0],B=$+4;if(g)for(var L=B,q=0;q<=T;++q){var te=B+q;if(q==T||K[te>>>0]==0){if(L=je(L,te-L),X===void 0)var X=L;else X+=String.fromCharCode(0),X+=L;L=te+1}}else{for(X=Array(T),q=0;q<T;++q)X[q]=String.fromCharCode(K[B+q>>>0]);X=X.join("")}return rt($),X},toWireType:function($,T){T instanceof ArrayBuffer&&(T=new Uint8Array(T));var B=typeof T=="string";if(!(B||T instanceof Uint8Array||T instanceof Uint8ClampedArray||T instanceof Int8Array))throw new st("Cannot pass non-string to std::string");var L=g&&B?Vt(T):T.length,q=Wt(4+L+1),te=q+4;if(se[q>>>2>>>0]=L,g&&B)at(T,K,te,L+1);else if(B)for(B=0;B<L;++B){var X=T.charCodeAt(B);if(255<X)throw rt(te),new st("String has UTF-16 code units that do not fit in 8 bits");K[te+B>>>0]=X}else for(B=0;B<L;++B)K[te+B>>>0]=T[B];return $!==null&&$.push(rt,q),q},argPackAdvance:8,readValueFromPointer:lr,bb($){rt($)}})},y:function(s,m,g){if(m>>>=0,g>>>=0,g=ft(g),m===2)var $=jr,T=qn,B=Kr,L=q=>he[q>>>1>>>0];else m===4&&($=jn,T=Yr,B=Zr,L=q=>se[q>>>2>>>0]);ht(s>>>0,{name:g,fromWireType:q=>{for(var te=se[q>>>2>>>0],X,de=q+4,Ee=0;Ee<=te;++Ee){var Oe=q+4+Ee*m;(Ee==te||L(Oe)==0)&&(de=$(de,Oe-de),X===void 0?X=de:(X+=String.fromCharCode(0),X+=de),de=Oe+m)}return rt(q),X},toWireType:(q,te)=>{if(typeof te!="string")throw new st(`Cannot pass non-string to C++ string type ${g}`);var X=B(te),de=Wt(4+X+m);return se[de>>>2>>>0]=X/m,T(te,de+4,X+m),q!==null&&q.push(rt,de),de},argPackAdvance:8,readValueFromPointer:lr,bb(q){rt(q)}})},L:function(s,m){m=ft(m>>>0),ht(s>>>0,{ob:!0,name:m,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ha:()=>1,u:function(s,m,g){return m>>>=0,g>>>=0,s=Xe(s>>>0),m=cr(m,"emval::as"),Pr(m,g,s)},x:function(s){return s>>>=0,Rr(()=>(s=Xe(s),s.then(ut)))},n:function(s,m,g,$){return g>>>=0,$>>>=0,s=Xt[s>>>0],m=Xe(m>>>0),s(null,m,g,$)},j:function(s,m,g,$,T){return g>>>=0,$>>>=0,T>>>=0,s=Xt[s>>>0],m=Xe(m>>>0),g=nt(g),s(m,m[g],$,T)},b:dr,w:function(s,m){return m>>>=0,s=Xe(s>>>0),m=Xe(m),s==m},m:function(s){return s>>>=0,s===0?ut(mr()):(s=nt(s),ut(mr()[s]))},i:function(s,m,g){m=Kn(s,m>>>0);var $=m.shift();s--;var T=`return function (obj, func, destructorsRef, args) {\n`,B=0,L=[];g===0&&L.push("obj");for(var q=["retType"],te=[$],X=0;X<s;++X)L.push("arg"+X),q.push("argType"+X),te.push(m[X]),T+=`  var arg${X} = argType${X}.readValueFromPointer(args${B?"+"+B:""});\n`,B+=m[X].argPackAdvance;return T+=`  var rv = ${g===1?"new func":"func.call"}(${L.join(", ")});\n`,$.ob||(q.push("emval_returnValue"),te.push(Pr),T+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),q.push(T+`};\n`),s=Yn(q)(...te),g=`methodCaller<(${m.map(de=>de.name).join(", ")}) => ${$.name}>`,Br(wt(g,s))},r:function(s,m){return m>>>=0,s=Xe(s>>>0),m=Xe(m),ut(s[m])},e:function(s){s>>>=0,9<s&&(Te[s+1]+=1)},t:function(){return ut([])},l:function(s){s=Xe(s>>>0);for(var m=Array(s.length),g=0;g<s.length;g++)m[g]=s[g];return ut(m)},f:function(s){return ut(nt(s>>>0))},k:function(){return ut({})},h:function(s){s>>>=0;for(var m=Xe(s);m.length;){var g=m.pop();m.pop()(g)}dr(s)},g:function(s,m,g){m>>>=0,g>>>=0,s=Xe(s>>>0),m=Xe(m),g=Xe(g),s[m]=g},c:function(s,m){return m>>>=0,s=cr(s>>>0,"_emval_take_value"),s=s.readValueFromPointer(m),ut(s)},W:function(s,m){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),m>>>=0,s=new Date(1e3*s),W[m>>>2>>>0]=s.getUTCSeconds(),W[m+4>>>2>>>0]=s.getUTCMinutes(),W[m+8>>>2>>>0]=s.getUTCHours(),W[m+12>>>2>>>0]=s.getUTCDate(),W[m+16>>>2>>>0]=s.getUTCMonth(),W[m+20>>>2>>>0]=s.getUTCFullYear()-1900,W[m+24>>>2>>>0]=s.getUTCDay(),W[m+28>>>2>>>0]=(s.getTime()-Date.UTC(s.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},X:function(s,m){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),m>>>=0,s=new Date(1e3*s),W[m>>>2>>>0]=s.getSeconds(),W[m+4>>>2>>>0]=s.getMinutes(),W[m+8>>>2>>>0]=s.getHours(),W[m+12>>>2>>>0]=s.getDate(),W[m+16>>>2>>>0]=s.getMonth(),W[m+20>>>2>>>0]=s.getFullYear()-1900,W[m+24>>>2>>>0]=s.getDay(),W[m+28>>>2>>>0]=(Je(s.getFullYear())?Dr:fr)[s.getMonth()]+s.getDate()-1|0,W[m+36>>>2>>>0]=-(60*s.getTimezoneOffset());var g=new Date(s.getFullYear(),6,1).getTimezoneOffset(),$=new Date(s.getFullYear(),0,1).getTimezoneOffset();W[m+32>>>2>>>0]=(g!=$&&s.getTimezoneOffset()==Math.min($,g))|0},Y:function(s){s>>>=0;var m=new Date(W[s+20>>>2>>>0]+1900,W[s+16>>>2>>>0],W[s+12>>>2>>>0],W[s+8>>>2>>>0],W[s+4>>>2>>>0],W[s>>>2>>>0],0),g=W[s+32>>>2>>>0],$=m.getTimezoneOffset(),T=new Date(m.getFullYear(),6,1).getTimezoneOffset(),B=new Date(m.getFullYear(),0,1).getTimezoneOffset(),L=Math.min(B,T);return 0>g?W[s+32>>>2>>>0]=+(T!=B&&L==$):0<g!=(L==$)&&(T=Math.max(B,T),m.setTime(m.getTime()+6e4*((0<g?L:T)-$))),W[s+24>>>2>>>0]=m.getDay(),W[s+28>>>2>>>0]=(Je(m.getFullYear())?Dr:fr)[m.getMonth()]+m.getDate()-1|0,W[s>>>2>>>0]=m.getSeconds(),W[s+4>>>2>>>0]=m.getMinutes(),W[s+8>>>2>>>0]=m.getHours(),W[s+12>>>2>>>0]=m.getDate(),W[s+16>>>2>>>0]=m.getMonth(),W[s+20>>>2>>>0]=m.getYear(),s=m.getTime(),BigInt(isNaN(s)?-1:s/1e3)},U:function(){return-52},V:function(){},N:function(s,m,g,$){g>>>=0,$>>>=0;var T=new Date().getFullYear(),B=new Date(T,0,1),L=new Date(T,6,1);T=B.getTimezoneOffset();var q=L.getTimezoneOffset();se[s>>>0>>>2>>>0]=60*Math.max(T,q),W[m>>>0>>>2>>>0]=+(T!=q),s=te=>te.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],B=s(B),L=s(L),q<T?(at(B,K,g,17),at(L,K,$,17)):(at(B,K,$,17),at(L,K,g,17))},v:()=>{ne("")},d:function(s,m,g){return s>>>=0,m=hr(m>>>0,g>>>0),Ot[s](...m)},I:function(s,m,g){return s>>>=0,m=hr(m>>>0,g>>>0),Ot[s](...m)},H:()=>Date.now(),O:function(){return 4294901760},q:()=>performance.now(),M:function(s){s>>>=0;var m=K.length;if(4294901760<s)return!1;for(var g=1;4>=g;g*=2){var $=m*(1+.2/g);$=Math.min($,s+100663296);var T=Math;$=Math.max(s,$);e:{T=(T.min.call(T,4294901760,$+(65536-$%65536)%65536)-O.buffer.byteLength+65535)/65536;try{O.grow(T),Ae();var B=1;break e}catch{}B=void 0}if(B)return!0}return!1},$:function(s,m){s>>>=0,m>>>=0;var g=0;return ot().forEach(($,T)=>{var B=m+g;for(T=se[s+4*T>>>2>>>0]=B,B=0;B<$.length;++B)N[T++>>>0]=$.charCodeAt(B);N[T>>>0]=0,g+=$.length+1}),0},aa:function(s,m){s>>>=0,m>>>=0;var g=ot();se[s>>>2>>>0]=g.length;var $=0;return g.forEach(T=>$+=T.length+1),se[m>>>2>>>0]=$,0},A:()=>52,F:function(){return 52},_:function(){return 70},E:function(s,m,g,$){m>>>=0,g>>>=0,$>>>=0;for(var T=0,B=0;B<g;B++){var L=se[m>>>2>>>0],q=se[m+4>>>2>>>0];m+=8;for(var te=0;te<q;te++){var X=K[L+te>>>0],de=Zn[s];X===0||X===10?((s===1?E:P)(Kt(de,0)),de.length=0):de.push(X)}T+=q}return se[$>>>2>>>0]=T,0},fa:sn,p:function(s,m,g,$){return sn(s>>>0,m>>>0,g>>>0,$>>>0)}},pe=function(){function s(g){return pe=g.exports,pe=Qr(),pe=ln(),O=pe.ja,Ae(),ie.unshift(pe.ka),le--,le==0&&(qe!==null&&(clearInterval(qe),qe=null),G&&(g=G,G=null,g())),pe}var m={a:Qn};if(le++,r.instantiateWasm)try{return r.instantiateWasm(m,s)}catch(g){P(`Module.instantiateWasm callback failed with error: ${g}`),i(g)}return mt(m,function(g){s(g.instance)}).catch(i),{}}(),Mr=s=>(Mr=pe.la)(s);r._OrtInit=(s,m)=>(r._OrtInit=pe.ma)(s,m),r._OrtGetLastError=(s,m)=>(r._OrtGetLastError=pe.na)(s,m),r._OrtCreateSessionOptions=(s,m,g,$,T,B,L,q,te,X)=>(r._OrtCreateSessionOptions=pe.oa)(s,m,g,$,T,B,L,q,te,X),r._OrtAppendExecutionProvider=(s,m)=>(r._OrtAppendExecutionProvider=pe.pa)(s,m),r._OrtAddFreeDimensionOverride=(s,m,g)=>(r._OrtAddFreeDimensionOverride=pe.qa)(s,m,g),r._OrtAddSessionConfigEntry=(s,m,g)=>(r._OrtAddSessionConfigEntry=pe.ra)(s,m,g),r._OrtReleaseSessionOptions=s=>(r._OrtReleaseSessionOptions=pe.sa)(s),r._OrtCreateSession=(s,m,g)=>(r._OrtCreateSession=pe.ta)(s,m,g),r._OrtReleaseSession=s=>(r._OrtReleaseSession=pe.ua)(s),r._OrtGetInputOutputCount=(s,m,g)=>(r._OrtGetInputOutputCount=pe.va)(s,m,g),r._OrtGetInputName=(s,m)=>(r._OrtGetInputName=pe.wa)(s,m),r._OrtGetOutputName=(s,m)=>(r._OrtGetOutputName=pe.xa)(s,m),r._OrtFree=s=>(r._OrtFree=pe.ya)(s),r._OrtCreateTensor=(s,m,g,$,T,B)=>(r._OrtCreateTensor=pe.za)(s,m,g,$,T,B),r._OrtGetTensorData=(s,m,g,$,T)=>(r._OrtGetTensorData=pe.Aa)(s,m,g,$,T),r._OrtReleaseTensor=s=>(r._OrtReleaseTensor=pe.Ba)(s),r._OrtCreateRunOptions=(s,m,g,$)=>(r._OrtCreateRunOptions=pe.Ca)(s,m,g,$),r._OrtAddRunConfigEntry=(s,m,g)=>(r._OrtAddRunConfigEntry=pe.Da)(s,m,g),r._OrtReleaseRunOptions=s=>(r._OrtReleaseRunOptions=pe.Ea)(s),r._OrtCreateBinding=s=>(r._OrtCreateBinding=pe.Fa)(s),r._OrtBindInput=(s,m,g)=>(r._OrtBindInput=pe.Ga)(s,m,g),r._OrtBindOutput=(s,m,g,$)=>(r._OrtBindOutput=pe.Ha)(s,m,g,$),r._OrtClearBoundOutputs=s=>(r._OrtClearBoundOutputs=pe.Ia)(s),r._OrtReleaseBinding=s=>(r._OrtReleaseBinding=pe.Ja)(s),r._OrtRunWithBinding=(s,m,g,$,T)=>(r._OrtRunWithBinding=pe.Ka)(s,m,g,$,T),r._OrtRun=(s,m,g,$,T,B,L,q)=>(r._OrtRun=pe.La)(s,m,g,$,T,B,L,q),r._OrtEndProfiling=s=>(r._OrtEndProfiling=pe.Ma)(s),r._JsepOutput=(s,m,g)=>(r._JsepOutput=pe.Na)(s,m,g),r._JsepGetNodeName=s=>(r._JsepGetNodeName=pe.Oa)(s);var Wt=r._malloc=s=>(Wt=r._malloc=pe.Pa)(s),rt=r._free=s=>(rt=r._free=pe.Qa)(s),yr=s=>(yr=pe.Sa)(s),br=s=>(br=pe.Ta)(s),Ur=()=>(Ur=pe.Ua)(),Jt=s=>(Jt=pe.Wa)(s),dn=()=>(dn=pe.Xa)(),vt=s=>(vt=pe.Ya)(s),ct=()=>(ct=pe.Za)();r.___start_em_js=837968,r.___stop_em_js=838129;function ln(){var s=pe;s=Object.assign({},s);var m=g=>$=>g($)>>>0;return s.la=m(s.la),s.Pa=m(s.Pa),s.Ta=m(s.Ta),s.Ua=(g=>()=>g()>>>0)(s.Ua),s}r.stackSave=()=>Ur(),r.stackRestore=s=>yr(s),r.stackAlloc=s=>br(s),r.UTF8ToString=je,r.stringToUTF8=(s,m,g)=>at(s,K,m,g),r.lengthBytesUTF8=Vt;var Bt;G=function s(){Bt||Vr(),Bt||(G=s)};function Vr(){if(!(0<le)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;){var s=r.preRun.shift();me.unshift(s)}for(;0<me.length;)me.shift()(r);if(!(0<le||Bt||(Bt=!0,r.calledRun=!0,R))){for(;0<ie.length;)ie.shift()(r);for(o(r);0<ue.length;)ue.shift()(r)}}}return Vr(),u}})();typeof Ti=="object"&&typeof po=="object"?po.exports=Ii:typeof define=="function"&&define.amd&&define([],()=>Ii)});var Pi=Wr(()=>{});var ki=Wr(()=>{});var Oi={};gn(Oi,{cpus:()=>ll});var ll,Ri=Y(()=>{ll=void 0});var zi=Wr((Di,mo)=>{"use strict";var Bi=(()=>{var e=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(e||=__filename),function(t={}){function r(){return ae.buffer!=ue.buffer&&Ne(),ue}function o(){return ae.buffer!=ue.buffer&&Ne(),le}function i(){return ae.buffer!=ue.buffer&&Ne(),qe}function u(){return ae.buffer!=ue.buffer&&Ne(),G}function a(){return ae.buffer!=ue.buffer&&Ne(),ne}function c(){return ae.buffer!=ue.buffer&&Ne(),xe}function p(){return ae.buffer!=ue.buffer&&Ne(),Ke}function h(){return ae.buffer!=ue.buffer&&Ne(),Mt}var d=t,y,w,_=new Promise((n,l)=>{y=n,w=l});d.mountExternalData=(n,l)=>{(d.Db||(d.Db=new Map)).set(n,l)},d.unmountExternalData=()=>{delete d.Db};let v=()=>{let n=(f,b,C)=>(...k)=>{let V=ct,F=b?.();k=f(...k);let re=b?.();return F!==re&&(f=re,C(F),b=C=null),ct!=V?T():k},l=f=>async(...b)=>{try{if(d.Cb)throw Error("Session already started");let C=d.Cb={ec:b[0],errors:[]},k=await f(...b);if(d.Cb!==C)throw Error("Session mismatch");d.Kb?.flush();let V=C.errors;if(0<V.length){let F=await Promise.all(V);if(F=F.filter(re=>re),0<F.length)throw Error(F.join(`\n`))}return k}finally{d.Cb=null}};d._OrtCreateSession=n(d._OrtCreateSession,()=>d._OrtCreateSession,f=>d._OrtCreateSession=f),d._OrtRun=l(n(d._OrtRun,()=>d._OrtRun,f=>d._OrtRun=f)),d._OrtRunWithBinding=l(n(d._OrtRunWithBinding,()=>d._OrtRunWithBinding,f=>d._OrtRunWithBinding=f)),d._OrtBindInput=n(d._OrtBindInput,()=>d._OrtBindInput,f=>d._OrtBindInput=f),v=void 0};d.jsepInit=(n,l)=>{if(v?.(),n==="webgpu"){[d.Kb,d.Wb,d.$b,d.Lb,d.Zb,d.ob,d.ac,d.cc,d.Xb,d.Yb,d.bc]=l;let f=d.Kb;d.jsepRegisterBuffer=(b,C,k,V)=>f.registerBuffer(b,C,k,V),d.jsepGetBuffer=b=>f.getBuffer(b),d.jsepCreateDownloader=(b,C,k)=>f.createDownloader(b,C,k),d.jsepOnReleaseSession=b=>{f.onReleaseSession(b)},d.jsepOnRunStart=b=>f.onRunStart(b)}};var S=Object.assign({},d),I="./this.program",A=(n,l)=>{throw l},x=typeof window=="object",E=typeof importScripts=="function",P=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",O=d.ENVIRONMENT_IS_PTHREAD||!1,R="";function H(n){return d.locateFile?d.locateFile(n,R):R+n}var N,K,Q;if(P){var he=(uo(),wr(so)),W=(co(),wr(lo));R=E?W.dirname(R)+"/":__dirname+"/",N=(n,l)=>(n=Vt(n)?new URL(n):W.normalize(n),he.readFileSync(n,l?void 0:"utf8")),Q=n=>(n=N(n,!0),n.buffer||(n=new Uint8Array(n)),n),K=(n,l,f,b=!0)=>{n=Vt(n)?new URL(n):W.normalize(n),he.readFile(n,b?void 0:"utf8",(C,k)=>{C?f(C):l(b?k.buffer:k)})},!d.thisProgram&&1<process.argv.length&&(I=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),A=(n,l)=>{throw process.exitCode=n,l},global.Worker=Pi().Worker}else(x||E)&&(E?R=self.location.href:typeof document<"u"&&document.currentScript&&(R=document.currentScript.src),typeof e<"u"&&e&&(R=e),R.startsWith("blob:")?R="":R=R.substr(0,R.replace(/[?#].*/,"").lastIndexOf("/")+1),P||(N=n=>{var l=new XMLHttpRequest;return l.open("GET",n,!1),l.send(null),l.responseText},E&&(Q=n=>{var l=new XMLHttpRequest;return l.open("GET",n,!1),l.responseType="arraybuffer",l.send(null),new Uint8Array(l.response)}),K=(n,l,f)=>{var b=new XMLHttpRequest;b.open("GET",n,!0),b.responseType="arraybuffer",b.onload=()=>{b.status==200||b.status==0&&b.response?l(b.response):f()},b.onerror=f,b.send(null)}));P&&typeof performance>"u"&&(global.performance=ki().performance);var se=console.log.bind(console),Ce=console.error.bind(console);P&&(se=(...n)=>he.writeSync(1,n.join(" ")+`\n`),Ce=(...n)=>he.writeSync(2,n.join(" ")+`\n`));var We=se,ee=Ce;Object.assign(d,S),S=null;var ae,Ae,me=!1,ie,ue,le,qe,G,ne,xe,Ke,De,Ge,Mt;function Ne(){var n=ae.buffer;d.HEAP8=ue=new Int8Array(n),d.HEAP16=qe=new Int16Array(n),d.HEAPU8=le=new Uint8Array(n),d.HEAPU16=G=new Uint16Array(n),d.HEAP32=ne=new Int32Array(n),d.HEAPU32=xe=new Uint32Array(n),d.HEAPF32=Ke=new Float32Array(n),d.HEAPF64=Mt=new Float64Array(n),d.HEAP64=De=new BigInt64Array(n),d.HEAPU64=Ge=new BigUint64Array(n)}var Ye=16777216;if(O)ae=d.wasmMemory;else if(d.wasmMemory)ae=d.wasmMemory;else if(ae=new WebAssembly.Memory({initial:Ye/65536,maximum:65536,shared:!0}),!(ae.buffer instanceof SharedArrayBuffer))throw ee("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),P&&ee("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Ne(),Ye=ae.buffer.byteLength;var mt=[],Ot=[],qt=[],Ut=0,sr=null,jt=null;function xr(){if(Ut--,Ut==0&&(sr!==null&&(clearInterval(sr),sr=null),jt)){var n=jt;jt=null,n()}}function Kt(n){throw n="Aborted("+n+")",ee(n),me=!0,ie=1,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),w(n),n}var je=n=>n.startsWith("data:application/octet-stream;base64,"),Vt=n=>n.startsWith("file://"),at;at="ort-wasm-simd-threaded.wasm",je(at)||(at=H(at));function Cr(n){if(Q)return Q(n);throw"both async and sync fetching of the wasm failed"}function ft(n){if(x||E){if(typeof fetch=="function"&&!Vt(n))return fetch(n,{credentials:"same-origin"}).then(l=>{if(!l.ok)throw`failed to load wasm binary file at \'${n}\'`;return l.arrayBuffer()}).catch(()=>Cr(n));if(K)return new Promise((l,f)=>{K(n,b=>l(new Uint8Array(b)),f)})}return Promise.resolve().then(()=>Cr(n))}function ur(n,l,f){return ft(n).then(b=>WebAssembly.instantiate(b,l)).then(f,b=>{ee(`failed to asynchronously prepare wasm: ${b}`),Kt(b)})}function Ar(n,l){var f=at;return typeof WebAssembly.instantiateStreaming!="function"||je(f)||Vt(f)||P||typeof fetch!="function"?ur(f,n,l):fetch(f,{credentials:"same-origin"}).then(b=>WebAssembly.instantiateStreaming(b,n).then(l,function(C){return ee(`wasm streaming compile failed: ${C}`),ee("falling back to ArrayBuffer instantiation"),ur(f,n,l)}))}var Ir={826468:(n,l,f,b)=>{if(typeof d>"u"||!d.Db)return 1;if(n=He(n>>>0),n.startsWith("./")&&(n=n.substring(2)),n=d.Db.get(n),!n)return 2;if(l>>>=0,f>>>=0,b>>>=0,l+f>n.byteLength)return 3;try{return o().set(n.subarray(l,l+f),b>>>0),0}catch{return 4}},826969:()=>{d.Xb()},827e3:()=>{d.Yb()},827029:()=>{d.bc()},827054:n=>d.Wb(n),827087:n=>d.$b(n),827119:(n,l,f)=>{d.Lb(n,l,f,!0)},827158:(n,l,f)=>{d.Lb(n,l,f)},827191:n=>{d.ob("Abs",n,void 0)},827242:n=>{d.ob("Neg",n,void 0)},827293:n=>{d.ob("Floor",n,void 0)},827346:n=>{d.ob("Ceil",n,void 0)},827398:n=>{d.ob("Reciprocal",n,void 0)},827456:n=>{d.ob("Sqrt",n,void 0)},827508:n=>{d.ob("Exp",n,void 0)},827559:n=>{d.ob("Erf",n,void 0)},827610:n=>{d.ob("Sigmoid",n,void 0)},827665:(n,l,f)=>{d.ob("HardSigmoid",n,{alpha:l,beta:f})},827744:n=>{d.ob("Log",n,void 0)},827795:n=>{d.ob("Sin",n,void 0)},827846:n=>{d.ob("Cos",n,void 0)},827897:n=>{d.ob("Tan",n,void 0)},827948:n=>{d.ob("Asin",n,void 0)},828e3:n=>{d.ob("Acos",n,void 0)},828052:n=>{d.ob("Atan",n,void 0)},828104:n=>{d.ob("Sinh",n,void 0)},828156:n=>{d.ob("Cosh",n,void 0)},828208:n=>{d.ob("Asinh",n,void 0)},828261:n=>{d.ob("Acosh",n,void 0)},828314:n=>{d.ob("Atanh",n,void 0)},828367:n=>{d.ob("Tanh",n,void 0)},828419:n=>{d.ob("Not",n,void 0)},828470:(n,l,f)=>{d.ob("Clip",n,{min:l,max:f})},828539:n=>{d.ob("Clip",n,void 0)},828591:(n,l)=>{d.ob("Elu",n,{alpha:l})},828649:n=>{d.ob("Relu",n,void 0)},828701:(n,l)=>{d.ob("LeakyRelu",n,{alpha:l})},828765:(n,l)=>{d.ob("ThresholdedRelu",n,{alpha:l})},828835:(n,l)=>{d.ob("Cast",n,{to:l})},828893:n=>{d.ob("Add",n,void 0)},828944:n=>{d.ob("Sub",n,void 0)},828995:n=>{d.ob("Mul",n,void 0)},829046:n=>{d.ob("Div",n,void 0)},829097:n=>{d.ob("Pow",n,void 0)},829148:n=>{d.ob("Equal",n,void 0)},829201:n=>{d.ob("Greater",n,void 0)},829256:n=>{d.ob("GreaterOrEqual",n,void 0)},829318:n=>{d.ob("Less",n,void 0)},829370:n=>{d.ob("LessOrEqual",n,void 0)},829429:(n,l,f,b,C)=>{d.ob("ReduceMean",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},829588:(n,l,f,b,C)=>{d.ob("ReduceMax",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},829746:(n,l,f,b,C)=>{d.ob("ReduceMin",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},829904:(n,l,f,b,C)=>{d.ob("ReduceProd",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830063:(n,l,f,b,C)=>{d.ob("ReduceSum",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830221:(n,l,f,b,C)=>{d.ob("ReduceL1",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830378:(n,l,f,b,C)=>{d.ob("ReduceL2",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830535:(n,l,f,b,C)=>{d.ob("ReduceLogSum",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830696:(n,l,f,b,C)=>{d.ob("ReduceSumSquare",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830860:(n,l,f,b,C)=>{d.ob("ReduceLogSumExp",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},831024:n=>{d.ob("Where",n,void 0)},831077:(n,l,f)=>{d.ob("Transpose",n,{perm:l?Array.from(a().subarray(l>>>0,f>>>0)):[]})},831185:(n,l,f,b)=>{d.ob("DepthToSpace",n,{blocksize:l,mode:He(f),format:b?"NHWC":"NCHW"})},831318:(n,l,f,b)=>{d.ob("DepthToSpace",n,{blocksize:l,mode:He(f),format:b?"NHWC":"NCHW"})},831451:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we)=>{d.ob("ConvTranspose",n,{format:re?"NHWC":"NCHW",autoPad:l,dilations:[f],group:b,kernelShape:[C],pads:[k,V],strides:[F],wIsConst:()=>!!r()[J>>>0],outputPadding:ce?Array.from(a().subarray(ce>>>0,Re>>>0)):[],outputShape:ze?Array.from(a().subarray(ze>>>0,z>>>0)):[],activation:He(we)})},831852:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z)=>{d.ob("ConvTranspose",n,{format:F?"NHWC":"NCHW",autoPad:l,dilations:Array.from(a().subarray(f>>>0,(f>>>0)+2>>>0)),group:b,kernelShape:Array.from(a().subarray(C>>>0,(C>>>0)+2>>>0)),pads:Array.from(a().subarray(k>>>0,(k>>>0)+4>>>0)),strides:Array.from(a().subarray(V>>>0,(V>>>0)+2>>>0)),wIsConst:()=>!!r()[re>>>0],outputPadding:J?Array.from(a().subarray(J>>>0,ce>>>0)):[],outputShape:Re?Array.from(a().subarray(Re>>>0,ze>>>0)):[],activation:He(z)})},832417:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we)=>{d.ob("ConvTranspose",n,{format:re?"NHWC":"NCHW",autoPad:l,dilations:[f],group:b,kernelShape:[C],pads:[k,V],strides:[F],wIsConst:()=>!!r()[J>>>0],outputPadding:ce?Array.from(a().subarray(ce>>>0,Re>>>0)):[],outputShape:ze?Array.from(a().subarray(ze>>>0,z>>>0)):[],activation:He(we)})},832818:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z)=>{d.ob("ConvTranspose",n,{format:F?"NHWC":"NCHW",autoPad:l,dilations:Array.from(a().subarray(f>>>0,(f>>>0)+2>>>0)),group:b,kernelShape:Array.from(a().subarray(C>>>0,(C>>>0)+2>>>0)),pads:Array.from(a().subarray(k>>>0,(k>>>0)+4>>>0)),strides:Array.from(a().subarray(V>>>0,(V>>>0)+2>>>0)),wIsConst:()=>!!r()[re>>>0],outputPadding:J?Array.from(a().subarray(J>>>0,ce>>>0)):[],outputShape:Re?Array.from(a().subarray(Re>>>0,ze>>>0)):[],activation:He(z)})},833383:(n,l)=>{d.ob("GlobalAveragePool",n,{format:l?"NHWC":"NCHW"})},833474:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("AveragePool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},833758:(n,l)=>{d.ob("GlobalAveragePool",n,{format:l?"NHWC":"NCHW"})},833849:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("AveragePool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},834133:(n,l)=>{d.ob("GlobalMaxPool",n,{format:l?"NHWC":"NCHW"})},834220:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("MaxPool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},834500:(n,l)=>{d.ob("GlobalMaxPool",n,{format:l?"NHWC":"NCHW"})},834587:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("MaxPool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},834867:(n,l,f,b,C)=>{d.ob("Gemm",n,{alpha:l,beta:f,transA:b,transB:C})},834971:n=>{d.ob("MatMul",n,void 0)},835025:(n,l,f,b)=>{d.ob("ArgMax",n,{keepDims:!!l,selectLastIndex:!!f,axis:b})},835133:(n,l,f,b)=>{d.ob("ArgMin",n,{keepDims:!!l,selectLastIndex:!!f,axis:b})},835241:(n,l)=>{d.ob("Softmax",n,{axis:l})},835304:(n,l)=>{d.ob("Concat",n,{axis:l})},835364:(n,l,f,b,C)=>{d.ob("Split",n,{axis:l,numOutputs:f,splitSizes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},835504:n=>{d.ob("Expand",n,void 0)},835558:(n,l)=>{d.ob("Gather",n,{axis:Number(l)})},835629:(n,l)=>{d.ob("GatherElements",n,{axis:Number(l)})},835708:(n,l,f,b,C,k,V,F,re,J,ce)=>{d.ob("Resize",n,{antialias:l,axes:f?Array.from(a().subarray(f>>>0,b>>>0)):[],coordinateTransformMode:He(C),cubicCoeffA:k,excludeOutside:V,extrapolationValue:F,keepAspectRatioPolicy:He(re),mode:He(J),nearestMode:He(ce)})},836054:(n,l,f,b,C,k,V)=>{d.ob("Slice",n,{starts:l?Array.from(a().subarray(l>>>0,f>>>0)):[],ends:b?Array.from(a().subarray(b>>>0,C>>>0)):[],axes:k?Array.from(a().subarray(k>>>0,V>>>0)):[]})},836270:n=>{d.ob("Tile",n,void 0)},836322:(n,l,f,b)=>{d.ob("LayerNormalization",n,{axis:l,epsilon:f,simplified:!!b})},836433:(n,l,f)=>{d.ob("InstanceNormalization",n,{epsilon:l,format:f?"NHWC":"NCHW"})},836547:(n,l,f)=>{d.ob("InstanceNormalization",n,{epsilon:l,format:f?"NHWC":"NCHW"})},836661:n=>{d.ob("Range",n,void 0)},836714:(n,l)=>{d.ob("Einsum",n,{equation:He(l)})},836795:(n,l,f,b,C)=>{d.ob("Pad",n,{mode:l,value:f,pads:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},836922:(n,l,f,b,C,k)=>{d.ob("BatchNormalization",n,{epsilon:l,momentum:f,spatial:!!C,trainingMode:!!b,format:k?"NHWC":"NCHW"})},837091:(n,l,f,b,C,k)=>{d.ob("BatchNormalization",n,{epsilon:l,momentum:f,spatial:!!C,trainingMode:!!b,format:k?"NHWC":"NCHW"})},837260:(n,l,f)=>{d.ob("CumSum",n,{exclusive:Number(l),reverse:Number(f)})},837357:(n,l,f,b,C,k,V,F,re)=>{d.ob("Attention",n,{numHeads:l,isUnidirectional:f,maskFilterValue:b,scale:C,doRotary:k,qkvHiddenSizes:V?Array.from(a().subarray(Number(F)>>>0,Number(F)+V>>>0)):[],pastPresentShareBuffer:!!re})},837629:n=>{d.ob("BiasAdd",n,void 0)},837684:n=>{d.ob("BiasSplitGelu",n,void 0)},837745:n=>{d.ob("FastGelu",n,void 0)},837801:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze)=>{d.ob("Conv",n,{format:re?"NHWC":"NCHW",auto_pad:l,dilations:[f],group:b,kernel_shape:[C],pads:k?Array.from(a().subarray(k>>>0,V>>>0)):[],strides:[F],w_is_const:()=>!!r()[J>>>0],activation:He(ce),activation_params:Re?Array.from(p().subarray(Re>>>0,ze>>>0)):[]})},838171:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("Conv",n,{format:Re?"NHWC":"NCHW",auto_pad:l,dilations:[f,b],group:C,kernel_shape:[k,V],pads:F?Array.from(a().subarray(F>>>0,re>>>0)):[],strides:[J,ce],w_is_const:()=>!!r()[ze>>>0],activation:He(z),activation_params:we?Array.from(p().subarray(we>>>0,Pe>>>0)):[]})},838562:n=>{d.ob("Gelu",n,void 0)},838614:(n,l,f,b,C,k)=>{d.ob("MatMulNBits",n,{k:l,n:f,accuracyLevel:b,bits:C,blockSize:k})},838741:(n,l,f,b,C,k)=>{d.ob("MultiHeadAttention",n,{numHeads:l,isUnidirectional:f,maskFilterValue:b,scale:C,doRotary:k})},838900:(n,l,f,b,C)=>{d.ob("RotaryEmbedding",n,{interleaved:!!l,numHeads:f,rotaryEmbeddingDim:b,scale:C})},839039:(n,l,f)=>{d.ob("SkipLayerNormalization",n,{epsilon:l,simplified:!!f})},839141:(n,l,f)=>{d.ob("SkipLayerNormalization",n,{epsilon:l,simplified:!!f})},839243:(n,l,f,b)=>{d.ob("LayerNormalization",n,{axis:l,epsilon:f,simplified:!!b})},839354:n=>{d.ac(n)},839388:(n,l)=>d.cc(n,l,d.Cb.ec,d.Cb.errors)};function st(n){this.name="ExitStatus",this.message=`Program terminated with exit(${n})`,this.status=n}var Tr=n=>{n.terminate(),n.onmessage=()=>{}},ht=n=>{ge.xb.length==0&&(lr(),ge.Mb(ge.xb[0]));var l=ge.xb.pop();if(!l)return 6;ge.yb.push(l),ge.ub[n.wb]=l,l.wb=n.wb;var f={cmd:"run",start_routine:n.fc,arg:n.Rb,pthread_ptr:n.wb};return P&&l.unref(),l.postMessage(f,n.mc),0},bt=0,Er=n=>{var l=io();return n=n(),fn(l),n},Te=(n,l,...f)=>Er(()=>{for(var b=2*f.length,C=oo(8*b),k=C>>>3,V=0;V<f.length;V++){var F=f[V];typeof F=="bigint"?(De[k+2*V]=1n,De[k+2*V+1]=F):(De[k+2*V]=0n,h()[k+2*V+1>>>0]=F)}return gi(n,0,b,C,l)});function dr(n){if(O)return Te(0,1,n);ie=n,0<bt||(ge.hc(),d.onExit?.(n),me=!0),A(n,new st(n))}var Xe=n=>{if(ie=n,O)throw jr(n),"unwind";dr(n)};function ut(){for(var n=d.numThreads;n--;)lr();mt.unshift(()=>{Ut++,Fn(()=>xr())})}function lr(){var n=H("ort-wasm-simd-threaded.worker.js");n=new Worker(n),ge.xb.push(n)}function Fn(n){O?n():Promise.all(ge.xb.map(ge.Mb)).then(n)}var ge={xb:[],yb:[],Qb:[],ub:{},Gb(){O?(ge.receiveObjectTransfer=ge.dc,ge.threadInitTLS=ge.Pb,ge.setExitStatus=ge.Ob):ut()},Ob:n=>ie=n,pc:["$terminateWorker"],hc:()=>{for(var n of ge.yb)Tr(n);for(n of ge.xb)Tr(n);ge.xb=[],ge.yb=[],ge.ub=[]},Nb:n=>{var l=n.wb;delete ge.ub[l],ge.xb.push(n),ge.yb.splice(ge.yb.indexOf(n),1),n.wb=0,ro(l)},dc(){},Pb(){ge.Qb.forEach(n=>n())},Mb:n=>new Promise(l=>{n.onmessage=k=>{k=k.data;var V=k.cmd;if(k.targetThread&&k.targetThread!=pn()){var F=ge.ub[k.targetThread];F?F.postMessage(k,k.transferList):ee(`Internal error! Worker sent a message "${V}" to target pthread ${k.targetThread}, but that thread no longer exists!`)}else V==="checkMailbox"?rt():V==="spawnThread"?ht(k):V==="cleanupThread"?ge.Nb(ge.ub[k.thread]):V==="killThread"?(k=k.thread,V=ge.ub[k],delete ge.ub[k],Tr(V),ro(k),ge.yb.splice(ge.yb.indexOf(V),1),V.wb=0):V==="cancelThread"?ge.ub[k.thread].postMessage({cmd:"cancel"}):V==="loaded"?(n.loaded=!0,P&&!n.wb&&n.unref(),l(n)):V==="alert"?alert(`Thread ${k.threadId}: ${k.text}`):k.target==="setimmediate"?n.postMessage(k):V==="callHandler"?d[k.handler](...k.args):V&&ee(`worker sent an unknown command ${V}`)},n.onerror=k=>{throw ee(`worker sent an error! ${k.filename}:${k.lineno}: ${k.message}`),k},P&&(n.on("message",k=>n.onmessage({data:k})),n.on("error",k=>n.onerror(k)));var f=[],b=["onExit"],C;for(C of b)d.hasOwnProperty(C)&&f.push(C);n.postMessage({cmd:"load",handlers:f,urlOrBlob:d.mainScriptUrlOrBlob||e,wasmMemory:ae,wasmModule:Ae})})};d.PThread=ge;var Yt=n=>{for(;0<n.length;)n.shift()(d)};d.establishStackSpace=()=>{var n=pn(),l=c()[n+52>>>2>>>0];n=c()[n+56>>>2>>>0],bi(l,l-n),fn(l)};function jr(n){if(O)return Te(1,0,n);Xe(n)}d.invokeEntryPoint=(n,l)=>{bt=0,n=wi(n,l),0<bt?ge.Ob(n):no(n)};class qn{constructor(l){this.Ib=l-24}Gb(l,f){c()[this.Ib+16>>>2>>>0]=0,c()[this.Ib+4>>>2>>>0]=l,c()[this.Ib+8>>>2>>>0]=f}}var Kr=0,jn=0;function Yr(n,l,f,b){return O?Te(2,1,n,l,f,b):Zr(n,l,f,b)}function Zr(n,l,f,b){if(n>>>=0,l>>>=0,f>>>=0,b>>>=0,typeof SharedArrayBuffer>"u")return ee("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var C=[];return O&&C.length===0?Yr(n,l,f,b):(n={fc:f,wb:n,Rb:b,mc:C},O?(n.oc="spawnThread",postMessage(n,C),0):ht(n))}var cr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Pr=(n,l,f)=>{l>>>=0;var b=l+f;for(f=l;n[f]&&!(f>=b);)++f;if(16<f-l&&n.buffer&&cr)return cr.decode(n.buffer instanceof SharedArrayBuffer?n.slice(l,f):n.subarray(l,f));for(b="";l<f;){var C=n[l++];if(C&128){var k=n[l++]&63;if((C&224)==192)b+=String.fromCharCode((C&31)<<6|k);else{var V=n[l++]&63;C=(C&240)==224?(C&15)<<12|k<<6|V:(C&7)<<18|k<<12|V<<6|n[l++]&63,65536>C?b+=String.fromCharCode(C):(C-=65536,b+=String.fromCharCode(55296|C>>10,56320|C&1023))}}else b+=String.fromCharCode(C)}return b},He=(n,l)=>(n>>>=0)?Pr(o(),n,l):"";function Xr(n,l,f){return O?Te(3,1,n,l,f):0}function Qr(n,l){if(O)return Te(4,1,n,l)}var gt=n=>{for(var l=0,f=0;f<n.length;++f){var b=n.charCodeAt(f);127>=b?l++:2047>=b?l+=2:55296<=b&&57343>=b?(l+=4,++f):l+=3}return l},dt=(n,l,f,b)=>{if(f>>>=0,!(0<b))return 0;var C=f;b=f+b-1;for(var k=0;k<n.length;++k){var V=n.charCodeAt(k);if(55296<=V&&57343>=V){var F=n.charCodeAt(++k);V=65536+((V&1023)<<10)|F&1023}if(127>=V){if(f>=b)break;l[f++>>>0]=V}else{if(2047>=V){if(f+1>=b)break;l[f++>>>0]=192|V>>6}else{if(65535>=V){if(f+2>=b)break;l[f++>>>0]=224|V>>12}else{if(f+3>=b)break;l[f++>>>0]=240|V>>18,l[f++>>>0]=128|V>>12&63}l[f++>>>0]=128|V>>6&63}l[f++>>>0]=128|V&63}}return l[f>>>0]=0,f-C},Rt=(n,l,f)=>dt(n,o(),l,f);function Zt(n,l){if(O)return Te(5,1,n,l)}function kr(n,l,f){if(O)return Te(6,1,n,l,f)}function Or(n,l,f){return O?Te(7,1,n,l,f):0}function Jr(n,l){if(O)return Te(8,1,n,l)}function pr(n,l,f){if(O)return Te(9,1,n,l,f)}function en(n,l,f,b){if(O)return Te(10,1,n,l,f,b)}function tn(n,l,f,b){if(O)return Te(11,1,n,l,f,b)}function rn(n,l,f,b){if(O)return Te(12,1,n,l,f,b)}function nn(n){if(O)return Te(13,1,n)}function Rr(n,l){if(O)return Te(14,1,n,l)}function Xt(n,l,f){if(O)return Te(15,1,n,l,f)}var on,nt=n=>{for(var l="";o()[n>>>0];)l+=on[o()[n++>>>0]];return l},mr={},Br={},Kn={},wt;function Yn(n,l,f={}){var b=l.name;if(!n)throw new wt(`type "${b}" must have a positive integer typeid pointer`);if(Br.hasOwnProperty(n)){if(f.Ub)return;throw new wt(`Cannot register type \'${b}\' twice`)}Br[n]=l,delete Kn[n],mr.hasOwnProperty(n)&&(l=mr[n],delete mr[n],l.forEach(C=>C()))}function Je(n,l,f={}){if(!("argPackAdvance"in l))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Yn(n,l,f)}var Dr=(n,l,f)=>{switch(l){case 1:return f?b=>r()[b>>>0]:b=>o()[b>>>0];case 2:return f?b=>i()[b>>>1>>>0]:b=>u()[b>>>1>>>0];case 4:return f?b=>a()[b>>>2>>>0]:b=>c()[b>>>2>>>0];case 8:return f?b=>De[b>>>3]:b=>Ge[b>>>3];default:throw new TypeError(`invalid integer width (${l}): ${n}`)}},fr=[],lt=[];function hr(n){n>>>=0,9<n&&--lt[n+1]===0&&(lt[n]=void 0,fr.push(n))}var Qe=n=>{if(!n)throw new wt("Cannot use deleted val. handle = "+n);return lt[n]},ot=n=>{switch(n){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let l=fr.pop()||lt.length;return lt[l]=n,lt[l+1]=1,l}};function Qt(n){return this.fromWireType(c()[n>>>2>>>0])}var Zn={name:"emscripten::val",fromWireType:n=>{var l=Qe(n);return hr(n),l},toWireType:(n,l)=>ot(l),argPackAdvance:8,readValueFromPointer:Qt,Bb:null},an=(n,l)=>{switch(l){case 4:return function(f){return this.fromWireType(p()[f>>>2>>>0])};case 8:return function(f){return this.fromWireType(h()[f>>>3>>>0])};default:throw new TypeError(`invalid float width (${l}): ${n}`)}},zr=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Xn=(n,l)=>{for(var f=n>>1,b=f+l/2;!(f>=b)&&u()[f>>>0];)++f;if(f<<=1,32<f-n&&zr)return zr.decode(o().slice(n,f));for(f="",b=0;!(b>=l/2);++b){var C=i()[n+2*b>>>1>>>0];if(C==0)break;f+=String.fromCharCode(C)}return f},sn=(n,l,f)=>{if(f??=2147483647,2>f)return 0;f-=2;var b=l;f=f<2*n.length?f/2:n.length;for(var C=0;C<f;++C){var k=n.charCodeAt(C);i()[l>>>1>>>0]=k,l+=2}return i()[l>>>1>>>0]=0,l-b},un=n=>2*n.length,gr=(n,l)=>{for(var f=0,b="";!(f>=l/4);){var C=a()[n+4*f>>>2>>>0];if(C==0)break;++f,65536<=C?(C-=65536,b+=String.fromCharCode(55296|C>>10,56320|C&1023)):b+=String.fromCharCode(C)}return b},Qn=(n,l,f)=>{if(l>>>=0,f??=2147483647,4>f)return 0;var b=l;f=b+f-4;for(var C=0;C<n.length;++C){var k=n.charCodeAt(C);if(55296<=k&&57343>=k){var V=n.charCodeAt(++C);k=65536+((k&1023)<<10)|V&1023}if(a()[l>>>2>>>0]=k,l+=4,l+4>f)break}return a()[l>>>2>>>0]=0,l-b},pe=n=>{for(var l=0,f=0;f<n.length;++f){var b=n.charCodeAt(f);55296<=b&&57343>=b&&++f,l+=4}return l},Mr=n=>{if(!me)try{if(n(),!(0<bt))try{O?no(ie):Xe(ie)}catch(l){l instanceof st||l=="unwind"||A(1,l)}}catch(l){l instanceof st||l=="unwind"||A(1,l)}};function Wt(n){n>>>=0,typeof Atomics.nc=="function"&&(Atomics.nc(a(),n>>>2,n).value.then(rt),n+=128,Atomics.store(a(),n>>>2,1))}d.__emscripten_thread_mailbox_await=Wt;var rt=()=>{var n=pn();n&&(Wt(n),Mr(yi))};d.checkMailbox=rt;var yr=[],br=(n,l)=>{var f=Br[n];if(f===void 0)throw n=fi(n),f=nt(n),Ct(n),new wt(`${l} has unknown type ${f}`);return f},Ur=(n,l,f)=>{var b=[];return n=n.toWireType(b,f),b.length&&(c()[l>>>2>>>0]=ot(b)),n},Jt=n=>{try{n()}catch(l){Kt(l)}};function dn(){var n=oe,l={};for(let[f,b]of Object.entries(n))l[f]=typeof b=="function"?(...C)=>{Bt.push(f);try{return b(...C)}finally{me||(Bt.pop(),ct&&vt===1&&Bt.length===0&&(vt=0,bt+=1,Jt($i),typeof Fibers<"u"&&Fibers.rc()))}}:b;return l}var vt=0,ct=null,ln=0,Bt=[],Vr={},s={},m=0,g=null,$=[];function T(){return new Promise((n,l)=>{g={resolve:n,reject:l}})}function B(){var n=mn(65548),l=n+12;c()[n>>>2>>>0]=l,c()[n+4>>>2>>>0]=l+65536,l=Bt[0];var f=Vr[l];return f===void 0&&(f=m++,Vr[l]=f,s[f]=l),l=f,a()[n+8>>>2>>>0]=l,n}function L(){var n=a()[ct+8>>>2>>>0];return n=oe[s[n]],--bt,n()}function q(n){if(!me){if(vt===0){var l=!1,f=!1;n((b=0)=>{if(!me&&(ln=b,l=!0,f)){vt=2,Jt(()=>_i(ct)),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.resume(),b=!1;try{var C=L()}catch(F){C=F,b=!0}var k=!1;if(!ct){var V=g;V&&(g=null,(b?V.reject:V.resolve)(C),k=!0)}if(b&&!k)throw C}}),f=!0,l||(vt=1,ct=B(),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.pause(),Jt(()=>vi(ct)))}else vt===2?(vt=0,Jt(Si),Ct(ct),ct=null,$.forEach(Mr)):Kt(`invalid state: ${vt}`);return ln}}function te(n){return q(l=>{n().then(l)})}var X=[],de={},Ee=n=>{var l=de[n];return l===void 0?nt(n):l},Oe=()=>typeof globalThis=="object"?globalThis:Function("return this")(),D=n=>{var l=X.length;return X.push(n),l},be=(n,l)=>{for(var f=Array(n),b=0;b<n;++b)f[b]=br(c()[l+4*b>>>2>>>0],"parameter "+b);return f},Ie=(n,l)=>Object.defineProperty(l,"name",{value:n});function Dt(n){var l=Function;if(!(l instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof l} which is not a function`);var f=Ie(l.name||"unknownFunctionName",function(){});return f.prototype=l.prototype,f=new f,n=l.apply(f,n),n instanceof Object?n:f}var zt=n=>n%4===0&&(n%100!==0||n%400===0),Qo=[0,31,60,91,121,152,182,213,244,274,305,335],Jo=[0,31,59,90,120,151,181,212,243,273,304,334];function ei(n,l,f,b,C,k,V){return O?Te(16,1,n,l,f,b,C,k,V):-52}function ti(n,l,f,b,C,k){if(O)return Te(17,1,n,l,f,b,C,k)}var Jn=[],ri=(n,l)=>{Jn.length=0;for(var f;f=o()[n++>>>0];){var b=f!=105;b&=f!=112,l+=b&&l%8?4:0,Jn.push(f==112?c()[l>>>2>>>0]:f==106?De[l>>>3]:f==105?a()[l>>>2>>>0]:h()[l>>>3>>>0]),l+=b?8:4}return Jn},eo={},ni=()=>{if(!to){var n={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:I||"./this.program"},l;for(l in eo)eo[l]===void 0?delete n[l]:n[l]=eo[l];var f=[];for(l in n)f.push(`${l}=${n[l]}`);to=f}return to},to;function oi(n,l){if(O)return Te(18,1,n,l);n>>>=0,l>>>=0;var f=0;return ni().forEach((b,C)=>{var k=l+f;for(C=c()[n+4*C>>>2>>>0]=k,k=0;k<b.length;++k)r()[C++>>>0]=b.charCodeAt(k);r()[C>>>0]=0,f+=b.length+1}),0}function ii(n,l){if(O)return Te(19,1,n,l);n>>>=0,l>>>=0;var f=ni();c()[n>>>2>>>0]=f.length;var b=0;return f.forEach(C=>b+=C.length+1),c()[l>>>2>>>0]=b,0}function ai(n){return O?Te(20,1,n):52}function si(n,l,f,b){return O?Te(21,1,n,l,f,b):52}function ui(n,l,f,b){return O?Te(22,1,n,l,f,b):70}var Xd=[null,[],[]];function di(n,l,f,b){if(O)return Te(23,1,n,l,f,b);l>>>=0,f>>>=0,b>>>=0;for(var C=0,k=0;k<f;k++){var V=c()[l>>>2>>>0],F=c()[l+4>>>2>>>0];l+=8;for(var re=0;re<F;re++){var J=o()[V+re>>>0],ce=Xd[n];J===0||J===10?((n===1?We:ee)(Pr(ce,0)),ce.length=0):ce.push(J)}C+=F}return c()[b>>>2>>>0]=C,0}var li=[31,29,31,30,31,30,31,31,30,31,30,31],ci=[31,28,31,30,31,30,31,31,30,31,30,31];function Qd(n){var l=Array(gt(n)+1);return dt(n,l,0,l.length),l}var Jd=(n,l)=>{r().set(n,l>>>0)};function pi(n,l,f,b){function C(z,we,Pe){for(z=typeof z=="number"?z.toString():z||"";z.length<we;)z=Pe[0]+z;return z}function k(z,we){return C(z,we,"0")}function V(z,we){function Pe(Ci){return 0>Ci?-1:0<Ci?1:0}var er;return(er=Pe(z.getFullYear()-we.getFullYear()))===0&&(er=Pe(z.getMonth()-we.getMonth()))===0&&(er=Pe(z.getDate()-we.getDate())),er}function F(z){switch(z.getDay()){case 0:return new Date(z.getFullYear()-1,11,29);case 1:return z;case 2:return new Date(z.getFullYear(),0,3);case 3:return new Date(z.getFullYear(),0,2);case 4:return new Date(z.getFullYear(),0,1);case 5:return new Date(z.getFullYear()-1,11,31);case 6:return new Date(z.getFullYear()-1,11,30)}}function re(z){var we=z.zb;for(z=new Date(new Date(z.Ab+1900,0,1).getTime());0<we;){var Pe=z.getMonth(),er=(zt(z.getFullYear())?li:ci)[Pe];if(we>er-z.getDate())we-=er-z.getDate()+1,z.setDate(1),11>Pe?z.setMonth(Pe+1):(z.setMonth(0),z.setFullYear(z.getFullYear()+1));else{z.setDate(z.getDate()+we);break}}return Pe=new Date(z.getFullYear()+1,0,4),we=F(new Date(z.getFullYear(),0,4)),Pe=F(Pe),0>=V(we,z)?0>=V(Pe,z)?z.getFullYear()+1:z.getFullYear():z.getFullYear()-1}n>>>=0,l>>>=0,f>>>=0,b>>>=0;var J=c()[b+40>>>2>>>0];b={kc:a()[b>>>2>>>0],jc:a()[b+4>>>2>>>0],Eb:a()[b+8>>>2>>>0],Jb:a()[b+12>>>2>>>0],Fb:a()[b+16>>>2>>>0],Ab:a()[b+20>>>2>>>0],vb:a()[b+24>>>2>>>0],zb:a()[b+28>>>2>>>0],qc:a()[b+32>>>2>>>0],ic:a()[b+36>>>2>>>0],lc:J?He(J):""},f=He(f),J={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ce in J)f=f.replace(new RegExp(ce,"g"),J[ce]);var Re="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ze="January February March April May June July August September October November December".split(" ");J={"%a":z=>Re[z.vb].substring(0,3),"%A":z=>Re[z.vb],"%b":z=>ze[z.Fb].substring(0,3),"%B":z=>ze[z.Fb],"%C":z=>k((z.Ab+1900)/100|0,2),"%d":z=>k(z.Jb,2),"%e":z=>C(z.Jb,2," "),"%g":z=>re(z).toString().substring(2),"%G":re,"%H":z=>k(z.Eb,2),"%I":z=>(z=z.Eb,z==0?z=12:12<z&&(z-=12),k(z,2)),"%j":z=>{for(var we=0,Pe=0;Pe<=z.Fb-1;we+=(zt(z.Ab+1900)?li:ci)[Pe++]);return k(z.Jb+we,3)},"%m":z=>k(z.Fb+1,2),"%M":z=>k(z.jc,2),"%n":()=>`\n`,"%p":z=>0<=z.Eb&&12>z.Eb?"AM":"PM","%S":z=>k(z.kc,2),"%t":()=>"	","%u":z=>z.vb||7,"%U":z=>k(Math.floor((z.zb+7-z.vb)/7),2),"%V":z=>{var we=Math.floor((z.zb+7-(z.vb+6)%7)/7);if(2>=(z.vb+371-z.zb-2)%7&&we++,we)we==53&&(Pe=(z.vb+371-z.zb)%7,Pe==4||Pe==3&&zt(z.Ab)||(we=1));else{we=52;var Pe=(z.vb+7-z.zb-1)%7;(Pe==4||Pe==5&&zt(z.Ab%400-1))&&we++}return k(we,2)},"%w":z=>z.vb,"%W":z=>k(Math.floor((z.zb+7-(z.vb+6)%7)/7),2),"%y":z=>(z.Ab+1900).toString().substring(2),"%Y":z=>z.Ab+1900,"%z":z=>{z=z.ic;var we=0<=z;return z=Math.abs(z)/60,(we?"+":"-")+("0000"+(z/60*100+z%60)).slice(-4)},"%Z":z=>z.lc,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(ce in J)f.includes(ce)&&(f=f.replace(new RegExp(ce,"g"),J[ce](b)));return f=f.replace(/\\0\\0/g,"%"),ce=Qd(f),ce.length>l?0:(Jd(ce,n),ce.length-1)}ge.Gb();for(var mi=Array(256),cn=0;256>cn;++cn)mi[cn]=String.fromCharCode(cn);on=mi,wt=d.BindingError=class extends Error{constructor(n){super(n),this.name="BindingError"}},d.InternalError=class extends Error{constructor(n){super(n),this.name="InternalError"}},lt.push(0,1,void 0,1,null,1,!0,1,!1,1),d.count_emval_handles=()=>lt.length/2-5-fr.length;var el=[dr,jr,Yr,Xr,Qr,Zt,kr,Or,Jr,pr,en,tn,rn,nn,Rr,Xt,ei,ti,oi,ii,ai,si,ui,di],tl={ua:function(n,l,f){return te(async()=>{await d.Zb(n,l,f)})},b:function(n,l,f){throw n>>>=0,new qn(n).Gb(l>>>0,f>>>0),Kr=n,jn++,Kr},ia:function(n){hi(n>>>0,!E,1,!x,131072,!1),ge.Pb()},G:function(n){n>>>=0,O?postMessage({cmd:"cleanupThread",thread:n}):ge.Nb(ge.ub[n])},_:Zr,B:Xr,pa:Qr,W:Zt,Y:kr,qa:Or,na:Jr,fa:pr,ma:en,K:tn,X:rn,U:nn,oa:Rr,V:Xt,E:function(n,l,f){n>>>=0,f>>>=0,l=nt(l>>>0),Je(n,{name:l,fromWireType:b=>b,toWireType:function(b,C){if(typeof C!="bigint"&&typeof C!="number")throw C===null?C="null":(b=typeof C,C=b==="object"||b==="array"||b==="function"?C.toString():""+C),new TypeError(`Cannot convert "${C}" to ${this.name}`);return typeof C=="number"&&(C=BigInt(C)),C},argPackAdvance:8,readValueFromPointer:Dr(l,f,l.indexOf("u")==-1),Bb:null})},O:function(n,l,f,b){n>>>=0,l=nt(l>>>0),Je(n,{name:l,fromWireType:function(C){return!!C},toWireType:function(C,k){return k?f:b},argPackAdvance:8,readValueFromPointer:function(C){return this.fromWireType(o()[C>>>0])},Bb:null})},N:function(n){return Je(n>>>0,Zn)},D:function(n,l,f){n>>>=0,f>>>=0,l=nt(l>>>0),Je(n,{name:l,fromWireType:b=>b,toWireType:(b,C)=>C,argPackAdvance:8,readValueFromPointer:an(l,f),Bb:null})},t:function(n,l,f,b,C){if(n>>>=0,f>>>=0,l=nt(l>>>0),C===-1&&(C=4294967295),C=F=>F,b===0){var k=32-8*f;C=F=>F<<k>>>k}var V=l.includes("unsigned")?function(F,re){return re>>>0}:function(F,re){return re};Je(n,{name:l,fromWireType:C,toWireType:V,argPackAdvance:8,readValueFromPointer:Dr(l,f,b!==0),Bb:null})},p:function(n,l,f){function b(k){var V=c()[k>>>2>>>0];return k=c()[k+4>>>2>>>0],new C(r().buffer,k,V)}n>>>=0;var C=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][l];f=nt(f>>>0),Je(n,{name:f,fromWireType:b,argPackAdvance:8,readValueFromPointer:b},{Ub:!0})},F:function(n,l){n>>>=0,l=nt(l>>>0);var f=l==="std::string";Je(n,{name:l,fromWireType:function(b){var C=c()[b>>>2>>>0],k=b+4;if(f)for(var V=k,F=0;F<=C;++F){var re=k+F;if(F==C||o()[re>>>0]==0){if(V=He(V,re-V),J===void 0)var J=V;else J+=String.fromCharCode(0),J+=V;V=re+1}}else{for(J=Array(C),F=0;F<C;++F)J[F]=String.fromCharCode(o()[k+F>>>0]);J=J.join("")}return Ct(b),J},toWireType:function(b,C){C instanceof ArrayBuffer&&(C=new Uint8Array(C));var k=typeof C=="string";if(!(k||C instanceof Uint8Array||C instanceof Uint8ClampedArray||C instanceof Int8Array))throw new wt("Cannot pass non-string to std::string");var V=f&&k?gt(C):C.length,F=mn(4+V+1),re=F+4;if(c()[F>>>2>>>0]=V,f&&k)Rt(C,re,V+1);else if(k)for(k=0;k<V;++k){var J=C.charCodeAt(k);if(255<J)throw Ct(re),new wt("String has UTF-16 code units that do not fit in 8 bits");o()[re+k>>>0]=J}else for(k=0;k<V;++k)o()[re+k>>>0]=C[k];return b!==null&&b.push(Ct,F),F},argPackAdvance:8,readValueFromPointer:Qt,Bb(b){Ct(b)}})},A:function(n,l,f){if(n>>>=0,l>>>=0,f>>>=0,f=nt(f),l===2)var b=Xn,C=sn,k=un,V=F=>u()[F>>>1>>>0];else l===4&&(b=gr,C=Qn,k=pe,V=F=>c()[F>>>2>>>0]);Je(n,{name:f,fromWireType:F=>{for(var re=c()[F>>>2>>>0],J,ce=F+4,Re=0;Re<=re;++Re){var ze=F+4+Re*l;(Re==re||V(ze)==0)&&(ce=b(ce,ze-ce),J===void 0?J=ce:(J+=String.fromCharCode(0),J+=ce),ce=ze+l)}return Ct(F),J},toWireType:(F,re)=>{if(typeof re!="string")throw new wt(`Cannot pass non-string to C++ string type ${f}`);var J=k(re),ce=mn(4+J+l);return c()[ce>>>2>>>0]=J/l,C(re,ce+4,J+l),F!==null&&F.push(Ct,ce),ce},argPackAdvance:8,readValueFromPointer:Qt,Bb(F){Ct(F)}})},P:function(n,l){n>>>=0,l=nt(l>>>0),Je(n,{Vb:!0,name:l,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ta:()=>1,S:function(n,l){n>>>=0,n==l>>>0?setTimeout(rt):O?postMessage({targetThread:n,cmd:"checkMailbox"}):(n=ge.ub[n])&&n.postMessage({cmd:"checkMailbox"})},$:function(n,l,f,b,C){l>>>=0,f>>>=0,b/=2,yr.length=b,C=C>>>0>>>3;for(var k=0;k<b;k++)yr[k]=De[C+2*k]?De[C+2*k+1]:h()[C+2*k+1>>>0];return n=l?Ir[l]:el[n],ge.Sb=f,f=n(...yr),ge.Sb=0,f},ha:Wt,sa:function(n){P&&ge.ub[n>>>0].ref()},w:function(n,l,f){return l>>>=0,f>>>=0,n=Qe(n>>>0),l=br(l,"emval::as"),Ur(l,f,n)},z:function(n){return n>>>=0,te(()=>(n=Qe(n),n.then(ot)))},o:function(n,l,f,b){return f>>>=0,b>>>=0,n=X[n>>>0],l=Qe(l>>>0),n(null,l,f,b)},k:function(n,l,f,b,C){return f>>>=0,b>>>=0,C>>>=0,n=X[n>>>0],l=Qe(l>>>0),f=Ee(f),n(l,l[f],b,C)},c:hr,y:function(n,l){return l>>>=0,n=Qe(n>>>0),l=Qe(l),n==l},n:function(n){return n>>>=0,n===0?ot(Oe()):(n=Ee(n),ot(Oe()[n]))},j:function(n,l,f){l=be(n,l>>>0);var b=l.shift();n--;var C=`return function (obj, func, destructorsRef, args) {\n`,k=0,V=[];f===0&&V.push("obj");for(var F=["retType"],re=[b],J=0;J<n;++J)V.push("arg"+J),F.push("argType"+J),re.push(l[J]),C+=`  var arg${J} = argType${J}.readValueFromPointer(args${k?"+"+k:""});\n`,k+=l[J].argPackAdvance;return C+=`  var rv = ${f===1?"new func":"func.call"}(${V.join(", ")});\n`,b.Vb||(F.push("emval_returnValue"),re.push(Ur),C+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),F.push(C+`};\n`),n=Dt(F)(...re),f=`methodCaller<(${l.map(ce=>ce.name).join(", ")}) => ${b.name}>`,D(Ie(f,n))},s:function(n,l){return l>>>=0,n=Qe(n>>>0),l=Qe(l),ot(n[l])},d:function(n){n>>>=0,9<n&&(lt[n+1]+=1)},v:function(){return ot([])},m:function(n){n=Qe(n>>>0);for(var l=Array(n.length),f=0;f<n.length;f++)l[f]=n[f];return ot(l)},g:function(n){return ot(Ee(n>>>0))},l:function(){return ot({})},i:function(n){n>>>=0;for(var l=Qe(n);l.length;){var f=l.pop();l.pop()(f)}hr(n)},h:function(n,l,f){l>>>=0,f>>>=0,n=Qe(n>>>0),l=Qe(l),f=Qe(f),n[l]=f},e:function(n,l){return l>>>=0,n=br(n>>>0,"_emval_take_value"),n=n.readValueFromPointer(l),ot(n)},ca:function(n,l){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),l>>>=0,n=new Date(1e3*n),a()[l>>>2>>>0]=n.getUTCSeconds(),a()[l+4>>>2>>>0]=n.getUTCMinutes(),a()[l+8>>>2>>>0]=n.getUTCHours(),a()[l+12>>>2>>>0]=n.getUTCDate(),a()[l+16>>>2>>>0]=n.getUTCMonth(),a()[l+20>>>2>>>0]=n.getUTCFullYear()-1900,a()[l+24>>>2>>>0]=n.getUTCDay(),n=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[l+28>>>2>>>0]=n},da:function(n,l){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),l>>>=0,n=new Date(1e3*n),a()[l>>>2>>>0]=n.getSeconds(),a()[l+4>>>2>>>0]=n.getMinutes(),a()[l+8>>>2>>>0]=n.getHours(),a()[l+12>>>2>>>0]=n.getDate(),a()[l+16>>>2>>>0]=n.getMonth(),a()[l+20>>>2>>>0]=n.getFullYear()-1900,a()[l+24>>>2>>>0]=n.getDay();var f=(zt(n.getFullYear())?Qo:Jo)[n.getMonth()]+n.getDate()-1|0;a()[l+28>>>2>>>0]=f,a()[l+36>>>2>>>0]=-(60*n.getTimezoneOffset()),f=new Date(n.getFullYear(),6,1).getTimezoneOffset();var b=new Date(n.getFullYear(),0,1).getTimezoneOffset();n=(f!=b&&n.getTimezoneOffset()==Math.min(b,f))|0,a()[l+32>>>2>>>0]=n},ea:function(n){n>>>=0;var l=new Date(a()[n+20>>>2>>>0]+1900,a()[n+16>>>2>>>0],a()[n+12>>>2>>>0],a()[n+8>>>2>>>0],a()[n+4>>>2>>>0],a()[n>>>2>>>0],0),f=a()[n+32>>>2>>>0],b=l.getTimezoneOffset(),C=new Date(l.getFullYear(),6,1).getTimezoneOffset(),k=new Date(l.getFullYear(),0,1).getTimezoneOffset(),V=Math.min(k,C);return 0>f?a()[n+32>>>2>>>0]=+(C!=k&&V==b):0<f!=(V==b)&&(C=Math.max(k,C),l.setTime(l.getTime()+6e4*((0<f?V:C)-b))),a()[n+24>>>2>>>0]=l.getDay(),f=(zt(l.getFullYear())?Qo:Jo)[l.getMonth()]+l.getDate()-1|0,a()[n+28>>>2>>>0]=f,a()[n>>>2>>>0]=l.getSeconds(),a()[n+4>>>2>>>0]=l.getMinutes(),a()[n+8>>>2>>>0]=l.getHours(),a()[n+12>>>2>>>0]=l.getDate(),a()[n+16>>>2>>>0]=l.getMonth(),a()[n+20>>>2>>>0]=l.getYear(),n=l.getTime(),BigInt(isNaN(n)?-1:n/1e3)},aa:ei,ba:ti,R:function(n,l,f,b){n>>>=0,l>>>=0,f>>>=0,b>>>=0;var C=new Date().getFullYear(),k=new Date(C,0,1),V=new Date(C,6,1);C=k.getTimezoneOffset();var F=V.getTimezoneOffset(),re=Math.max(C,F);c()[n>>>2>>>0]=60*re,a()[l>>>2>>>0]=+(C!=F),n=J=>J.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],k=n(k),V=n(V),F<C?(Rt(k,f,17),Rt(V,b,17)):(Rt(k,b,17),Rt(V,f,17))},q:()=>{Kt("")},f:function(n,l,f){return n>>>=0,l=ri(l>>>0,f>>>0),Ir[n](...l)},M:function(n,l,f){return n>>>=0,l=ri(l>>>0,f>>>0),Ir[n](...l)},H:()=>{},L:()=>Date.now(),ra:()=>{throw bt+=1,"unwind"},T:function(){return 4294901760},u:()=>performance.timeOrigin+performance.now(),x:()=>P?(Ri(),wr(Oi)).cpus().length:navigator.hardwareConcurrency,Q:function(n){n>>>=0;var l=o().length;if(n<=l||4294901760<n)return!1;for(var f=1;4>=f;f*=2){var b=l*(1+.2/f);b=Math.min(b,n+100663296);var C=Math;b=Math.max(n,b);e:{C=(C.min.call(C,4294901760,b+(65536-b%65536)%65536)-ae.buffer.byteLength+65535)/65536;try{ae.grow(C),Ne();var k=1;break e}catch{}k=void 0}if(k)return!0}return!1},ja:oi,la:ii,Z:Xe,C:ai,J:si,ga:ui,I:di,a:ae||d.wasmMemory,ka:pi,r:function(n,l,f,b){return pi(n>>>0,l>>>0,f>>>0,b>>>0)}},oe=function(){function n(f,b){return oe=f.exports,oe=dn(),oe=rl(),ge.Qb.push(oe.cb),Ot.unshift(oe.va),Ae=b,xr(),oe}var l={a:tl};if(Ut++,d.instantiateWasm)try{return d.instantiateWasm(l,n)}catch(f){ee(`Module.instantiateWasm callback failed with error: ${f}`),w(f)}return Ar(l,function(f){n(f.instance,f.module)}).catch(w),{}}(),fi=n=>(fi=oe.wa)(n);d.__embind_initialize_bindings=()=>(d.__embind_initialize_bindings=oe.xa)(),d._OrtInit=(n,l)=>(d._OrtInit=oe.ya)(n,l),d._OrtGetLastError=(n,l)=>(d._OrtGetLastError=oe.za)(n,l),d._OrtCreateSessionOptions=(n,l,f,b,C,k,V,F,re,J)=>(d._OrtCreateSessionOptions=oe.Aa)(n,l,f,b,C,k,V,F,re,J),d._OrtAppendExecutionProvider=(n,l)=>(d._OrtAppendExecutionProvider=oe.Ba)(n,l),d._OrtAddFreeDimensionOverride=(n,l,f)=>(d._OrtAddFreeDimensionOverride=oe.Ca)(n,l,f),d._OrtAddSessionConfigEntry=(n,l,f)=>(d._OrtAddSessionConfigEntry=oe.Da)(n,l,f),d._OrtReleaseSessionOptions=n=>(d._OrtReleaseSessionOptions=oe.Ea)(n),d._OrtCreateSession=(n,l,f)=>(d._OrtCreateSession=oe.Fa)(n,l,f),d._OrtReleaseSession=n=>(d._OrtReleaseSession=oe.Ga)(n),d._OrtGetInputOutputCount=(n,l,f)=>(d._OrtGetInputOutputCount=oe.Ha)(n,l,f),d._OrtGetInputName=(n,l)=>(d._OrtGetInputName=oe.Ia)(n,l),d._OrtGetOutputName=(n,l)=>(d._OrtGetOutputName=oe.Ja)(n,l),d._OrtFree=n=>(d._OrtFree=oe.Ka)(n),d._OrtCreateTensor=(n,l,f,b,C,k)=>(d._OrtCreateTensor=oe.La)(n,l,f,b,C,k),d._OrtGetTensorData=(n,l,f,b,C)=>(d._OrtGetTensorData=oe.Ma)(n,l,f,b,C),d._OrtReleaseTensor=n=>(d._OrtReleaseTensor=oe.Na)(n),d._OrtCreateRunOptions=(n,l,f,b)=>(d._OrtCreateRunOptions=oe.Oa)(n,l,f,b),d._OrtAddRunConfigEntry=(n,l,f)=>(d._OrtAddRunConfigEntry=oe.Pa)(n,l,f),d._OrtReleaseRunOptions=n=>(d._OrtReleaseRunOptions=oe.Qa)(n),d._OrtCreateBinding=n=>(d._OrtCreateBinding=oe.Ra)(n),d._OrtBindInput=(n,l,f)=>(d._OrtBindInput=oe.Sa)(n,l,f),d._OrtBindOutput=(n,l,f,b)=>(d._OrtBindOutput=oe.Ta)(n,l,f,b),d._OrtClearBoundOutputs=n=>(d._OrtClearBoundOutputs=oe.Ua)(n),d._OrtReleaseBinding=n=>(d._OrtReleaseBinding=oe.Va)(n),d._OrtRunWithBinding=(n,l,f,b,C)=>(d._OrtRunWithBinding=oe.Wa)(n,l,f,b,C),d._OrtRun=(n,l,f,b,C,k,V,F)=>(d._OrtRun=oe.Xa)(n,l,f,b,C,k,V,F),d._OrtEndProfiling=n=>(d._OrtEndProfiling=oe.Ya)(n),d._JsepOutput=(n,l,f)=>(d._JsepOutput=oe.Za)(n,l,f),d._JsepGetNodeName=n=>(d._JsepGetNodeName=oe._a)(n);var pn=d._pthread_self=()=>(pn=d._pthread_self=oe.$a)(),mn=d._malloc=n=>(mn=d._malloc=oe.ab)(n),Ct=d._free=n=>(Ct=d._free=oe.bb)(n);d.__emscripten_tls_init=()=>(d.__emscripten_tls_init=oe.cb)();var hi=d.__emscripten_thread_init=(n,l,f,b,C,k)=>(hi=d.__emscripten_thread_init=oe.eb)(n,l,f,b,C,k);d.__emscripten_thread_crashed=()=>(d.__emscripten_thread_crashed=oe.fb)();var gi=(n,l,f,b,C)=>(gi=oe.gb)(n,l,f,b,C),ro=n=>(ro=oe.hb)(n),no=d.__emscripten_thread_exit=n=>(no=d.__emscripten_thread_exit=oe.ib)(n),yi=()=>(yi=oe.jb)(),bi=(n,l)=>(bi=oe.kb)(n,l),fn=n=>(fn=oe.lb)(n),oo=n=>(oo=oe.mb)(n),io=()=>(io=oe.nb)(),wi=d.dynCall_ii=(n,l)=>(wi=d.dynCall_ii=oe.pb)(n,l),vi=n=>(vi=oe.qb)(n),$i=()=>($i=oe.rb)(),_i=n=>(_i=oe.sb)(n),Si=()=>(Si=oe.tb)();d.___start_em_js=839500,d.___stop_em_js=839661;function rl(){var n=oe;n=Object.assign({},n);var l=b=>C=>b(C)>>>0,f=b=>()=>b()>>>0;return n.wa=l(n.wa),n.$a=f(n.$a),n.ab=l(n.ab),n.emscripten_main_runtime_thread_id=f(n.emscripten_main_runtime_thread_id),n.mb=l(n.mb),n.nb=f(n.nb),n}d.wasmMemory=ae,d.stackSave=()=>io(),d.stackRestore=n=>fn(n),d.stackAlloc=n=>oo(n),d.keepRuntimeAlive=()=>0<bt,d.UTF8ToString=He,d.stringToUTF8=Rt,d.lengthBytesUTF8=gt,d.ExitStatus=st,d.PThread=ge;var hn;jt=function n(){hn||xi(),hn||(jt=n)};function xi(){if(!(0<Ut))if(O)y(d),O||Yt(Ot),startWorker(d);else{if(d.preRun)for(typeof d.preRun=="function"&&(d.preRun=[d.preRun]);d.preRun.length;)mt.unshift(d.preRun.shift());Yt(mt),0<Ut||hn||(hn=!0,d.calledRun=!0,me||(O||Yt(Ot),y(d),O||Yt(qt)))}}return xi(),_}})();typeof Di=="object"&&typeof mo=="object"?mo.exports=Bi:typeof define=="function"&&define.amd&&define([],()=>Bi)});var Mi=Wr((gm,cl)=>{cl.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(...e){var a=e.join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,a+`\\n`);return}console.error(a)}function threadAlert(...e){var a=e.join(" ");postMessage({cmd:"alert",text:a,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,a)=>{var r=Module.wasmModule;Module.wasmModule=null;var t=new WebAssembly.Instance(r,e);return a(t)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let r=[];self.onmessage=t=>r.push(t),self.startWorker=t=>{Module=t,postMessage({cmd:"loaded"});for(let s of r)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const t of e.data.handlers)Module[t]=(...s)=>{postMessage({cmd:"callHandler",handler:t,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var a=URL.createObjectURL(e.data.urlOrBlob);importScripts(a),URL.revokeObjectURL(a)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(r){if(r!="unwind")throw r}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(r){throw Module.__emscripten_thread_crashed?.(),r}}self.onmessage=handleMessage;\\n\'});var go,Nt,tr,bn,Gr,Hi,yo,ye=Y(()=>{"use strict";go=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Nt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},tr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],bn=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Gr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Hi=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool",yo=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var wn=Y(()=>{"use strict"});var Fi=Y(()=>{"use strict";wn()});var qi,ji=Y(()=>{"use strict";qi="1.18.0-dev.20240424-218b6b0a73"});var Ki,pt,bo=Y(()=>{"use strict";ji();Ki="warning",pt={wasm:{},webgl:{},webgpu:{},versions:{common:qi},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Ki=e}},get logLevel(){return Ki}};Object.defineProperty(pt,"logLevel",{enumerable:!0})});var vr,Yi=Y(()=>{"use strict";bo();vr=pt});var Zi=Y(()=>{"use strict"});var Xi=Y(()=>{"use strict";vn()});var Ji=Y(()=>{"use strict"});var ea=Y(()=>{"use strict";vn()});var vn=Y(()=>{"use strict";Zi();Xi();Ji();ea()});var $n=Y(()=>{"use strict";vn()});var wo,ta,rr,Gt,vo=Y(()=>{"use strict";bo();wo=(e,t)=>{(typeof pt.trace>"u"?!pt.wasm.trace:!pt.trace)||console.timeStamp(`${e}::ORT::${t}`)},ta=(e,t)=>{let r=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],o=!1;for(let i=0;i<r.length;i++){if(o&&!r[i].includes("TRACE_FUNC")){let u=`FUNC_${e}::${r[i].trim().split(" ")[1]}`;t&&(u+=`::${t}`),wo("CPU",u);return}r[i].includes("TRACE_FUNC")&&(o=!0)}},rr=e=>{(typeof pt.trace>"u"?!pt.wasm.trace:!pt.trace)||ta("BEGIN",e)},Gt=e=>{(typeof pt.trace>"u"?!pt.wasm.trace:!pt.trace)||ta("END",e)}});var ra=Y(()=>{"use strict";wn();$n();vo()});var na=Y(()=>{"use strict";ra()});var oa=Y(()=>{"use strict"});var ia=Y(()=>{"use strict"});var aa=Y(()=>{"use strict"});var sa=Y(()=>{"use strict"});var ua=Y(()=>{"use strict";wn();$n()});var da=Y(()=>{"use strict";ua()});var $r=Y(()=>{"use strict";Fi();Yi();na();$n();oa();ia();vo();aa();sa();da()});var _l,Sl,la,ca,pa,xl,Ve,Ht=Y(()=>{"use strict";ye();_l=["V","I","W","E","F"],Sl=(e,t)=>{console.log(`[${_l[e]},${new Date().toISOString()}]${t}`)},pa=(e,t)=>{la=e,ca=t},xl=(e,t)=>{let r=Gr(e),o=Gr(la);r>=o&&Sl(r,typeof t=="function"?t():t)},Ve=(...e)=>{ca&&xl(...e)}});var ma,fa=Y(()=>{"use strict";ye();ma=(e,t)=>new(bn(t))(e)});var _n=Y(()=>{"use strict"});var ha,$o,_o,Cl,Al,ga,xo,So,ba,wa=Y(()=>{"use strict";Ht();_n();ha=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),$o=[],_o=e=>Math.ceil(e/16)*16,Cl=e=>{for(let t=0;t<$o.length;t++){let r=$o[t];if(e<=r)return r}return Math.ceil(e/16)*16},Al=1,ga=()=>Al++,xo=async(e,t,r,o)=>{let i=_o(r),u=e.device.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,u,0,i),e.flush(),await u.mapAsync(GPUMapMode.READ);let c=u.getMappedRange();if(o){let p=o();return p.set(new Uint8Array(c,0,r)),p}else return new Uint8Array(c.slice(0,r))}finally{u.destroy()}},So=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map,this.capturedPendingBuffers=new Map;for(let[r]of ha)$o.push(r),this.freeBuffers.set(r,[]),this.freeUniformBuffers.set(r,[])}upload(t,r){let o=r.buffer,i=r.byteOffset,u=r.byteLength,a=_o(u),c=this.storageCache.get(t);if(!c)throw new Error("gpu data for uploading does not exist");if(c.originalSize!==u)throw new Error(`inconsistent data size. gpu data size=${c.originalSize}, data size=${u}`);let p=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),h=p.getMappedRange();new Uint8Array(h).set(new Uint8Array(o,i,u)),p.unmap();let d=this.backend.getCommandEncoder();this.backend.endComputePass(),d.copyBufferToBuffer(p,0,c.gpuData.buffer,0,a),Ve("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(p)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(r);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let u=_o(o.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(o.gpuData.buffer,0,i.gpuData.buffer,0,u)}registerExternalBuffer(t,r,o){let i;if(o){if(i=this.externalBuffers.get(o),i===void 0)throw new Error("previous buffer is not registered");if(t===o)return Ve("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, buffer is the same, skip.`),i;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`);this.externalBuffers.delete(o)}else i=ga();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,i),Ve("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, registered.`),i}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Ve("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Cl(t),i,u=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(u||a){let h=(u?this.freeBuffers:this.freeUniformBuffers).get(o);h?h.length>0?i=h.pop():i=this.backend.device.createBuffer({size:o,usage:r}):i=this.backend.device.createBuffer({size:o,usage:r})}else i=this.backend.device.createBuffer({size:o,usage:r});let c={id:ga(),type:0,buffer:i};return this.storageCache.set(c.id,{gpuData:c,originalSize:t}),Ve("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${c.id}`),c}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Ve("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await xo(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let t of this.buffersPending){let r=ha.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let o=this.freeBuffers.get(t.size)||[];r===void 0||o.length>=r?t.destroy():o.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let o=this.freeUniformBuffers.get(t.size)||[];r===void 0||o.length>=r?t.destroy():o.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let r of this.buffersPending)t.push(r);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(t){let r=this.capturedPendingBuffers.get(t);r&&(r.forEach(o=>{o.destroy()}),this.capturedPendingBuffers.delete(t))}},ba=(...e)=>new So(...e)});var Co,ve,Ze=Y(()=>{"use strict";Co=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},ve=e=>new Co(e)});var Ao,At,M,nr,Sn,xn,Cn,Se=Y(()=>{"use strict";Ao=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},At=class{static calcShape(t,r,o=!1){let i=t.length,u=r.length;if(i===0)return r;if(u===0)return t;let a=Math.max(t.length,r.length),c=new Array(a);if(o){if(i<2||u<2)return;let p=Ao.calcMatMulShape([t[i-2],t[i-1]],[r[u-2],r[u-1]]);if(p===void 0)return;[c[a-2],c[a-1]]=p}for(let p=o?3:1;p<=a;p++){let h=i-p<0?1:t[i-p],d=u-p<0?1:r[u-p];if(h!==d&&h>1&&d>1)return;let y=Math.max(h,d);if(h&&d)c[a-p]=Math.max(h,d);else{if(y>1)return;c[a-p]=0}}return c}static isValidBroadcast(t,r){let o=t.length,i=r.length;if(o>i)return!1;for(let u=1;u<=o;u++)if(t[o-u]!==1&&t[o-u]!==r[i-u])return!1;return!0}},M=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,r=4){let o=t.length;if(o===0)return[];let i=new Array(o),u=o-1;for(;u>=0;){if(t[u]%r===0){i[u]=t[u]/r;break}if(r%t[u]!==0)throw new Error("cannot convert shape");i[u]=1,r/=t[u],u--}for(u--;u>=0;u--)i[u]=t[u];return i}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let i=1;for(let u=r;u<o;u++){if(t[u]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");i*=t[u]}return i}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let i=r-3;i>=0;--i)o[i]=o[i+1]*t[i+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((i,u)=>i+r[u]+r[u+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,i)=>o===r[i])}},nr=class e{static adjustPoolAttributes(t,r,o,i,u,a){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let c=0;c<r.length-2;c++)c>=o.length?o.push(r[c+2]):o[c]=r[c+2];for(let c=0;c<o.length;c++)if(c<i.length){if(i[c]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let c=0;c<o.length;c++)if(c<u.length){if(u[c]<0)throw new Error("dilations should be greater than or equal to 1")}else u.push(1);for(let c=0;c<o.length*2;c++)if(c<a.length){if(a[c]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let c=0;c<o.length;c++){if(o[c]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[c]>=o[c]||a[c+o.length]>=o[c])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,i,u,a,c){if(c){if(u.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(i.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let p=0;p<t.length-2;p++)e.adjustPadAndReturnShape(t[p+(a?1:2)],r[p],o[p],i[p],u,p,p+t.length-2,c)}}static computePoolOutputShape(t,r,o,i,u,a,c){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let p=[r[0],r[1]];return e.computeShapeHelper(t,r,p,o,i,u,a,c),p}static computeConvOutputShape(t,r,o,i,u,a,c){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let p=[t[0],r[0]];return e.computeShapeHelper(!1,t,p,o,i,u,a,c),p}static computeShapeHelper(t,r,o,i,u,a,c,p){if(t)for(let h=0;h<r.length-2;h++)o.push(1);else for(let h=0;h<r.length-2;h++)o.push(e.adjustPadAndReturnShape(r[h+2],i[h],u[h],a[h],c,h,h+r.length-2,p))}static adjustPadAndReturnShape(t,r,o,i,u,a,c,p){let h=o*(i-1)+1;if(p&&p!=="NOTSET")switch(p){case"VALID":return u[a]=0,u[c]=0,Math.floor((t-h)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let y=((t+r-1)/r-1)*r+i-t;return u[a]=Math.floor(p==="SAME_LOWER"?(y+1)/2:y/2),u[c]=y-u[a],Math.floor((t+y-i)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+u[a]+u[c]-h)/r+1)}},Sn=class{static getShapeOfGemmResult(t,r,o,i,u){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let a,c,p;r?(a=t[1],c=t[0]):(a=t[0],c=t[1]);let h=-1;if(i?(p=o[0],h=1):(p=o[1],h=0),o[h]!==c)throw new Error("dimension mismatch");if(a<=0||p<=0||c<=0)throw new Error("invalid shape specified");if(u&&!At.isValidBroadcast(u,[a,p]))throw new Error("gemm: invalid bias shape for broadcast");return[a,p,c]}},xn=-34028234663852886e22,Cn=34028234663852886e22});var or,To,Be,et,Z,Me,Lt,ir,$t,fe,Eo,U,j,An,Io,va,_r,_e=Y(()=>{"use strict";ye();Se();or=64,To=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Be=(e,t=1)=>{let r=To(e,t);return typeof r=="string"?r:r[0]},et=(e,t=1)=>{let r=To(e,t);return typeof r=="string"?r:r[1]},Z=(...e)=>{let t=[];return e.forEach(r=>{r.length!==0&&t.push({type:12,data:r},{type:12,data:M.computeStrides(r)})}),t},Me=e=>e%4===0?4:e%2===0?2:1,Lt=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,ir=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}<f32>(${r})`,$t=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,fe=(e,t,r,o)=>e.startsWith("uniforms.")&&r>4?typeof t=="string"?o==="f16"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:o==="f16"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,Eo=(e,t,r,o,i)=>{let u=typeof r=="number",a=u?r:r.length,c=[...new Array(a).keys()],p=a<2?"u32":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,h=To(t,i),d=typeof h=="string"?h:h[1],y=typeof h=="string"?h:h[0],w={indices:p,value:d,storage:y,tensor:t},_=G=>typeof G=="string"?G:`${G}u`,v={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},S=u?"uniforms.":"",I=`${S}${e}_shape`,A=`${S}${e}_strides`,x="";for(let G=0;G<a-1;G++)x+=`\n    let dim${G} = current / ${fe(A,G,a)};\n    let rest${G} = current % ${fe(A,G,a)};\n    indices[${G}] = dim${G};\n    current = rest${G};\n    `;x+=`indices[${a-1}] = current;`;let E=a<2?"":`\n  fn o2i_${e}(offset: u32) -> ${w.indices} {\n    var indices: ${w.indices};\n    var current = offset;\n    ${x}\n    return indices;\n  }`,P=G=>(v.offsetToIndices=!0,a<2?G:`o2i_${e}(${G})`),O=[];if(a>=2)for(let G=a-1;G>=0;G--)O.push(`${fe(A,G,a)} * (indices[${G}])`);let R=a<2?"":`\n  fn i2o_${e}(indices: ${w.indices}) -> u32 {\n    return ${O.join("+")};\n  }`,H=G=>(v.indicesToOffset=!0,a<2?G:`i2o_${e}(${G})`),N=(...G)=>a===0?"0u":`${w.indices}(${G.map(_).join(",")})`,K=(G,ne)=>a<2?`${G}`:`${fe(G,ne,a)}`,Q=(G,ne,xe)=>a<2?`${G}=${xe};`:`${fe(G,ne,a)}=${xe};`,he={},W=(G,ne)=>{v.broadcastedIndicesToOffset=!0;let xe=`${ne.name}broadcastedIndicesTo${e}Offset`;if(xe in he)return`${xe}(${G})`;let Ke=[];for(let De=a-1;De>=0;De--){let Ge=ne.indicesGet("outputIndices",De+ne.rank-a);Ke.push(`${K(A,De)} * (${Ge} % ${K(I,De)})`)}return he[xe]=`fn ${xe}(outputIndices: ${ne.type.indices}) -> u32 {\n             return ${Ke.length>0?Ke.join("+"):"0u"};\n           }`,`${xe}(${G})`},se=(G,ne)=>(()=>{if(w.storage===w.value)return`${e}[${G}]=${ne};`;if(w.storage==="vec2<u32>"&&w.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${ne}), select(0u, 0xFFFFFFFFu, ${ne} < 0));`;if(w.storage==="vec2<u32>"&&w.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${ne}), 0u);`;if(w.storage==="u32"&&w.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${ne}));`;throw new Error(`not supported combination of storage type ${w.storage} and value type ${w.value} yet`)})(),Ce=G=>(()=>{if(w.storage===w.value)return`${e}[${G}]`;if(w.storage==="vec2<u32>"&&w.value==="i32")return`i32(${e}[${G}].x)`;if(w.storage==="vec2<u32>"&&w.value==="u32")return`u32(${e}[${G}].x)`;if(w.storage==="u32"&&w.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${w.storage} and value type ${w.value} yet`)})(),We=a<2?"":`\n  fn get_${e}ByIndices(indices: ${w.indices}) -> ${d} {\n    return ${Ce(`i2o_${e}(indices)`)};\n  }`,ee=a<2?"":(()=>{let G=c.map(xe=>`d${xe}: u32`).join(", "),ne=c.map(xe=>`d${xe}`).join(", ");return`\n  fn get_${e}(${G}) -> ${d} {\n    return get_${e}ByIndices(${N(ne)});\n  }`})(),ae=(...G)=>{if(G.length!==a)throw new Error(`indices length must be ${a}`);let ne=G.map(_).join(",");return a===0?Ce("0u"):a===1?Ce(ne[0]):(v.get=!0,v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}(${ne})`)},Ae=G=>a<2?Ce(G):(v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}ByIndices(${G})`),me=a<2?"":`\n  fn set_${e}ByIndices(indices: ${w.indices}, value: ${d}) {\n    ${se(`i2o_${e}(indices)`,"value")}\n  }`,ie=a<2?"":(()=>{let G=c.map(xe=>`d${xe}: u32`).join(", "),ne=c.map(xe=>`d${xe}`).join(", ");return`\n  fn set_${e}(${G}, value: ${d}) {\n    set_${e}ByIndices(${N(ne)}, value);\n  }`})();return{impl:()=>{let G=[],ne=!1;return v.offsetToIndices&&(G.push(E),ne=!0),v.indicesToOffset&&(G.push(R),ne=!0),v.broadcastedIndicesToOffset&&(Object.values(he).forEach(xe=>G.push(xe)),ne=!0),v.set&&(G.push(ie),ne=!0),v.setByIndices&&(G.push(me),ne=!0),v.get&&(G.push(ee),ne=!0),v.getByIndices&&(G.push(We),ne=!0),!u&&ne&&G.unshift(`const ${I} = ${w.indices}(${r.join(",")});`,`const ${A} = ${w.indices}(${M.computeStrides(r).join(",")});`),G.join(`\n`)},type:w,offsetToIndices:P,indicesToOffset:H,broadcastedIndicesToOffset:W,indices:N,indicesGet:K,indicesSet:Q,set:(...G)=>{if(G.length!==a+1)throw new Error(`indices length must be ${a}`);let ne=G[a];if(typeof ne!="string")throw new Error("value must be string");let xe=G.slice(0,a).map(_).join(",");return a===0?se("0u",ne):a===1?se(xe[0],ne):(v.set=!0,v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}(${xe}, ${ne})`)},setByOffset:se,setByIndices:(G,ne)=>a<2?se(G,ne):(v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${ne});`),get:ae,getByOffset:Ce,getByIndices:Ae,usage:o,name:e,strides:A,shape:I,rank:a}},U=(e,t,r,o=1)=>Eo(e,t,r,"input",o),j=(e,t,r,o=1)=>Eo(e,t,r,"output",o),An=(e,t,r,o=1)=>Eo(e,t,r,"internal",o),Io=class{constructor(t,r){this.normalizedDispatchGroup=t;this.limits=r;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=or){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],i=typeof t=="number"?1:t[2];if(r>this.limits.maxComputeWorkgroupSizeX||o>this.limits.maxComputeWorkgroupSizeY||i>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${r}, ${o}, ${i}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(r*o*i>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${r}, ${o}, ${i}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let u=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,a=u?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,c=u?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*o*i}u + local_idx;`;return`@compute @workgroup_size(${r}, ${o}, ${i})\n  fn main(${a}) {\n    ${c}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,r){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let o=t.usage==="input"?"read":"read_write",i=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${i}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,o=1){return this.uniforms.push({name:t,type:r,length:o}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o,length:i}of this.uniforms)if(i&&i>4)o==="f16"?t.push(`@align(16) ${r}:array<mat2x4<${o}>, ${Math.ceil(i/8)}>`):t.push(`${r}:array<vec4<${o}>, ${Math.ceil(i/4)}>`);else{let u=i==null||i===1?o:`vec${i}<${o}>`;t.push(`${r}:${u}`)}return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=r=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(r)];return this.uniforms.map(r=>[t(r.type),r.length??1])}},va=(e,t)=>new Io(e,t),_r=(e,t)=>{let r=e.length,o=[];for(let i=0;i<r;i++){let u=r-1-i,a=e[u]||1;(t[t.length-1-i]||1)>1&&a===1&&o.unshift(u)}return o}});var Il,$a,Tl,El,yt,_a,Sa,Sr=Y(()=>{"use strict";ye();Se();Ze();_e();Il=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},$a=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Tl=(e,t)=>M.sortBasedOnPerm(e,$a(e.length,t)),El=(e,t,r,o)=>{let i=[];i.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let u=0;u<t;++u)i.push(r.indicesSet("a",e[u],`i[${u}]`));return i.push("return a;}"),i.join(`\n`)},yt=(e,t)=>{let r=e.dataType,o=e.dims.length,i=$a(o,t),u=Tl(e.dims,i),a=j("output",r,u.length),c=U("a",r,o),p=h=>`\n  ${h.registerUniform("output_size","u32").declareVariables(c,a)}\n\n  ${El(i,o,c,a)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${a.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${a.setByOffset("global_idx",c.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:h=>{let d=M.size(u);return{outputs:[{dims:u,dataType:h[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},...Z(h[0].dims,u)]}},getShaderSource:p}},_a=(e,t)=>{Il(e.inputs),e.compute(yt(e.inputs[0],t.perm))},Sa=e=>ve({perm:e.perm})});var Pl,kl,Ol,Rl,Bl,Dl,zl,Ml,Ul,Vl,It,xa,Ca,Aa,Ia,Ta,Ea,Pa,ka,Oa,Ra,Ba=Y(()=>{"use strict";ye();Se();_e();In();Sr();Pl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},kl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Ol={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Rl={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Bl=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},Dl=(e,t)=>{let r=[],o=e.length;for(let u=0;u<o;u++)t.indexOf(u)===-1&&r.push(e[u]);let i=t.map(u=>e[u]);return[r,i]},zl=(e,t)=>{let r=e.length+t.length,o=[],i=0;for(let u=0;u<r;u++)t.indexOf(u)===-1?o.push(e[i++]):o.push(1);return o},Ml=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},Ul=(e,t)=>{let r=[];if(!Ml(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},Vl=(e,t,r,o,i,u,a)=>{let c=r[0].dims,p=M.size(u),h=M.size(a),d=U("_A",r[0].dataType,c),y=j("output",i,u),w=32,_=`\n          var<workgroup> aBestValues : array<f32, ${w}>;\n       `;return{name:e,shaderCache:t,getShaderSource:S=>`\n        ${S.registerUniform("reduceSize","u32").declareVariables(d,y)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${S.mainStart(w)}\n\n          let outputIndex = global_idx / ${w};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${Ol[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${w}) {\n           let candidate = f32(${d.getByOffset("offset + k")});\n           bestValue = ${Pl[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${w}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${kl[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${y.setByOffset("outputIndex",`${o==="mean"?`${y.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${y.type.storage}(${Rl[o]})`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:p},programUniforms:[{type:12,data:h}]})}},It=(e,t,r,o)=>{let i=e.inputs.length===1?r:Po(e.inputs,r),u=i.axes;u.length===0&&!i.noopWithEmptyAxes&&(u=e.inputs[0].dims.map((_,v)=>v));let a=M.normalizeAxes(u,e.inputs[0].dims.length),c=a,p=e.inputs[0],h=Ul(c,e.inputs[0].dims.length);h.length>0&&(p=e.compute(yt(e.inputs[0],h),{inputs:[0],outputs:[-1]})[0],c=Bl(c.length,p.dims.length));let[d,y]=Dl(p.dims,c),w=d;i.keepDims&&(w=zl(d,a)),e.compute(Vl(t,{hint:i.cacheKey,inputDependencies:["type"]},[p],o,e.inputs[0].dataType,w,y),{inputs:[p]})},xa=(e,t)=>{It(e,"ReduceMeanShared",t,"mean")},Ca=(e,t)=>{It(e,"ReduceL1Shared",t,"l1")},Aa=(e,t)=>{It(e,"ReduceL2Shared",t,"l2")},Ia=(e,t)=>{It(e,"ReduceLogSumExpShared",t,"logSumExp")},Ta=(e,t)=>{It(e,"ReduceMaxShared",t,"max")},Ea=(e,t)=>{It(e,"ReduceMinShared",t,"min")},Pa=(e,t)=>{It(e,"ReduceProdShared",t,"prod")},ka=(e,t)=>{It(e,"ReduceSumShared",t,"sum")},Oa=(e,t)=>{It(e,"ReduceSumSquareShared",t,"sumSquare")},Ra=(e,t)=>{It(e,"ReduceLogSumShared",t,"logSum")}});var Tt,Wl,Tn,Po,Et,Nl,Gl,Hl,Ll,Fl,ql,jl,Kl,Yl,Zl,Pt,Da,za,Ma,Ua,Va,Wa,Na,Ga,Ha,La,In=Y(()=>{"use strict";ye();Se();Ze();_e();Ba();Tt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Wl=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Tn=(e,t,r,o,i,u,a=!1,c=!1)=>{let p=[],h=r[0].dims,d=h.length,y=M.normalizeAxes(i,d),w=!c&&y.length===0;h.forEach((I,A)=>{w||y.indexOf(A)>=0?a&&p.push(1):p.push(I)});let _=p.length,v=M.size(p);return{name:e,shaderCache:t,getShaderSource:I=>{let A=[],x=U("_A",r[0].dataType,d),E=j("output",u,_),P=o(x,E,y),O=P[2];for(let R=0,H=0;R<d;R++)w||y.indexOf(R)>=0?(a&&H++,O=`for(var j${R}: u32 = 0; j${R} < ${h[R]}; j${R}++) {\n                  ${P[2].includes("last_index")?`let last_index = j${R};`:""}\n                  ${x.indicesSet("input_indices",R,`j${R}`)}\n                  ${O}\n                }`):(A.push(`${x.indicesSet("input_indices",R,E.indicesGet("output_indices",H))};`),H++);return`\n\n        ${I.registerUniform("output_size","u32").declareVariables(x,E)}\n\n        ${I.mainStart()}\n          ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${x.type.indices};\n          let output_indices = ${E.offsetToIndices("global_idx")};\n\n          ${A.join(`\n`)}\n          ${P[0]}       // init ops for reduce max/min\n          ${P[1]}\n          ${O}\n          ${P[3]}\n          ${P.length===4?E.setByOffset("global_idx","value"):P.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:p,dataType:u}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:[{type:12,data:v},...Z(h,p)]})}},Po=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ve({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},Et=(e,t,r,o)=>{let i=e.inputs,u=i.length===1?r:Po(i,r);e.compute(Tn(t,{hint:u.cacheKey,inputDependencies:["rank"]},[i[0]],u.noopWithEmptyAxes&&u.axes.length===0?Wl:o,u.axes,i[0].dataType,u.keepDims,u.noopWithEmptyAxes),{inputs:[0]})},Nl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceLogSum",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,"value = log(value);"])},Gl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceL1",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += abs(${o.getByIndices("input_indices")});`,""])},Hl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceL2",t,(o,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Ll=(e,t)=>{Tt(e.inputs),Et(e,"ReduceLogSumExp",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += exp(${o.getByIndices("input_indices")});`,"value = log(value);"])},Fl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceMax",t,(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(o.indicesSet("input_indices",c,0));return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = max(value, ${o.getByIndices("input_indices")});`,""]})},ql=(e,t)=>{Tt(e.inputs),Et(e,"ReduceMean",t,(o,i,u)=>{let a=1;for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&(a*=e.inputs[0].dims[c]);return["var sum = f32(0);","",`sum += f32(${o.getByIndices("input_indices")});`,`let value = ${i.type.value}(sum / ${a});`]})},jl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceMin",t,(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(`input_indices[${c}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = min(value, ${o.getByIndices("input_indices")});`,""]})},Kl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceProd",t,(o,i)=>[`var value = ${i.type.storage}(1);`,"",`value *= ${o.getByIndices("input_indices")};`,""])},Yl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceSum",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,""])},Zl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceSumSquare",t,(o,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += t * t;`,""])},Pt=(e,t,r)=>{if(t.length===0)return r;let o=1,i=1;for(let u=0;u<t.length;u++)t.indexOf(u)===-1?o*=e[u]:i*=e[u];return i<32&&o>1024},Da=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ql(e,t):xa(e,t)},za=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Gl(e,t):Ca(e,t)},Ma=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Hl(e,t):Aa(e,t)},Ua=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ll(e,t):Ia(e,t)},Va=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Fl(e,t):Ta(e,t)},Wa=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?jl(e,t):Ea(e,t)},Na=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Kl(e,t):Pa(e,t)},Ga=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Yl(e,t):ka(e,t)},Ha=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Zl(e,t):Oa(e,t)},La=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Nl(e,t):Ra(e,t)}});var Fa,qa,ja,ko,Ka=Y(()=>{"use strict";ye();Ze();In();Fa=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},qa=(e,t)=>{Fa(e.inputs);let r=(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(`input_indices[${c}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(Tn("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ja=(e,t)=>{Fa(e.inputs);let r=(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(`input_indices[${c}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(Tn("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ko=e=>ve(e)});var Xl,Ql,Jl,En,Ya,Za,Oo=Y(()=>{"use strict";ye();Se();Ze();_e();Xl=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let r=0,o=e[r],i=o.dataType,u=o.dims.length;e.forEach((a,c)=>{if(c!==r){if(a.dataType!==i)throw new Error("input tensors should be one type");if(a.dims.length!==u)throw new Error("input tensors should have the same shape");a.dims.forEach((p,h)=>{if(h!==t&&p!==o.dims[h])throw new Error("non concat dimensions must match")})}})},Ql=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Jl=(e,t)=>{let r=e.length,o=[];for(let i=0;i<r;++i){let u=t.setByOffset("global_idx",e[i].getByIndices("indices"));r===1?o.push(u):i===0?o.push(`if (inputIndex == ${i}u) { ${u} }`):i===r-1?o.push(`else { ${u} }`):o.push(`else if (inputIndex == ${i}) { ${u} }`)}return o.join(`\n`)},En=(e,t,r,o)=>{let i=M.size(r),u=new Array(e.length),a=new Array(e.length),c=0,p=[],h=[],d=[{type:12,data:i}];for(let S=0;S<e.length;++S)c+=e[S].dims[t],u[S]=c,h.push(e[S].dims.length),a[S]=U(`input${S}`,o,h[S]),p.push("rank"),d.push({type:12,data:u[S]});for(let S=0;S<e.length;++S)d.push(...Z(e[S].dims));d.push(...Z(r));let y=j("output",o,r.length),w=y.indicesGet("indices",t),_=Array.from(Array(u.length).keys()).map(S=>`uniforms.sizeInConcatAxis${S}`).join(","),v=S=>`\n\n  ${(()=>{S.registerUniform("outputSize","u32");for(let I=0;I<e.length;I++)S.registerUniform(`sizeInConcatAxis${I}`,"u32");return S.declareVariables(...a,y)})()}\n\n  ${Ql(u.length,_)}\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${y.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${w});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${u.length}u>(${_});\n      ${w} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Jl(a,y)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:r,dataType:o}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:d}),getShaderSource:v}},Ya=(e,t)=>{let r=e.inputs,o=r[0].dims,i=M.normalizeAxis(t.axis,o.length);Xl(r,i);let u=o.slice();u[i]=r.reduce((c,p)=>c+(p.dims.length>i?p.dims[i]:0),0);let a=r.filter(c=>M.size(c.dims)>0);e.compute(En(a,i,u,r[0].dataType),{inputs:a})},Za=e=>ve({axis:e.axis})});var ec,tc,rc,nc,Pn,oc,Xa,Ro=Y(()=>{"use strict";ye();_n();_e();Oo();ec=(e,t)=>{let r=e[0],o=e[1],i=e[2],u=e[3],a=e[4],c=e[5];if(a&&c)throw new Error("Attention cannot have both past and relative_position_bias");if(r.dims.length!==3)throw new Error(\'Input "input" must have 3 dimensions\');let p=r.dims[0],h=r.dims[1],d=r.dims[2];if(i.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(o.dims.length!==2)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(o.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(i.dims[0]!==o.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let y=i.dims[0]/3,w=y,_=w;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let E of t.qkvHiddenSizes)if(E%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");y=t.qkvHiddenSizes[0],w=t.qkvHiddenSizes[1],_=t.qkvHiddenSizes[2]}let v=h;if(y!==w)throw new Error("qkv_hidden_sizes first element should be same as the second");if(i.dims[0]!==y+w+_)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let S=0;if(a){if(w!==_)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(a.dims.length!==5)throw new Error(\'Input "past" must have 5 dimensions\');if(a.dims[0]!==2)throw new Error(\'Input "past" first dimension must be 2\');if(a.dims[1]!==p)throw new Error(\'Input "past" second dimension must be batch_size\');if(a.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(a.dims[4]!==w/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||(S=a.dims[3])}let I=v+S,A=-1,x=0;if(u)throw new Error("Mask not supported");if(a)throw new Error("past is not supported");return{batchSize:p,sequenceLength:h,pastSequenceLength:S,kvSequenceLength:v,totalSequenceLength:I,maxSequenceLength:A,inputHiddenSize:d,hiddenSize:y,vHiddenSize:_,headSize:Math.floor(y/t.numHeads),vHeadSize:Math.floor(_/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:x,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},tc=(e,t,r,o)=>{let i=Me(o),u=64,a=o/i;a<u?u=1:a/8<64&&(u=Math.ceil(a/8));let c=Math.ceil(o/i/u),p=[{type:t.dataType,data:1/o},{type:12,data:a},{type:12,data:c}],h=Be(t.dataType,i),d=et(1,i),y=w=>{let _=j("x",t.dataType,t.dims,i),S=[{name:"d_inv",type:et(t.dataType)},{name:"d_comp",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`\n  var<workgroup> thread_max: array<f32, ${u}>;\n  var<workgroup> thread_sum: array<f32, ${u}>;\n  ${w.registerUniforms(S).declareVariables(_)}\n  ${w.mainStart([u,1,1])}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = workgroup_id.x * uniforms.d_comp + local_offset;\n\n    var thread_max_vector = ${d}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n      thread_max_vector = max(${d}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(i){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${i}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${u}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${d}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n      sum_vector += exp(${d}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(i){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${i}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${u}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n        x[offset + i] = ${_.type.value}(uniforms.d_inv);\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n        var f32input = ${d}(x[offset + i]);\n        x[offset + i] = ${_.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${h};${i}`},getShaderSource:y,getRunData:()=>({outputs:[],dispatchGroup:{x:r},programUniforms:p})}},rc=(e,t,r,o,i,u,a)=>{let c=a+i.kvSequenceLength,p=[i.batchSize,i.numHeads,i.sequenceLength,c],h=u.scale===0?1/Math.sqrt(i.headSize):u.scale,d=Me(i.headSize),y=i.headSize/d,w=12,_={x:Math.ceil(c/w),y:Math.ceil(i.sequenceLength/w),z:i.batchSize*i.numHeads},v=[{type:12,data:i.sequenceLength},{type:12,data:y},{type:12,data:c},{type:12,data:i.numHeads},{type:1,data:h}],S=o?["type","type","type"]:["type","type"],I=A=>{let x=U("q",t.dataType,t.dims,d),E=U("key",r.dataType,r.dims,d),P=[x,E];o&&P.push(U("relative_position_bias",o.dataType,o.dims));let O=j("output",t.dataType,p),R=et(1,d),H=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"alpha",type:"f32"}];return`\n  const TILE_SIZE = ${w}u;\n\n  var<workgroup> tileQ: array<${x.type.storage}, ${w*w}>;\n  var<workgroup> tileK: array<${x.type.storage}, ${w*w}>;\n  ${A.registerUniforms(H).declareVariables(...P,O)}\n  ${A.mainStart([w,w,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;\n    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;\n\n    var value = ${R}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n        value += ${R}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * uniforms.M * uniforms.N;\n    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(d){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${d}`)}})()};\n        output[outputIdx] = ${O.type.value} (sum * uniforms.alpha) + ${o?"relative_position_bias[outputIdx]":"0.0"};\n    }\n  }`};return{name:"AttentionProbs",shaderCache:{hint:`${d}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:p,dataType:t.dataType,gpuDataType:0}],dispatchGroup:_,programUniforms:v}),getShaderSource:I}},nc=(e,t,r,o,i)=>{let u=i+o.kvSequenceLength,a=[o.batchSize,o.sequenceLength,o.vHiddenSize],c=12,p={x:Math.ceil(o.vHeadSize/c),y:Math.ceil(o.sequenceLength/c),z:o.batchSize*o.numHeads},h=[{type:12,data:o.sequenceLength},{type:12,data:u},{type:12,data:o.vHeadSize},{type:12,data:o.numHeads},{type:12,data:o.vHiddenSize}];return{name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType,gpuDataType:0}],dispatchGroup:p,programUniforms:h}),getShaderSource:w=>{let _=U("probs",t.dataType,t.dims),v=U("v",r.dataType,r.dims),S=j("output",t.dataType,a),I=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}];return`\n  const TILE_SIZE = ${c}u;\n  var<workgroup> tileQ: array<${_.type.value}, ${c*c}>;\n  var<workgroup> tileK: array<${_.type.value}, ${c*c}>;\n  ${w.registerUniforms(I).declareVariables(_,v,S)}\n  ${w.mainStart([c,c,1])}\n   let headIdx = workgroup_id.z;\n   let m = global_id.y;\n   let n = global_id.x;\n\n   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;\n   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;\n\n   var value = ${_.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n     if (m < uniforms.M && w + local_id.x < uniforms.K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < uniforms.N && w + local_id.y < uniforms.K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + currentBatchHeadNumber * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`}}},Pn=(e,t,r,o,i,u,a,c,p,h,d)=>{let y=e.outputCount>1,w=e.outputCount>2,_=y&&w?h.pastSequenceLength:0,v=_+h.kvSequenceLength,S=[h.batchSize,h.numHeads,v,h.headSize],I=a?[a,r]:[r],A=y?e.compute(En(I,2,S,r.dataType),{inputs:I,outputs:[1]})[0]:r,x=[h.batchSize,h.numHeads,v,h.headSize],E=c?[c,o]:[o],P=w?e.compute(En(E,2,x,o.dataType),{inputs:E,outputs:[2]})[0]:o,O=[t,A];p&&O.push(p);let R=e.compute(rc(e,t,A,p,h,d,_),{inputs:O,outputs:[-1]})[0];e.compute(tc(e,R,h.batchSize*h.numHeads*h.sequenceLength,v),{inputs:[R],outputs:[]});let H=[R,P];e.compute(nc(e,R,P,h,_),{inputs:H,outputs:[0]})},oc=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],o=t.sequenceLength,i=t.inputHiddenSize,u=t.headSize,a=12,c={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},p=[e.inputs[0],e.inputs[1],e.inputs[2]],h=[{type:12,data:o},{type:12,data:i},{type:12,data:u},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],d=y=>{let w=j("output_q",p[0].dataType,r),_=j("output_k",p[0].dataType,r),v=j("output_v",p[0].dataType,r),S=U("input",p[0].dataType,p[0].dims),I=U("weight",p[1].dataType,p[1].dims),A=U("bias",p[2].dataType,p[2].dims),x=S.type.storage,E=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`\n  const TILE_SIZE = ${a}u;\n  var<workgroup> tileInput: array<${x}, ${a*a}>;\n  var<workgroup> tileWeightQ: array<${x}, ${a*a}>;\n  var<workgroup> tileWeightK: array<${x}, ${a*a}>;\n  var<workgroup> tileWeightV: array<${x}, ${a*a}>;\n  ${y.registerUniforms(E).declareVariables(S,I,A,w,_,v)}\n  ${y.mainStart([a,a,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${x}(0);\n    var valueK = ${x}(0);\n    var valueV = ${x}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:c,programUniforms:h}),getShaderSource:d},{inputs:p,outputs:[-1,-1,-1]})},Xa=(e,t)=>{let r=ec(e.inputs,t),[o,i,u]=oc(e,r);return Pn(e,o,i,u,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var ic,ac,sc,Qa,Ja=Y(()=>{"use strict";$r();ye();Se();Ze();_e();ic=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let r=(o,i,u)=>{let a=i.length;if(a!==o.length)throw new Error(`${u}: num dimensions != ${a}`);i.forEach((c,p)=>{if(c!==o[p])throw new Error(`${u}: dim[${p}] do not match`)})};if(e[0].dims.length>1){let o=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,o,"Invalid input scale"),r(e[2].dims,o,"Invalid input B"),r(e[3].dims,o,"Invalid input mean"),r(e[4].dims,o,"Invalid input var")}else r(e[1].dims,[1],"Invalid input scale"),r(e[2].dims,[1],"Invalid input B"),r(e[3].dims,[1],"Invalid input mean"),r(e[4].dims,[1],"Invalid input var")},ac=(e,t)=>{let{epsilon:r,spatial:o,format:i}=t,u=e[0].dims,a=o?Me(u[u.length-1]):1,c=i==="NHWC"&&u.length>1?a:1,p=M.size(u)/a,h=o,d=h?u.length:u,y=U("x",e[0].dataType,e[0].dims,a),w=U("scale",e[1].dataType,e[1].dims,c),_=U("bias",e[2].dataType,e[2].dims,c),v=U("inputMean",e[3].dataType,e[3].dims,c),S=U("inputVar",e[4].dataType,e[4].dims,c),I=j("y",e[0].dataType,d,a),A=()=>{let E="";if(o)E=`let cOffset = ${u.length===1?"0u":i==="NHWC"?`outputIndices[${u.length-1}] / ${a}`:"outputIndices[1]"};`;else if(i==="NCHW")E=`\n            ${I.indicesSet("outputIndices","0","0")}\n            let cOffset = ${I.indicesToOffset("outputIndices")};`;else{E=`var cIndices = ${w.type.indices}(0);\n                       cIndices[0] = outputIndices[${u.length-1}];`;for(let P=1;P<w.rank;P++)E+=`cIndices[${P}] = outputIndices[${P}];`;E+=`let cOffset = ${w.indicesToOffset("cIndices")};`}return E},x=E=>`\n  const epsilon = ${r};\n  ${E.registerUniform("outputSize","u32").declareVariables(y,w,_,v,S,I)}\n  ${E.mainStart()}\n  ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${I.offsetToIndices(`global_idx * ${a}`)};\n    ${A()}\n    let scale = ${w.getByOffset("cOffset")};\n    let bias = ${_.getByOffset("cOffset")};\n    let inputMean = ${v.getByOffset("cOffset")};\n    let inputVar = ${S.getByOffset("cOffset")};\n    let x = ${y.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${I.setByOffset("global_idx","value")}\n  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${o}_${a}`,inputDependencies:h?["rank","type","type","type","type"]:void 0},getShaderSource:x,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h?[{type:12,data:p},...Z(u)]:[{type:12,data:p}]})}},sc=e=>ve(e),Qa=(e,t)=>{let{inputs:r,outputCount:o}=e,i=sc({...t,outputCount:o});if(vr.webgpu.validateInputContent&&ic(r,i),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(ac(r,i))}});var uc,dc,es,ts=Y(()=>{"use strict";Se();_e();uc=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},dc=e=>{let t=e[0].dims,r=e[0].dims[2],o=M.size(t)/4,i=e[0].dataType,u=U("input",i,t,4),a=U("bias",i,[r],4),c=U("residual",i,t,4),p=j("output",i,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:d=>`\n  const channels = ${r}u / 4;\n  ${d.declareVariables(u,a,c,p)}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${u.getByOffset("global_idx")}\n      + ${a.getByOffset("global_idx % channels")} + ${c.getByOffset("global_idx")};\n    ${p.setByOffset("global_idx","value")}\n  }`}},es=e=>{uc(e.inputs),e.compute(dc(e.inputs))}});var lc,ke,rs,ns,os,is,as,ss,us,ds,ls,cc,cs,ps,ms,fs,kn,hs,On,gs,ys,bs,ws,vs,$s,_s,Ss,xs,Cs,As,Is,Ts,Es,Ps,ks,Os,Rs,Bo,Do,Bs,Ds,zs,Rn=Y(()=>{"use strict";ye();Se();Ze();_e();lc=(e,t,r,o,i,u)=>{let a=Math.ceil(t/4),c="";typeof i=="string"?c=`${i}(a)`:c=i("a");let p=U("inputData",r,[a],4),h=j("outputData",o,[a],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(p,h)}\n\n  ${u??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${p.getByOffset("global_idx")};\n    ${h.setByOffset("global_idx",c)}\n  }`},ke=(e,t,r,o,i,u=e.dataType)=>({name:t,shaderCache:{hint:i,inputDependencies:["type"]},getShaderSource:a=>lc(a,M.size(e.dims),e.dataType,u,r,o),getRunData:a=>({outputs:[{dims:e.dims,dataType:u}],dispatchGroup:{x:Math.ceil(M.size(a[0].dims)/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(e.dims)/4)}]})}),rs=e=>{e.compute(ke(e.inputs[0],"Abs","abs"))},ns=e=>{e.compute(ke(e.inputs[0],"Acos","acos"))},os=e=>{e.compute(ke(e.inputs[0],"Acosh","acosh"))},is=e=>{e.compute(ke(e.inputs[0],"Asin","asin"))},as=e=>{e.compute(ke(e.inputs[0],"Asinh","asinh"))},ss=e=>{e.compute(ke(e.inputs[0],"Atan","atan"))},us=e=>{e.compute(ke(e.inputs[0],"Atanh","atanh"))},ds=e=>ve(e),ls=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(ke(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},cc=e=>{let t=e.length>=2&&e[1].data!==0?e[1].getFloat32Array()[0]:xn,r=e.length>=3&&e[2].data!==0?e[2].getFloat32Array()[0]:Cn;return ve({min:t,max:r})},cs=(e,t)=>{let r=e.inputs.length===1?t:cc(e.inputs),o=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Clip",i=>`clamp(${i}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${o}> = vec4(${o}(${r.min}));\n    const clip_max_: vec4<${o}> = vec4(${o}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},ps=e=>{e.compute(ke(e.inputs[0],"Ceil","ceil"))},ms=e=>{e.compute(ke(e.inputs[0],"Cos","cos"))},fs=e=>{e.compute(ke(e.inputs[0],"Cosh","cosh"))},kn=e=>ve(e),hs=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Elu",o=>`elu_vf32(${o})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},On=(e="f32")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,gs=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,On(t)))},ys=e=>{e.compute(ke(e.inputs[0],"Exp","exp"))},bs=e=>{e.compute(ke(e.inputs[0],"Floor","floor"))},ws=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,On(t)))},vs=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"LeakyRelu",o=>`select(leaky_relu_alpha_ * ${o}, ${o}, ${o} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},$s=e=>{e.compute(ke(e.inputs[0],"Not",t=>`!${t}`))},_s=e=>{e.compute(ke(e.inputs[0],"Neg",t=>`-${t}`))},Ss=e=>{e.compute(ke(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},xs=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Relu",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},Cs=e=>{e.compute(ke(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},As=e=>ve(e),Is=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"HardSigmoid",o=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${o} + vec4<${r}>(${t.beta})))`,void 0,t.cacheKey))},Ts=e=>{e.compute(ke(e.inputs[0],"Sin","sin"))},Es=e=>{e.compute(ke(e.inputs[0],"Sinh","sinh"))},Ps=e=>{e.compute(ke(e.inputs[0],"Sqrt","sqrt"))},ks=e=>{e.compute(ke(e.inputs[0],"Tan","tan"))},Os=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,Rs=e=>{e.compute(ke(e.inputs[0],"Tanh",Os))},Bo=(e="f32")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${Os("v")};\n}\n`,Do=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,Bs=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"FastGelu",Do,Bo(t),void 0,e.inputs[0].dataType))},Ds=(e,t)=>{let r=et(e.inputs[0].dataType);return e.compute(ke(e.inputs[0],"ThresholdedRelu",o=>`select(vec4<${r}>(0.0), ${o}, ${o} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},zs=e=>{e.compute(ke(e.inputs[0],"Log","log"))}});var pc,mc,Us,Vs=Y(()=>{"use strict";Se();_e();Rn();pc=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},mc=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=U("input",e[0].dataType,e[0].dims,4),o=U("bias",e[0].dataType,[e[0].dims[2]],4),i=j("output",e[0].dataType,t,4),u=M.size(t)/4,a=Be(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:p=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${p.declareVariables(r,o,i)}\n\n  ${On(a)}\n\n  ${p.mainStart()}\n    ${p.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${i.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Us=e=>{pc(e.inputs),e.compute(mc(e.inputs))}});var fc,hc,kt,Ws,Ns,Gs,Hs,Ls,Fs,qs,js,Ks,Ys,Zs=Y(()=>{"use strict";ye();Se();_e();fc=(e,t,r,o,i,u,a,c,p,h,d,y)=>{let w,_;typeof c=="string"?w=_=(x,E)=>`${c}((${x}),(${E}))`:typeof c=="function"?w=_=c:(w=c.scalar,_=c.vector);let v=j("outputData",d,o.length,4),S=U("aData",p,t.length,4),I=U("bData",h,r.length,4),A;if(i)if(u){let x=M.size(t)===1,E=M.size(r)===1,P=t.length>0&&t[t.length-1]%4===0,O=r.length>0&&r[r.length-1]%4===0;x||E?A=v.setByOffset("global_idx",_(x?`${S.type.value}(${S.getByOffset("0")}.x)`:S.getByOffset("global_idx"),E?`${I.type.value}(${I.getByOffset("0")}.x)`:I.getByOffset("global_idx"))):A=`\n            let outputIndices = ${v.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${S.broadcastedIndicesToOffset("outputIndices",v)};\n            let offsetB = ${I.broadcastedIndicesToOffset("outputIndices",v)};\n            ${v.setByOffset("global_idx",_(a||P?S.getByOffset("offsetA / 4u"):`${S.type.value}(${S.getByOffset("offsetA / 4u")}[offsetA % 4u])`,a||O?I.getByOffset("offsetB / 4u"):`${I.type.value}(${I.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else A=v.setByOffset("global_idx",_(S.getByOffset("global_idx"),I.getByOffset("global_idx")));else{if(!u)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let x=(E,P,O="")=>{let R=`aData[indexA${P}][componentA${P}]`,H=`bData[indexB${P}][componentB${P}]`;return`\n            let outputIndices${P} = ${v.offsetToIndices(`global_idx * 4u + ${P}u`)};\n            let offsetA${P} = ${S.broadcastedIndicesToOffset(`outputIndices${P}`,v)};\n            let offsetB${P} = ${I.broadcastedIndicesToOffset(`outputIndices${P}`,v)};\n            let indexA${P} = offsetA${P} / 4u;\n            let indexB${P} = offsetB${P} / 4u;\n            let componentA${P} = offsetA${P} % 4u;\n            let componentB${P} = offsetB${P} % 4u;\n            ${E}[${P}] = ${O}(${w(R,H)});\n          `};d===9?A=`\n            var data = vec4<u32>(0);\n            ${x("data",0,"u32")}\n            ${x("data",1,"u32")}\n            ${x("data",2,"u32")}\n            ${x("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:A=`\n            ${x("outputData[global_idx]",0)}\n            ${x("outputData[global_idx]",1)}\n            ${x("outputData[global_idx]",2)}\n            ${x("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(S,I,v)}\n\n        ${y??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${A}\n      }`},hc=(e,t,r,o,i,u,a=r.dataType)=>{let c=!M.areEqual(r.dims,o.dims),p=r.dims,h=M.size(r.dims),d=!1,y=!1,w=[c];if(c){let _=At.calcShape(r.dims,o.dims,!1);if(!_)throw new Error("Can\'t perform binary op on the given tensors");p=_,h=M.size(p);let v=M.size(r.dims)===1,S=M.size(o.dims)===1,I=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,A=o.dims.length>0&&o.dims[o.dims.length-1]%4===0;w.push(v),w.push(S),w.push(I),w.push(A);let x=1;for(let E=1;E<p.length;E++){let P=r.dims[r.dims.length-E]??1,O=o.dims[o.dims.length-E]??1;if(P===O)x*=P;else break}x%4===0?(y=!0,d=!0):(v||S||I||A)&&(d=!0)}else d=!0;return w.push(d),{name:e,shaderCache:{hint:t+w.map(_=>_.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:_=>fc(_,r.dims,o.dims,p,d,c,y,i,r.dataType,o.dataType,a,u),getRunData:()=>({outputs:[{dims:p,dataType:a}],dispatchGroup:{x:Math.ceil(h/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(p)/4)},...Z(r.dims,o.dims,p)]})}},kt=(e,t,r,o,i,u)=>{e.compute(hc(t,i??"",e.inputs[0],e.inputs[1],r,o,u))},Ws=e=>{kt(e,"Add",(t,r)=>`${t}+${r}`)},Ns=e=>{kt(e,"Div",(t,r)=>`${t}/${r}`)},Gs=e=>{kt(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Hs=e=>{kt(e,"Mul",(t,r)=>`${t}*${r}`)},Ls=e=>{let t=U("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;kt(e,"Pow",{scalar:(o,i)=>`pow_custom(${o},${i})`,vector:(o,i)=>`pow_vector_custom(${o},${i})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Fs=e=>{kt(e,"Sub",(t,r)=>`${t}-${r}`)},qs=e=>{kt(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},js=e=>{kt(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Ks=e=>{kt(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Ys=e=>{kt(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var _t,St,xt,Bn,Ft=Y(()=>{"use strict";ye();Se();_t=(e,t,r="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},St=(e,t)=>{e.activation==="Clip"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation==="HardSigmoid"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation==="LeakyRelu"&&t.push({type:1,data:e.alpha})},xt=(e,t)=>{e.activation==="Clip"?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):e.activation==="HardSigmoid"?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):e.activation==="LeakyRelu"&&t.push({name:"alpha",type:"f32"})},Bn=e=>{let t=e?.activation||"";if(t==="HardSigmoid"){let[r,o]=e?.activation_params||[.2,.5];return{activation:t,alpha:r,beta:o}}else if(t==="Clip"){let[r,o]=e?.activation_params||[xn,Cn];return{activation:t,clipMax:o,clipMin:r}}else if(t==="LeakyRelu"){let[r]=e?.activation_params||[.01];return{activation:t,alpha:r}}return{activation:t}}});var tt,Dn,zn=Y(()=>{"use strict";tt=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Dn=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var Mn,zo=Y(()=>{"use strict";Mn=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var yc,bc,Hr,Xs,wc,Lr,vc,Un,Fr=Y(()=>{"use strict";ye();Se();_e();Ft();zn();yc=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,bc=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,Hr=(e,t,r="f32",o,i=!1,u=32,a=!1,c=32)=>{let p=t[1]*e[1],h=t[0]*e[0],d=i?p:u,y=i?u:p,w=d/t[0],_=u/t[1];if(!((i&&w===4&&e[1]===4||!i&&(w===3||w===4))&&d%t[0]===0&&u%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${i} is true, innerElementSize ${w} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${w} must be 3 or 4.\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${u} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${w}<${r}>, ${d/w}>, ${y}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${h/e[0]}>, ${u}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${w};\nconst tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${a?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${p};\n\n  let num_tiles = ${a?`${Math.ceil(c/u)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n  var kStart = ${a?`i32(globalId.z) * ${c}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${yc(i,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${w===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${bc(i,w)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Xs=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,wc=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Lr=(e,t,r="f32",o,i=!1,u=32,a=!1,c=32,p=!1)=>{let h=e[1]*t[1],d=e[0]*t[0],y=i?h:u,w=i?u:h;if(!(w%t[1]===0&&y%t[0]===0&&u%t[1]===0))throw new Error(`tileAHight ${w} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${y} must be divisible by workgroupSize[0]${t[0]}, tileInner ${u} must be divisible by workgroupSize[1]${t[1]}`);let _=w/t[1],v=y/t[0],S=u/t[1],I=p?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${h};\n    let globalColStart = i32(workgroupId.x) * ${d};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${w}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${y}; inputCol = inputCol + ${t[0]}) {\n          ${Xs(i,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${u}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${i?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${h};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${v};\nlet tileRowB = i32(localId.y) * ${S};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${v}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Xs(i,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${S}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${wc(i)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${y}>, ${w}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${d}>, ${u}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${a?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let num_tiles = ${a?`${Math.ceil(c/u)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n    var kStart = ${a?`i32(globalId.z) * ${c}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${I}\n  }\n`},vc=(e,t,r,o,i,u=!1)=>{let[a,c,p]=i,[h,d,y,w]=o,_=_r(a,p),v=_r(c,p),S=Be(o[0].type.tensor),I=()=>{let E=d.rank,P=h.rank,O=`var aIndices: ${d.type.indices};`;for(let R=E-2-1,H=P-1;R>=0;R--,H--)O+=`\naIndices[${R}] = ${P>1?`batchIndices[${H}]`:"batchIndices"};`;return _.forEach(R=>{O+=`\naIndices[${R}] = 0;`}),O+=`\naIndices[${E-2}] = u32(row);\n                   aIndices[${E-1}] = u32(colIn);`,O},A=()=>{let E=y.rank,P=h.rank,O=`var bIndices: ${y.type.indices};`;for(let R=E-2-1,H=P-1;R>=0;R--,H--)O+=`\nbIndices[${R}] = ${P>1?`batchIndices[${H}]`:"batchIndices"};`;return v.forEach(R=>{O+=`\nbIndices[${R}] = 0;`}),O+=`\nbIndices[${E-2}] = u32(row);\n                   bIndices[${E-1}] = u32(colIn);`,O};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${tt(e,S)} {\n      var value = ${tt(e,S)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        ${I()}\n        value = ${d.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${tt(e,S)} {\n      var value = ${tt(e,S)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        ${A()}\n        value = ${y.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${tt(e,S)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${u?"bias[colIn]":`${tt(e,S)}(bias[row])`};`:""}\n        ${r}\n        ${w.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Un=(e,t,r,o,i=!1)=>{let u=e[0].dims,a=e[1].dims,c=u.slice(0,-2),p=a.slice(0,-2),h=o?o.slice(0,-2):r.slice(0,-2),d=M.size(h),y=u[u.length-2],w=u[u.length-1],_=a[a.length-1],v=w%4===0&&_%4===0,S=y<=8?[4,1,1]:[4,4,1],I=[8,8,1],A=[Math.ceil(_/I[0]/S[0]),Math.ceil(y/I[1]/S[1]),Math.ceil(d/I[2]/S[2])],x=v?4:1,E=[...c,y,w/x],P=E.length,O=[...p,w,_/x],R=O.length,H=[d,y,_/x],N=[{type:6,data:y},{type:6,data:_},{type:6,data:w}];St(t,N),N.push(...Z(h,E,O));let K=["rank","rank"],Q=e.length>2;Q&&(N.push(...Z(e[2].dims)),K.push("rank")),N.push(...Z(H));let he=W=>{let se=h.length,Ce=An("batchDims",e[0].dataType,se,1),We=Be(e[0].dataType),ee=U("a",e[0].dataType,P,x),ae=U("b",e[1].dataType,R,x),Ae=j("result",e[0].dataType,H.length,x),me=[ee,ae];if(Q){let G=i?x:1;me.push(U("bias",e[2].dataType,e[2].dims.length,G))}let ie=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];xt(t,ie);let ue=Be(Ae.type.tensor),le=_t(t,Ae.type.value,ue),qe=vc(x,Q,le,[Ce,ee,ae,Ae],[c,p,h],i);return`\n  ${W.registerUniforms(ie).registerInternalVariables(Ce).declareVariables(...me,Ae)}\n  ${qe}\n  ${v?Hr(S,I,We,Ce):Lr(S,I,We,Ce)}\n                   `};return{name:"MatMul",shaderCache:{hint:`${S};${t.activation};${v};${i}`,inputDependencies:K},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:A[0],y:A[1],z:A[2]},programUniforms:N}),getShaderSource:he}}});var $c,Qs,Js=Y(()=>{"use strict";ye();Ht();_e();Ft();zn();zo();Fr();$c=(e,t,r,o,i=!1,u,a=4,c=4,p=4,h="f32")=>{let d=Q=>{switch(Q){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${h}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Q} is not supported.`)}},y=Q=>{switch(Q){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${Q} is not supported.`)}},w=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,_=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,v=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",S=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",I=e?"row":"col",A=e?"col":"row",x=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${I} / outWidth;\n    let outCol = ${I} % outWidth;\n\n    let WRow = ${A} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${A} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${A} % inChannels;\n    var resData = ${tt(a,h)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${v} && xCol >= 0 && xCol < ${S}) {\n      ${w}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${d(a)}\n    }\n    return resData;`,E=e?t&&o?`\n    let col = colIn * ${a};\n    ${x}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${x}\n    }\n    return ${tt(a,h)}(0.0);`:o&&r?`\n    let col = colIn * ${a};\n    ${x}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${x}\n    }\n    return ${tt(a,h)}(0.0);`,P=`${y(c)}`,O=tt(p,h),R=e?tt(a,h):tt(c,h),H=e?tt(c,h):tt(a,h),N=_t(u,O,h);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${R} {\n      ${e?E:P}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${H} {\n      ${e?P:E}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${O}) {\n      let col = colIn * ${p};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${_}\n      ${Dn(i)}\n      ${N}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Qs=(e,t,r,o,i,u,a,c)=>{let p=t.format==="NHWC",h=p?e[0].dims[3]:e[0].dims[1],d=r[0],y=p?r[2]:r[3],w=p?r[1]:r[2],_=p?r[3]:r[1],v=p&&(h%4===0||h%3===0)&&_%4===0,S=p?_:y*w,I=p?y*w:_,A=[8,8,1],x=o<=8?[4,1,1]:[4,4,1],E=[Math.ceil(S/A[0]/x[0]),Math.ceil(I/A[1]/x[1]),Math.ceil(d/A[2]/x[2])];Ve("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${E}`);let P=v?p&&h%4!==0?3:4:1,O=A[1]*x[1],R=A[0]*x[0],H=Math.max(A[0]*P,A[1]),N=o%O===0,K=i%R===0,Q=u%H===0,he=v?[P,4,4]:[1,1,1],W=[{type:6,data:o},{type:6,data:i},{type:6,data:u},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];St(t,W),W.push(...Z(e[0].dims,e[1].dims));let se=["rank","rank"];a&&(W.push(...Z(e[2].dims)),se.push("rank")),W.push(...Z(r));let Ce=We=>{let ee=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];xt(t,ee);let ae=v?4:1,Ae=Be(e[0].dataType),me=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${v?`vec4<${Ae}>`:Ae}) {\n        result[flatIndex] = ${v?`vec4<${Ae}>`:Ae}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${v?`vec4<${Ae}>`:Ae}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${v?"/ 4":""}, value);\n      }`,ie=U("x",e[0].dataType,e[0].dims.length,P===3?1:P),ue=U("w",e[1].dataType,e[1].dims.length,ae),le=[ie,ue],qe=j("result",e[0].dataType,r.length,ae);if(a){let G=U("bias",e[2].dataType,e[2].dims.length,ae);le.push(G),me+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?`vec4<${Ae}>`:Ae} {\n          return bias[coords.${p?"w":"y"}${v?"/ 4":""}];\n        }`}return`\n        ${Mn("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${We.registerUniforms(ee).declareVariables(...le,qe)}\n        ${me}\n        ${$c(p,N,K,Q,a,t,he[0],he[1],he[2],Ae)}\n        ${v?Hr(x,A,Ae,void 0,!p,H):Lr(x,A,Ae,void 0,!p,H,!1,void 0,c)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${P};${v};${N};${K};${Q};${O};${R};${H}`,inputDependencies:se},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:W}),getShaderSource:Ce}}});var Mo,eu,tu=Y(()=>{"use strict";ye();Se();_e();Uo();Ft();Mo=(e,t,r)=>{let o=e.length>2,i=o?"value += b[output_channel];":"",u=e[0].dims,a=e[1].dims,c=a[0]/t.group,p=t.format==="NHWC",h=Vn(u,a,t.dilations,t.pads,t.strides,p),d=M.size(h),y=[{type:12,data:d},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:c}];St(t,y),y.push(...Z(u,a));let w=["rank","rank"];o&&(y.push(...Z(e[2].dims)),w.push("rank")),y.push(...Z(h));let _=v=>{let S=j("output",e[0].dataType,h.length),I=Be(S.type.tensor),A=_t(t,S.type.value,I),x=U("x",e[0].dataType,u.length),E=U("w",e[1].dataType,a.length),P=[x,E];o&&P.push(U("b",e[2].dataType,e[2].dims.length));let O=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];return xt(t,O),`\n  ${v.registerUniforms(O).declareVariables(...P,S)}\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let outputIndices = ${S.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${p?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${p?1:2}], outputIndices[${p?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel / uniforms.output_channels_per_group;\n\n    var value: ${S.type.value} = ${S.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[${p?1:2}]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[${p?2:3}]) {\n            continue;\n          }\n\n          let xVal = ${p?x.get("batch","xHeight","xWidth","input_channel"):x.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${E.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${i}\n    ${A}\n    ${S.setByOffset("global_idx","value")}\n  }`};return{name:"GroupedConv",shaderCache:{hint:t.cacheKey,inputDependencies:w},getRunData:()=>({outputs:[{dims:r?r(h):h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:y}),getShaderSource:_}},eu=(e,t,r)=>{let o=e.length>2,i=Me(r[3]),u=Me(r[2]),a=M.size(r)/i/u,c=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/i],p=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/i],h=[r[0],r[1],r[2],r[3]/i],d=[{type:12,data:a},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];St(t,d),d.push(...Z(c,p,h));let y=(u-1)*t.strides[1]+p[1],w=_=>{let v=j("output",e[0].dataType,h.length,i),S=Be(v.type.tensor),I=_t(t,v.type.value,S),A=U("x",e[0].dataType,c.length,i),x=U("w",e[1].dataType,p.length,i),E=[A,x];o&&E.push(U("b",e[2].dataType,e[2].dims,i));let P=o?"value += b[output_channel];":"",O=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return xt(t,O),`\n  ${_.registerUniforms(O).declareVariables(...E,v)}\n  ${_.mainStart()}\n    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${u}u;\n    let col = (index1 % width1) * ${u}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${A.type.value}, ${y}>;\n    var values: array<${v.type.value}, ${u}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w\'s height/width.\n    for (var w_height: u32 = 0u; w_height < ${p[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${y}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${A.get("batch","u32(x_height)","u32(x_width)","input_channel")};\n          } else {\n            x_vals[i] = ${A.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${p[1]}; w_width++) {\n          let w_val = ${x.get("w_height","w_width","0","output_channel")};\n          for (var i = 0u; i < ${u}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${u}u; i++) {\n      var value = values[i];\n      ${P}\n      ${I}\n      ${v.set("batch","row","col + i","output_channel","value")};\n    }\n  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${i};${u};${y};${p[0]};${p[1]}`,inputDependencies:o?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:d}),getShaderSource:w}}});var Vo,_c,ru,Wo=Y(()=>{"use strict";ye();Se();Fr();_e();Ft();Vo=(e,t,r,o,i=!1)=>{let u=e[0].dims,a=e[1].dims,c=u[u.length-2],p=a[a.length-1],h=u[u.length-1],d=Me(p),y=Me(h),w=Me(c),_=M.size(r)/d/w,v=e.length>2,S=o?o.slice(0,-2):r.slice(0,-2),A=[M.size(S),c,p],x=[{type:12,data:_},{type:12,data:c},{type:12,data:p},{type:12,data:h}];St(t,x),x.push(...Z(S,u,a)),v&&x.push(...Z(e[2].dims)),x.push(...Z(A));let E=P=>{let O=An("batch_dims",e[0].dataType,S.length),R=U("a",e[0].dataType,u.length,y),H=U("b",e[1].dataType,a.length,d),N=j("output",e[0].dataType,A.length,d),K=Be(N.type.tensor),Q=_t(t,N.type.value,K),he=[R,H],W="";if(v){let ie=i?d:1;he.push(U("bias",e[2].dataType,e[2].dims.length,ie)),W=`${i?`value += bias[col / ${ie}];`:`value += ${N.type.value}(bias[row + i]);`}`}let se=u.slice(0,-2),Ce=a.slice(0,-2),We=_r(se,S),ee=_r(Ce,S),ae=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];xt(t,ae);let Ae=(ie,ue)=>{let le=ie.rank,qe=ie.name;if(le===2)return`var ${qe}_indices = ${ie.type.indices}(0u, 0u);`;let G=O.rank,ne=`var ${qe}_indices: ${ie.type.indices};`;for(let xe=le-2-1,Ke=G-1;xe>=0;xe--,Ke--)ne+=`\n${qe}_indices[${xe}] = ${G>1?`batch_indices[${Ke}]`:"batch_indices"};`;return ue.forEach(xe=>{ne+=`\n${qe}_indices[${xe}] = 0;`}),ne+=`${qe}_indices[${le-2}] = 0u;\n                     ${qe}_indices[${le-1}] = 0u;`,ne},me=()=>{let ie=`var a_data: ${R.type.value};`;for(let ue=0;ue<y;ue++)ie+=`\n              let b_data${ue} = b[(b_offset + (k + ${ue}) * uniforms.N + col) / ${d}];`;for(let ue=0;ue<w;ue++){ie+=`a_data = a[(a_offset + (row + ${ue}) * uniforms.K + k) / ${y}];`;for(let le=0;le<y;le++)ie+=`\n            values[${ue}] = fma(${H.type.value}(a_data${y===1?"":`[${le}]`}), b_data${le}, values[${ue}]);\n`}return ie};return`\n  ${P.registerUniforms(ae).registerInternalVariables(O).declareVariables(...he,N)}\n  ${P.mainStart()}\n    ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let col = (global_idx % (uniforms.N / ${d})) * ${d};\n    var index1 = global_idx / (uniforms.N / ${d});\n    let stride1 = uniforms.M / ${w};\n    let row = (index1 % stride1) * ${w};\n    let batch = index1 / stride1;\n\n    ${r.length===2?"":`let batch_indices = ${O.offsetToIndices("batch")};`}\n    ${Ae(R,We)}\n    let a_offset = ${R.indicesToOffset("a_indices")};\n    ${Ae(H,ee)}\n    let b_offset = ${H.indicesToOffset("b_indices")};\n    var values: array<${N.type.value}, ${w}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${y}) {\n      ${me()}\n    }\n    for (var i = 0u; i < ${w}u; i++) {\n      var value = values[i];\n      ${W}\n      ${Q}\n      let cur_indices = ${N.type.indices}(batch, row + i, col);\n      let offset = ${N.indicesToOffset("cur_indices")};\n      ${N.setByOffset(`offset / ${d}`,"value")};\n    }\n  }\n  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${d};${y};${w};${i}`,inputDependencies:v?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:x}),getShaderSource:E}},_c=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},ru=e=>{_c(e.inputs);let t=At.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");let r=t[t.length-1],o=e.inputs[0].dims[e.inputs[0].dims.length-1];r<8&&o<8?e.compute(Vo(e.inputs,{activation:""},t)):e.compute(Un(e.inputs,{activation:""},t))}});var Vn,No,Sc,nu,Go,xc,Cc,Ho,Uo=Y(()=>{"use strict";Se();Js();Fr();tu();Ft();Wo();Sr();Vn=(e,t,r,o,i,u)=>{let a=e[0],c=e.slice(u?1:2,u?3:4),p=c.length,h=t[0],y=t.slice(2).map((v,S)=>v+(v-1)*(r[S]-1)),_=c.map((v,S)=>v+o[S]+o[S+p]).map((v,S)=>Math.floor((v-y[S]+i[S])/i[S]));return _.splice(0,0,a),_.splice(u?3:1,0,h),_},No=[2,3,1,0],Sc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let i=e[0].dims.length-2;if(t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},nu=(e,t)=>{let r=e.kernelShape.slice();for(let u=2;u<t[1].dims.length;++u)r[u-2]===0&&(r[u-2]=t[1].dims[u]);let o=e.pads.slice();nr.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let i=Object.assign({},e);return Object.assign(i,{kernelShape:r,pads:o}),i},Go=e=>{let t=Bn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],i=e.dilations,u=e.group,a=e.kernel_shape,c=e.pads,p=e.strides,h=e.w_is_const();return{autoPad:o,format:r,dilations:i,group:u,kernelShape:a,pads:c,strides:p,wIsConst:h,...t,cacheKey:`${e.format};${t.activation};`}},xc=(e,t,r)=>{let o=nu(r,t),i=r.format==="NHWC";if(r.group!==1){if(!e.adapterInfo.isArchitecture("ampere")&&i&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1){let H=Vn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,i),N=e.kernelCustomData.wT??e.compute(yt(t[1],No),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=N);let K=[t[0],N];t.length===3&&K.push(t[2]),e.compute(eu(K,o,H),{inputs:K})}else e.compute(Mo(t,o));return}let u=t.length===3,a=t[0].dims[i?1:2],c=t[0].dims[i?2:3],p=t[0].dims[i?3:1],h=t[1].dims[2],d=t[1].dims[3],y=Vn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,i),w=y[i?1:2],_=y[i?2:3],v=y[i?3:1],S=i&&h===a&&d===c&&r.pads[0]===0&&r.pads[1]===0;if(S||h===1&&d===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let R=y[0],H,N,K,Q=[];if(i){let se=e.kernelCustomData.wT??e.compute(yt(t[1],No),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=se),S){let Ce=a*c*p;H=t[0].reshape([1,R,Ce]),N=se.reshape([1,Ce,v]),K=[1,R,v]}else H=t[0].reshape([R,a*c,p]),N=se.reshape([1,p,v]),K=[R,w*_,v];Q.push(H),Q.push(N)}else H=t[0].reshape([R,p,a*c]),N=t[1].reshape([1,v,p]),K=[R,v,w*_],Q.push(N),Q.push(H);u&&Q.push(t[2]);let he=K[2],W=Q[0].dims[Q[0].dims.length-1];he<8&&W<8?e.compute(Vo(Q,o,y,K,i),{inputs:Q}):e.compute(Un(Q,o,y,K,i),{inputs:Q});return}let I=!0,A=e.kernelCustomData.wT??e.compute(yt(t[1],No),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let x=[t[0],A];u&&x.push(t[2]);let E=i?w*_:v,P=i?v:w*_,O=h*d*p;e.compute(Qs(x,o,y,E,P,O,u,I),{inputs:x})},Cc=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let i=[0,t.pads[0],0,t.pads[1]],u=[1].concat(t.strides),a=[1].concat(t.dilations),c=[1].concat(t.kernelShape),p=nu({...t,pads:i,strides:u,dilations:a,kernelShape:c},o);e.compute(Mo(o,p,h=>r?[h[0],h[2],h[3]]:[]))},Ho=(e,t)=>{Sc(e.inputs,t),e.inputs[0].dims.length===3?Cc(e,t):xc(e,e.inputs,t)}});var Ac,ou,iu=Y(()=>{"use strict";ye();Ht();_e();Ft();zn();zo();Fr();Ac=(e,t=!1,r,o,i=4)=>{let u=A=>{switch(A){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return ${o}(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${A} is not supported.`)}},a=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,c=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,p=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",h=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",d=e?"row":"col",y=e?"col":"row",w=`\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      let outRow = ${d} / outWidth;\n      let outCol = ${d} % outWidth;\n\n      let WRow = ${y} / (uniforms.filter_dims[1] * inChannels);\n      let WCol = ${y} / inChannels % uniforms.filter_dims[1];\n      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(${p}) || fract(xR) > 0.0) {\n        return ${o}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${h}) || fract(xC) > 0.0) {\n        return ${o}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${y} % inChannels;\n      ${a}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${i}];`,_=e?`\n      let col = colIn * ${i};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n        ${w}\n      }\n      return ${o}(0.0);`:`\n      let col = colIn * ${i};\n      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n        ${w}\n      }\n      return ${o}(0.0);`,v=`\n      let col = colIn * ${i};\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);\n      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];\n      if (${e?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${u(i)}\n      }\n      return ${o}(0.0);\n      `,S=_t(r,o);return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${o} {\n    ${e?_:v}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${o} {\n    ${e?v:_}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${o}) {\n    let col = colIn * ${i};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n      var value = valueInput;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${c}\n      ${Dn(t)}\n      ${S}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${i}] = value;\n    }\n  }`},ou=(e,t,r,o,i,u,a,c)=>{let p=t.format==="NHWC",h=p?e[0].dims[3]:e[0].dims[1],d=r[0],y=p?r[2]:r[3],w=p?r[1]:r[2],_=p?r[3]:r[1],v=p&&h%4===0&&h%3&&_%4===0,S=p?_:y*w,I=p?y*w:_,A=[8,8,1],x=o<=8?[4,1,1]:[4,4,1],E=[Math.ceil(S/A[0]/x[0]),Math.ceil(I/A[1]/x[1]),Math.ceil(d/A[2]/x[2])];Ve("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${E}`);let P=v?4:1,O=Math.max(A[0]*P,A[1]),R=v?4:1,H=[t.kernelShape[p?1:2],t.kernelShape[p?2:3]],N=[H[0]+(t.dilations[0]<=1?0:(H[0]-1)*(t.dilations[0]-1)),H[1]+(t.dilations[1]<=1?0:(H[1]-1)*(t.dilations[1]-1))],K=[N[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),N[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],Q=[{type:6,data:o},{type:6,data:i},{type:6,data:u},{type:6,data:t.strides},{type:6,data:t.dilations},{type:6,data:H},{type:6,data:K}];St(t,Q),Q.push(...Z(e[0].dims,e[1].dims));let he=["rank","rank"];a&&(Q.push(...Z(e[2].dims)),he.push("rank")),Q.push(...Z(r));let W=se=>{let Ce=U("x",e[0].dataType,e[0].dims.length,R),We=U("w",e[1].dataType,e[1].dims.length,1),ee=j("result",e[0].dataType,r.length,R),ae=[Ce,We],Ae="";if(a){let ue=U("bias",e[2].dataType,e[2].dims.length,R);ae.push(ue),Ae+=`\n          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${ue.type.value} {\n            return bias[coords.${p?"w":"y"}${v?"/ 4":""}];\n          }`}let me=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:H.length},{name:"pads",type:"i32",length:K.length}];xt(t,me);let ie=Be(e[0].dataType,1);if(ie!=="f16"&&ie!=="f32")throw new Error(`elemType ${ie} is not supported.`);return`\n        ${Mn("uniforms.result_strides")}\n        ${se.registerUniforms(me).declareVariables(...ae,ee)};\n        ${Ae}\n        ${Ac(p,a,t,Ce.type.value,P)}\n        ${v?Hr(x,A,ie,void 0,!p,O):Lr(x,A,ie,void 0,!p,O,!1,void 0,c)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${t.cacheKey};${x};${A};${v}`,inputDependencies:he},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:Q}),getShaderSource:W}}});var Ic,Lo,au=Y(()=>{"use strict";ye();Ht();Se();_e();Ic=(e,t,r,o,i,u=!1,a,c,p=!1)=>{let h=p?1:2,d=p?2:3,y=p?3:1,w=u?2:1,_=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${a}>`:a}) {\n    result[flatIndex] = ${u?`vec4<${a}>`:a}(value);\n  }`;o&&(_+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${a}>`:a} {\n      return bias[coords.${p?"w":"y"}${u?"/ 4":""}];\n    }`);let v=u?4:1,S=U("W",t[1].dataType,t[1].dims.length,v),I=U("Dy",t[0].dataType,t[0].dims.length,v),A=[I,S];o&&A.push(U("bias",t[2].dataType,[r[y]].length,v));let x=j("result",t[0].dataType,r.length,v),E=`{\n        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];\n        let r = ${i?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];\n        let c = ${i?"global_id.y":"workgroup_id.y"} * ${w};\n        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${a}>, ${w}>;\n        for (var i = 0; i < ${w}; i++) {\n          dotProd[i] = vec4<${a}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {\n          var dyR = (${a}(dyCorner.x) + ${a}(wR)) / ${a}(uniforms.strides.x);\n          let wRPerm = uniforms.filter_dims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${a}(uniforms.Dy_shape[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {\n            let dyC = (${a}(dyCorner.y) + ${a}(wC)) / ${a}(uniforms.strides.y);\n            let dyC2 = (${a}(dyCorner.y) + 1.0 + ${a}(wC)) / ${a}(uniforms.strides.y);\n            let wCPerm = uniforms.filter_dims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${a}(uniforms.Dy_shape[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${a}(uniforms.Dy_shape[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${I.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${I.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${a}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = uniforms.Dy_shape[${y}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${I.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${I.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${w}; i = i + 1) {\n          let value = dotProd[i] + ${o?"bias[c+i]":`vec4<${a}>(0.0)`};\n          ${x.set("batch","r","c + i","d1","value")};\n        }\n      }`,P=`\n          let outputIndices = ${x.offsetToIndices("global_idx")};\n          let batch = ${x.indicesGet("outputIndices",0)};\n          let d1 = ${x.indicesGet("outputIndices",y)};\n          let r = ${x.indicesGet("outputIndices",h)};\n          let c = ${x.indicesGet("outputIndices",d)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / uniforms.output_channels_per_group;\n          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = ${a}(0.0);\n          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n            if (wR % uniforms.dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${a}(dyRCorner) + ${a}(wR)) / ${a}(uniforms.strides[0]);\n            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n            if (dyR < 0.0 || dyR >= ${a}(uniforms.Dy_shape[${h}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n              if (wC % uniforms.dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${a}(dyCCorner) + ${a}(wC)) / ${a}(uniforms.strides.y);\n              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n              if (dyC < 0.0 || dyC >= ${a}(uniforms.Dy_shape[${d}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * uniforms.input_channels_per_group;\n              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {\n                let xValue = ${p?I.get("batch","idyR","idyC","inputChannel"):I.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${S.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${o?"bias[d1]":`${a}(0.0)`};\n          ${x.setByOffset("global_idx","value")};\n        `;return`\n  ${e.registerUniforms(c).declareVariables(...A,x)}\n  ${_}\n\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\n  ${u?E:P}}`},Lo=(e,t,r)=>{let o=e.length>2,i=t.outputShape,u=M.size(i),a=[Math.ceil(u/64),1,1];Ve("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${a}`);let c=t.format==="NHWC",p=["rank","rank"],h=[t.strides[0],t.strides[1]],d=[t.kernelShape[c?1:2],t.kernelShape[c?2:3]],y=[t.dilations[0],t.dilations[1]],w=[d[0]+(t.dilations[0]<=1?0:(t.kernelShape[c?1:2]-1)*(t.dilations[0]-1)),d[1]+(t.dilations[1]<=1?0:(t.kernelShape[c?2:3]-1)*(t.dilations[1]-1))],_=[w[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),w[1]-1-Math.floor(t.pads[1]+t.pads[3])/2],v=!1,S=t.group,I=e[1].dims,A=I[0]/S,x=I[1],E=[{type:12,data:u},{type:12,data:h},{type:12,data:d},{type:12,data:y},{type:12,data:w},{type:6,data:_},{type:12,data:A},{type:12,data:x},...Z(e[0].dims,e[1].dims)];o&&(E.push(...Z(e[2].dims)),p.push("rank")),E.push(...Z(i));let P=a[1]===1&&a[2]===1,O=R=>{let H=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:h.length},{name:"filter_dims",type:"u32",length:d.length},{name:"dilations",type:"u32",length:d.length},{name:"effective_filter_dims",type:"u32",length:w.length},{name:"pads",type:"i32",length:_.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],N=Be(e[0].dataType);return`${Ic(R,e,i,o,P,v,N,H,c)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};`,inputDependencies:p},getRunData:()=>({dispatchGroup:{x:a[0],y:a[1],z:a[2]},outputs:[{dims:r?r(i):i,dataType:e[0].dataType}],programUniforms:E}),getShaderSource:O}}});var Tc,Ec,Pc,su,uu,kc,Oc,Rc,Bc,du,lu=Y(()=>{"use strict";iu();au();Ft();Sr();Tc=(e,t,r,o,i,u)=>(e-1)*t+r+(o-1)*i+1-u,Ec=(e,t,r,o,i)=>{let u=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=u,r[i]=e-u):t==="SAME_LOWER"&&(r[o]=e-u,r[i]=u)},Pc=(e,t,r,o,i,u,a,c,p,h)=>{let d=e.length-2,y=h.length===0;if(p.length===0)for(let v=0;v<d;++v)p.push(0);let w=e[0],_=t[c?3:1]*i;for(let v=0,S=e.length-d-(c?1:0);v<d;++v,++S){let I=e[S],A=y?I*a[v]:h[v],x=Tc(I,a[v],u[v],t[S],r[v],A);Ec(x,o,u,v,v+d),y&&h.push(a[v]*(I-1)+p[v]+(t[S]-1)*r[v]+1-u[v]-u[v+d])}h.splice(0,0,w),h.splice(c?3:1,0,_)},su=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((y,w)=>y*w,1)===0){r.length=0;for(let y=2;y<t[1].dims.length;++y)r.push(t[1].dims[y])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let i=e.pads.slice(),u=e.outputShape.slice(),a=e.outputPadding.slice(),c=t[0].dims,p=e.dilations.slice();if(p.reduce((y,w)=>y+w,0)===0){let y=t[0].dims.length-2;p=new Array(y).fill(1)}let h=e.strides.slice();if(h.reduce((y,w)=>y+w,0)===0){let y=t[0].dims.length-2;h=new Array(y).fill(1)}Pc(c,r,p,e.autoPad,e.group,i,h,o,a,u);let d=Object.assign({},e);return Object.assign(d,{kernelShape:r,pads:i,outputPadding:a,outputShape:u,dilations:p,strides:h}),d},uu=e=>{let t=Bn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],i=e.dilations,u=e.group,a=e.kernelShape,c=e.pads,p=e.strides,h=e.wIsConst(),d=e.outputPadding,y=e.outputShape;return{autoPad:o,format:r,dilations:i,group:u,kernelShape:a,outputPadding:d,outputShape:y,pads:c,strides:p,wIsConst:h,...t,cacheKey:`${e.format};${t.activation};`}},kc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==i))throw new Error("invalid bias");let u=e[0].dims.length-2;if(t.dilations.reduce((d,y)=>d+y,0)>0&&t.dilations.length!==u)throw new Error(`dilations should be ${u}D`);if(t.strides.reduce((d,y)=>d+y,0)>0&&t.strides.length!==u)throw new Error(`strides should be ${u}D`);if(t.pads.reduce((d,y)=>d+y,0)>0&&t.pads.length!==u*2)throw new Error(`pads should be ${u*2}D`);if(t.outputPadding.length!==u&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${u}D`);if(t.kernelShape.reduce((d,y)=>d+y,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Oc=[2,3,1,0],Rc=(e,t,r)=>{let o=su(r,t),i=r.format==="NHWC",u=o.outputShape,a=u[i?3:1],c=t[0].dims[i?3:1];if(o.group!==1||a===1&&c===1){e.compute(Lo(t,o));return}let p=u[i?1:2],h=u[i?2:3],d=t[1].dims[2],y=t[1].dims[3],w=i?p*h:a,_=i?a:p*h,v=d*y*c,S=!0,I=e.kernelCustomData.wT??e.compute(yt(t[1],Oc),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let A=[t[0],I],x=t.length===3;x&&(!i&&t[2].dims.length===1?A.push(t[2].reshape([t[2].dims[0],1,1])):A.push(t[2])),e.compute(ou(A,o,u,w,_,v,x,S),{inputs:A})},Bc=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let i=t.kernelShape;(i.length===0||i[0]===0)&&(i=[e.inputs[1].dims[2]]);let u=t.dilations;(u.length===0||u[0]===0)&&(u=[1]);let a=t.strides;(a.length===0||a[0]===0)&&(a=[1]);let c=t.pads;c.length===0&&(c=[0,0]),c=[0,c[0],0,c[1]],a=[1].concat(a),u=[1].concat(u),i=[1].concat(i);let p=su({...t,pads:c,strides:a,dilations:u,kernelShape:i},o);e.compute(Lo(o,p,h=>r?[h[0],h[2],h[3]]:[h[0],h[1],h[3]]))},du=(e,t)=>{kc(e.inputs,t),e.inputs[0].dims.length===3?Bc(e,t):Rc(e,e.inputs,t)}});var Dc,cu,pu,mu=Y(()=>{"use strict";ye();Se();Ze();_e();Dc=(e,t,r,o)=>{let i=M.size(t),u=t.length,a=U("input",e,u),c=j("output",e,u),p=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),h=M.normalizeAxis(p,u),d=y=>{let w=` i32(${a.indicesGet("inputIndices","uniforms.axis")}) `,_=fe("uniforms.input_shape","uniforms.axis",u),v=o.reverse?w+(o.exclusive?" + 1":""):"0",S=o.reverse?_:w+(o.exclusive?"":" + 1");return`\n                ${y.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(a,c)}\n                ${y.mainStart()}\n                  ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${c.offsetToIndices("global_idx")};\n                  var sum = ${c.type.value}(0);\n                  let first : i32 = ${v};\n                  let last : i32 = ${S};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${a.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${a.getByIndices("inputIndices")};\n                  }\n                  ${c.setByOffset("global_idx","sum")};\n                }`};return{name:"CumSum",shaderCache:{hint:o.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},{type:12,data:h},...Z(t,t)]}),getShaderSource:d}},cu=(e,t)=>{let r=e.inputs[0].dims,o=e.inputs[0].dataType,i=e.inputs[1];e.compute(Dc(o,r,i,t),{inputs:[0]})},pu=e=>{let t=e.exclusive===1,r=e.reverse===1;return ve({exclusive:t,reverse:r})}});var zc,Mc,Uc,fu,hu,gu=Y(()=>{"use strict";ye();Se();Ze();_e();zc=e=>{if(!e||e.length!==1)throw new Error("DepthToSpace requires 1 input.");if(e[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},Mc=(e,t,r,o)=>{let i=[];i.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let u=0;u<t;++u)i.push(r.indicesSet("a",e[u],`i[${u}]`));return i.push("return a;}"),i.join(`\n`)},Uc=(e,t)=>{let r,o,i,u,a,c,p=t.format==="NHWC",h=t.blocksize,d=t.mode==="DCR";p?([r,o,i,u]=e.dims,a=d?[r,o,i,h,h,u/h**2]:[r,o,i,u/h**2,h,h],c=d?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([r,o,i,u]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],a=d?[r,h,h,u/h**2,o,i]:[r,u/h**2,h,h,o,i],c=d?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let y=e.reshape(a),w=y.dims.length,_=e.dataType,v=U("a",_,w),S=j("output",_,w),I=A=>`\n  ${A.registerUniform("output_size","u32").declareVariables(v,S)}\n\n  ${Mc(c,w,v,S)}\n\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${S.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${S.setByOffset("global_idx",v.getByIndices("aIndices"))}\n  }`;return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:A=>{let x=p?[r,o*h,i*h,u/h**2]:[r,u/h**2,o*h,i*h],E=M.size(x),P=y.dims,O=M.sortBasedOnPerm(P,c);return{outputs:[{dims:x,dataType:A[0].dataType}],dispatchGroup:{x:Math.ceil(E/64)},programUniforms:[{type:12,data:E},...Z(P,O)]}},getShaderSource:I}},fu=(e,t)=>{zc(e.inputs),e.compute(Uc(e.inputs[0],t))},hu=e=>ve({blocksize:e.blocksize,mode:e.mode,format:e.format})});var Fo,Wn,yu,Vc,Wc,qo,jo,bu,Nc,wu,vu,$u=Y(()=>{"use strict";ye();Se();Ze();_e();Fo="[a-zA-Z]|\\\\.\\\\.\\\\.",Wn="("+Fo+")+",yu="^"+Wn+"$",Vc="("+Wn+",)*"+Wn,Wc="^"+Vc+"$",qo=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},jo=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,i]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(Wc)))throw new Error("Invalid LHS term");if(o.split(",").forEach((c,p)=>{let h=t[p].dims.slice();if(!c.match(RegExp(yu)))throw new Error("Invalid LHS term");let d=this.processTerm(c,!0,h,p);this.lhs.push(d)}),i==="")i+=[...this.symbolToInfo.entries()].filter(([c,p])=>p.count===1||c==="...").map(([c])=>c).join("");else if(!i.match(RegExp(Wn)))throw new Error("Invalid RHS");i.match(RegExp(Fo,"g"))?.forEach(c=>{if(c==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let p=this.symbolToInfo.get(c);if(p===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(p.dimValue)}}),this.rhs=this.processTerm(i,!1,this.outputDims)}addSymbol(t,r,o){let i=this.symbolToInfo.get(t);if(i!==void 0){if(i.dimValue!==r&&i.count!==1)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(o)}else i={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,i)}processTerm(t,r,o,i=-1){let u=o.length,a=!1,c=[],p=0;if(!t.match(RegExp(yu))&&!r&&t!=="")throw new Error("Invalid LHS term");let h=t.match(RegExp(Fo,"g")),d=new qo(i);return h?.forEach((y,w)=>{if(y==="..."){if(a)throw new Error("Only one ellipsis is allowed per input term");a=!0;let _=u-h.length+1;if(_<0)throw new Error("Ellipsis out of bounds");if(c=o.slice(p,p+_),this.hasEllipsis){if(this.ellipsisDims.length!==c.length||this.ellipsisDims.toString()!==c.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=c;else throw new Error("Ellipsis must be specified in the LHS");for(let v=0;v<c.length;v++){let S=String.fromCharCode("0".charCodeAt(0)+v);d.addSymbol(S,w+v),this.addSymbol(S,o[p++],i)}}else d.addSymbol(y,w+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(y,o[p++],i)}),d}},bu=e=>e+"_max",Nc=(e,t,r,o)=>{let u=e.map(d=>d.length).map((d,y)=>U(`input${y}`,t,d)),a=M.size(o),c=j("output",t,o.length),p=[...r.symbolToInfo.keys()].filter(d=>!r.rhs.symbolToIndices.has(d)),h=d=>{let y=[],w="var prod = 1.0;",_="var sum = 0.0;",v="sum += prod;",S=[],I=[],A=[],x=[],E=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((O,R)=>{if(r.rhs.symbolToIndices.has(R)){let H=r.rhs.symbolToIndices.get(R)?.[0];H!==void 0&&r.lhs.forEach((N,K)=>{if(O.inputIndices.includes(K)){let Q=N.symbolToIndices.get(R);if(Q===void 0)throw new Error("Invalid symbol error");Q.forEach(he=>{y.push(`${u[K].indicesSet(`input${K}Indices`,he,c.indicesGet("outputIndices",H))}`)})}})}else r.lhs.forEach((H,N)=>{if(O.inputIndices.includes(N)){let K=H.symbolToIndices.get(R);if(K===void 0)throw new Error("Invalid symbol error");K.forEach(Q=>{S.push(`${u[N].indicesSet(`input${N}Indices`,Q,`${R}`)}`)}),x.push(`prod *= ${u[N].getByIndices(`input${N}Indices`)};`)}}),I.push(`for(var ${R}: u32 = 0; ${R} < uniforms.${bu(R)}; ${R}++) {`),A.push("}")});let P=E?[...y,`let sum = ${u.map((O,R)=>O.getByIndices(`input${R}Indices`)).join(" * ")};`]:[...y,_,...I,...S,w,...x,v,...A];return`\n            ${d.registerUniforms(p.map(O=>({name:`${bu(O)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...u,c)}\n\n            ${d.mainStart()}\n            ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${c.offsetToIndices("global_idx")};\n            ${u.map((O,R)=>`var input${R}Indices: ${u[R].type.indices};`).join(`\n`)}\n            ${P.join(`\n`)};\n            ${c.setByOffset("global_idx","sum")};\n          }`};return{name:"Einsum",shaderCache:{hint:r.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let d=p.filter(w=>r.symbolToInfo.has(w)).map(w=>({type:12,data:r.symbolToInfo.get(w)?.dimValue||0}));d.push({type:12,data:a});let y=e.map((w,_)=>[...Z(w)]).reduce((w,_)=>w.concat(_),d);return y.push(...Z(o)),{outputs:[{dims:o,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:y}},getShaderSource:h}},wu=(e,t)=>{let r=new jo(e.inputs,t.equation),o=r.outputDims,i=e.inputs.map((u,a)=>u.dims);e.compute(Nc(i,e.inputs[0].dataType,r,o))},vu=e=>{let t=e.equation.replace(/\\s+/g,"");return ve({equation:t})}});var Gc,_u,Hc,Lc,Su,xu=Y(()=>{"use strict";ye();Se();_e();Gc=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,i=t.length<r.length?0:t.length-r.length;for(;o<r.length&&i<t.length;++o,++i)if(r[o]!==t[i]&&r[o]!==1&&t[i]!==1)throw new Error("Expand requires shape to be broadcastable to input")},_u=(e,t)=>{let r=e.length-t.length,o=[];for(let i=0;i<r;++i)o.push(e[i]);for(let i=0;i<t.length;++i)o.push(t[i]===1?e[i+r]:t[i]);return o},Hc=(e,t)=>e.length>t.length?_u(e,t):_u(t,e),Lc=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=Hc(t,r),i=e[0].dataType,u=i===9?4:1,a=Math.ceil(M.size(o)/u),c=h=>{let d=U("input",i,t.length,u),y=j("output",i,o.length,u),w;if(i===9){let _=(v,S,I="")=>`\n          let outputIndices${S} = ${y.offsetToIndices(`outputOffset + ${S}u`)};\n          let offset${S} = ${d.broadcastedIndicesToOffset(`outputIndices${S}`,y)};\n          let index${S} = offset${S} / 4u;\n          let component${S} = offset${S} % 4u;\n          ${v}[${S}] = ${I}(${d.getByOffset(`index${S}`)}[component${S}]);\n        `;w=`\n        let outputOffset = global_idx * ${u};\n        var data = vec4<u32>(0);\n        ${_("data",0,"u32")}\n        ${_("data",1,"u32")}\n        ${_("data",2,"u32")}\n        ${_("data",3,"u32")}\n        ${y.setByOffset("global_idx","data")}\n      }`}else w=`\n        let outputIndices = ${y.offsetToIndices("global_idx")};\n        let inputOffset = ${d.broadcastedIndicesToOffset("outputIndices",y)};\n        ${y.setByOffset("global_idx",d.getByOffset("inputOffset"))}\n      }`;return`\n    ${h.registerUniform("vec_size","u32").declareVariables(d,y)}\n    ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${w}`},p=[{type:12,data:a},...Z(t,o)];return{name:"Expand",shaderCache:{hint:`${o.length}`,inputDependencies:["rank"]},getShaderSource:c,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p})}},Su=e=>{Gc(e.inputs),e.compute(Lc(e.inputs),{inputs:[0]})}});var Fc,Cu,Au=Y(()=>{"use strict";ye();Se();_e();Rn();Fc=e=>{let t=e[0].dataType,r=M.size(e[0].dims),o=M.size(e[1].dims),i=o%4===0,u=a=>{let c=U("x",t,[1],4),p=U("bias",t,[1],4),h=j("y",t,[1],4),d=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],y=_=>`\n      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;\n      let bias${_} = ${p.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,w=i?`\n      let bias = ${p.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${y(0)}${y(1)}${y(2)}${y(3)}\n      let bias = ${c.type.value}(bias0, bias1, bias2, bias3);`;return`${a.registerUniforms(d).declareVariables(c,p,h)}\n\n    ${Bo(et(t))}\n\n    ${a.mainStart(or)}\n      ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\n\n      let x = ${c.getByOffset("global_idx")};\n      ${w}\n      let x_in = x + bias;\n      ${h.setByOffset("global_idx",Do("x_in"))}\n    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${i}`,inputDependencies:["type","type"]},getShaderSource:u,getRunData:a=>({outputs:[{dims:a[0].dims,dataType:a[0].dataType}],programUniforms:[{type:12,data:Math.ceil(r/4)},{type:12,data:o}],dispatchGroup:{x:Math.ceil(r/or/4)}})}},Cu=e=>{e.inputs.length<2||M.size(e.inputs[1].dims)===0?Bs(e):e.compute(Fc(e.inputs))}});var qc,jc,Iu,Tu,Eu=Y(()=>{"use strict";ye();Se();Ze();_e();qc=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},jc=(e,t)=>{let r=e[0].dims,o=e[1].dims,i=r.length,u=M.normalizeAxis(t.axis,i),a=r.slice(0);a.splice(u,1,...o);let c=r[u],p=e[0].dataType===9?4:1,h=Math.ceil(M.size(a)/p),d=[{type:12,data:h},{type:6,data:c},{type:12,data:u},...Z(e[0].dims,e[1].dims,a)],y=w=>{let _=U("data",e[0].dataType,e[0].dims.length,p),v=U("inputIndices",e[1].dataType,e[1].dims.length),S=j("output",e[0].dataType,a.length,p),I=x=>{let E=o.length,P=`var indicesIndices${x}  = ${v.type.indices}(0);`;for(let O=0;O<E;O++)P+=`${E>1?`indicesIndices${x}[${O}]`:`indicesIndices${x}`} = ${a.length>1?`outputIndices${x}[uniforms.axis + ${O}]`:`outputIndices${x}`};`;P+=`\n          var idx${x} = ${v.getByIndices(`indicesIndices${x}`)};\n          if (idx${x} < 0) {\n            idx${x} = idx${x} + uniforms.axisDimLimit;\n          }\n          var dataIndices${x} : ${_.type.indices};\n        `;for(let O=0,R=0;O<i;O++)O===u?(P+=`${i>1?`dataIndices${x}[${O}]`:`dataIndices${x}`} = u32(idx${x});`,R+=E):(P+=`${i>1?`dataIndices${x}[${O}]`:`dataIndices${x}`} = ${a.length>1?`outputIndices${x}[${R}]`:`outputIndices${x}`};`,R++);return P},A;if(e[0].dataType===9){let x=(E,P,O="")=>`\n          let outputIndices${P} = ${S.offsetToIndices(`outputOffset + ${P}u`)};\n          ${I(P)};\n          let offset${P} = ${_.indicesToOffset(`dataIndices${P}`)};\n          let index${P} = offset${P} / 4u;\n          let component${P} = offset${P} % 4u;\n          ${E}[${P}] = ${O}(${_.getByOffset(`index${P}`)}[component${P}]);\n        `;A=`\n        let outputOffset = global_idx * ${p};\n        var value = vec4<u32>(0);\n        ${x("value",0,"u32")}\n        ${x("value",1,"u32")}\n        ${x("value",2,"u32")}\n        ${x("value",3,"u32")}\n        ${S.setByOffset("global_idx","value")}\n      `}else A=`\n      let outputIndices = ${S.offsetToIndices("global_idx")};\n      ${I("")};\n      let value = ${_.getByIndices("dataIndices")};\n      ${S.setByOffset("global_idx","value")};\n      `;return`\n      ${w.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(_,v,S)}\n      ${w.mainStart()}\n        ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${A}\n      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:d}),getShaderSource:y}},Iu=e=>ve({axis:e.axis}),Tu=(e,t)=>{let r=e.inputs;qc(r),e.compute(jc(e.inputs,t))}});var Kc,Yc,Pu,ku,Ou=Y(()=>{"use strict";ye();Se();Ze();_e();Kc=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Yc=(e,t)=>{let r=e[0].dims,o=e[0].dataType,i=r.length,u=e[1].dims,a=e[1].dataType,c=M.normalizeAxis(t.axis,i),p=r[c],h=u.slice(0),d=M.size(h),y=U("input",o,i),w=U("indicesInput",a,u.length),_=j("output",o,h.length),v=[{type:12,data:d},{type:6,data:p},{type:12,data:c}];return v.push(...Z(r,u,h)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:v}),getShaderSource:A=>`\n      ${A.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(y,w,_)}\n      ${A.mainStart()}\n      ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${_.offsetToIndices("global_idx")};\n\n      var idx = ${w.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${y.type.indices}(outputIndices);\n      ${y.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${y.getByIndices("inputIndices")};\n\n      ${_.setByOffset("global_idx","value")};\n  }`}},Pu=e=>ve({axis:e.axis}),ku=(e,t)=>{let r=e.inputs;Kc(r),e.compute(Yc(e.inputs,t))}});var Zc,Xc,Ru,Bu,Du=Y(()=>{"use strict";ye();Se();_e();Zc=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Xc=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[i,u,a]=Sn.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),c=[i,u];if(!c)throw new Error("Can\'t use gemm on the given tensors");let p=M.size(c),h=[{type:12,data:p},{type:12,data:i},{type:12,data:u},{type:12,data:a},{type:1,data:t.alpha},{type:1,data:t.beta}],d=["type","type"];e.length===3&&(h.push(...Z(e[2].dims)),d.push("rank")),h.push(...Z(c));let y=w=>{let _="";t.transA&&t.transB?_="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?_="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?_="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(_="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let v=t.alpha===1?"":"value *= uniforms.alpha;",S=U("a",e[0].dataType,e[0].dims),I=U("b",e[1].dataType,e[1].dims),A=S.type.value,x=null,E=[S,I];e.length===3&&(x=U("c",e[2].dataType,e[2].dims.length),E.push(x));let P=j("output",e[0].dataType,c.length);E.push(P);let O=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`\n  ${w.registerUniforms(O).declareVariables(...E)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${A}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${_}\n    }\n\n    ${v}\n    ${(()=>x!=null?`let cOffset = ${x.broadcastedIndicesToOffset("vec2(m, n)",P)}; value += ${A}(uniforms.beta) * ${x.getByOffset("cOffset")};`:"")()}\n    output[global_idx] = value;\n  }`};return{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:c,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h}),getShaderSource:y}},Ru=e=>{let t=e.transA,r=e.transB,o=e.alpha,i=e.beta;return{transA:t,transB:r,alpha:o,beta:i,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},Bu=(e,t)=>{Zc(e.inputs),e.compute(Xc(e.inputs,t))}});var Qc,Jc,ep,zu,Mu=Y(()=>{"use strict";ye();Se();_e();Qc=(e,t)=>{let r=e[0].dims,o=r,i=2,u=M.sizeToDimension(r,i),a=M.sizeFromDimension(r,i),c=Me(a),p=a/c,h=[r[0],r[1],p],d=["rank","type","type"],y=[{type:12,data:a},{type:12,data:p}];y.push(...Z(h,h));let w=_=>{let v=U("x",e[0].dataType,h.length,c),S=U("scale",e[1].dataType,e[1].dims),I=U("bias",e[2].dataType,e[2].dims),A=j("output",e[0].dataType,h.length,c),x=[v,S,I,A],E=v.type.value,P=c===1?"f32":`vec${c}<f32>`,O=64,R=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${P}, ${O}>;\n  const workgroupSize = ${O}u;\n  ${_.registerUniforms(R).declareVariables(...x)}\n  ${_.mainStart(O)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / uniforms.x_shape[1];\n    let channel = norm % uniforms.x_shape[1];\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${P}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      initial = initial + ${P}(${v.get("batch","channel","h")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${$t("workgroupShared[0]",c)} / f32(uniforms.normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${P}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let deviation =  ${P}(${v.get("batch","channel","h")}) - ${P}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${$t("workgroupShared[0]",c)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${t.epsilon}));\n    let channelScale = invStdDev * f32(${S.getByOffset("channel")});\n    let channelShift = f32(${I.getByOffset("channel")}) - meanShared * channelScale;\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let value = ${v.get("batch","channel","h")} * ${E}(${P}(channelScale)) + ${E}(${P}(channelShift));\n      ${A.set("batch","channel","h","value")};\n    }\n  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${t.epsilon};${c}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u},programUniforms:y}),getShaderSource:w}},Jc=(e,t,r,o,i,u,a,c)=>{let p=Me(a),h=64,d=p===1?"vec2f":`mat2x${p}f`,y=p===1?"f32":`vec${p}f`,w=(R,H)=>`${d}(${R}, ${H})`,_=i*a/p,v=Math.ceil(u/h),S=["type"],I=[{type:12,data:v},{type:12,data:u},{type:12,data:Math.floor(a/p)},{type:12,data:Math.floor(u*a/p)}],A=R=>{let H=U("input",t.dataType,t.dims,p);return`\n  ${R.declareVariables(H)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${d}>;\n  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};\n  @group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\n  ${R.mainStart(h)}\n    let currentImageNumber = global_idx / ${h} / uniforms.C;\n    let currentChannelNumber = (global_idx / ${h}) % uniforms.C;\n    let wgOffset = local_id.x * uniforms.wg_size;\n    if (wgOffset >= uniforms.H) {\n        return;\n    }\n    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);\n\n    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;\n    var sum = ${Lt("f32",p)};\n    var squaredSum = ${Lt("f32",p)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${y}(input[offset + i * uniforms.C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${w("sum","squaredSum")};\n  }`},x=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${p}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:[i,a,h,2],dataType:1}],dispatchGroup:{x:i*a/p},programUniforms:I}),getShaderSource:A},{inputs:[t],outputs:[-1]})[0],E=[{type:12,data:_},{type:12,data:u},{type:12,data:Math.floor(a/p)},{type:12,data:Math.floor(h*a/p)}],P=["type","type","type"],O=R=>{let H=U("scale",r.dataType,r.dims,p),N=U("bias",o.dataType,o.dims,p);return`\n  @group(0) @binding(0) var<storage, read> input : array<${d}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${H.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${N.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${d}>;\n  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};\n  @group(0) @binding(4) var<uniform> uniforms: Uniforms;\n\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}\n    let currentImageNumber = global_idx / uniforms.C;\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let offset = currentImageNumber * uniforms.image_size;\n    var sum = ${Lt("f32",p)};\n    var squaredSum = ${Lt("f32",p)};\n    for (var i: u32 = 0; i < min(${h}, uniforms.H); i++) {\n        let value = input[offset + i + currentChannelNumber * ${h}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(uniforms.H);\n    squaredSum = squaredSum / f32(uniforms.H);\n    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${c}));\n    let channelScale = invStdDev * ${y}(scale[currentChannelNumber]);\n    let channelShift = ${y}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${w("channelScale","channelShift")};\n  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${p};${c}`,inputDependencies:P},getRunData:()=>({outputs:[{dims:[i,a,2],dataType:1}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:E}),getShaderSource:O},{inputs:[x,r,o],outputs:[-1]})[0]},ep=(e,t,r)=>{let o=t[0].dims,i=o,u=o[0],a=o[o.length-1],c=M.sizeFromDimension(o,1)/a,p=Me(a),h=M.size(i)/p,d=[{type:12,data:c},{type:12,data:Math.floor(a/p)}],y=["type","type"],w=Jc(e,t[0],t[1],t[2],u,c,a,r.epsilon),_=v=>{let S=Be(t[0].dataType),I=p===1?"vec2f":`mat2x${p}f`,A=p===1?S:`vec${p}<${S}>`,x=U("input",t[0].dataType,t[0].dims,p),E=j("output",t[0].dataType,i,p);return`\n  @group(0) @binding(0) var<storage, read> input : array<${x.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${I}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${E.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${v.mainStart()}\n    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${A}(scale[0]), ${A}(scale[1]));\n  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${p}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:d}),getShaderSource:_},{inputs:[t[0],w]})},zu=(e,t)=>{t.format==="NHWC"?ep(e,e.inputs,t):e.compute(Qc(e.inputs,t))}});var tp,rp,Uu,Vu=Y(()=>{"use strict";ye();Se();_e();tp=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},rp=(e,t,r)=>{let o=t.simplified,i=e[0].dims,u=e[1],a=!o&&e[2],c=i,p=M.normalizeAxis(t.axis,i.length),h=M.sizeToDimension(i,p),d=M.sizeFromDimension(i,p),y=M.size(u.dims),w=a?M.size(a.dims):0;if(y!==d||a&&w!==d)throw new Error(`Size of X.shape()[axis:] == ${d}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${y} and bias size of ${w}`);let _=[];for(let O=0;O<i.length;++O)O<p?_.push(i[O]):_.push(1);let v=Me(d),S=["type","type"],I=[{type:12,data:h},{type:1,data:d},{type:12,data:Math.floor(d/v)},{type:1,data:t.epsilon}];a&&S.push("type");let A=r>1,x=r>2,E=O=>{let R=Be(e[0].dataType),H=[U("x",e[0].dataType,e[0].dims,v),U("scale",u.dataType,u.dims,v)];a&&H.push(U("bias",a.dataType,a.dims,v)),H.push(j("output",e[0].dataType,c,v)),A&&H.push(j("mean_data_output",1,_)),x&&H.push(j("inv_std_output",1,_));let N=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`\n  ${O.registerUniforms(N).declareVariables(...H)}\n  ${O.mainStart()}\n    ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${Lt("f32",v)};\n    var mean_square_vector = ${Lt("f32",v)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${ir(R,v,"x[h + offset]")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${$t("mean_vector",v)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${$t("mean_square_vector",v)} / uniforms.norm_size ${o?"":"- mean * mean"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${ir(R,v,"x[j + offset]")};\n      let f32scale = ${ir(R,v,"scale[j]")};\n      output[j + offset] = ${H[0].type.value}((f32input ${o?"":"- mean"}) * inv_std_dev * f32scale\n        ${a?`+ ${ir(R,v,"bias[j]")}`:""}\n      );\n    }\n\n    ${A?"mean_data_output[global_idx] = mean":""};\n    ${x?"inv_std_output[global_idx] = inv_std_dev":""};\n  }`},P=[{dims:c,dataType:e[0].dataType}];return A&&P.push({dims:_,dataType:1}),x&&P.push({dims:_,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${v};${r};${o}`,inputDependencies:S},getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(h/64)},programUniforms:I}),getShaderSource:E}},Uu=(e,t)=>{tp(e.inputs),e.compute(rp(e.inputs,t,e.outputCount))}});var np,op,Wu,Nu,Gu=Y(()=>{"use strict";ye();Se();Ze();_e();np=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let r=e[0],o=r.dims.length;if(r.dims[o-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let i=Math.floor((t.k+t.blockSize-1)/t.blockSize),u=t.blockSize/8*t.bits,a=e[1];if(!M.areEqual(a.dims,[t.n,i,u]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let p=e[2].dims;if(M.size(p)!==t.n*i)throw new Error("scales input size error.");if(e.length===4){let d=e[3].dims,y=t.bits>4?t.n*i:t.n*Math.floor((i+1)/2);if(M.size(d)!==y)throw new Error("zeroPoints input size error.")}},op=(e,t,r,o)=>{let i=e[0].dims,u=i.length,a=Math.floor((t.k+t.blockSize-1)/t.blockSize),c=i[u-2],p=t.k,h=t.n,d=i.slice(0,u-2),y=M.size(d),_=t.blockSize/8*t.bits/4,v=e[0].dataType,S=Me(c),I=Me(t.k),A=Me(_),x=tr(v),E=c*a*x,P=Math.floor(o/E),O=a<=r[0]&&P>0,R=!O||P>=4?Me(h):P>=2&&Me(h)>=2?2:1,H=d.concat([c,h]),N=M.size(H)/R/S,K=O?[]:[{type:12,data:N},{type:12,data:t.blockSize}],Q=[y,c,p/I],he=M.convertShape(e[1].dims).slice();he.splice(-1,1,_/A),K.push(...Z(Q)),K.push(...Z(he)),K.push(...Z(e[2].dims)),e.length===4&&K.push(...Z(M.convertShape(e[3].dims)));let W=[y,c,h/R];K.push(...Z(W));let se=Ce=>{let We=Q.length,ee=U("a",e[0].dataType,We,I),ae=U("b",12,he.length,A),Ae=U("scales",e[2].dataType,e[2].dims.length),me=[ee,ae,Ae],ie=e.length===4?U("zero_points",12,e[3].dims.length):void 0;ie&&me.push(ie);let ue=W.length,le=j("output",e[0].dataType,ue,R),qe=[{name:"output_size",type:"u32"},{name:"block_size",type:"u32"}],G=Be(e[0].dataType),ne=(()=>{switch(I){case 1:return`array<${G}, 8>`;case 2:return`mat4x2<${G}>`;case 4:return`mat2x4<${G}>`;default:throw new Error(`${I}-component is not supported.`)}})(),xe=`\n        for (var word: u32 = 0; word < ${_}; word += ${A}) {\n          ${ae.indicesSet("b_indices","2","word")};\n          let b_data = ${ae.getByIndices("b_indices")};\n          for (var i: u32 = 0; i < ${A}; i++) {\n            let b_value: u32 = ${A===1?"b_data":"b_data[word + i]"};\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            let b_value_lower: vec4<u32> = unpack4xU8(b_value & b_mask);\n            let b_value_upper: vec4<u32> = unpack4xU8((b_value >> 4) & b_mask);\n            let b_quantized_values = ${ne}(${Array.from({length:4},(De,Ge)=>`${G}(b_value_lower[${Ge}]), ${G}(b_value_upper[${Ge}])`).join(", ")});\n            let b_dequantized_values = ${(()=>I===1?`${ne}(${Array.from({length:8},(De,Ge)=>`(b_quantized_values[${Ge}] - zero_point) * scale`).join(", ")});`:`(b_quantized_values - ${ne}(${Array(8).fill("zero_point").join(",")})) * scale;`)()};\n            // Number of B elements per 32-bit word is 32/bits = 32/4 = 8\n            for (var m: u32 = 0; m < ${O?c:S}u; m++) {\n              ${ee.indicesSet("a_indices",We-2,O?"m":`row * ${S} + m`)};\n              ${ee.indicesSet("a_indices",We-1,"word_offset")};\n              var input_offset = ${ee.indicesToOffset("a_indices")};\n              var a_data: ${ne};\n              for (var j: u32 = 0; j < ${8/I}; j++) {\n                a_data[j] = ${ee.getByOffset("input_offset")};\n                input_offset++;\n              }\n              ${O?"workgroup_shared[workgroup_shared_offset + m]":"output_values[m]"}${R>1?"[c]":""} += ${Array.from({length:8/I},(De,Ge)=>`${I===1?`a_data[${Ge}] * b_dequantized_values[${Ge}]`:`dot(a_data[${Ge}], b_dequantized_values[${Ge}])`}`).join(" + ")};\n            }\n            word_offset += ${8/I};\n          }\n        }`,Ke=ie?`\n          zero_point_offset += 4;\n          if (zero_point_offset == 32) {\n            zero_point_offset = 0;\n            zero_point_index++;\n            zero_point_word = ${ie.getByOffset("zero_point_index")};\n          }`:"";return O?`\n        var<workgroup> workgroup_shared: array<${le.type.value}, ${c*a}>;\n        ${Ce.declareVariables(...me,le)}\n        ${Ce.mainStart([a,1,1])}\n          var a_indices: ${ee.type.indices};\n          var block = local_id.x;\n          var col = workgroup_id.y;\n          var batch = workgroup_id.z;\n          ${ee.indicesSet("a_indices","0","batch")};\n          // Two zero points are packed into one byte when uniforms.bits is 4.\n          for (var c: u32 = 0; c < ${R}; c++) {\n            let col_times_components_plus_c = col * ${R} + c;\n              ${ie?`\n            var zero_point_bytes_per_col: u32 = (${a} + 1) / 2;\n            var zero_point_byte_count: u32 = col_times_components_plus_c * zero_point_bytes_per_col + (block >> 0x1u);\n            var zero_point_word_index: u32 = zero_point_byte_count >> 0x2u;\n            var zero_point_byte_offset: u32 = zero_point_byte_count & 0x3u;\n            var zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32 = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            var zero_point_word: u32 = ${ie.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;`:""}\n            var b_indices: ${ae.type.indices};\n            ${ae.indicesSet("b_indices","0","col_times_components_plus_c")};\n            // The scale and zero points are computed per block.\n            var scales_index = col_times_components_plus_c * ${a} + block;\n            let scale = ${Ae.getByOffset("scales_index")};\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${G}(${ie?"(zero_point_word) & 0xFu":8});\n            ${ae.indicesSet("b_indices","1","block")};\n            var word_offset: u32 = block * ${t.blockSize/I};\n            var workgroup_shared_offset: u32 = block * ${c};\n            ${xe}\n          }\n          workgroupBarrier();\n          var output_indices: ${le.type.indices};\n          var elements_per_thread: u32 = ${Math.ceil(c/a)};\n          ${le.indicesSet("output_indices","0","batch")};\n          ${le.indicesSet("output_indices",ue-1,"col")};\n          ${le.indicesSet("output_indices",ue-2,"local_id.x * elements_per_thread")};\n          var output_offset = ${le.indicesToOffset("output_indices")};\n          for (var m: u32 = 0u; m < elements_per_thread; m++) {\n            var row = m + local_id.x * elements_per_thread;\n            if (row < ${c}) {\n              var output_value: ${le.type.value} = ${le.type.value}(0);\n              var workgroup_shared_offset: u32 = row;\n              for (var b: u32 = 0u; b < ${a}u; b++) {\n                output_value += workgroup_shared[workgroup_shared_offset];\n                workgroup_shared_offset += ${c};\n              }\n              ${le.setByOffset("output_offset","output_value")};\n              output_offset += ${h/R};\n            }\n          }\n        }`:`\n        ${Ce.registerUniforms(qe).declareVariables(...me,le)}\n        ${Ce.mainStart()}\n          ${Ce.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var output_values: array<${le.type.value}, ${S}>;\n          var output_indices = ${le.offsetToIndices("global_idx")};\n          var col = ${le.indicesGet("output_indices",ue-1)};\n          var row = ${le.indicesGet("output_indices",ue-2)};\n          var a_indices: ${ee.type.indices} = output_indices;\n          // Two zero points are packed into one byte because uniforms.bits <= 4.\n          // zero_point_offset is either 0 or 4. It is bit offset within one byte.\n          // TODO support zero_point_offset for bits > 4\n          ${ie?`\n          var zero_point_abs_offset = col * ${R} * ((${a} + 1) / 2);\n          var zero_point_index: u32 = zero_point_abs_offset / 4;\n          var zero_point_word: u32 = ${ie.getByOffset("zero_point_index")};\n          var zero_point_offset: u32 = (zero_point_abs_offset % 4) * 8;`:""}\n          var scale_index = col * ${a*R};\n          var b_indices: ${ae.type.indices};\n          for (var c: u32 = 0; c < ${R}; c++) {\n            ${ae.indicesSet("b_indices","0",`col * ${R} + c`)};\n            var block_offset: u32 = 0;\n            for (var block: u32 = 0; block < ${a}; block++) {\n              // The scale and zero points are computed per block.\n              let scale = ${Ae.getByOffset("scale_index")};\n              // The default zero point is 8 for unsigned 4-bit quantization.\n              let zero_point = ${G}(${ie?"extractBits(zero_point_word, zero_point_offset, 4)":8});\n              ${ae.indicesSet("b_indices","1","block")};\n              var word_offset: u32 = block_offset;\n              ${xe}\n              scale_index++;\n              ${Ke}\n              block_offset += uniforms.block_size / ${I};\n            }\n            // Drop the trailing 4 bits if the zero_poit_offset is not a byte boundary to align with the next byte.\n            ${ie?`if (zero_point_offset % 8 > 0) {\n                ${Ke}\n              }`:""}\n            }\n            for (var k: u32 = 0u; k < ${S}u; k++) {\n              ${le.indicesSet("output_indices",ue-2,`${S} * row + k`)};\n              ${le.setByIndices("output_indices","output_values[k]")}\n            }\n        }`};return{name:O?"BlockwiseMatMulNBits":"MatMulNBits",shaderCache:{hint:`${t.cacheKey};${c};${v};${e.length}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:H,dataType:v}],name:O?"BlockwiseMatMulNBits":"MatMulNBits",dispatchGroup:O?{x:1,y:Math.ceil(h/R),z:y}:{x:Math.ceil(N/64)},programUniforms:K}),getShaderSource:se}},Wu=(e,t)=>{np(e.inputs,t);let r=e.getMaxComputeWorkgroupSizes(),o=e.getMaxComputeWorkgroupStoragesize();e.compute(op(e.inputs,t,r,o))},Nu=e=>ve(e)});var it,ip,Lu,Hu,ap,Ko,Fu,qu=Y(()=>{"use strict";ye();Se();Ze();_n();Ro();_e();Sr();it=(e,t)=>e.length>t&&e[t].dims.length>0&&M.size(e[t].dims)>0?e[t]:void 0,ip=(e,t)=>{let r=e[0],o=it(e,1),i=it(e,2),u=it(e,3),a=it(e,4),c=it(e,5),p=it(e,6),h=it(e,7);if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let d=!1,y=r.dims[0],w=r.dims[1],_=r.dims.length===3?d?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],v=w,S=0,I=0,A=Math.floor(_/t.numHeads);if(p&&h){if(p.dims.length!==4)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(p.dims[0]!==y||p.dims[1]!==t.numHeads||p.dims[3]!==A)throw new Error(\'Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(h.dims[0]!==y||h.dims[1]!==t.numHeads||h.dims[3]!==A)throw new Error(\'Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(p.dims[2]!==h.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)\');if(h.dims.length!==4)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');S=p.dims[2],I=p.dims[2]}else if(p||h)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let x;if(o){if(r.dims.length!==3)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(o.dims.length<3||o.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(r.dims[0]!==o.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(o.dims.length===3){if(o.dims[2]!==r.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');x=2,v=o.dims[1]}else if(o.dims.length===5){if(o.dims[2]!==t.numHeads||o.dims[3]!==2||o.dims[4]!==A)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(i)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');x=5,v=o.dims[1]}else{if(o.dims[1]!==t.numHeads||o.dims[3]!==A)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');x=0,v=o.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');x=3}if(u){if(u.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(i&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let E=0;if(a){E=8;let N=a.dims;throw N.length===1?N[0]===y?E=1:N[0]===3*y+2&&(E=3):N.length===2&&N[0]===y&&N[1]===v&&(E=5),E===8?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)\'):new Error("Mask not supported")}let P=!1,O=_;if(i){if(i.dims.length!==3&&i.dims.length!==4)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(r.dims[0]!==i.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(i.dims.length===3){if(v!==i.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');O=i.dims[2]}else{if(v!==i.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');O=i.dims[1]*i.dims[3],P=!0}}let R=S+v,H=!1;if(a)throw new Error("Key padding mask is not supported");if(c){if(c.dims.length!==4)throw new Error(\'Input "relative_position_bias" is expected to have 4 dimensions\');if(c.dims[0]!==y&&c.dims[0]!==1||c.dims[1]!==t.numHeads||c.dims[2]!==w||c.dims[3]!==R)throw new Error(\'Input "relative_position_bias" shape (batch_size, 1, sequence_length, kv_sequence_length)\')}return{batchSize:y,sequenceLength:w,pastSequenceLength:S,kvSequenceLength:v,totalSequenceLength:R,maxSequenceLength:I,inputHiddenSize:0,hiddenSize:_,vHiddenSize:O,headSize:A,vHeadSize:Math.floor(O/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:E,scale:t.scale,broadcastResPosBias:H,passPastInKv:P,qkvFormat:x}},Lu=e=>ve({...e}),Hu=ve({perm:[0,2,1,3]}),ap=(e,t,r,o,i,u,a)=>{let c=[o,i,u],p=M.size(c),h=[{type:12,data:p},{type:12,data:a},{type:12,data:u}],d=y=>{let w=j("qkv_with_bias",t.dataType,c),_=U("qkv",t.dataType,c),v=U("bias",r.dataType,c),S=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`\n  ${y.registerUniforms(S).declareVariables(_,v,w)}\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:c,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h}),getShaderSource:d},{inputs:[t,r],outputs:[-1]})[0]},Ko=(e,t,r,o,i,u,a,c)=>{let p=u;if(a){if(o===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return p=ap(e,u,a,t,o,r*i,c),p=p.reshape([t,o,r,i]),e.compute(yt(p,Hu.perm),{inputs:[p],outputs:[-1]})[0]}else return u.dims.length===3&&(p=u.reshape([t,o,r,i])),e.compute(yt(p,Hu.perm),{inputs:[p],outputs:[-1]})[0]},Fu=(e,t)=>{let r=ip(e.inputs,t),o=e.inputs[0],i=it(e.inputs,1),u=it(e.inputs,2),a=it(e.inputs,3),c=it(e.inputs,4),p=it(e.inputs,5),h=it(e.inputs,6),d=it(e.inputs,7);if(o.dims.length===5)throw new Error("Packed QKV is not implemented");if(i?.dims.length===5)throw new Error("Packed KV is not implemented");let y=i&&u&&i.dims.length===4&&u.dims.length===4,w=Ko(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,o,a,0);if(y)return Pn(e,w,i,u,c,void 0,h,d,p,r,t);if(!i||!u)throw new Error("key and value must be provided");let _=Ko(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,i,a,r.hiddenSize),v=Ko(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,u,a,2*r.hiddenSize);Pn(e,w,_,v,c,void 0,h,d,p,r,t)}});var sp,up,dp,lp,cp,pp,mp,fp,ju,Ku=Y(()=>{"use strict";ye();Se();_e();sp=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},up=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n            k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${fe("uniforms.x_shape",i,t)})) {\n              break;\n            }\n            offset += k * i32(${fe("uniforms.x_strides",i,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${o}\n            value = x[offset];\n          }\n      `},dp=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${fe("uniforms.x_shape",i,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${fe("uniforms.x_shape",i,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${fe("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},lp=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${fe("uniforms.x_shape",i,t)})) {\n                  k = i32(${fe("uniforms.x_shape",i,t)}) - 1;\n                }\n                offset += k * i32(${fe("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},cp=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n                if (k < 0)  {\n                  k += i32(${fe("uniforms.x_shape",i,t)}]);\n                }\n                if (k >= i32(${fe("uniforms.x_shape",i,t)})) {\n                  k -= i32(${fe("uniforms.x_shape",i,t)});\n                }\n                offset += k * i32(${fe("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},pp=(e,t,r)=>{switch(r.mode){case 0:return up(e,t,r.pads.length);case 1:return dp(e,t,r.pads.length);case 2:return lp(e,t,r.pads.length);case 3:return cp(e,t,r.pads.length);default:throw new Error("Invalid mode")}},mp=(e,t)=>{let r=M.padShape(e[0].dims.slice(),t.pads),o=e[0].dims,i=M.size(r),u=[{type:12,data:i},{type:6,data:t.pads}];t.mode===0&&u.push({type:e[0].dataType,data:t.value}),u.push(...Z(e[0].dims,r));let a=["rank"],c=p=>{let h=j("output",e[0].dataType,r.length),d=U("x",e[0].dataType,o.length),y=d.type.value,w=pp(h,o.length,t),_=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&_.push({name:"constant_value",type:y}),`\n            ${p.registerUniforms(_).declareVariables(d,h)}\n            ${p.mainStart()}\n            ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${h.offsetToIndices("global_idx")};\n\n            var value = ${y}(0);\n            ${w}\n            output[global_idx] = value;\n        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}`,inputDependencies:a},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(r)/64)},programUniforms:u}),getShaderSource:c}},fp=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,i=e[0].dims.length,u=new Int32Array(2*i).fill(0);if(e.length>=4){let c=e[3].getBigInt64Array();for(let p=0;p<c.length;p++)u[Number(c[p])]=Number(r[p]),u[Number(c[p])+i]=Number(r[p+c.length])}else r.forEach((c,p)=>u[Number(p)]=Number(c));let a=[];return u.forEach(c=>a.push(c)),{mode:t.mode,value:o,pads:a}}else return t},ju=(e,t)=>{sp(e.inputs);let r=fp(e.inputs,t);e.compute(mp(e.inputs,r),{inputs:[0]})}});var Nn,Yu,Zu,Xu,Qu,hp,gp,Ju,ed,td,rd,nd,od,id,ad,sd,ud,dd,ld,cd=Y(()=>{"use strict";$r();ye();Se();_e();Nn=e=>{if(vr.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},Yu=(e,t,r)=>{let o=t.format==="NHWC",i=e.dims.slice();o&&i.splice(1,0,i.pop());let u=Object.hasOwnProperty.call(t,"dilations"),a=t.kernelShape.slice(),c=t.strides.slice(),p=u?t.dilations.slice():[],h=t.pads.slice();nr.adjustPoolAttributes(r,i,a,c,p,h);let d=nr.computePoolOutputShape(r,i,c,p,a,h,t.autoPad),y=Object.assign({},t);u?Object.assign(y,{kernelShape:a,strides:c,pads:h,dilations:p,cacheKey:t.cacheKey}):Object.assign(y,{kernelShape:a,strides:c,pads:h,cacheKey:t.cacheKey});let w=d.slice();return w.push(w.splice(1,1)[0]),[y,o?w:d]},Zu=(e,t)=>{let r=t.format==="NHWC",o=M.size(e),i=M.size(t.kernelShape),u=[{type:12,data:o},{type:12,data:i}],a=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let c=t.kernelShape[t.kernelShape.length-1],p=t.strides[t.strides.length-1],h=t.pads[t.pads.length/2-1],d=t.pads[t.pads.length-1],y=!!(h+d);u.push({type:12,data:c},{type:12,data:p},{type:12,data:h},{type:12,data:d}),a.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let w=!1;if(t.kernelShape.length===2){let _=t.kernelShape[t.kernelShape.length-2],v=t.strides[t.strides.length-2],S=t.pads[t.pads.length/2-2],I=t.pads[t.pads.length-2];w=!!(S+I),u.push({type:12,data:_},{type:12,data:v},{type:12,data:S},{type:12,data:I}),a.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[u,a,!0,y,w]}else{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let c=M.computeStrides(t.kernelShape);u.push({type:12,data:c},{type:12,data:t.pads},{type:12,data:t.strides}),a.push({name:"kernelStrides",type:"u32",length:c.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let p=t.pads.reduce((h,d)=>h+d);return[u,a,!!p,!1,!1]}},Xu=(e,t,r,o,i,u,a,c,p,h,d,y)=>{let w=i.format==="NHWC",_=t.type.value,v=j("output",t.type.tensor,o);if(i.kernelShape.length<=2){let S="",I="",A="",x=r-(w?2:1);if(d?S=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${x}] < 0 || xIndices[${x}]\n                      >= uniforms.x_shape[${x}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`:S=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`,i.kernelShape.length===2){let P=r-(w?3:2);y?I=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${P}] = indices[${P}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${P}] < 0 || xIndices[${P}] >= uniforms.x_shape[${P}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:I=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${P}] = indices[${P}] * uniforms.sh - uniforms.phStart + j;\n                `,A=`\n              }\n            `}return`\n            ${e.registerUniforms(p).declareVariables(t,v)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${v.offsetToIndices("global_idx")};\n              var xIndices = ${v.offsetToIndices("global_idx")};\n\n              var value = ${_}(${c});\n              var pad = 0;\n              ${I}\n              ${S}\n              ${A}\n              ${a}\n\n              output[global_idx] = value;\n            }`}else{if(w)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let S=i.kernelShape.length,I=i.pads.length,A="";return h?A=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${u}\n              }`:A=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${u}\n            `,`\n            ${e.registerUniforms(p).declareVariables(t,v)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${v.offsetToIndices("global_idx")};\n              var xIndices = ${v.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${S}>;\n\n              var value = ${_}(${c});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${S-1}u; j++) {\n                  offsets[j] = offset / ${fe("uniforms.kernelStrides","j",S)};\n                  offset -= offsets[j] * ${fe("uniforms.kernelStrides","j",S)};\n                }\n                offsets[${S-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-S}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${fe("uniforms.strides",`j - ${r-S}u`,S)}\n                    + offsets[j - ${r-S}u] - ${fe("uniforms.pads","j - 2u",I)};\n                  ${A}\n              }\n              ${a}\n\n              output[global_idx] = value;\n            }`}},Qu=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,hp=e=>`${Qu(e)};${e.countIncludePad}`,gp=e=>`${Qu(e)};${e.storageOrder};${e.dilations}`,Ju=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),ed=(e,t,r,o)=>{let[i,u]=Yu(t,o,r),a=U("x",t.dataType,t.dims.length),c=a.type.value,p="value += x_val;",h="";i.countIncludePad?h+=`value /= ${c}(uniforms.kernelSize);`:h+=`value /= ${c}(i32(uniforms.kernelSize) - pad);`;let[d,y,w,_,v]=Zu(u,i);d.push(...Z(t.dims,u));let S=["rank"];return{name:e,shaderCache:{hint:`${o.cacheKey};${w};${_};${v}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(M.size(u)/64)},programUniforms:d}),getShaderSource:I=>Xu(I,a,t.dims.length,u.length,i,p,h,0,y,w,_,v)}},td=e=>{let t=e.count_include_pad!==0,r=Ju(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let o={countIncludePad:t,...r,cacheKey:""};return{...o,cacheKey:hp(o)}},rd=(e,t)=>{Nn(e.inputs),e.compute(ed("AveragePool",e.inputs[0],!1,t))},nd={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},od=e=>{let t=e.format;return{format:t,...nd,cacheKey:t}},id=(e,t)=>{Nn(e.inputs),e.compute(ed("GlobalAveragePool",e.inputs[0],!0,t))},ad=(e,t,r,o)=>{let[i,u]=Yu(t,o,r),a=`\n      value = max(x_val, value);\n    `,c="",p=U("x",t.dataType,t.dims.length),h=["rank"],[d,y,w,_,v]=Zu(u,i);return d.push(...Z(t.dims,u)),{name:e,shaderCache:{hint:`${o.cacheKey};${w};${_};${v}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(M.size(u)/64)},programUniforms:d}),getShaderSource:S=>Xu(S,p,t.dims.length,u.length,i,a,c,t.dataType===10?-65504:-1e5,y,w,_,v)}},sd=(e,t)=>{Nn(e.inputs),e.compute(ad("MaxPool",e.inputs[0],!1,t))},ud=e=>{let t=e.storage_order,r=e.dilations,o=Ju(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let i={storageOrder:t,dilations:r,...o,cacheKey:""};return{...i,cacheKey:gp(i)}},dd=e=>{let t=e.format;return{format:t,...nd,cacheKey:t}},ld=(e,t)=>{Nn(e.inputs),e.compute(ad("GlobalMaxPool",e.inputs[0],!0,t))}});var bp,wp,pd,md=Y(()=>{"use strict";$r();ye();_e();bp=(e,t,r)=>{let o=e===t,i=e<t&&r<0,u=e>t&&r>0;if(o||i||u)throw new Error("Range these inputs\' contents are invalid.")},wp=(e,t,r,o)=>{let i=Math.abs(Math.ceil((t-e)/r)),u=[i],a=i,c=[{type:12,data:a},{type:o,data:e},{type:o,data:r},...Z(u)],p=h=>{let d=j("output",o,u.length),y=d.type.value,w=[{name:"outputSize",type:"u32"},{name:"start",type:y},{name:"delta",type:y}];return`\n        ${h.registerUniforms(w).declareVariables(d)}\n        ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${y}(global_idx) * uniforms.delta;\n      }`};return{name:"Range",shaderCache:{hint:`${o}`},getShaderSource:p,getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:c})}},pd=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),vr.webgpu.validateInputContent&&bp(t,r,o),e.compute(wp(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var vp,$p,_p,Sp,xp,Cp,Ap,Ip,Tp,Ep,Pp,fd,kp,Op,Rp,Bp,Dp,hd,gd,yd=Y(()=>{"use strict";ye();Se();Ze();_e();vp=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},$p=(e,t,r)=>{t.every(i=>i>=0&&i<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((i,u)=>o[i]=e[u]),o},_p=(e,t,r,o,i,u)=>{let[a,c,p]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],h=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach(d=>u.push(d));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(c>0&&e.length>c&&e[c].dims.length>0){if(e[c].getFloat32Array().forEach(d=>o.push(d)),o.length!==0&&o.length!==h&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");vp(o,t),t.axes.length>0&&$p(o,t.axes,h).forEach((d,y)=>o[y]=d)}if(p>0&&e.length>p&&(e[p].getBigInt64Array().forEach(d=>i.push(Number(d))),i.length!==h||r>=18&&i.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(i.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof i<"u"&&o.length>0&&i.length>h)throw new Error("Resize requires only of scales or sizes to be specified")},Sp=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`return ${t}(xResized) / ${t}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\n                    return whole + fract;\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",xp=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Cp=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),i=e.length===0?o:e.slice();return t.length>0?(t.forEach((u,a)=>{o[u]=i[a],o[a+r]=i[t.length+a]}),o):i},Ap=(e,t,r,o)=>{let i=[];if(r.length>0)if(o.length>0){if(e.forEach(u=>i.push(u)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((u,a)=>i[u]=r[a])}else r.forEach(u=>i.push(u));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");i=e.map((u,a)=>Math.round(u*t[a]))}return i},Ip=(e,t,r)=>{let o=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(u=>t[u]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(u=>t[u]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let i=e.slice();return r.axes.length>0?(r.axes.forEach(u=>t[u]=o),r.axes.forEach(u=>i[u]=Math.round(e[u]*t[u]))):(t.fill(o,0,t.length),i.forEach((u,a)=>i[a]=Math.round(u*t[a]))),i},Tp=(e,t,r,o,i)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${fe("uniforms.scales","i",o)};\n        var roi_low = ${fe("uniforms.roi","i",i)};\n        var roi_hi = ${fe("uniforms.roi",`i + ${t.length}`,i)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${fe("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${fe("uniforms.output_shape","i",r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Ep=(e,t,r,o,i,u,a)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${o.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${fe("uniforms.scales","i",i)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${fe("uniforms.roi","i",u)};\n          var roi_hi = ${fe("uniforms.roi",`i + ${r.length}`,u)};\n          var input_shape_i = ${fe("uniforms.input_shape","i",r.length)};\n          var output_shape_i = ${fe("uniforms.output_shape","i",o.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i"," input_index")}\n      }\n      return input_indices;\n    }`,Pp=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${fe("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,fd=(e,t,r,o)=>e.rank>o?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",r,"batch")};\n`:"",kp=(e,t,r,o,i)=>{let[a,c,p,h]=r.length===2?[-1,0,1,-1]:[0,2,3,1],d=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${d} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",c,`max(0, min(row, ${r[c]} - 1))`)};\n      ${e.indicesSet("input_indices",p,`max(0, min(col, ${r[p]} - 1))`)};\n      ${fd(e,h,a,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${d} = originalIndices[${c}];\n      var col:${d} = originalIndices[${p}];\n      ${o?`if (row < 0 || row > (${r[c]} - 1) || col < 0 || col > (${r[p]} - 1)) {\n        return ${i};\n      }`:""};\n      row = max(0, min(row, ${r[c]} - 1));\n      col = max(0, min(col, ${r[p]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length>2?`u32(originalIndices[${h}])`:"0"};\n      var batch: u32 =  ${r.length>2?`u32(originalIndices[${a}])`:"0"};\n      var x11: ${d} = getInputValue(batch, channel, row1, col1);\n      var x12: ${d} = getInputValue(batch, channel, row1, col2);\n      var x21: ${d} = getInputValue(batch, channel, row2, col1);\n      var x22: ${d} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${d} = abs(row - ${d}(row1));\n      var dx2: ${d} = abs(${d}(row2) - row);\n      var dy1: ${d} = abs(col - ${d}(col1));\n      var dy2: ${d} = abs(${d}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Op=(e,t,r,o,i,u,a,c,p,h)=>{let d=r.length===2,y=!0,[w,_]=d?[0,1]:y?[2,3]:[1,2],v=e.type.value,S=I=>{let A=I===w?"row":"col";return`\n      fn ${A}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${v} {\n        var output_index = ${t.indicesGet("output_indices",I)};\n        var originalIdx: ${v} = getOriginalCoordinateFromResizedCoordinate(output_index, ${i[I]},\n        ${o[I]}, ${r[I]}, ${u[I]}, ${u[I]} + ${r.length});\n        var fractOriginalIdx: ${v} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${c} && (originalIdx < 0 || originalIdx > (${r[I]} - 1))) {\n          return ${p};\n        }\n        var data: array<${v}, 4> = array<${v}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${A}: ${v} = originalIdx + ${v}(i);\n          if (${A} < 0 || ${A} >= ${r[I]}) {\n            ${(()=>h?`coefs[i + 1] = 0.0;\n                        continue;`:c?`return ${p};`:`${A} = max(0, min(${A}, ${r[I]} - 1));`)()};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",I,`u32(${A})`)};\n          data[i + 1] = ${I===w?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${S(w)};\n    ${S(_)};\n  fn getCubicInterpolationCoefs(s: ${v}) -> array<${v}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${v}, 4> = array<${v}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${v} = 1.0 - absS;\n    var twoMinusAbsS: ${v} = 2.0 - absS;\n    var onePlusAbsS: ${v} = 1.0 + absS;\n    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};\n    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${v}, 4>, coefs: array<${v}, 4>) -> ${v} {\n    var coefsSum: ${v} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${v} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},Rp=(e,t,r,o,i)=>{let[a,c,p,h,d]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],y=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${y} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",c,`max(0, min(depth, ${r[c]} - 1))`)};\n      ${e.indicesSet("input_indices",p,`max(0, min(height, ${r[p]} - 1))`)};\n      ${e.indicesSet("input_indices",h,`max(0, min(width, ${r[h]} - 1))`)};\n      ${fd(e,d,a,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${y} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${y} = originalIndices[${c}];\n      var height:${y} = originalIndices[${p}];\n      var width:${y} = originalIndices[${h}];\n      ${o?`if (depth < 0 || depth > (${r[c]} - 1) || height < 0 || height > (${r[p]} - 1) || width < 0 || (width > ${r[h]} - 1)) {\n      return ${i};\n        }`:""};\n\n    depth = max(0, min(depth, ${r[c]} - 1));\n      height = max(0, min(height, ${r[p]} - 1));\n      width = max(0, min(width, ${r[h]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length>3?`u32(originalIndices[${d}])`:"0"};\n      var batch: u32 =  ${r.length>3?`u32(originalIndices[${a}])`:"0"};\n\n      var x111: ${y} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${y} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${y} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${y} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${y} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${y} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${y} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${y} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${y} = abs(depth - ${y}(depth1));\n      var dx2: ${y} = abs(${y}(depth2) - depth);\n      var dy1: ${y} = abs(height - ${y}(height1));\n      var dy2: ${y} = abs(${y}(height2) - height);\n      var dz1: ${y} = abs(width - ${y}(width1));\n      var dz2: ${y} = abs(${y}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Bp=(e,t,r,o,i,u)=>{let a=e.dims,c=Cp(u,t.axes,a.length),p=Ap(a,o,i,t.axes),h=o.slice();o.length===0&&(h=a.map((x,E)=>x===0?1:p[E]/x),t.keepAspectRatioPolicy!=="stretch"&&(p=Ip(a,h,t)));let d=j("output",e.dataType,p.length),y=U("input",e.dataType,a.length),w=M.size(p),_=a.length===p.length&&a.every((x,E)=>x===p[E]),v=t.coordinateTransformMode==="tf_crop_and_resize",S=t.extrapolationValue,I=y.type.value,A=x=>`\n      ${_?"":`\n      ${Sp(t.coordinateTransformMode,I)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Pp(y,a)};\n              ${xp(t.nearestMode,r,I)};\n              ${Ep(y,d,a,p,h.length,c.length,v)};\n              `;case"linear":return`\n              ${Tp(d,a,p,h.length,c.length)};\n              ${(()=>{if(a.length===2||a.length===4)return`${kp(y,d,a,v,S)}`;if(a.length===3||a.length===5)return`${Rp(y,d,a,v,S)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(a.length===2||a.length===4)return`${Op(y,d,a,p,h,c,t.cubicCoeffA,v,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${x.registerUniform("output_size","u32").registerUniform("scales","f32",h.length).registerUniform("roi","f32",c.length).declareVariables(y,d)}\n      ${x.mainStart()}\n        ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${_?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${d.offsetToIndices("global_idx")};\n        var input_indices: ${y.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${y.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${a.length===2||a.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${h.length>0?h:""}|${i.length>0?i:""}|${c.length>0?c:""}|${_}|${a}`,inputDependencies:["rank"]},getShaderSource:A,getRunData:()=>({outputs:[{dims:p,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:[{type:12,data:w},{type:1,data:h},{type:1,data:c},...Z(a,p)]})}},Dp=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},hd=(e,t)=>{let r=[],o=[],i=[],u=Dp(e);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");_p(e.inputs,t,u,r,o,i),e.compute(Bp(e.inputs[0],t,u,r,o,i),{inputs:[0]})},gd=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,i=e.cubicCoeffA,u=e.excludeOutside!==0,a=e.extrapolationValue,c=e.keepAspectRatioPolicy,p=e.mode,h=e.nearestMode===""?"simple":e.nearestMode;return ve({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:i,excludeOutside:u,extrapolationValue:a,keepAspectRatioPolicy:c,mode:p,nearestMode:h})}});var zp,Mp,bd,wd=Y(()=>{"use strict";ye();Se();Ze();_e();zp=(e,t)=>{let[r,o,i,u]=e,{numHeads:a,rotaryEmbeddingDim:c}=t;if(r.dims.length!==3&&r.dims.length!==4)throw new Error(`Input \'x\' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);if(!M.areEqual(o.dims,[])&&!M.areEqual(o.dims,[1])&&o.dims.length!==2)throw new Error(`Input \'position_ids\' is expected to have 0, 1, or 2 dimensions, got ${o.dims.length}`);if(i.dims.length!==2)throw new Error(`Input \'cos_cache\' is expected to have 2 dimensions, got ${i.dims.length}`);if(u.dims.length!==2)throw new Error(`Input \'sin_cache\' is expected to have 2 dimensions, got ${u.dims.length}`);if(!M.areEqual(i.dims,u.dims))throw new Error("Inputs \'cos_cache\' and \'sin_cache\' are expected to have the same shape");if(c>0&&a===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let p=r.dims[0],h=r.dims[r.dims.length-2],d=i.dims[0],y=M.sizeFromDimension(r.dims,1)/h,w=c===0?i.dims[1]*2:y/a;if(c>w)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(o.dims.length===2){if(p!==o.dims[0])throw new Error(`Input \'position_ids\' dimension 0 should be of size batch_size, got ${o.dims[0]}`);if(h!==o.dims[1])throw new Error(`Input \'position_ids\' dimension 1 should be of size sequence_length, got ${o.dims[1]}`)}if(w/2!==i.dims[1]&&c/2!==i.dims[1])throw new Error(`Input \'cos_cache\' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${i.dims[1]}`);if(h>d)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},Mp=(e,t)=>{let{interleaved:r,numHeads:o,rotaryEmbeddingDim:i,scale:u}=t,a=e[0].dims[0],c=M.sizeFromDimension(e[0].dims,1),p=e[0].dims[e[0].dims.length-2],h=c/p,d=e[2].dims[1],y=i===0?d*2:h/o,w=new Array(a,p,h/y,y-d),_=M.computeStrides(w),v=[{type:1,data:u},{type:12,data:w},{type:12,data:_},...e[0].dims.length===3?new Array({type:12,data:[c,h,y,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[c,y,p*y,1]}):[],...Z(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],S=I=>{let A=U("input",e[0].dataType,e[0].dims.length),x=U("position_ids",e[1].dataType,e[1].dims.length),E=U("cos_cache",e[2].dataType,e[2].dims.length),P=U("sin_cache",e[3].dataType,e[3].dims.length),O=j("output",e[0].dataType,e[0].dims.length);return I.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:w.length},{name:"global_strides",type:"u32",length:_.length},{name:"input_output_strides",type:"u32",length:_.length}]),`\n        ${I.declareVariables(A,x,E,P,O)}\n\n        ${I.mainStart(or)}\n          let half_rotary_emb_dim = uniforms.${E.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${I.guardAgainstOutOfBoundsWorkgroupSizes("size")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${x.broadcastedIndicesToOffset("bsnh.xy",j("",x.type.tensor,2))};\n            let position_id =\n                u32(${x.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});\n            let j = i + select(half_rotary_emb_dim, 1, ${r});\n            let re = ${A.getByOffset("i")} * ${E.get("position_id","bsnh[3]")} -\n                ${A.getByOffset("j")} * ${P.get("position_id","bsnh[3]")};\n            ${O.setByOffset("i","re")}\n            let im = ${A.getByOffset("i")} * ${P.get("position_id","bsnh[3]")} +\n                ${A.getByOffset("j")} * ${E.get("position_id","bsnh[3]")};\n            ${O.setByOffset("j","im")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${O.setByOffset("k",A.getByOffset("k"))}\n          }\n        }`};return{name:"RotaryEmbedding",shaderCache:{hint:ve({interleaved:r}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:S,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(w)/or)},programUniforms:v})}},bd=(e,t)=>{zp(e.inputs,t),e.compute(Mp(e.inputs,t))}});var Up,Vp,vd,$d=Y(()=>{"use strict";ye();Se();_e();Up=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let i=t.dims[t.dims.length-1],u=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==i)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==u)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==i)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let a=e[3];if(a.dims.length!==1)throw new Error("Beta must be 1D");if(a.dims[a.dims.length-1]!==i)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let a=e[4];if(a.dims.length!==1)throw new Error("Bias must be 1D");if(a.dims[a.dims.length-1]!==i)throw new Error("Bias must have the same hidden size as input")}},Vp=(e,t,r,o)=>{let i=t.simplified,u=e[0].dims,a=M.size(u),c=u,p=a,h=u.slice(-1)[0],d=o?u.slice(0,-1).concat(1):[],y=!i&&e.length>3,w=e.length>4,_=o&&r>1,v=o&&r>2,S=r>3,I=64,A=Me(h),x=[{type:12,data:p},{type:12,data:A},{type:12,data:h},{type:1,data:t.epsilon}],E=O=>{let R=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],H=[U("x",e[0].dataType,e[0].dims,A),U("skip",e[1].dataType,e[1].dims,A),U("gamma",e[2].dataType,e[2].dims,A)];y&&H.push(U("beta",e[3].dataType,e[3].dims,A)),w&&H.push(U("bias",e[4].dataType,e[4].dims,A)),H.push(j("output",e[0].dataType,c,A)),_&&H.push(j("mean_output",1,d)),v&&H.push(j("inv_std_output",1,d)),S&&H.push(j("input_skip_bias_sum",e[0].dataType,c,A));let N=Be(e[0].dataType),K=Be(1,A);return`\n\n      ${O.registerUniforms(R).declareVariables(...H)}\n      var<workgroup> sum_shared : array<${K}, ${I}>;\n      var<workgroup> sum_squared_shared : array<${K}, ${I}>;\n\n      ${O.mainStart([I,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / ${I};\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / ${I};\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == ${I-1}) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${w?"bias[offset1d + i]":N+"(0.0)"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${S?"input_skip_bias_sum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32_value = ${ir(N,A,"value")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = ${I};\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${$t("sum",A)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${$t("square_sum",A)} / f32(uniforms.hidden_size) ${i?"":"- mean * mean"} + uniforms.epsilon);\n        ${_?"mean_output[global_idx] = mean;":""}\n        ${v?"inv_std_output[global_idx] = inv_std_dev;":""}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${i?"":`- ${N}(mean)`}) *\n            ${N}(inv_std_dev) * gamma[offset1d + i]\n            ${y?"+ beta[offset1d + i]":""};\n        }\n      }`},P=[{dims:c,dataType:e[0].dataType}];return r>1&&P.push({dims:d,dataType:1}),r>2&&P.push({dims:d,dataType:1}),r>3&&P.push({dims:u,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${A};${_};${v};${S}`,inputDependencies:e.map((O,R)=>"type")},getShaderSource:E,getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(p/h)},programUniforms:x})}},vd=(e,t)=>{Up(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(Vp(e.inputs,t,e.outputCount,!1),{outputs:o})}});var Wp,Gn,Np,_d,Gp,Hp,Sd,xd,Cd=Y(()=>{"use strict";ye();Se();Ze();_e();Wp=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},Gn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Np=(e,t)=>{if(e.length>1){let r=Gn(e,1),o=Gn(e,2),i=Gn(e,3);return i.length===0&&(i=[...Array(e[0].dims.length).keys()]),ve({starts:r,ends:o,axes:i})}else return t},_d=(e,t,r,o,i)=>{let u=e;return e<0&&(u+=r[o[t]]),i[t]<0?Math.max(0,Math.min(u,r[o[t]]-1)):Math.max(0,Math.min(u,r[o[t]]))},Gp=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${fe("uniforms.input_shape","i",r.length)};\n            let steps_i = ${fe("uniforms.steps","i",r.length)};\n            let signs_i = ${fe("uniforms.signs","i",r.length)};\n            let starts_i = ${fe("uniforms.starts","i",r.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,Hp=(e,t)=>{let r=e[0].dims,o=M.size(r),i=t.axes.length>0?M.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],u=Gn(e,4);u.forEach(A=>A!==0||(()=>{throw new Error("step cannot be 0")})),u.length===0&&(u=Array(i.length).fill(1));let a=t.starts.map((A,x)=>_d(A,x,r,i,u)),c=t.ends.map((A,x)=>_d(A,x,r,i,u));if(i.length!==a.length||i.length!==c.length)throw new Error("start, ends and axes should have the same number of elements");if(i.length!==r.length)for(let A=0;A<r.length;++A)i.includes(A)||(a.splice(A,0,0),c.splice(A,0,r[A]),u.splice(A,0,1));let p=u.map(A=>Math.sign(A));u.forEach((A,x,E)=>{if(A<0){let P=(c[x]-a[x])/A,O=a[x],R=O+P*u[x];a[x]=R,c[x]=O,E[x]=-A}});let h=r.slice(0);i.forEach((A,x)=>{h[A]=Math.ceil((c[A]-a[A])/u[A])});let d={dims:h,dataType:e[0].dataType},y=j("output",e[0].dataType,h.length),w=U("input",e[0].dataType,e[0].dims.length),_=M.size(h),v=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:a.length},{name:"signs",type:"i32",length:p.length},{name:"steps",type:"u32",length:u.length}],S=[{type:12,data:_},{type:12,data:a},{type:6,data:p},{type:12,data:u},...Z(e[0].dims,h)],I=A=>`\n      ${A.registerUniforms(v).declareVariables(w,y)}\n        ${Gp(w,y,r)}\n        ${A.mainStart()}\n          ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${y.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${y.setByOffset("global_idx",w.getByIndices("input_indices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${p.length}_${a.length}_${u.length}`,inputDependencies:["rank"]},getShaderSource:I,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:S})}},Sd=(e,t)=>{Wp(e.inputs,t);let r=Np(e.inputs,t);e.compute(Hp(e.inputs,r),{inputs:[0]})},xd=e=>{let t=e.starts,r=e.ends,o=e.axes;return ve({starts:t,ends:r,axes:o})}});var Lp,Fp,Ad,Id,Td=Y(()=>{"use strict";ye();Se();Ze();_e();Lp=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Fp=(e,t)=>{let r=e.dims,o=M.size(r),i=64,u=t.axis;if(u<0&&(u=r.length+u),u<r.length-1)throw new Error("softmax only supports last axis for now.");let a=r[u],c=o/a,p=Me(a),h=a/p,d=(I,A)=>A===4?`max(max(${I}.x, ${I}.y), max(${I}.z, ${I}.w))`:A===2?`max(${I}.x, ${I}.y)`:A===3?`max(max(${I}.x, ${I}.y), ${I}.z)`:I,y=U("x",e.dataType,e.dims,p),w=j("result",e.dataType,e.dims,p),_=y.type.value,v=Be(e.dataType)==="f32"?`var threadMax = ${_}(-3.402823e+38f);`:`var threadMax = ${_}(-65504.0h);`,S=I=>`\n      var<workgroup> rowMaxShared : ${_};\n      var<workgroup> rowSumShared : ${_};\n      var<workgroup> threadShared : array<${_}, ${i}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${_} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${_}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${I.registerUniform("packedCols","i32").declareVariables(y,w)}\n      ${I.mainStart()}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${i};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${v}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${_}(${d("threadShared[0]",p)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${_}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${_}(${$t("threadShared[0]",p)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${p}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:c},programUniforms:[{type:6,data:h}]}),getShaderSource:S}},Ad=(e,t)=>{Lp(e.inputs),e.compute(Fp(e.inputs[0],t))},Id=e=>ve({axis:e.axis})});var qp,jp,Kp,Yp,Zp,Ed,Pd,kd=Y(()=>{"use strict";ye();Se();Ze();_e();qp=e=>{if(!e||e.length<1)throw new Error("too few inputs")},jp=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(i=>r.push(Number(i))),o=r.length),ve({numOutputs:o,axis:t.axis,splitSizes:r})},Kp=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${fe("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Yp=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let i=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(i):o===0?r.push(`if (output_number == ${o}u) { ${i} }`):o===t-1?r.push(`else { ${i} }`):r.push(`else if (output_number == ${o}) { ${i} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},Zp=(e,t)=>{let r=e[0].dims,o=M.size(r),i=e[0].dataType,u=M.normalizeAxis(t.axis,r.length),a=new Array(t.numOutputs),c=U("input",i,r.length),p=new Array(t.numOutputs),h=[],d=[],y=0,w=[{type:12,data:o}];for(let v=0;v<t.numOutputs;v++){y+=t.splitSizes[v],p[v]=y;let S=r.slice();S[t.axis]=t.splitSizes[v],d.push(S),a[v]=j(`output${v}`,i,S.length),h.push({dims:d[v],dataType:e[0].dataType})}w.push({type:12,data:p},...Z(r,...d));let _=v=>`\n  ${v.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",p.length).declareVariables(c,...a)}\n  ${Kp(p.length)}\n  ${Yp(a)}\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${c.offsetToIndices("global_idx")};\n    var index = ${c.indicesGet("indices",u)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${fe("uniforms.size_in_split_axis","output_number - 1u",p.length)};\n      ${c.indicesSet("indices",u,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:_,getRunData:()=>({outputs:h,dispatchGroup:{x:Math.ceil(o/64)},programUniforms:w})}},Ed=(e,t)=>{qp(e.inputs);let r=e.inputs.length===1?t:jp(e.inputs,t);e.compute(Zp(e.inputs,r),{inputs:[0]})},Pd=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ve({axis:t,numOutputs:o,splitSizes:r})}});var Od,Xp,Qp,Jp,Rd,Bd=Y(()=>{"use strict";ye();Se();_e();Od=e=>Array.from(e.getBigInt64Array(),Number),Xp=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Od(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Qp=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},Jp=e=>{let t=e[0].dims,r=Od(e[1]),o=Qp(t,r),i=M.size(o),u=e[0].dataType,a=U("input",u,t.length),c=j("output",u,o.length),p=h=>`\n      const inputShape = ${a.indices(...t)};\n      ${h.registerUniform("output_size","u32").declareVariables(a,c)}\n      ${h.mainStart()}\n      ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${c.offsetToIndices("global_idx")};\n      var input_indices: ${a.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let input_dim_i = ${a.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${c.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${a.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${c.setByOffset("global_idx",a.getByIndices("input_indices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...Z(e[0].dims,o)]}),getShaderSource:p}},Rd=e=>{Xp(e.inputs),e.compute(Jp(e.inputs),{inputs:[0]})}});var em,tm,Dd,zd=Y(()=>{"use strict";ye();Se();_e();em=(e,t,r,o,i)=>{let u=j("output_data",i,r.length,4),a=U("a_data",t[1].dataType,t[1].dims.length,4),c=U("b_data",t[2].dataType,t[2].dims.length,4),p=U("c_data",t[0].dataType,t[0].dims.length,4),h,d=(y,w,_)=>`select(${w}, ${y}, ${_})`;if(!o)h=u.setByOffset("global_idx",d(a.getByOffset("global_idx"),c.getByOffset("global_idx"),p.getByOffset("global_idx")));else{let y=(w,_,v="")=>{let S=`a_data[index_a${_}][component_a${_}]`,I=`b_data[index_b${_}][component_b${_}]`,A=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`\n            let output_indices${_} = ${u.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${a.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let offset_b${_} = ${c.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let offset_c${_} = ${p.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            let component_c${_} = offset_c${_} % 4u;\n            ${w}[${_}] = ${v}(${d(S,I,A)});\n          `};i===9?h=`\n            var data = vec4<u32>(0);\n            ${y("data",0,"u32")}\n            ${y("data",1,"u32")}\n            ${y("data",2,"u32")}\n            ${y("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:h=`\n            ${y("output_data[global_idx]",0)}\n            ${y("output_data[global_idx]",1)}\n            ${y("output_data[global_idx]",2)}\n            ${y("output_data[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(p,a,c,u)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${h}\n      }`},tm=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,i=e[1].dataType,u=!(M.areEqual(t,r)&&M.areEqual(r,o)),a=t,c=M.size(t);if(u){let h=At.calcShape(At.calcShape(t,r,!1),o,!1);if(!h)throw new Error("Can\'t perform where op on the given tensors");a=h,c=M.size(a)}let p=Math.ceil(c/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:h=>em(h,e,a,u,i),getRunData:()=>({outputs:[{dims:a,dataType:i}],dispatchGroup:{x:Math.ceil(c/64/4)},programUniforms:[{type:12,data:p},...Z(o,t,r,a)]})}},Dd=e=>{e.compute(tm(e.inputs))}});var Md,Ud=Y(()=>{"use strict";Ka();Ro();Ja();ts();Vs();Zs();Oo();Uo();lu();mu();gu();$u();xu();Au();Eu();Ou();Du();Mu();Vu();Wo();Gu();qu();Ku();cd();md();In();yd();wd();$d();Cd();Td();kd();Bd();Sr();Rn();zd();Md=new Map([["Abs",[rs]],["Acos",[ns]],["Acosh",[os]],["Add",[Ws]],["ArgMax",[ja,ko]],["ArgMin",[qa,ko]],["Asin",[is]],["Asinh",[as]],["Atan",[ss]],["Atanh",[us]],["Attention",[Xa]],["AveragePool",[rd,td]],["BatchNormalization",[Qa]],["BiasAdd",[es]],["BiasSplitGelu",[Us]],["Cast",[ls,ds]],["Ceil",[ps]],["Clip",[cs]],["Concat",[Ya,Za]],["Conv",[Ho,Go]],["ConvTranspose",[du,uu]],["Cos",[ms]],["Cosh",[fs]],["CumSum",[cu,pu]],["DepthToSpace",[fu,hu]],["Div",[Ns]],["Einsum",[wu,vu]],["Elu",[hs,kn]],["Equal",[Gs]],["Erf",[gs]],["Exp",[ys]],["Expand",[Su]],["FastGelu",[Cu]],["Floor",[bs]],["FusedConv",[Ho,Go]],["Gather",[Tu,Iu]],["GatherElements",[ku,Pu]],["Gelu",[ws]],["Gemm",[Bu,Ru]],["GlobalAveragePool",[id,od]],["GlobalMaxPool",[ld,dd]],["Greater",[qs]],["GreaterOrEqual",[Ks]],["HardSigmoid",[Is,As]],["InstanceNormalization",[zu]],["LayerNormalization",[Uu]],["LeakyRelu",[vs,kn]],["Less",[js]],["LessOrEqual",[Ys]],["Log",[zs]],["MatMul",[ru]],["MatMulNBits",[Wu,Nu]],["MaxPool",[sd,ud]],["Mul",[Hs]],["MultiHeadAttention",[Fu,Lu]],["Neg",[_s]],["Not",[$s]],["Pad",[ju]],["Pow",[Ls]],["Range",[pd]],["Reciprocal",[Ss]],["ReduceMin",[Wa]],["ReduceMean",[Da]],["ReduceMax",[Va]],["ReduceSum",[Ga]],["ReduceProd",[Na]],["ReduceL1",[za]],["ReduceL2",[Ma]],["ReduceLogSum",[La]],["ReduceLogSumExp",[Ua]],["ReduceSumSquare",[Ha]],["Relu",[xs]],["Resize",[hd,gd]],["RotaryEmbedding",[bd]],["Sigmoid",[Cs]],["Sin",[Ts]],["Sinh",[Es]],["Slice",[Sd,xd]],["SkipLayerNormalization",[vd]],["Split",[Ed,Pd]],["Sqrt",[Ps]],["Softmax",[Ad,Id]],["Sub",[Fs]],["Tan",[ks]],["Tanh",[Rs]],["ThresholdedRelu",[Ds,kn]],["Tile",[Rd]],["Transpose",[_a,Sa]],["Where",[Dd]]])});var Hn,Vd=Y(()=>{"use strict";$r();Ht();_e();Hn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,i,u){rr(t.programInfo.name);let a=this.backend.device,c=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let p=[];for(let d of r)p.push({binding:p.length,resource:{buffer:d.buffer}});for(let d of o)p.push({binding:p.length,resource:{buffer:d.buffer}});u&&p.push({binding:p.length,resource:u});let h=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:p,label:t.programInfo.name});if(this.backend.sessionStatus==="capturing"){let d={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:h,dispatchGroup:i};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(d)}c.setPipeline(t.computePipeline),c.setBindGroup(0,h),c.dispatchWorkgroups(...i),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Gt(t.programInfo.name)}dispose(){}build(t,r){rr(t.name);let o=this.backend.device,i=[];o.features.has("shader-f16")&&i.push("enable f16;");let u=va(r,this.backend.device.limits),a=t.getShaderSource(u),c=`${i.join(`\n`)}\n${u.additionalImplementations}\n${a}`,p=o.createShaderModule({code:c,label:t.name});Ve("verbose",()=>`[WebGPU] ${t.name} shader code: ${c}`);let h=o.createComputePipeline({compute:{module:p,entryPoint:"main"},layout:"auto",label:t.name});return Gt(t.name),{programInfo:t,computePipeline:h,uniformVariablesInfo:u.variablesInfo}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,i=typeof t=="number"?1:t.z||1,u=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=u&&o<=u&&i<=u)return[r,o,i];let a=r*o*i,c=Math.ceil(Math.sqrt(a));if(c>u){if(c=Math.ceil(Math.cbrt(a)),c>u)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[c,c,c]}else return[c,c,1]}}});var rm,nm,Yo,Ln,Wd=Y(()=>{"use strict";$r();ye();Ht();fa();wa();Ud();Vd();rm=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let i=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${i}`);break}case"rank":{let u=e[o].dims.length;r.push(`${i};${u}`);break}case"dims":{let u=e[o].dims.join(",");r.push(`${i};${u}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},nm=(e,t,r)=>{let o=e.name;return e.shaderCache?.hint&&(o+="["+e.shaderCache.hint+"]"),o+=":"+r+`:${rm(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,o},Yo=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},Ln=class{constructor(){this.currentSessionId=null;this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionStatus="default";this.capturedCommandList=new Map;this.capturedPendingKernels=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,r){this.env=t;let o=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("chromium-experimental-timestamp-query-inside-passes")?o.push("chromium-experimental-timestamp-query-inside-passes"):r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(i),this.adapterInfo=new Yo(await r.requestAdapterInfo()),this.gpuDataManager=ba(this),this.programManager=new Hn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,pa(t.logLevel,!!t.debug),this.device.onuncapturederror=u=>{u.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${u.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:r,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),r={};this.queryType==="at-passes"&&(r.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(r)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;rr(),this.endComputePass();let t;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&t.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.getMappedRange()),o=this.pendingQueries.get(t);for(let i=0;i<r.length/2;i++){let u=o[i],a=u.kernelId,c=this.kernels.get(a),p=c.kernelType,h=c.kernelName,d=u.programName,y=u.inputTensorViews,w=u.outputTensorViews,_=r[i*2],v=r[i*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=_);let S=Number(_-this.queryTimeBase),I=Number(v-this.queryTimeBase);if(!Number.isSafeInteger(S)||!Number.isSafeInteger(I))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:y.map(A=>({dims:A.dims,dataType:Nt(A.dataType)})),outputsMetadata:w.map(A=>({dims:A.dims,dataType:Nt(A.dataType)})),kernelId:a,kernelType:p,kernelName:h,programName:d,startTime:S,endTime:I});else{let A="";y.forEach((E,P)=>{A+=`input[${P}]: [${E.dims}] | ${Nt(E.dataType)}, `});let x="";w.forEach((E,P)=>{x+=`output[${P}]: [${E.dims}] | ${Nt(E.dataType)}, `}),console.log(`[profiling] kernel "${a}|${p}|${h}|${d}" ${A}${x}execution time: ${I-S} ns`)}wo("GPU",`${d}::${_}::${v}`)}t.unmap(),this.pendingQueries.delete(t)}),Gt()}run(t,r,o,i,u,a){rr(t.name);let c=[];for(let E=0;E<r.length;++E){let P=r[E].data;if(P===0)continue;let O=this.gpuDataManager.get(P);if(!O)throw new Error(`no GPU data for input: ${P}`);c.push(O)}let{outputs:p,dispatchGroup:h,programUniforms:d}=t.getRunData(r),y=o.length===0?p.map((E,P)=>P):o;if(y.length!==p.length)throw new Error(`Output size ${y.length} must be equal to ${p.length}.`);let w=[],_=[];for(let E=0;E<p.length;++E){if(!Number.isInteger(y[E])||y[E]<-3||y[E]>=a)throw new Error(`Invalid output index: ${y[E]}`);if(y[E]===-3)continue;let P=y[E]===-1,O=y[E]===-2,R=P||O?u(p[E].dataType,p[E].dims):i(y[E],p[E].dataType,p[E].dims);if(w.push(R),R.data===0)continue;let H=this.gpuDataManager.get(R.data);if(!H)throw new Error(`no GPU data for output: ${R.data}`);if(P&&this.temporaryData.push(H),O){let N=this.kernelPersistentData.get(this.currentKernelId);N||(N=[],this.kernelPersistentData.set(this.currentKernelId,N)),N.push(H)}_.push(H)}if(c.length!==r.length||_.length!==w.length){if(_.length===0)return Gt(t.name),w;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let v;if(d){let E=0,P=[];d.forEach(N=>{let K=typeof N.data=="number"?[N.data]:N.data;if(K.length===0)return;let Q=N.type===10?2:4,he,W;N.type===10?(W=K.length>4?16:K.length>2?8:K.length*Q,he=K.length>4?16:Q*K.length):(W=K.length<=2?K.length*Q:16,he=16),E=Math.ceil(E/W)*W,P.push(E);let se=N.type===10?8:4;E+=K.length>4?Math.ceil(K.length/se)*he:K.length*Q});let O=16;E=Math.ceil(E/O)*O;let R=new ArrayBuffer(E);d.forEach((N,K)=>{let Q=P[K],he=typeof N.data=="number"?[N.data]:N.data;if(N.type===6)new Int32Array(R,Q,he.length).set(he);else if(N.type===12)new Uint32Array(R,Q,he.length).set(he);else if(N.type===10)new Uint16Array(R,Q,he.length).set(he);else if(N.type===1)new Float32Array(R,Q,he.length).set(he);else throw new Error(`Unsupported uniform type: ${Nt(N.type)}`)});let H=this.gpuDataManager.create(E,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(H.buffer,0,R,0,E),this.gpuDataManager.release(H.id),v={offset:0,size:E,buffer:H.buffer}}let S=this.programManager.normalizeDispatchGroupSize(h),I=S[1]===1&&S[2]===1,A=nm(t,r,I),x=this.programManager.getArtifact(A);if(x||(x=this.programManager.build(t,S),this.programManager.setArtifact(A,x),Ve("info",()=>`[artifact] key: ${A}, programName: ${t.name}`)),d&&x.uniformVariablesInfo){if(d.length!==x.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${x.uniformVariablesInfo.length}, got ${d.length} in program "${x.programInfo.name}".`);for(let E=0;E<d.length;E++){let P=d[E],O=P.type,R=typeof P.data=="number"?1:P.data.length,[H,N]=x.uniformVariablesInfo[E];if(O!==H||R!==N)throw new Error(`Uniform variable ${E} mismatch: expect type ${H} with size ${N}, got type ${O} with size ${R} in program "${x.programInfo.name}".`)}}if(Ve("info",()=>`[ProgramManager] run "${t.name}" (key=${A}) with ${S[0]}x${S[1]}x${S[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let E={kernelId:this.currentKernelId,programName:x.programInfo.name,inputTensorViews:r,outputTensorViews:w};this.pendingKernels.push(E),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(E)}return this.programManager.run(x,c,_,S,v),Gt(t.name),w}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,i){let u=Md.get(t);if(!u)throw new Error(`kernel not implemented: ${t}`);let a={kernelType:t,kernelName:i,kernelEntry:u[0],attributes:[u[1],o]};this.kernels.set(r,a)}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let i=this.kernels.get(t);if(!i)throw new Error(`kernel not created: ${t}`);let u=i.kernelType,a=i.kernelName,c=i.kernelEntry,p=i.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${u}] ${a}" is not allowed to be called recursively`);this.currentKernelId=t,p[0]&&(p[1]=p[0](p[1]),p[0]=void 0),Ve("info",()=>`[WebGPU] Start to run kernel "[${u}] ${a}"...`);let h=this.env.debug;this.temporaryData=[];try{return h&&this.device.pushErrorScope("validation"),c(r,p[1]),0}catch(d){return o.push(Promise.resolve(`[WebGPU] Kernel "[${u}] ${a}" failed. ${d}`)),1}finally{h&&o.push(this.device.popErrorScope().then(d=>d?`GPU validation error for kernel "[${u}] ${a}": ${d.message}`:null));for(let d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,i){let u=this.sessionExternalDataMapping.get(t);u||(u=new Map,this.sessionExternalDataMapping.set(t,u));let a=u.get(r),c=this.gpuDataManager.registerExternalBuffer(o,i,a?.[1]);return u.set(r,[c,o]),c}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let i=await xo(this,t,r);return ma(i.buffer,o)}}writeTimestamp(t){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Ve("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Ve("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Ve("info","replay"),this.sessionStatus="replaying";let t=this.capturedCommandList.get(this.currentSessionId),r=this.capturedPendingKernels.get(this.currentSessionId),o=t.length;this.pendingKernels=[];for(let i=0;i<o;i++){let u=this.getComputePassEncoder(),a=t[i];this.writeTimestamp(this.pendingDispatchNumber*2),u.setPipeline(a.computePipeline),u.setBindGroup(0,a.bindGroup),u.dispatchWorkgroups(...a.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(r[i]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}});var Nd={};gn(Nd,{init:()=>om});var qr,Zo,om,Gd=Y(()=>{"use strict";ye();Wd();Ht();Se();qr=class e{constructor(t,r,o,i){this.module=t;this.dataType=r;this.data=o;this.dims=i}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(M.size(t)!==M.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Zo=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;this.adapterInfo=r.adapterInfo;let i=t.HEAPU32,u=o>>>2;this.opKernelContext=i[u++];let a=i[u++];this.outputCount=i[u++],this.customDataOffset=i[u++],this.customDataSize=i[u++];let c=[];for(let p=0;p<a;p++){let h=i[u++],d=i[u++],y=i[u++],w=[];for(let _=0;_<y;_++)w.push(i[u++]);c.push(new qr(t,h,d,w))}this.inputs=c}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(t,r){let o=r?.inputs?.map(c=>typeof c=="number"?this.inputs[c]:c)??this.inputs,i=r?.outputs??[],u=(c,p,h)=>new qr(this.module,p,this.output(c,h),h),a=(c,p)=>{let h=tr(c);if(!h)throw new Error(`Unsupported data type: ${c}`);let d=h*M.size(p),y=d>0?this.backend.gpuDataManager.create(d).id:0;return new qr(this.module,c,y,p)};return this.backend.run(t,o,i,u,a,this.outputCount)}output(t,r){let o=this.module.stackSave();try{let i=this.module.stackAlloc((1+r.length)*4),u=i>>2;this.module.HEAPU32[u++]=r.length;for(let a=0;a<r.length;a++)this.module.HEAPU32[u++]=r[a];return this.module._JsepOutput(this.opKernelContext,t,i)}catch(i){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${i}`)}finally{this.module.stackRestore(o)}}},om=async(e,t,r,o)=>{let i=t.jsepInit;if(!i)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(e==="webgpu"){let u=new Ln;await u.initialize(r,o),i("webgpu",[u,a=>u.alloc(a),a=>u.free(a),(a,c,p,h=!1)=>{if(h)Ve("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${a}, dst=${c}, size=${p}`),u.memcpy(a,c);else{Ve("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${a}, gpuDataId=${c}, size=${p}`);let d=t.HEAPU8.subarray(a>>>0,(a>>>0)+p);u.upload(c,d)}},async(a,c,p)=>{Ve("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${c}, size=${p}`),await u.download(a,()=>t.HEAPU8.subarray(c>>>0,(c>>>0)+p))},(a,c,p)=>u.createKernel(a,c,p,t.UTF8ToString(t._JsepGetNodeName(c))),a=>u.releaseKernel(a),(a,c,p,h)=>{Ve("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${p}, kernel=${a}, contextDataOffset=${c}`);let d=new Zo(t,u,c);return u.computeKernel(a,d,h)},()=>u.captureBegin(),()=>u.captureEnd(),()=>u.replay()])}else i("webnn")}});var Vi;Vi=Ei();var pl=zi(),fo,ho=!1,yn=!1,Ui=!1,ml=e=>{if(e===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+e+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+e+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},fl=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},hl=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Wi=async e=>{if(ho)return Promise.resolve();if(yn)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Ui)throw new Error("previous call to \'initializeWebAssembly()\' failed.");yn=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,i=ml(r),u=o&&fl(),a=e.wasmPaths,c=typeof a=="string"?a:void 0,p=hl(u,i),h=typeof a=="object"?a[p]:void 0,d=!1,y=[];if(t>0&&y.push(new Promise(w=>{setTimeout(()=>{d=!0,w()},t)})),y.push(new Promise((w,_)=>{let v=i?pl:Vi,S={locateFile:(I,A)=>{if(i&&I.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Mi()],{type:"text/javascript"}));if(I.endsWith(".wasm")){if(h)return h;let x=c??A;return p==="ort-wasm-simd.wasm"?x+"ort-wasm-simd.jsep.wasm":p==="ort-wasm-simd-threaded.wasm"?x+"ort-wasm-simd-threaded.jsep.wasm":x+p}return A+I}};if(i)if(S.numThreads=r,typeof Blob>"u")S.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let I=`var ortWasmThreaded=${v.toString()};`;S.mainScriptUrlOrBlob=new Blob([I],{type:"text/javascript"})}v(S).then(I=>{yn=!1,ho=!0,fo=I,w()},I=>{yn=!1,Ui=!0,_(I)})})),await Promise.race(y),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Le=()=>{if(ho&&fo)return fo;throw new Error("WebAssembly is not initialized yet.")};var Fe=(e,t)=>{let r=Le(),o=r.lengthBytesUTF8(e)+1,i=r._malloc(o);return r.stringToUTF8(e,i,o),t.push(i),i},Nr=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([i,u])=>{let a=t?t+i:i;if(typeof u=="object")Nr(u,a+".",r,o);else if(typeof u=="string"||typeof u=="number")o(a,u.toString());else if(typeof u=="boolean")o(a,u?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof u}`)})},Ue=e=>{let t=Le(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let i=t.HEAP32[o/4],u=t.HEAPU32[o/4+1],a=u?t.UTF8ToString(u):"";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(r)}};var Ni=e=>{let t=Le(),r=0,o=[],i=e||{};try{if(e?.logSeverityLevel===void 0)i.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)i.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(i.terminate=!1);let u=0;return e?.tag!==void 0&&(u=Fe(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,u),r===0&&Ue("Can\'t create run options."),e?.extra!==void 0&&Nr(e.extra,"",new WeakSet,(a,c)=>{let p=Fe(a,o),h=Fe(c,o);t._OrtAddRunConfigEntry(r,p,h)!==0&&Ue(`Can\'t set a run config entry: ${a} - ${c}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(a=>t._free(a)),u}};var gl=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},yl=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},bl=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},wl=(e,t,r)=>{for(let o of t){let i=typeof o=="string"?o:o.name;switch(i){case"webnn":if(i="WEBNN",typeof o!="string"){let a=o;if(a?.deviceType){let c=Fe("deviceType",r),p=Fe(a.deviceType,r);Le()._OrtAddSessionConfigEntry(e,c,p)!==0&&Ue(`Can\'t set a session config entry: \'deviceType\' - ${a.deviceType}.`)}if(a?.numThreads){let c=a.numThreads;(typeof c!="number"||!Number.isInteger(c)||c<0)&&(c=0);let p=Fe("numThreads",r),h=Fe(c.toString(),r);Le()._OrtAddSessionConfigEntry(e,p,h)!==0&&Ue(`Can\'t set a session config entry: \'numThreads\' - ${a.numThreads}.`)}if(a?.powerPreference){let c=Fe("powerPreference",r),p=Fe(a.powerPreference,r);Le()._OrtAddSessionConfigEntry(e,c,p)!==0&&Ue(`Can\'t set a session config entry: \'powerPreference\' - ${a.powerPreference}.`)}}break;case"webgpu":if(i="JS",typeof o!="string"){let a=o;if(a?.preferredLayout){if(a.preferredLayout!=="NCHW"&&a.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${a.preferredLayout}`);let c=Fe("preferredLayout",r),p=Fe(a.preferredLayout,r);Le()._OrtAddSessionConfigEntry(e,c,p)!==0&&Ue(`Can\'t set a session config entry: \'preferredLayout\' - ${a.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${i}`)}let u=Fe(i,r);Le()._OrtAppendExecutionProvider(e,u)!==0&&Ue(`Can\'t append execution provider: ${i}.`)}},Gi=e=>{let t=Le(),r=0,o=[],i=e||{};bl(i);try{let u=gl(i.graphOptimizationLevel??"all"),a=yl(i.executionMode??"sequential"),c=typeof i.logId=="string"?Fe(i.logId,o):0,p=i.logSeverityLevel??2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);let h=i.logVerbosityLevel??0;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log verbosity level is not valid: ${h}`);let d=typeof i.optimizedModelFilePath=="string"?Fe(i.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(u,!!i.enableCpuMemArena,!!i.enableMemPattern,a,!!i.enableProfiling,0,c,p,h,d),r===0&&Ue("Can\'t create session options."),i.executionProviders&&wl(r,i.executionProviders,o),i.enableGraphCapture!==void 0){if(typeof i.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${i.enableGraphCapture}`);let y=Fe("enableGraphCapture",o),w=Fe(i.enableGraphCapture.toString(),o);t._OrtAddSessionConfigEntry(r,y,w)!==0&&Ue(`Can\'t set a session config entry: \'enableGraphCapture\' - ${i.enableGraphCapture}.`)}if(i.freeDimensionOverrides)for(let[y,w]of Object.entries(i.freeDimensionOverrides)){if(typeof y!="string")throw new Error(`free dimension override name must be a string: ${y}`);if(typeof w!="number"||!Number.isInteger(w)||w<0)throw new Error(`free dimension override value must be a non-negative integer: ${w}`);let _=Fe(y,o);t._OrtAddFreeDimensionOverride(r,_,w)!==0&&Ue(`Can\'t set a free dimension override: ${y} - ${w}.`)}return i.extra!==void 0&&Nr(i.extra,"",new WeakSet,(y,w)=>{let _=Fe(y,o),v=Fe(w,o);t._OrtAddSessionConfigEntry(r,_,v)!==0&&Ue(`Can\'t set a session config entry: ${y} - ${w}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(a=>t._free(a)),u}};ye();var Li=async e=>{if(typeof e=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let r=(void 0)(e),o=[];for await(let i of r)o.push(i);return new Uint8Array(Buffer.concat(o))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),o=r?parseInt(r,10):0;if(o<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let i=t.body.getReader(),u;try{u=new ArrayBuffer(o)}catch(c){if(c instanceof RangeError){let p=Math.ceil(o/65536);u=new WebAssembly.Memory({initial:p,maximum:p}).buffer}else throw c}let a=0;for(;;){let{done:c,value:p}=await i.read();if(c)break;let h=p.byteLength;new Uint8Array(u,a,h).set(p),a+=h}return new Uint8Array(u,0,o)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)};var im=(e,t)=>{Le()._OrtInit(e,t)!==0&&Ue("Can\'t initialize onnxruntime.")},Ld=async e=>{im(e.wasm.numThreads,Gr(e.logLevel))},Fd=async(e,t)=>{{let r=(Gd(),wr(Nd)).init;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let o=e.webgpu.adapter;if(o){if(typeof o.limits!="object"||typeof o.features!="object"||typeof o.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let i=e.webgpu.powerPreference;if(i!==void 0&&i!=="low-power"&&i!=="high-performance")throw new Error(`Invalid powerPreference setting: "${i}"`);let u=e.webgpu.forceFallbackAdapter;if(u!==void 0&&typeof u!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${u}"`);if(o=await navigator.gpu.requestAdapter({powerPreference:i,forceFallbackAdapter:u}),!o)throw new Error(\'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.\')}if(!e.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");await r("webgpu",Le(),e,o)}if(t==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await r("webnn",Le(),e)}}},ar=new Map,am=e=>{let t=Le(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ue("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},Xo=e=>{let t=Le(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},qd=async(e,t)=>{let r,o,i=Le();Array.isArray(e)?[r,o]=e:e.buffer===i.HEAPU8.buffer?[r,o]=[e.byteOffset,e.byteLength]:[r,o]=Xo(e);let u=0,a=0,c=0,p=[],h=[],d=[];try{if([a,p]=Gi(t),t?.externalData&&i.mountExternalData){let x=[];for(let E of t.externalData){let P=typeof E=="string"?E:E.path;x.push(Li(typeof E=="string"?E:E.data).then(O=>{i.mountExternalData(P,O)}))}await Promise.all(x)}u=await i._OrtCreateSession(r,o,a),u===0&&Ue("Can\'t create a session.");let[y,w]=am(u),_=!!t?.enableGraphCapture,v=[],S=[],I=[];for(let x=0;x<y;x++){let E=i._OrtGetInputName(u,x);E===0&&Ue("Can\'t get an input name."),h.push(E),v.push(i.UTF8ToString(E))}for(let x=0;x<w;x++){let E=i._OrtGetOutputName(u,x);E===0&&Ue("Can\'t get an output name."),d.push(E);let P=i.UTF8ToString(E);S.push(P);{if(_&&t?.preferredOutputLocation===void 0){I.push("gpu-buffer");continue}let O=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[P]??"cpu";if(O!=="cpu"&&O!=="cpu-pinned"&&O!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${O}.`);if(_&&O!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${O}. Only \'gpu-buffer\' location is supported when enableGraphCapture is true.`);I.push(O)}}let A=null;return I.some(x=>x==="gpu-buffer")&&(c=i._OrtCreateBinding(u),c===0&&Ue("Can\'t create IO binding."),A={handle:c,outputPreferredLocations:I,outputPreferredLocationsEncoded:I.map(x=>yo(x))}),ar.set(u,[u,h,d,A,_,!1]),[u,v,S]}catch(y){throw h.forEach(w=>i._OrtFree(w)),d.forEach(w=>i._OrtFree(w)),c!==0&&i._OrtReleaseBinding(c),u!==0&&i._OrtReleaseSession(u),y}finally{i._free(r),a!==0&&i._OrtReleaseSessionOptions(a),p.forEach(y=>i._free(y)),i.unmountExternalData?.()}},jd=e=>{let t=Le(),r=ar.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,i,u,a,c]=r;a&&(c&&t._OrtClearBoundOutputs(a.handle),t._OrtReleaseBinding(a.handle)),t.jsepOnReleaseSession?.(e),i.forEach(p=>t._OrtFree(p)),u.forEach(p=>t._OrtFree(p)),t._OrtReleaseSession(o),ar.delete(e)},Hd=(e,t,r,o,i,u=!1)=>{if(!e){t.push(0);return}let a=Le(),c=e[0],p=e[1],h=e[3],d,y;if(c==="string"&&h==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(u&&h!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${i} when enableGraphCapture is true.`);if(h==="gpu-buffer"){let v=e[2].gpuBuffer,S=tr(go(c));y=p.reduce((A,x)=>A*x,1)*S;let I=a.jsepRegisterBuffer;if(!I)throw new Error(\'Tensor location "gpu-buffer" is not supported without using WebGPU.\');d=I(o,i,v,y)}else{let v=e[2];if(Array.isArray(v)){y=4*v.length,d=a._malloc(y),r.push(d);let S=d/4;for(let I=0;I<v.length;I++){if(typeof v[I]!="string")throw new TypeError(`tensor data at index ${I} is not a string`);a.HEAPU32[S++]=Fe(v[I],r)}}else y=v.byteLength,d=a._malloc(y),r.push(d),a.HEAPU8.set(new Uint8Array(v.buffer,v.byteOffset,y),d)}let w=a.stackSave(),_=a.stackAlloc(4*p.length);try{let v=_/4;p.forEach(I=>a.HEAP32[v++]=I);let S=a._OrtCreateTensor(go(c),d,y,_,p.length,yo(h));S===0&&Ue(`Can\'t create tensor for input/output. session=${o}, index=${i}.`),t.push(S)}finally{a.stackRestore(w)}},Kd=async(e,t,r,o,i,u)=>{let a=Le(),c=ar.get(e);if(!c)throw new Error(`cannot run inference. invalid session id: ${e}`);let p=c[0],h=c[1],d=c[2],y=c[3],w=c[4],_=c[5],v=t.length,S=o.length,I=0,A=[],x=[],E=[],P=[],O=a.stackSave(),R=a.stackAlloc(v*4),H=a.stackAlloc(v*4),N=a.stackAlloc(S*4),K=a.stackAlloc(S*4);try{[I,A]=Ni(u);for(let ee=0;ee<v;ee++)Hd(r[ee],x,P,e,t[ee],w);for(let ee=0;ee<S;ee++)Hd(i[ee],E,P,e,v+o[ee],w);let Q=R/4,he=H/4,W=N/4,se=K/4;for(let ee=0;ee<v;ee++)a.HEAPU32[Q++]=x[ee],a.HEAPU32[he++]=h[t[ee]];for(let ee=0;ee<S;ee++)a.HEAPU32[W++]=E[ee],a.HEAPU32[se++]=d[o[ee]];if(y&&!_){let{handle:ee,outputPreferredLocations:ae,outputPreferredLocationsEncoded:Ae}=y;if(h.length!==v)throw new Error(`input count from feeds (${v}) is expected to be always equal to model\'s input count (${h.length}).`);for(let me=0;me<v;me++){let ie=t[me];await a._OrtBindInput(ee,h[ie],x[me])!==0&&Ue(`Can\'t bind input[${me}] for session=${e}.`)}for(let me=0;me<S;me++){let ie=o[me];i[me]?.[3]?a._OrtBindOutput(ee,d[ie],E[me],0)!==0&&Ue(`Can\'t bind pre-allocated output[${me}] for session=${e}.`):a._OrtBindOutput(ee,d[ie],0,Ae[ie])!==0&&Ue(`Can\'t bind output[${me}] to ${ae[me]} for session=${e}.`)}ar.set(e,[p,h,d,y,w,!0])}a.jsepOnRunStart?.(p);let Ce;y?Ce=await a._OrtRunWithBinding(p,y.handle,S,N,I):Ce=await a._OrtRun(p,H,R,v,K,S,N,I),Ce!==0&&Ue("failed to call OrtRun().");let We=[];for(let ee=0;ee<S;ee++){let ae=a.HEAPU32[N/4+ee];if(ae===E[ee]){We.push(i[ee]);continue}let Ae=a.stackSave(),me=a.stackAlloc(4*4),ie=!1,ue,le=0;try{a._OrtGetTensorData(ae,me,me+4,me+8,me+12)!==0&&Ue(`Can\'t access output tensor data on index ${ee}.`);let G=me/4,ne=a.HEAPU32[G++];le=a.HEAPU32[G++];let xe=a.HEAPU32[G++],Ke=a.HEAPU32[G++],De=[];for(let Ne=0;Ne<Ke;Ne++)De.push(a.HEAPU32[xe/4+Ne]);a._OrtFree(xe);let Ge=De.reduce((Ne,Ye)=>Ne*Ye,1);ue=Nt(ne);let Mt=y?.outputPreferredLocations[o[ee]];if(ue==="string"){if(Mt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ne=[],Ye=le/4;for(let mt=0;mt<Ge;mt++){let Ot=a.HEAPU32[Ye++],qt=mt===Ge-1?void 0:a.HEAPU32[Ye]-Ot;Ne.push(a.UTF8ToString(Ot,qt))}We.push([ue,De,Ne,"cpu"])}else if(Mt==="gpu-buffer"&&Ge>0){let Ne=a.jsepGetBuffer;if(!Ne)throw new Error(\'preferredLocation "gpu-buffer" is not supported without using WebGPU.\');let Ye=Ne(le),mt=tr(ne);if(mt===void 0||!Hi(ue))throw new Error(`Unsupported data type: ${ue}`);ie=!0,We.push([ue,De,{gpuBuffer:Ye,download:a.jsepCreateDownloader(Ye,Ge*mt,ue),dispose:()=>{a._OrtReleaseTensor(ae)}},"gpu-buffer"])}else{let Ne=bn(ue),Ye=new Ne(Ge);new Uint8Array(Ye.buffer,Ye.byteOffset,Ye.byteLength).set(a.HEAPU8.subarray(le,le+Ye.byteLength)),We.push([ue,De,Ye,"cpu"])}}finally{a.stackRestore(Ae),ue==="string"&&le&&a._free(le),ie||a._OrtReleaseTensor(ae)}}return y&&!w&&(a._OrtClearBoundOutputs(y.handle),ar.set(e,[p,h,d,y,w,!1])),We}finally{a.stackRestore(O),x.forEach(Q=>a._OrtReleaseTensor(Q)),E.forEach(Q=>a._OrtReleaseTensor(Q)),P.forEach(Q=>a._free(Q)),I!==0&&a._OrtReleaseRunOptions(I),A.forEach(Q=>a._free(Q))}},Yd=e=>{let t=Le(),r=ar.get(e);if(!r)throw new Error("invalid session id");let o=r[0],i=t._OrtEndProfiling(o);i===0&&Ue("Can\'t get an profile file name."),t._OrtFree(i)},Zd=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":Wi(r.wasm).then(()=>{Ld(r).then(()=>{postMessage({type:t})},o=>{postMessage({type:t,err:o})})},o=>{postMessage({type:t,err:o})});break;case"init-ep":{let{epName:o,env:i}=r;Fd(i,o).then(()=>{postMessage({type:t})},u=>{postMessage({type:t,err:u})});break}case"copy-from":{let{buffer:o}=r,i=Xo(o);postMessage({type:t,out:i});break}case"create":{let{model:o,options:i}=r;qd(o,i).then(u=>{postMessage({type:t,out:u})},u=>{postMessage({type:t,err:u})});break}case"release":jd(r),postMessage({type:t});break;case"run":{let{sessionId:o,inputIndices:i,inputs:u,outputIndices:a,options:c}=r;Kd(o,i,u,a,new Array(a.length).fill(null),c).then(p=>{p.some(h=>h[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:p},Zd([...u,...p]))},p=>{postMessage({type:t,err:p})});break}case"end-profiling":Yd(r),postMessage({type:t});break;default:}}catch(o){postMessage({type:t,err:o})}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'}),gr,St,sn,pi,mi,Sa,Ca,zr,Br,pf,ci,Wd,Nd,Vd,Hd,Gd,Ld,Fd,Ia=j(()=>{_t(),Md(),Or(),gr=()=>!!ke.wasm.proxy&&typeof document<"u",sn=!1,pi=!1,mi=!1,Ca=new Map,zr=(o,e)=>{let s=Ca.get(o);s?s.push(e):Ca.set(o,[e])},Br=()=>{if(sn||!pi||mi||!St)throw new Error("worker not ready")},pf=o=>{switch(o.data.type){case"init-wasm":sn=!1,o.data.err?(mi=!0,Sa[1](o.data.err)):(pi=!0,Sa[0]());break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=Ca.get(o.data.type);o.data.err?e.shift()[1](o.data.err):e.shift()[0](o.data.out);break}}},ci=typeof document<"u"?document?.currentScript?.src:void 0,Wd=async()=>{if(!pi){if(sn)throw new Error("multiple calls to 'initWasm()' detected.");if(mi)throw new Error("previous call to 'initWasm()' failed.");if(sn=!0,gr())return ke.wasm.wasmPaths===void 0&&ci&&ci.indexOf("blob:")!==0&&(ke.wasm.wasmPaths=ci.substr(0,+ci.lastIndexOf("/")+1)),new Promise((o,e)=>{St?.terminate();let s=URL.createObjectURL(new Blob([Ud()],{type:"text/javascript"}));St=new Worker(s,{name:"ort-wasm-proxy-worker"}),St.onerror=d=>e(d),St.onmessage=pf,URL.revokeObjectURL(s),Sa=[o,e];let a={type:"init-wasm",in:ke};St.postMessage(a)});try{await Fo(ke.wasm),await kd(ke),pi=!0}catch(o){throw mi=!0,o}finally{sn=!1}}},Nd=async o=>{if(gr())return Br(),new Promise((e,s)=>{zr("init-ep",[e,s]);let a={type:"init-ep",in:{epName:o,env:ke}};St.postMessage(a)});await Od(ke,o)},Vd=async o=>gr()?(Br(),new Promise((e,s)=>{zr("copy-from",[e,s]);let a={type:"copy-from",in:{buffer:o}};St.postMessage(a,[o.buffer])})):xa(o),Hd=async(o,e)=>{if(gr()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Br(),new Promise((s,a)=>{zr("create",[s,a]);let d={type:"create",in:{model:o,options:{...e}}},h=[];o instanceof Uint8Array&&h.push(o.buffer),St.postMessage(d,h)})}else return Pd(o,e)},Gd=async o=>{if(gr())return Br(),new Promise((e,s)=>{zr("release",[e,s]);let a={type:"release",in:o};St.postMessage(a)});Rd(o)},Ld=async(o,e,s,a,d,h)=>{if(gr()){if(s.some(b=>b[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(d.some(b=>b))throw new Error("pre-allocated output tensor is not supported for proxy.");return Br(),new Promise((b,et)=>{zr("run",[b,et]);let st=s,$={type:"run",in:{sessionId:o,inputIndices:e,inputs:st,outputIndices:a,options:h}};St.postMessage($,Dd(st))})}else return zd(o,e,s,a,d,h)},Fd=async o=>{if(gr())return Br(),new Promise((e,s)=>{zr("end-profiling",[e,s]);let a={type:"end-profiling",in:o};St.postMessage(a)});Bd(o)}}),qd,mf,fi,jd=j(()=>{_t(),Ia(),ye(),qi(),qd=(o,e)=>{switch(o.location){case"cpu":return[o.type,o.dims,o.data,"cpu"];case"gpu-buffer":return[o.type,o.dims,{gpuBuffer:o.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${o.location} for ${e()}`)}},mf=o=>{switch(o[3]){case"cpu":return new tt(o[0],o[2],o[1]);case"gpu-buffer":{let e=o[0];if(!Vn(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:s,download:a,dispose:d}=o[2];return tt.fromGpuBuffer(s,{dataType:e,dims:o[1],download:a,dispose:d})}default:throw new Error(`invalid data location: ${o[3]}`)}},fi=class{async fetchModelAndCopyToWasmMemory(o){return Vd(await tn(o))}async loadModel(o,e){yt();let s;typeof o=="string"?typeof process<"u"&&process.versions&&process.versions.node?s=await tn(o):s=await this.fetchModelAndCopyToWasmMemory(o):s=o,[this.sessionId,this.inputNames,this.outputNames]=await Hd(s,e),ut()}async dispose(){return Gd(this.sessionId)}async run(o,e,s){yt();let a=[],d=[];Object.entries(o).forEach(g=>{let c=g[0],_=g[1],ot=this.inputNames.indexOf(c);if(ot===-1)throw new Error(`invalid input '${c}'`);a.push(_),d.push(ot)});let h=[],b=[];Object.entries(e).forEach(g=>{let c=g[0],_=g[1],ot=this.outputNames.indexOf(c);if(ot===-1)throw new Error(`invalid output '${c}'`);h.push(_),b.push(ot)});let et=a.map((g,c)=>qd(g,()=>`input "${this.inputNames[d[c]]}"`)),st=h.map((g,c)=>g?qd(g,()=>`output "${this.outputNames[b[c]]}"`):null),$=await Ld(this.sessionId,d,et,b,st,s),it={};for(let g=0;g<$.length;g++)it[this.outputNames[b[g]]]=h[g]??mf($[g]);return ut(),it}startProfiling(){}endProfiling(){Fd(this.sessionId)}}}),ff,hi,Kd=j(()=>{_t(),Ia(),jd(),ff=()=>{if((typeof ke.wasm.initTimeout!="number"||ke.wasm.initTimeout<0)&&(ke.wasm.initTimeout=0),typeof ke.wasm.simd!="boolean"&&(ke.wasm.simd=!0),typeof ke.wasm.proxy!="boolean"&&(ke.wasm.proxy=!1),typeof ke.wasm.trace!="boolean"&&(ke.wasm.trace=!1),typeof ke.wasm.numThreads!="number"||!Number.isInteger(ke.wasm.numThreads)||ke.wasm.numThreads<=0){(typeof self<"u"&&!self.crossOriginIsolated||typeof process<"u"&&process.versions&&process.versions.node)&&(ke.wasm.numThreads=1);let o=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;ke.wasm.numThreads=Math.min(4,Math.ceil((o||1)/2))}},hi=class{async init(o){ff(),await Wd(),await Nd(o)}async createInferenceSessionHandler(o,e){let s=new fi;return await s.loadModel(o,e),Promise.resolve(s)}}}),Yd={};kr(Yd,{wasmBackend:()=>hf});var hf,Xd=j(()=>{Kd(),hf=new hi});_t();_t();_t();var ko="1.19.0-dev.20240509-69cfcba38a";{let o=(Xd(),sr(Yd)).wasmBackend;lr("webgpu",o,5),lr("webnn",o,5),lr("cpu",o,10),lr("wasm",o,10)}Object.defineProperty(ke.versions,"web",{value:ko,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MODELS={phi3:{name:"phi3",path:"microsoft/Phi-3-mini-4k-instruct-onnx-web",externaldata:!0,file:"model"},phi3dev:{name:"phi3dev",path:"schmuell/Phi-3-mini-4k-instruct-onnx-web",externaldata:!0},"SmolLM-135M":{name:"SmolLM-135M",path:"HuggingFaceTB/SmolLM-135M",externaldata:!0,file:"model"}};function getConfig(){const o="";var e={model:"phi3",provider:"webgpu",profiler:0,verbose:0,threads:1,show_special:0,csv:0,max_tokens:9999,local:0};let s=o.split("&");for(var a=0;a<s.length;a++){let d=s[a].split("=");if(d[0]in e){const h=d[0],b=decodeURIComponent(d[1]);typeof e[h]=="number"?e[h]=parseInt(b):e[h]=b}else if(d[0].length>0)throw new Error("unknown argument: "+d[0])}return MODELS[e.model]!==void 0&&(e.model=MODELS[e.model]),e}async function hasWebGPU(){if(!("gpu"in navigator))return 2;try{return(await navigator.gpu.requestAdapter()).features.has("shader-f16")?0:1}catch{return 2}}async function fetchAndCache(o,e,s=""){e({text:`Loading ${s}...`,progress:0});const a=1024*1024,d=await caches.open("onnx");try{const h=await d.match(o);if(h)return console.log(`${o} (cached)`),h.arrayBuffer();console.log(`${o} (network)`);const b=await fetch(o);if(!b.ok)throw new Error(`Failed to fetch ${o}: ${b.statusText}`);const et=b.headers.get("content-length"),st=et?parseInt(et,10):0;let $=0,it=0;if(st>a){const g=[],c=b.body.getReader();for(;;){const{done:ot,value:ct}=await c.read();if(ot)break;if(g.push(ct),$+=ct.length,st){const dt=Math.floor($/st*100);dt>it&&(e({text:s,progress:dt}),it=dt)}}const _=await new Blob(g).arrayBuffer();return await d.put(o,new Response(_.slice(0))),_}else{const g=await b.arrayBuffer();return await d.put(o,new Response(g.slice(0))),g}}catch(h){throw console.error(`Can't fetch ${o}:`,h),h}}ke.wasm.numThreads=1;ke.wasm.simd=!0;ke.wasm.wasmPaths="/task-coach-browser/dist/";class LLM{sess=void 0;profiler=!1;feed={};output_tokens=[];eos=2;need_position_ids=!0;stop=!1;kv_dims=[];dtype="float16";max_tokens=9999;model_bytes=null;opt=null;pipeline=void 0;constructor(e=void 0){if(e){ke.wasm.wasmPaths=e.location.pathname.replace("index.html","")+"dist/";return}ke.wasm.wasmPaths="/task-coach-browser/dist/"}async load(e,s,a){const d=s.provider||"webgpu",h=s.verbose,b=s.local,et=d==="wasm"?!1:s.hasFP16;this.profiler=s.profiler,console.log("model",e);const st=b?"models/"+e.path:"https://huggingface.co/"+e.path+"/resolve/main",$=e.path.includes("HuggingFaceTB");let it=e.file||"model";it=et?it+"_q4f16.onnx":it+"_q4.onnx",it=$?"model.onnx":it;const g=await fetchAndCache(st+"/config.json",a,"config.json file");let c=new TextDecoder;const _=JSON.parse(c.decode(g)),ot=await fetchAndCache(st+"/onnx/"+it,a,"Model file");let ct;try{ct=e.externaldata?await fetchAndCache(st+"/onnx/"+it+"_data",a,"Model external data"):!1}catch(ft){console.log(ft)}let dt=ot.byteLength;ct&&(dt+=ct.byteLength),console.log(`model size ${Math.round(dt/1024/1024)} MB`);const pt={executionProviders:[d],preferredOutputLocation:{}};switch(d){case"webgpu":for(let ft=0;ft<_.num_hidden_layers;++ft)pt.preferredOutputLocation[`present.${ft}.key`]="gpu-buffer",pt.preferredOutputLocation[`present.${ft}.value`]="gpu-buffer";break}ct!==void 0&&(pt.externalData=[{data:ct,path:it+"_data"}]),h&&(pt.logSeverityLevel=0,pt.logVerbosityLevel=0,ke.logLevel="verbose"),ke.webgpu.profiling={},this.profiler&&(pt.enableProfiling=!0,ke.webgpu.profilingMode="default",ke.webgpu.profiling.mode="default"),this.model_bytes=ot,this.opt=pt,this.sess=await uc.create(ot,pt),this.eos=_.eos_token_id,this.kv_dims=[1,_.num_key_value_heads,0,_.hidden_size/_.num_attention_heads],this.dtype=et?"float16":"float32",this.num_layers=_.num_hidden_layers,await this.initilize_feed(),a(null)}async refreshSession(){this.sess=await uc.create(this.model_bytes,this.opt)}async initilize_feed(){const e=this.feed;for(const a in e){const d=e[a];d.location==="gpu-buffer"&&await d.dispose()}this.feed={};const s=this.dtype==="float16"?new Uint16Array:[];for(let a=0;a<this.num_layers;++a)this.feed[`past_key_values.${a}.key`]=new tt(this.dtype,s,this.kv_dims),this.feed[`past_key_values.${a}.value`]=new tt(this.dtype,s,this.kv_dims);this.output_tokens=[]}argmax(e){const s=e.data,a=e.dims[2]*(e.dims[1]-1);let d=s[a],h=0;for(let b=0;b<e.dims[2];b++){const et=s[b+a];if(!isFinite(et))throw new Error("found infinitive in logits");et>d&&(d=s[b+a],h=b)}return h}update_kv_cache(e,s){for(const a in s)if(a.startsWith("present")){let d=a.replace("present","past_key_values");const h=e[d];h.location==="gpu-buffer"&&h.dispose(),e[d]=s[a]}}abort(){this.stop=!0}async generate(e,s,a){const d=a.max_tokens||256,h=this.feed,b=new tt("int64",BigInt64Array.from(e.map(BigInt)),[1,e.length]);h.input_ids=b,this.stop=!1,this.output_tokens.push(...b.data);let et=0n,st=this.output_tokens.length;const $=b.size;for(this.need_position_ids&&(h.position_ids=new tt("int64",BigInt64Array.from({length:$},(it,g)=>BigInt(st-$+g)),[1,$]));et!=this.eos&&et!=32007&&st<d&&!this.stop;){st=this.output_tokens.length,h.attention_mask=new tt("int64",BigInt64Array.from({length:st},()=>1n),[1,st]);const it=await this.sess.run(h);et=BigInt(this.argmax(it.logits)),this.output_tokens.push(et),s&&!this.profiler&&s(this.output_tokens),this.update_kv_cache(h,it),h.input_ids=new tt("int64",BigInt64Array.from([et]),[1,1]),this.need_position_ids&&(h.position_ids=new tt("int64",BigInt64Array.from([BigInt(st)]),[1,1]))}return this.profiler&&this.sess.endProfiling(),this.output_tokens}}class ModelContextSingleton{static instance=null;constructor(e=void 0,s={}){if(ModelContextSingleton.instance)return ModelContextSingleton.instance;const a=getConfig();env$1.localModelPath="models",env$1.allowRemoteModels=a.local==0,env$1.allowLocalModels=a.local==1,this.document=e||void 0,this.config=a,this.llm={},this.tokenizer=null,this.isModelLoaded=!1,this.progress="starting progress",this.props=s,this.props?.setConfig!==void 0&&this.props.setConfig(a),ModelContextSingleton.instance=this}static getInstance(e=void 0,s={}){return ModelContextSingleton.instance||(ModelContextSingleton.instance=new ModelContextSingleton(e,s)),ModelContextSingleton.instance}async initialize(e=void 0,s=void 0){this.isModelLoaded||(e&&(this.props.setProgress=e),s&&(this.props.setIsModelLoaded=s),this.tokenizer=await AutoTokenizer.from_pretrained(this.config.model.path),this.llm=new LLM(this.document),await this.llm.load(this.config.model,{provider:this.config.provider,profiler:this.config.profiler,verbose:this.config.verbose,local:this.config.local,maxTokens:this.config.maxTokens,hasFP16:await hasWebGPU()===0},a=>{this.progress=a,this.props?.setProgress!==void 0&&this.props.setProgress(a)}),this.isModelLoaded=!0,this.props?.setIsModelLoaded!==void 0&&this.props.setIsModelLoaded(!0))}getLLM(){return this.llm}getTokenizer(){return this.tokenizer}getConfig(){return this.config}getIsModelLoaded(){return this.isModelLoaded}getProgress(){return this.progress}getAll(){return{tokenizer:this.tokenizer,config:this.config,isModelLoaded:this.isModelLoaded,progress:this.progress,llm:this.llm}}}class WorkerInstance{constructor(){this.instance=ModelContextSingleton.getInstance(),this.tokenizer=null,this.llm=null,this.config=null}async initialize(e,s){await this.instance.initialize(e,s);const{tokenizer:a,llm:d,config:h}=this.instance.getAll();this.tokenizer=a,this.llm=d,this.config=h}async terminateModel(){return this.llm.abort?(this.llm.abort(),await this.llm.initilize_feed(),!0):!1}async chatCompletion(e,s,a,d){if(!this.tokenizer||!this.llm)return null;const h=generatePrompt(e,s);return this.llm.pipeline?this.pipelineGeneration(h,d):this.tokenGeneration(h,a,d)}async pipelineGeneration(e,s){return{status:"final",text:(await(await this.llm.pipeline)(e,{max_length:9999,num_return_sequences:1}))[0].generated_text,key:s}}async tokenGeneration(e,s,a){const{input_ids:d}=await this.tokenizer(e,{return_tensor:!1,padding:!0,truncation:!0});await this.llm.initilize_feed();const h=performance.now(),b=this.llm.output_tokens.length+d.length,et=await this.llm.generate(d,$=>{if($.length===d.length+1){const g=(performance.now()-h)/1e3;console.log(`time to first token in ${g.toFixed(1)}sec, ${d.length} tokens`)}const it=token_to_text(this.tokenizer,$,b,this.config);if(s)return{status:"stream",text:it,key:a}},{max_tokens:this.config.max_tokens});return this.llm.abort(),{status:"final",text:token_to_text(this.tokenizer,et,b,this.config),key:a}}}const ModelContext=reactExports.createContext(),useModel=()=>reactExports.useContext(ModelContext),defaultSettings={disallowedDownloading:!0,apiUrlBaseLLM:"http://localhost:11434/api/chat",modelApi:"llama3.1",useAPI:!1,useReplicateAPI:!1,replicateModelPath:"meta/meta-llama-3.1-405b-instruct",huggingFaceModel:"HuggingFaceTB/SmolLM-360M-Instruct"},USER_SETTINGS=defaultSettings,getUserSettings=()=>{const o=localStorage.getItem("userModelSettings");return o?{...defaultSettings,...JSON.parse(o)}:defaultSettings},saveUserSettings=o=>{const e={...getUserSettings(),...o,modified:new Date().toISOString()};return localStorage.setItem("userModelSettings",JSON.stringify(e)),e},ModelProvider=({children:o})=>{const[e,s]=reactExports.useState(null),[a,d]=reactExports.useState(!1),[h,b]=reactExports.useState({text:"Starting progress",progress:0}),[et,st]=reactExports.useState(!1),[$,it]=reactExports.useState(getUserSettings()),g=reactExports.useRef([]),c=reactExports.useRef(!1),_=reactExports.useRef(!1),ot=reactExports.useCallback((mt,$t)=>{it(Tt=>{const Nt={...Tt,[mt]:$t};return saveUserSettings(Nt),Nt})},[]),ct=reactExports.useCallback(async()=>{if(!_.current&&(_.current=!0,!($.useAPI||$.disallowedDownloading||$.useReplicateAPI)))try{const mt=new WorkerInstance;await mt.initialize($t=>b($t),$t=>d($t)),s(mt)}catch(mt){console.error("Failed to initialize worker:",mt),_.current=!1}},[$.useAPI,$.disallowedDownloading,$.useReplicateAPI]);reactExports.useEffect(()=>{ct()},[ct]);const dt=reactExports.useCallback(async()=>{if(!c.current){for(c.current=!0,st(!0);g.current.length>0;){const{query:mt,prompt:$t,resolve:Tt,reject:Nt,callBackUpdate:Ct,timeoutMiliseconds:Ft}=g.current[0];try{let ln;if($.useReplicateAPI)ln=await chatCompletionReplicate(mt,$t,$.replicateApiToken,$.replicateModelPath,Ct);else if($.useAPI)ln=await chatCompletionAPI({query:mt,prompt:$t,baseUrl:$.apiUrlBaseLLM,model:$.modelApi},Ct,Ft);else if(a&&e)ln=(await e.chatCompletion(mt,$t,!0,v4())).text;else throw new Error("No model loaded");Ct&&Ct(ln),Tt(ln)}catch(ln){Nt(ln)}finally{g.current.shift()}await new Promise(ln=>setTimeout(ln,50))}st(!1),c.current=!1}},[$,a,e]),pt=reactExports.useCallback(async(mt,$t,Tt=void 0,Nt=15e4)=>new Promise((Ct,Ft)=>{g.current.push({query:mt,prompt:$t,resolve:Ct,reject:Ft,callBackUpdate:Tt,timeoutMiliseconds:Nt}),dt()}),[dt]),ft=reactExports.useCallback(async(mt,$t,Tt=3,Nt=void 0,Ct=15e4)=>{for(let Ft=0;Ft<Tt;Ft++)try{const ln=await pt(mt,$t,Nt,Ct);return extractJsonString(ln)}catch(ln){if(console.error(`Attempt ${Ft+1} failed:`,ln),Ft===Tt-1)throw new Error(`Failed after ${Tt} attempts`)}},[pt]),ht=reactExports.useCallback(async()=>{e&&(await e.terminateModel(),s(null),_.current=!1,await ct())},[e,ct]),bt={isModelLoaded:a,progress:h,chatCompletionJSON:ft,chatCompletion:pt,abortWorker:ht,isGenerating:et,canUseChatCompletion:$.useAPI||$.useReplicateAPI||a,...$,setDisallowedDownloading:mt=>ot("disallowedDownloading",mt),setApiUrlBaseLLM:mt=>ot("apiUrlBaseLLM",mt),setDisplayModelSettings:mt=>ot("displayModelSettings",mt),setApiModel:mt=>ot("modelApi",mt),setUseAPI:mt=>ot("useAPI",mt),setUseReplicateAPI:mt=>ot("useReplicateAPI",mt),setReplicateApiToken:mt=>ot("replicateApiToken",mt),setReplicateModelPath:mt=>ot("replicateModelPath",mt),setHuggingFaceModel:mt=>ot("huggingFaceModel",mt)};return jsxRuntimeExports.jsx(ModelContext.Provider,{value:bt,children:o})};marked.use({mangle:!1,headerIds:!1});const ChatBot=({chatHistory:o,setChatHistory:e,onSubmit:s,abortWorker:a})=>{const{isModelLoaded:d,apiUrlBaseLLM:h,modelApi:b,isGenerating:et}=useModel(),[st,$]=reactExports.useState(""),it=reactExports.useRef(null);reactExports.useEffect(()=>{it.current?.scrollIntoView({behavior:"smooth"})},[o]);const g=ot=>{if(ot.preventDefault(),st.trim()!==""){if(et){$("");return}e(ct=>[...ct,{role:"user",content:st},{role:"assistant",content:".."}]),s(st),$("")}},c=()=>b!==""&&h!==""?"Send":!d&&b===""&&h===""?"Loading model...":et?"Generating...":"Send",_=()=>b!==""&&h!==""?!1:et||!d;return jsxRuntimeExports.jsxs("div",{className:"chat-container",children:[jsxRuntimeExports.jsxs("div",{className:"chat-history",children:[o.map((ot,ct)=>jsxRuntimeExports.jsx("div",{className:`message ${ot.role}`,children:jsxRuntimeExports.jsx("div",{dangerouslySetInnerHTML:{__html:marked(ot.content)}})},ct)),jsxRuntimeExports.jsx("div",{ref:it})]}),jsxRuntimeExports.jsxs("form",{onSubmit:g,children:[jsxRuntimeExports.jsx("input",{type:"text",value:st,onChange:ot=>$(ot.target.value),disabled:_()}),jsxRuntimeExports.jsx("button",{type:"submit",disabled:_(),children:c()}),jsxRuntimeExports.jsx("button",{onClick:a,children:"Abort"})]})]})},CorsDemoNotice=()=>jsxRuntimeExports.jsx("div",{className:"p-4 bg-gray-50 rounded-md",children:jsxRuntimeExports.jsxs("p",{className:"text-base text-gray-600",children:["For testing purposes, please enable"," ",jsxRuntimeExports.jsx("a",{className:"underline text-blue-600 hover:text-blue-800",target:"_blank",rel:"noopener noreferrer",href:"https://cors-anywhere.herokuapp.com/corsdemo",children:"CORS Anywhere"})," ","to allow your request to replicate the API."]})}),ModelSettingsEditor=()=>{const{disallowedDownloading:o,apiUrlBaseLLM:e,setApiUrlBaseLLM:s,setDisallowedDownloading:a,isModelLoaded:d,progress:h,modelApi:b,setApiModel:et,useAPI:st,setUseAPI:$,useReplicateAPI:it,setUseReplicateAPI:g,replicateApiToken:c,setReplicateApiToken:_,replicateModelPath:ot,setReplicateModelPath:ct}=useModel(),[dt,pt]=reactExports.useState(USER_SETTINGS),ft=({...mt})=>{(mt.useAPI||mt.useReplicateAPI)&&(mt.disallowedDownloading=!0);const $t=ht(mt);bt($t)},ht=({...mt})=>{const $t={modified:new Date().toISOString(),...dt,...mt};return pt($t),localStorage.setItem("userModelSettings",JSON.stringify($t)),$t};reactExports.useEffect(()=>{ft(USER_SETTINGS)},[]);const bt=mt=>{a(mt.disallowedDownloading),mt.apiUrlBaseLLM&&mt.apiUrlBaseLLM!==""&&s(mt.apiUrlBaseLLM),mt.apiModel&&mt.apiModel!==""&&et(mt.apiModel),mt.useAPI&&$(mt.useAPI),mt.useReplicateAPI!==void 0&&g(mt.useReplicateAPI),mt.replicateApiToken&&_(mt.replicateApiToken),mt.replicateModelPath&&ct(mt.replicateModelPath)};return jsxRuntimeExports.jsxs("div",{className:"w-full max-w-md mx-auto bg-white shadow-lg rounded-lg overflow-hidden",children:[jsxRuntimeExports.jsx("div",{className:"bg-gray-50 border-b border-gray-200 p-4",children:jsxRuntimeExports.jsxs("h2",{className:"text-lg font-semibold text-gray-700 flex items-center",children:[jsxRuntimeExports.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:"h-5 w-5 mr-2",viewBox:"0 0 20 20",fill:"currentColor",children:jsxRuntimeExports.jsx("path",{fillRule:"evenodd",d:"M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z",clipRule:"evenodd"})}),"Model Settings"]})}),jsxRuntimeExports.jsxs("div",{className:"p-4 space-y-4",children:[!d&&!o&&jsxRuntimeExports.jsx("div",{className:"text-sm text-gray-600",children:"Loading model..."}),!o&&h?.text&&h?.progress&&jsxRuntimeExports.jsxs("div",{className:"bg-blue-100 p-3 rounded-md",children:[jsxRuntimeExports.jsxs("div",{className:"text-sm font-medium text-blue-800 flex justify-between items-center",children:[jsxRuntimeExports.jsx("span",{children:h.text}),jsxRuntimeExports.jsxs("span",{className:"text-blue-600",children:[Math.round(h.progress),"%"]})]}),jsxRuntimeExports.jsx("div",{className:"mt-1 h-2 bg-blue-200 rounded-full",children:jsxRuntimeExports.jsx("div",{className:"h-full bg-blue-500 rounded-full transition-all duration-300 ease-in-out",style:{width:`${h.progress}%`}})})]}),jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-between",children:[jsxRuntimeExports.jsx("label",{htmlFor:"allow-download",className:"text-sm font-medium text-gray-700",children:"Allow Downloading"}),jsxRuntimeExports.jsxs("div",{className:"relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in",children:[jsxRuntimeExports.jsx("input",{type:"checkbox",name:"allow-download",id:"allow-download",checked:!o,onChange:mt=>ft({disallowedDownloading:!mt.target.checked}),className:"toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"}),jsxRuntimeExports.jsx("label",{htmlFor:"allow-download",className:"toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"})]})]}),jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-between",children:[jsxRuntimeExports.jsx("label",{htmlFor:"use-replicate-api",className:"text-sm font-medium text-gray-700",children:"Use Replicate API"}),jsxRuntimeExports.jsxs("div",{className:"relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in",children:[jsxRuntimeExports.jsx("input",{type:"checkbox",name:"use-replicate-api",id:"use-replicate-api",checked:it,onChange:mt=>{ft({useReplicateAPI:mt.target.checked}),g(mt.target.checked)},className:"toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"}),jsxRuntimeExports.jsx("label",{htmlFor:"use-replicate-api",className:"toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"})]})]}),jsxRuntimeExports.jsxs("div",{className:"space-y-2",children:[jsxRuntimeExports.jsx("label",{htmlFor:"replicate-api-token",className:"text-sm font-medium text-gray-700 block",children:"Replicate API Token"}),jsxRuntimeExports.jsx("input",{id:"replicate-api-token",type:"password",value:c,onChange:mt=>ft({replicateApiToken:mt.target.value}),placeholder:"Enter Replicate API token",className:"w-full px-3 py-2 text-gray-700 border rounded-lg focus:outline-none focus:border-blue-500"})]}),jsxRuntimeExports.jsxs("div",{className:"space-y-2",children:[jsxRuntimeExports.jsx("label",{htmlFor:"replicate-model-path",className:"text-sm font-medium text-gray-700 block",children:"Replicate Model Path"}),jsxRuntimeExports.jsx("input",{id:"replicate-model-path",type:"text",value:ot,onChange:mt=>ft({replicateModelPath:mt.target.value}),placeholder:"Enter Replicate model path",className:"w-full px-3 py-2 text-gray-700 border rounded-lg focus:outline-none focus:border-blue-500"})]}),jsxRuntimeExports.jsxs("p",{className:"text-base text-gray-500",children:["You need a"," ",jsxRuntimeExports.jsx("a",{className:"underline",target:"_blank",rel:"noopener noreferrer",href:"https://replicate.com/account/api-tokens?utm_campaign=llama2ai&utm_source=project",children:"Replicate API token"})," ","to run this demo. Copy it and paste above."]}),jsxRuntimeExports.jsx(CorsDemoNotice,{}),jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-between",children:[jsxRuntimeExports.jsx("label",{htmlFor:"use-api",className:"text-sm font-medium text-gray-700",children:"Use local API"}),jsxRuntimeExports.jsxs("div",{className:"relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in",children:[jsxRuntimeExports.jsx("input",{type:"checkbox",name:"use-api",id:"use-api",checked:st,onChange:mt=>{ft({useAPI:mt.target.checked}),$(mt.target.checked)},className:"toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"}),jsxRuntimeExports.jsx("label",{htmlFor:"use-api",className:"toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"})]})]}),jsxRuntimeExports.jsxs("div",{className:"space-y-2",children:[jsxRuntimeExports.jsx("label",{htmlFor:"api-url",className:"text-sm font-medium text-gray-700 block",children:"BASE API URL"}),jsxRuntimeExports.jsx("input",{id:"api-url",type:"text",value:e,onChange:mt=>ft({apiUrlBaseLLM:mt.target.value}),className:"w-full px-3 py-2 text-gray-700 border rounded-lg focus:outline-none focus:border-blue-500"}),jsxRuntimeExports.jsx("p",{className:"text-xs text-gray-500",children:"For running ollama locally, use http://localhost:11434/api/chat"})]}),jsxRuntimeExports.jsxs("div",{className:"space-y-2",children:[jsxRuntimeExports.jsx("label",{htmlFor:"model-api",className:"text-sm font-medium text-gray-700 block",children:"Model"}),jsxRuntimeExports.jsx("input",{id:"model-api",type:"text",value:b,onChange:mt=>ft({modelApi:mt.target.value}),placeholder:"Enter model name",className:"w-full px-3 py-2 text-gray-700 border rounded-lg focus:outline-none focus:border-blue-500"})]})]})]})},ASSISTANT_SYSTEM_PROMPT_VALIDATE_TASK=`Your Main Task: to know if user input is a task needed to create subtasks.
1. you must analyze and think about the user input.
2. you must validate if its a valid task by task definition to monday, jira, todo's, that the user input can be splitted or divided to steps, and tasks.
3. think it and provide explanation how its valid or invalid with "explain" field.
4. must output only 1 json formatted response.
you must think and do this step by step.
JSON markdown format like this:
{
  "valid": true,
  "explain": "task is valid due to the user's input"
}`,ASSISTANT_SYSTEM_PROMPT_WRITE_TASKS=`Your Main Task: write titles for tasks of user input.
1. you must analyze and think about the user input.
2. must think and Break down the main task into 5-7 subtasks.
3. must for each task think of only of title ,description, estimated time, priority.
4. Use "High", "Medium", or "Low" for the priority field.
5. Estimated time should be in hours or days (e.g., "2 hours" or "3 days").
6. must output only the list tasks markdown formatted response.
do this step by step.`,ASSISTANT_SYSTEM_PROMPT_TO_JSON=`Your Main Task: convert user input to JSON format.
1. you must analyze and think about the user input.
2. must output only the list tasks json formatted response.
do this step by step.
Must provide a response in JSON format with the following structure:
[{
    "title": "string",
    "estimatedTime": "string",
    "priority": "string",
    "description": "string"
  }]`,ASSISTANT_SYSTEM_PROMPT_WRITE_TASKS_JSON=`Your Main Task: write titles for tasks of user input to JSON format.
1. you must analyze and think about the user input.
2. must think and Break down the main task into 5-7 subtasks.
3. must for each task think of only of title ,description, estimated time, priority.
4. Use "High", "Medium", or "Low" for the priority field.
5. Estimated time should be in hours or days (e.g., "2 hours" or "3 days").
6. must output only the list tasks json formatted response.
Must provide a response in JSON format with the following structure:
[{
    "title": "string",
    "estimatedTime": "string",
    "priority": "string",
    "description": "string"
  }]
`,ASSISTANT_SYSTEM_PROMPT_GENERATE_TASK=`Your Main Task: write title and description of user input to JSON format.
1. you must analyze and think about the user input.
2. must think write it in jira format.
3. must think of only of title ,description, estimated time, priority.
4. Use "High", "Medium", or "Low" for the priority field.
5. Estimated time should be in hours or days (e.g., "2 hours" or "3 days").
6. must output only the task object json formatted response.
Must provide a response in JSON format with the following structure:
{
    "title": "string",
    "estimatedTime": "string",
    "priority": "string",
    "description": "string"
  }
`;/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const toKebabCase=o=>o.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),mergeClasses=(...o)=>o.filter((e,s,a)=>!!e&&a.indexOf(e)===s).join(" ");/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var defaultAttributes={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Icon=reactExports.forwardRef(({color:o="currentColor",size:e=24,strokeWidth:s=2,absoluteStrokeWidth:a,className:d="",children:h,iconNode:b,...et},st)=>reactExports.createElement("svg",{ref:st,...defaultAttributes,width:e,height:e,stroke:o,strokeWidth:a?Number(s)*24/Number(e):s,className:mergeClasses("lucide",d),...et},[...b.map(([$,it])=>reactExports.createElement($,it)),...Array.isArray(h)?h:[h]]));/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const createLucideIcon=(o,e)=>{const s=reactExports.forwardRef(({className:a,...d},h)=>reactExports.createElement(Icon,{ref:h,iconNode:e,className:mergeClasses(`lucide-${toKebabCase(o)}`,a),...d}));return s.displayName=`${o}`,s};/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ChevronDown=createLucideIcon("ChevronDown",[["path",{d:"m6 9 6 6 6-6",key:"qrunsl"}]]);/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ChevronUp=createLucideIcon("ChevronUp",[["path",{d:"m18 15-6-6-6 6",key:"153udz"}]]);/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Database=createLucideIcon("Database",[["ellipse",{cx:"12",cy:"5",rx:"9",ry:"3",key:"msslwz"}],["path",{d:"M3 5V19A9 3 0 0 0 21 19V5",key:"1wlel7"}],["path",{d:"M3 12A9 3 0 0 0 21 12",key:"mv7ke4"}]]);/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const House=createLucideIcon("House",[["path",{d:"M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8",key:"5wwlr5"}],["path",{d:"M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",key:"1d0kgt"}]]);/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Menu=createLucideIcon("Menu",[["line",{x1:"4",x2:"20",y1:"12",y2:"12",key:"1e0a9i"}],["line",{x1:"4",x2:"20",y1:"6",y2:"6",key:"1owob3"}],["line",{x1:"4",x2:"20",y1:"18",y2:"18",key:"yk5zj1"}]]);/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const MessageSquare=createLucideIcon("MessageSquare",[["path",{d:"M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z",key:"1lielz"}]]);/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Pen=createLucideIcon("Pen",[["path",{d:"M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z",key:"1a8usu"}]]);/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Settings=createLucideIcon("Settings",[["path",{d:"M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",key:"1qme2f"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]]);/**
 * @license lucide-react v0.414.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const X=createLucideIcon("X",[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]]),SystemPromptEditor=({systemPrompt:o,setSystemPrompt:e})=>{const[s,a]=reactExports.useState(!1),[d,h]=reactExports.useState("validate"),[b,et]=reactExports.useState(o),st={validate:ASSISTANT_SYSTEM_PROMPT_VALIDATE_TASK,writeTasks:ASSISTANT_SYSTEM_PROMPT_WRITE_TASKS,toJson:ASSISTANT_SYSTEM_PROMPT_TO_JSON,writeTasksJson:ASSISTANT_SYSTEM_PROMPT_WRITE_TASKS_JSON,generateTaskJson:ASSISTANT_SYSTEM_PROMPT_GENERATE_TASK},$=c=>{const _=c.target.value;h(_),et(st[_]),e(st[_])},it=c=>{const _=c.target.value;et(_),e(_)},g=()=>{a(!s)};return jsxRuntimeExports.jsxs("div",{className:"bg-gray-900 text-white p-4 rounded-lg shadow-lg",children:[jsxRuntimeExports.jsxs("button",{onClick:g,className:"mb-4 w-full flex justify-between items-center bg-gray-800 hover:bg-gray-700 p-2 rounded-md transition-colors duration-200",children:[jsxRuntimeExports.jsxs("span",{className:"flex items-center",children:[jsxRuntimeExports.jsx(Pen,{className:"mr-2",size:18}),"System Prompt Editor"]}),s?jsxRuntimeExports.jsx(ChevronUp,{size:18}):jsxRuntimeExports.jsx(ChevronDown,{size:18})]}),s&&jsxRuntimeExports.jsxs("div",{className:"space-y-4",children:[jsxRuntimeExports.jsxs("div",{className:"flex flex-col space-y-2",children:[jsxRuntimeExports.jsx("label",{htmlFor:"prompt-select",className:"text-sm font-medium",children:"Select Prompt:"}),jsxRuntimeExports.jsxs("select",{id:"prompt-select",value:d,onChange:$,className:"bg-gray-800 border border-gray-700 text-white rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500",children:[jsxRuntimeExports.jsx("option",{value:"validate",children:"Validate Task"}),jsxRuntimeExports.jsx("option",{value:"writeTasks",children:"Write Tasks"}),jsxRuntimeExports.jsx("option",{value:"toJson",children:"To JSON"}),jsxRuntimeExports.jsx("option",{value:"writeTasksJson",children:"Write Tasks JSON"}),jsxRuntimeExports.jsx("option",{value:"generateTaskJson",children:"Generate Task JSON"})]})]}),jsxRuntimeExports.jsx("textarea",{value:b,onChange:it,className:"w-full min-h-[200px] bg-gray-800 border border-gray-700 text-white rounded-md p-2 focus:outline-none focus:ring-2 focus:ring-blue-500",placeholder:"Enter your system prompt here..."})]})]})},LoadingIndicator=({percentage:o,text:e})=>jsxRuntimeExports.jsxs("div",{className:"flex flex-col items-center justify-center h-full",children:[jsxRuntimeExports.jsxs("div",{className:"w-32 h-32 relative",children:[jsxRuntimeExports.jsxs("svg",{className:"w-full h-full",viewBox:"0 0 100 100",children:[jsxRuntimeExports.jsx("circle",{className:"text-green-200 stroke-current",strokeWidth:"10",cx:"50",cy:"50",r:"40",fill:"transparent"}),jsxRuntimeExports.jsx("circle",{className:"text-green-500 progress-ring__circle stroke-current",strokeWidth:"10",strokeLinecap:"round",cx:"50",cy:"50",r:"40",fill:"transparent",strokeDasharray:"251.2",strokeDashoffset:251.2*(1-o/100),transform:"rotate(-90 50 50)"})]}),jsxRuntimeExports.jsx("div",{className:"absolute top-0 left-0 w-full h-full flex items-center justify-center",children:jsxRuntimeExports.jsxs("span",{className:"text-2xl font-bold text-green-700",children:[Math.round(o),"%"]})})]}),jsxRuntimeExports.jsx("p",{className:"mt-4 text-lg font-semibold text-green-700",children:e})]});function composeEventHandlers(o,e,{checkForDefaultPrevented:s=!0}={}){return function(d){if(o?.(d),s===!1||!d.defaultPrevented)return e?.(d)}}function setRef(o,e){typeof o=="function"?o(e):o!=null&&(o.current=e)}function composeRefs(...o){return e=>o.forEach(s=>setRef(s,e))}function useComposedRefs(...o){return reactExports.useCallback(composeRefs(...o),o)}function createContextScope(o,e=[]){let s=[];function a(h,b){const et=reactExports.createContext(b),st=s.length;s=[...s,b];function $(g){const{scope:c,children:_,...ot}=g,ct=c?.[o][st]||et,dt=reactExports.useMemo(()=>ot,Object.values(ot));return jsxRuntimeExports.jsx(ct.Provider,{value:dt,children:_})}function it(g,c){const _=c?.[o][st]||et,ot=reactExports.useContext(_);if(ot)return ot;if(b!==void 0)return b;throw new Error(`\`${g}\` must be used within \`${h}\``)}return $.displayName=h+"Provider",[$,it]}const d=()=>{const h=s.map(b=>reactExports.createContext(b));return function(et){const st=et?.[o]||h;return reactExports.useMemo(()=>({[`__scope${o}`]:{...et,[o]:st}}),[et,st])}};return d.scopeName=o,[a,composeContextScopes(d,...e)]}function composeContextScopes(...o){const e=o[0];if(o.length===1)return e;const s=()=>{const a=o.map(d=>({useScope:d(),scopeName:d.scopeName}));return function(h){const b=a.reduce((et,{useScope:st,scopeName:$})=>{const g=st(h)[`__scope${$}`];return{...et,...g}},{});return reactExports.useMemo(()=>({[`__scope${e.scopeName}`]:b}),[b])}};return s.scopeName=e.scopeName,s}var Slot=reactExports.forwardRef((o,e)=>{const{children:s,...a}=o,d=reactExports.Children.toArray(s),h=d.find(isSlottable);if(h){const b=h.props.children,et=d.map(st=>st===h?reactExports.Children.count(b)>1?reactExports.Children.only(null):reactExports.isValidElement(b)?b.props.children:null:st);return jsxRuntimeExports.jsx(SlotClone,{...a,ref:e,children:reactExports.isValidElement(b)?reactExports.cloneElement(b,void 0,et):null})}return jsxRuntimeExports.jsx(SlotClone,{...a,ref:e,children:s})});Slot.displayName="Slot";var SlotClone=reactExports.forwardRef((o,e)=>{const{children:s,...a}=o;if(reactExports.isValidElement(s)){const d=getElementRef$1(s);return reactExports.cloneElement(s,{...mergeProps(a,s.props),ref:e?composeRefs(e,d):d})}return reactExports.Children.count(s)>1?reactExports.Children.only(null):null});SlotClone.displayName="SlotClone";var Slottable=({children:o})=>jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment,{children:o});function isSlottable(o){return reactExports.isValidElement(o)&&o.type===Slottable}function mergeProps(o,e){const s={...e};for(const a in e){const d=o[a],h=e[a];/^on[A-Z]/.test(a)?d&&h?s[a]=(...et)=>{h(...et),d(...et)}:d&&(s[a]=d):a==="style"?s[a]={...d,...h}:a==="className"&&(s[a]=[d,h].filter(Boolean).join(" "))}return{...o,...s}}function getElementRef$1(o){let e=Object.getOwnPropertyDescriptor(o.props,"ref")?.get,s=e&&"isReactWarning"in e&&e.isReactWarning;return s?o.ref:(e=Object.getOwnPropertyDescriptor(o,"ref")?.get,s=e&&"isReactWarning"in e&&e.isReactWarning,s?o.props.ref:o.props.ref||o.ref)}var NODES=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Primitive=NODES.reduce((o,e)=>{const s=reactExports.forwardRef((a,d)=>{const{asChild:h,...b}=a,et=h?Slot:e;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),jsxRuntimeExports.jsx(et,{...b,ref:d})});return s.displayName=`Primitive.${e}`,{...o,[e]:s}},{});function dispatchDiscreteCustomEvent(o,e){o&&reactDomExports.flushSync(()=>o.dispatchEvent(e))}function useCallbackRef(o){const e=reactExports.useRef(o);return reactExports.useEffect(()=>{e.current=o}),reactExports.useMemo(()=>(...s)=>e.current?.(...s),[])}function useEscapeKeydown(o,e=globalThis?.document){const s=useCallbackRef(o);reactExports.useEffect(()=>{const a=d=>{d.key==="Escape"&&s(d)};return e.addEventListener("keydown",a,{capture:!0}),()=>e.removeEventListener("keydown",a,{capture:!0})},[s,e])}var DISMISSABLE_LAYER_NAME="DismissableLayer",CONTEXT_UPDATE="dismissableLayer.update",POINTER_DOWN_OUTSIDE="dismissableLayer.pointerDownOutside",FOCUS_OUTSIDE="dismissableLayer.focusOutside",originalBodyPointerEvents,DismissableLayerContext=reactExports.createContext({layers:new Set,layersWithOutsidePointerEventsDisabled:new Set,branches:new Set}),DismissableLayer=reactExports.forwardRef((o,e)=>{const{disableOutsidePointerEvents:s=!1,onEscapeKeyDown:a,onPointerDownOutside:d,onFocusOutside:h,onInteractOutside:b,onDismiss:et,...st}=o,$=reactExports.useContext(DismissableLayerContext),[it,g]=reactExports.useState(null),c=it?.ownerDocument??globalThis?.document,[,_]=reactExports.useState({}),ot=useComposedRefs(e,Tt=>g(Tt)),ct=Array.from($.layers),[dt]=[...$.layersWithOutsidePointerEventsDisabled].slice(-1),pt=ct.indexOf(dt),ft=it?ct.indexOf(it):-1,ht=$.layersWithOutsidePointerEventsDisabled.size>0,bt=ft>=pt,mt=usePointerDownOutside(Tt=>{const Nt=Tt.target,Ct=[...$.branches].some(Ft=>Ft.contains(Nt));!bt||Ct||(d?.(Tt),b?.(Tt),Tt.defaultPrevented||et?.())},c),$t=useFocusOutside(Tt=>{const Nt=Tt.target;[...$.branches].some(Ft=>Ft.contains(Nt))||(h?.(Tt),b?.(Tt),Tt.defaultPrevented||et?.())},c);return useEscapeKeydown(Tt=>{ft===$.layers.size-1&&(a?.(Tt),!Tt.defaultPrevented&&et&&(Tt.preventDefault(),et()))},c),reactExports.useEffect(()=>{if(it)return s&&($.layersWithOutsidePointerEventsDisabled.size===0&&(originalBodyPointerEvents=c.body.style.pointerEvents,c.body.style.pointerEvents="none"),$.layersWithOutsidePointerEventsDisabled.add(it)),$.layers.add(it),dispatchUpdate(),()=>{s&&$.layersWithOutsidePointerEventsDisabled.size===1&&(c.body.style.pointerEvents=originalBodyPointerEvents)}},[it,c,s,$]),reactExports.useEffect(()=>()=>{it&&($.layers.delete(it),$.layersWithOutsidePointerEventsDisabled.delete(it),dispatchUpdate())},[it,$]),reactExports.useEffect(()=>{const Tt=()=>_({});return document.addEventListener(CONTEXT_UPDATE,Tt),()=>document.removeEventListener(CONTEXT_UPDATE,Tt)},[]),jsxRuntimeExports.jsx(Primitive.div,{...st,ref:ot,style:{pointerEvents:ht?bt?"auto":"none":void 0,...o.style},onFocusCapture:composeEventHandlers(o.onFocusCapture,$t.onFocusCapture),onBlurCapture:composeEventHandlers(o.onBlurCapture,$t.onBlurCapture),onPointerDownCapture:composeEventHandlers(o.onPointerDownCapture,mt.onPointerDownCapture)})});DismissableLayer.displayName=DISMISSABLE_LAYER_NAME;var BRANCH_NAME="DismissableLayerBranch",DismissableLayerBranch=reactExports.forwardRef((o,e)=>{const s=reactExports.useContext(DismissableLayerContext),a=reactExports.useRef(null),d=useComposedRefs(e,a);return reactExports.useEffect(()=>{const h=a.current;if(h)return s.branches.add(h),()=>{s.branches.delete(h)}},[s.branches]),jsxRuntimeExports.jsx(Primitive.div,{...o,ref:d})});DismissableLayerBranch.displayName=BRANCH_NAME;function usePointerDownOutside(o,e=globalThis?.document){const s=useCallbackRef(o),a=reactExports.useRef(!1),d=reactExports.useRef(()=>{});return reactExports.useEffect(()=>{const h=et=>{if(et.target&&!a.current){let st=function(){handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE,s,$,{discrete:!0})};const $={originalEvent:et};et.pointerType==="touch"?(e.removeEventListener("click",d.current),d.current=st,e.addEventListener("click",d.current,{once:!0})):st()}else e.removeEventListener("click",d.current);a.current=!1},b=window.setTimeout(()=>{e.addEventListener("pointerdown",h)},0);return()=>{window.clearTimeout(b),e.removeEventListener("pointerdown",h),e.removeEventListener("click",d.current)}},[e,s]),{onPointerDownCapture:()=>a.current=!0}}function useFocusOutside(o,e=globalThis?.document){const s=useCallbackRef(o),a=reactExports.useRef(!1);return reactExports.useEffect(()=>{const d=h=>{h.target&&!a.current&&handleAndDispatchCustomEvent(FOCUS_OUTSIDE,s,{originalEvent:h},{discrete:!1})};return e.addEventListener("focusin",d),()=>e.removeEventListener("focusin",d)},[e,s]),{onFocusCapture:()=>a.current=!0,onBlurCapture:()=>a.current=!1}}function dispatchUpdate(){const o=new CustomEvent(CONTEXT_UPDATE);document.dispatchEvent(o)}function handleAndDispatchCustomEvent(o,e,s,{discrete:a}){const d=s.originalEvent.target,h=new CustomEvent(o,{bubbles:!1,cancelable:!0,detail:s});e&&d.addEventListener(o,e,{once:!0}),a?dispatchDiscreteCustomEvent(d,h):d.dispatchEvent(h)}var useLayoutEffect2=globalThis?.document?reactExports.useLayoutEffect:()=>{},useReactId=React$1.useId||(()=>{}),count=0;function useId(o){const[e,s]=reactExports.useState(useReactId());return useLayoutEffect2(()=>{s(a=>a??String(count++))},[o]),e?`radix-${e}`:""}const sides=["top","right","bottom","left"],min=Math.min,max=Math.max,round=Math.round,floor=Math.floor,createCoords=o=>({x:o,y:o}),oppositeSideMap={left:"right",right:"left",bottom:"top",top:"bottom"},oppositeAlignmentMap={start:"end",end:"start"};function clamp(o,e,s){return max(o,min(e,s))}function evaluate(o,e){return typeof o=="function"?o(e):o}function getSide(o){return o.split("-")[0]}function getAlignment(o){return o.split("-")[1]}function getOppositeAxis(o){return o==="x"?"y":"x"}function getAxisLength(o){return o==="y"?"height":"width"}function getSideAxis(o){return["top","bottom"].includes(getSide(o))?"y":"x"}function getAlignmentAxis(o){return getOppositeAxis(getSideAxis(o))}function getAlignmentSides(o,e,s){s===void 0&&(s=!1);const a=getAlignment(o),d=getAlignmentAxis(o),h=getAxisLength(d);let b=d==="x"?a===(s?"end":"start")?"right":"left":a==="start"?"bottom":"top";return e.reference[h]>e.floating[h]&&(b=getOppositePlacement(b)),[b,getOppositePlacement(b)]}function getExpandedPlacements(o){const e=getOppositePlacement(o);return[getOppositeAlignmentPlacement(o),e,getOppositeAlignmentPlacement(e)]}function getOppositeAlignmentPlacement(o){return o.replace(/start|end/g,e=>oppositeAlignmentMap[e])}function getSideList(o,e,s){const a=["left","right"],d=["right","left"],h=["top","bottom"],b=["bottom","top"];switch(o){case"top":case"bottom":return s?e?d:a:e?a:d;case"left":case"right":return e?h:b;default:return[]}}function getOppositeAxisPlacements(o,e,s,a){const d=getAlignment(o);let h=getSideList(getSide(o),s==="start",a);return d&&(h=h.map(b=>b+"-"+d),e&&(h=h.concat(h.map(getOppositeAlignmentPlacement)))),h}function getOppositePlacement(o){return o.replace(/left|right|bottom|top/g,e=>oppositeSideMap[e])}function expandPaddingObject(o){return{top:0,right:0,bottom:0,left:0,...o}}function getPaddingObject(o){return typeof o!="number"?expandPaddingObject(o):{top:o,right:o,bottom:o,left:o}}function rectToClientRect(o){const{x:e,y:s,width:a,height:d}=o;return{width:a,height:d,top:s,left:e,right:e+a,bottom:s+d,x:e,y:s}}function computeCoordsFromPlacement(o,e,s){let{reference:a,floating:d}=o;const h=getSideAxis(e),b=getAlignmentAxis(e),et=getAxisLength(b),st=getSide(e),$=h==="y",it=a.x+a.width/2-d.width/2,g=a.y+a.height/2-d.height/2,c=a[et]/2-d[et]/2;let _;switch(st){case"top":_={x:it,y:a.y-d.height};break;case"bottom":_={x:it,y:a.y+a.height};break;case"right":_={x:a.x+a.width,y:g};break;case"left":_={x:a.x-d.width,y:g};break;default:_={x:a.x,y:a.y}}switch(getAlignment(e)){case"start":_[b]-=c*(s&&$?-1:1);break;case"end":_[b]+=c*(s&&$?-1:1);break}return _}const computePosition$1=async(o,e,s)=>{const{placement:a="bottom",strategy:d="absolute",middleware:h=[],platform:b}=s,et=h.filter(Boolean),st=await(b.isRTL==null?void 0:b.isRTL(e));let $=await b.getElementRects({reference:o,floating:e,strategy:d}),{x:it,y:g}=computeCoordsFromPlacement($,a,st),c=a,_={},ot=0;for(let ct=0;ct<et.length;ct++){const{name:dt,fn:pt}=et[ct],{x:ft,y:ht,data:bt,reset:mt}=await pt({x:it,y:g,initialPlacement:a,placement:c,strategy:d,middlewareData:_,rects:$,platform:b,elements:{reference:o,floating:e}});it=ft??it,g=ht??g,_={..._,[dt]:{..._[dt],...bt}},mt&&ot<=50&&(ot++,typeof mt=="object"&&(mt.placement&&(c=mt.placement),mt.rects&&($=mt.rects===!0?await b.getElementRects({reference:o,floating:e,strategy:d}):mt.rects),{x:it,y:g}=computeCoordsFromPlacement($,c,st)),ct=-1)}return{x:it,y:g,placement:c,strategy:d,middlewareData:_}};async function detectOverflow(o,e){var s;e===void 0&&(e={});const{x:a,y:d,platform:h,rects:b,elements:et,strategy:st}=o,{boundary:$="clippingAncestors",rootBoundary:it="viewport",elementContext:g="floating",altBoundary:c=!1,padding:_=0}=evaluate(e,o),ot=getPaddingObject(_),dt=et[c?g==="floating"?"reference":"floating":g],pt=rectToClientRect(await h.getClippingRect({element:(s=await(h.isElement==null?void 0:h.isElement(dt)))==null||s?dt:dt.contextElement||await(h.getDocumentElement==null?void 0:h.getDocumentElement(et.floating)),boundary:$,rootBoundary:it,strategy:st})),ft=g==="floating"?{x:a,y:d,width:b.floating.width,height:b.floating.height}:b.reference,ht=await(h.getOffsetParent==null?void 0:h.getOffsetParent(et.floating)),bt=await(h.isElement==null?void 0:h.isElement(ht))?await(h.getScale==null?void 0:h.getScale(ht))||{x:1,y:1}:{x:1,y:1},mt=rectToClientRect(h.convertOffsetParentRelativeRectToViewportRelativeRect?await h.convertOffsetParentRelativeRectToViewportRelativeRect({elements:et,rect:ft,offsetParent:ht,strategy:st}):ft);return{top:(pt.top-mt.top+ot.top)/bt.y,bottom:(mt.bottom-pt.bottom+ot.bottom)/bt.y,left:(pt.left-mt.left+ot.left)/bt.x,right:(mt.right-pt.right+ot.right)/bt.x}}const arrow$3=o=>({name:"arrow",options:o,async fn(e){const{x:s,y:a,placement:d,rects:h,platform:b,elements:et,middlewareData:st}=e,{element:$,padding:it=0}=evaluate(o,e)||{};if($==null)return{};const g=getPaddingObject(it),c={x:s,y:a},_=getAlignmentAxis(d),ot=getAxisLength(_),ct=await b.getDimensions($),dt=_==="y",pt=dt?"top":"left",ft=dt?"bottom":"right",ht=dt?"clientHeight":"clientWidth",bt=h.reference[ot]+h.reference[_]-c[_]-h.floating[ot],mt=c[_]-h.reference[_],$t=await(b.getOffsetParent==null?void 0:b.getOffsetParent($));let Tt=$t?$t[ht]:0;(!Tt||!await(b.isElement==null?void 0:b.isElement($t)))&&(Tt=et.floating[ht]||h.floating[ot]);const Nt=bt/2-mt/2,Ct=Tt/2-ct[ot]/2-1,Ft=min(g[pt],Ct),ln=min(g[ft],Ct),mn=Ft,yn=Tt-ct[ot]-ln,pn=Tt/2-ct[ot]/2+Nt,Ht=clamp(mn,pn,yn),Gt=!st.arrow&&getAlignment(d)!=null&&pn!==Ht&&h.reference[ot]/2-(pn<mn?Ft:ln)-ct[ot]/2<0,cn=Gt?pn<mn?pn-mn:pn-yn:0;return{[_]:c[_]+cn,data:{[_]:Ht,centerOffset:pn-Ht-cn,...Gt&&{alignmentOffset:cn}},reset:Gt}}}),flip$2=function(o){return o===void 0&&(o={}),{name:"flip",options:o,async fn(e){var s,a;const{placement:d,middlewareData:h,rects:b,initialPlacement:et,platform:st,elements:$}=e,{mainAxis:it=!0,crossAxis:g=!0,fallbackPlacements:c,fallbackStrategy:_="bestFit",fallbackAxisSideDirection:ot="none",flipAlignment:ct=!0,...dt}=evaluate(o,e);if((s=h.arrow)!=null&&s.alignmentOffset)return{};const pt=getSide(d),ft=getSideAxis(et),ht=getSide(et)===et,bt=await(st.isRTL==null?void 0:st.isRTL($.floating)),mt=c||(ht||!ct?[getOppositePlacement(et)]:getExpandedPlacements(et)),$t=ot!=="none";!c&&$t&&mt.push(...getOppositeAxisPlacements(et,ct,ot,bt));const Tt=[et,...mt],Nt=await detectOverflow(e,dt),Ct=[];let Ft=((a=h.flip)==null?void 0:a.overflows)||[];if(it&&Ct.push(Nt[pt]),g){const pn=getAlignmentSides(d,b,bt);Ct.push(Nt[pn[0]],Nt[pn[1]])}if(Ft=[...Ft,{placement:d,overflows:Ct}],!Ct.every(pn=>pn<=0)){var ln,mn;const pn=(((ln=h.flip)==null?void 0:ln.index)||0)+1,Ht=Tt[pn];if(Ht)return{data:{index:pn,overflows:Ft},reset:{placement:Ht}};let Gt=(mn=Ft.filter(cn=>cn.overflows[0]<=0).sort((cn,xn)=>cn.overflows[1]-xn.overflows[1])[0])==null?void 0:mn.placement;if(!Gt)switch(_){case"bestFit":{var yn;const cn=(yn=Ft.filter(xn=>{if($t){const dn=getSideAxis(xn.placement);return dn===ft||dn==="y"}return!0}).map(xn=>[xn.placement,xn.overflows.filter(dn=>dn>0).reduce((dn,wn)=>dn+wn,0)]).sort((xn,dn)=>xn[1]-dn[1])[0])==null?void 0:yn[0];cn&&(Gt=cn);break}case"initialPlacement":Gt=et;break}if(d!==Gt)return{reset:{placement:Gt}}}return{}}}};function getSideOffsets(o,e){return{top:o.top-e.height,right:o.right-e.width,bottom:o.bottom-e.height,left:o.left-e.width}}function isAnySideFullyClipped(o){return sides.some(e=>o[e]>=0)}const hide$2=function(o){return o===void 0&&(o={}),{name:"hide",options:o,async fn(e){const{rects:s}=e,{strategy:a="referenceHidden",...d}=evaluate(o,e);switch(a){case"referenceHidden":{const h=await detectOverflow(e,{...d,elementContext:"reference"}),b=getSideOffsets(h,s.reference);return{data:{referenceHiddenOffsets:b,referenceHidden:isAnySideFullyClipped(b)}}}case"escaped":{const h=await detectOverflow(e,{...d,altBoundary:!0}),b=getSideOffsets(h,s.floating);return{data:{escapedOffsets:b,escaped:isAnySideFullyClipped(b)}}}default:return{}}}}};async function convertValueToCoords(o,e){const{placement:s,platform:a,elements:d}=o,h=await(a.isRTL==null?void 0:a.isRTL(d.floating)),b=getSide(s),et=getAlignment(s),st=getSideAxis(s)==="y",$=["left","top"].includes(b)?-1:1,it=h&&st?-1:1,g=evaluate(e,o);let{mainAxis:c,crossAxis:_,alignmentAxis:ot}=typeof g=="number"?{mainAxis:g,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...g};return et&&typeof ot=="number"&&(_=et==="end"?ot*-1:ot),st?{x:_*it,y:c*$}:{x:c*$,y:_*it}}const offset$2=function(o){return o===void 0&&(o=0),{name:"offset",options:o,async fn(e){var s,a;const{x:d,y:h,placement:b,middlewareData:et}=e,st=await convertValueToCoords(e,o);return b===((s=et.offset)==null?void 0:s.placement)&&(a=et.arrow)!=null&&a.alignmentOffset?{}:{x:d+st.x,y:h+st.y,data:{...st,placement:b}}}}},shift$2=function(o){return o===void 0&&(o={}),{name:"shift",options:o,async fn(e){const{x:s,y:a,placement:d}=e,{mainAxis:h=!0,crossAxis:b=!1,limiter:et={fn:dt=>{let{x:pt,y:ft}=dt;return{x:pt,y:ft}}},...st}=evaluate(o,e),$={x:s,y:a},it=await detectOverflow(e,st),g=getSideAxis(getSide(d)),c=getOppositeAxis(g);let _=$[c],ot=$[g];if(h){const dt=c==="y"?"top":"left",pt=c==="y"?"bottom":"right",ft=_+it[dt],ht=_-it[pt];_=clamp(ft,_,ht)}if(b){const dt=g==="y"?"top":"left",pt=g==="y"?"bottom":"right",ft=ot+it[dt],ht=ot-it[pt];ot=clamp(ft,ot,ht)}const ct=et.fn({...e,[c]:_,[g]:ot});return{...ct,data:{x:ct.x-s,y:ct.y-a}}}}},limitShift$2=function(o){return o===void 0&&(o={}),{options:o,fn(e){const{x:s,y:a,placement:d,rects:h,middlewareData:b}=e,{offset:et=0,mainAxis:st=!0,crossAxis:$=!0}=evaluate(o,e),it={x:s,y:a},g=getSideAxis(d),c=getOppositeAxis(g);let _=it[c],ot=it[g];const ct=evaluate(et,e),dt=typeof ct=="number"?{mainAxis:ct,crossAxis:0}:{mainAxis:0,crossAxis:0,...ct};if(st){const ht=c==="y"?"height":"width",bt=h.reference[c]-h.floating[ht]+dt.mainAxis,mt=h.reference[c]+h.reference[ht]-dt.mainAxis;_<bt?_=bt:_>mt&&(_=mt)}if($){var pt,ft;const ht=c==="y"?"width":"height",bt=["top","left"].includes(getSide(d)),mt=h.reference[g]-h.floating[ht]+(bt&&((pt=b.offset)==null?void 0:pt[g])||0)+(bt?0:dt.crossAxis),$t=h.reference[g]+h.reference[ht]+(bt?0:((ft=b.offset)==null?void 0:ft[g])||0)-(bt?dt.crossAxis:0);ot<mt?ot=mt:ot>$t&&(ot=$t)}return{[c]:_,[g]:ot}}}},size$2=function(o){return o===void 0&&(o={}),{name:"size",options:o,async fn(e){const{placement:s,rects:a,platform:d,elements:h}=e,{apply:b=()=>{},...et}=evaluate(o,e),st=await detectOverflow(e,et),$=getSide(s),it=getAlignment(s),g=getSideAxis(s)==="y",{width:c,height:_}=a.floating;let ot,ct;$==="top"||$==="bottom"?(ot=$,ct=it===(await(d.isRTL==null?void 0:d.isRTL(h.floating))?"start":"end")?"left":"right"):(ct=$,ot=it==="end"?"top":"bottom");const dt=_-st.top-st.bottom,pt=c-st.left-st.right,ft=min(_-st[ot],dt),ht=min(c-st[ct],pt),bt=!e.middlewareData.shift;let mt=ft,$t=ht;if(g?$t=it||bt?min(ht,pt):pt:mt=it||bt?min(ft,dt):dt,bt&&!it){const Nt=max(st.left,0),Ct=max(st.right,0),Ft=max(st.top,0),ln=max(st.bottom,0);g?$t=c-2*(Nt!==0||Ct!==0?Nt+Ct:max(st.left,st.right)):mt=_-2*(Ft!==0||ln!==0?Ft+ln:max(st.top,st.bottom))}await b({...e,availableWidth:$t,availableHeight:mt});const Tt=await d.getDimensions(h.floating);return c!==Tt.width||_!==Tt.height?{reset:{rects:!0}}:{}}}};function getNodeName(o){return isNode(o)?(o.nodeName||"").toLowerCase():"#document"}function getWindow(o){var e;return(o==null||(e=o.ownerDocument)==null?void 0:e.defaultView)||window}function getDocumentElement(o){var e;return(e=(isNode(o)?o.ownerDocument:o.document)||window.document)==null?void 0:e.documentElement}function isNode(o){return o instanceof Node||o instanceof getWindow(o).Node}function isElement(o){return o instanceof Element||o instanceof getWindow(o).Element}function isHTMLElement(o){return o instanceof HTMLElement||o instanceof getWindow(o).HTMLElement}function isShadowRoot(o){return typeof ShadowRoot>"u"?!1:o instanceof ShadowRoot||o instanceof getWindow(o).ShadowRoot}function isOverflowElement(o){const{overflow:e,overflowX:s,overflowY:a,display:d}=getComputedStyle$1(o);return/auto|scroll|overlay|hidden|clip/.test(e+a+s)&&!["inline","contents"].includes(d)}function isTableElement(o){return["table","td","th"].includes(getNodeName(o))}function isTopLayer(o){return[":popover-open",":modal"].some(e=>{try{return o.matches(e)}catch{return!1}})}function isContainingBlock(o){const e=isWebKit(),s=isElement(o)?getComputedStyle$1(o):o;return s.transform!=="none"||s.perspective!=="none"||(s.containerType?s.containerType!=="normal":!1)||!e&&(s.backdropFilter?s.backdropFilter!=="none":!1)||!e&&(s.filter?s.filter!=="none":!1)||["transform","perspective","filter"].some(a=>(s.willChange||"").includes(a))||["paint","layout","strict","content"].some(a=>(s.contain||"").includes(a))}function getContainingBlock(o){let e=getParentNode(o);for(;isHTMLElement(e)&&!isLastTraversableNode(e);){if(isContainingBlock(e))return e;if(isTopLayer(e))return null;e=getParentNode(e)}return null}function isWebKit(){return typeof CSS>"u"||!CSS.supports?!1:CSS.supports("-webkit-backdrop-filter","none")}function isLastTraversableNode(o){return["html","body","#document"].includes(getNodeName(o))}function getComputedStyle$1(o){return getWindow(o).getComputedStyle(o)}function getNodeScroll(o){return isElement(o)?{scrollLeft:o.scrollLeft,scrollTop:o.scrollTop}:{scrollLeft:o.scrollX,scrollTop:o.scrollY}}function getParentNode(o){if(getNodeName(o)==="html")return o;const e=o.assignedSlot||o.parentNode||isShadowRoot(o)&&o.host||getDocumentElement(o);return isShadowRoot(e)?e.host:e}function getNearestOverflowAncestor(o){const e=getParentNode(o);return isLastTraversableNode(e)?o.ownerDocument?o.ownerDocument.body:o.body:isHTMLElement(e)&&isOverflowElement(e)?e:getNearestOverflowAncestor(e)}function getOverflowAncestors(o,e,s){var a;e===void 0&&(e=[]),s===void 0&&(s=!0);const d=getNearestOverflowAncestor(o),h=d===((a=o.ownerDocument)==null?void 0:a.body),b=getWindow(d);if(h){const et=getFrameElement(b);return e.concat(b,b.visualViewport||[],isOverflowElement(d)?d:[],et&&s?getOverflowAncestors(et):[])}return e.concat(d,getOverflowAncestors(d,[],s))}function getFrameElement(o){return o.parent&&Object.getPrototypeOf(o.parent)?o.frameElement:null}function getCssDimensions(o){const e=getComputedStyle$1(o);let s=parseFloat(e.width)||0,a=parseFloat(e.height)||0;const d=isHTMLElement(o),h=d?o.offsetWidth:s,b=d?o.offsetHeight:a,et=round(s)!==h||round(a)!==b;return et&&(s=h,a=b),{width:s,height:a,$:et}}function unwrapElement(o){return isElement(o)?o:o.contextElement}function getScale(o){const e=unwrapElement(o);if(!isHTMLElement(e))return createCoords(1);const s=e.getBoundingClientRect(),{width:a,height:d,$:h}=getCssDimensions(e);let b=(h?round(s.width):s.width)/a,et=(h?round(s.height):s.height)/d;return(!b||!Number.isFinite(b))&&(b=1),(!et||!Number.isFinite(et))&&(et=1),{x:b,y:et}}const noOffsets=createCoords(0);function getVisualOffsets(o){const e=getWindow(o);return!isWebKit()||!e.visualViewport?noOffsets:{x:e.visualViewport.offsetLeft,y:e.visualViewport.offsetTop}}function shouldAddVisualOffsets(o,e,s){return e===void 0&&(e=!1),!s||e&&s!==getWindow(o)?!1:e}function getBoundingClientRect(o,e,s,a){e===void 0&&(e=!1),s===void 0&&(s=!1);const d=o.getBoundingClientRect(),h=unwrapElement(o);let b=createCoords(1);e&&(a?isElement(a)&&(b=getScale(a)):b=getScale(o));const et=shouldAddVisualOffsets(h,s,a)?getVisualOffsets(h):createCoords(0);let st=(d.left+et.x)/b.x,$=(d.top+et.y)/b.y,it=d.width/b.x,g=d.height/b.y;if(h){const c=getWindow(h),_=a&&isElement(a)?getWindow(a):a;let ot=c,ct=getFrameElement(ot);for(;ct&&a&&_!==ot;){const dt=getScale(ct),pt=ct.getBoundingClientRect(),ft=getComputedStyle$1(ct),ht=pt.left+(ct.clientLeft+parseFloat(ft.paddingLeft))*dt.x,bt=pt.top+(ct.clientTop+parseFloat(ft.paddingTop))*dt.y;st*=dt.x,$*=dt.y,it*=dt.x,g*=dt.y,st+=ht,$+=bt,ot=getWindow(ct),ct=getFrameElement(ot)}}return rectToClientRect({width:it,height:g,x:st,y:$})}function convertOffsetParentRelativeRectToViewportRelativeRect(o){let{elements:e,rect:s,offsetParent:a,strategy:d}=o;const h=d==="fixed",b=getDocumentElement(a),et=e?isTopLayer(e.floating):!1;if(a===b||et&&h)return s;let st={scrollLeft:0,scrollTop:0},$=createCoords(1);const it=createCoords(0),g=isHTMLElement(a);if((g||!g&&!h)&&((getNodeName(a)!=="body"||isOverflowElement(b))&&(st=getNodeScroll(a)),isHTMLElement(a))){const c=getBoundingClientRect(a);$=getScale(a),it.x=c.x+a.clientLeft,it.y=c.y+a.clientTop}return{width:s.width*$.x,height:s.height*$.y,x:s.x*$.x-st.scrollLeft*$.x+it.x,y:s.y*$.y-st.scrollTop*$.y+it.y}}function getClientRects(o){return Array.from(o.getClientRects())}function getWindowScrollBarX(o){return getBoundingClientRect(getDocumentElement(o)).left+getNodeScroll(o).scrollLeft}function getDocumentRect(o){const e=getDocumentElement(o),s=getNodeScroll(o),a=o.ownerDocument.body,d=max(e.scrollWidth,e.clientWidth,a.scrollWidth,a.clientWidth),h=max(e.scrollHeight,e.clientHeight,a.scrollHeight,a.clientHeight);let b=-s.scrollLeft+getWindowScrollBarX(o);const et=-s.scrollTop;return getComputedStyle$1(a).direction==="rtl"&&(b+=max(e.clientWidth,a.clientWidth)-d),{width:d,height:h,x:b,y:et}}function getViewportRect(o,e){const s=getWindow(o),a=getDocumentElement(o),d=s.visualViewport;let h=a.clientWidth,b=a.clientHeight,et=0,st=0;if(d){h=d.width,b=d.height;const $=isWebKit();(!$||$&&e==="fixed")&&(et=d.offsetLeft,st=d.offsetTop)}return{width:h,height:b,x:et,y:st}}function getInnerBoundingClientRect(o,e){const s=getBoundingClientRect(o,!0,e==="fixed"),a=s.top+o.clientTop,d=s.left+o.clientLeft,h=isHTMLElement(o)?getScale(o):createCoords(1),b=o.clientWidth*h.x,et=o.clientHeight*h.y,st=d*h.x,$=a*h.y;return{width:b,height:et,x:st,y:$}}function getClientRectFromClippingAncestor(o,e,s){let a;if(e==="viewport")a=getViewportRect(o,s);else if(e==="document")a=getDocumentRect(getDocumentElement(o));else if(isElement(e))a=getInnerBoundingClientRect(e,s);else{const d=getVisualOffsets(o);a={...e,x:e.x-d.x,y:e.y-d.y}}return rectToClientRect(a)}function hasFixedPositionAncestor(o,e){const s=getParentNode(o);return s===e||!isElement(s)||isLastTraversableNode(s)?!1:getComputedStyle$1(s).position==="fixed"||hasFixedPositionAncestor(s,e)}function getClippingElementAncestors(o,e){const s=e.get(o);if(s)return s;let a=getOverflowAncestors(o,[],!1).filter(et=>isElement(et)&&getNodeName(et)!=="body"),d=null;const h=getComputedStyle$1(o).position==="fixed";let b=h?getParentNode(o):o;for(;isElement(b)&&!isLastTraversableNode(b);){const et=getComputedStyle$1(b),st=isContainingBlock(b);!st&&et.position==="fixed"&&(d=null),(h?!st&&!d:!st&&et.position==="static"&&!!d&&["absolute","fixed"].includes(d.position)||isOverflowElement(b)&&!st&&hasFixedPositionAncestor(o,b))?a=a.filter(it=>it!==b):d=et,b=getParentNode(b)}return e.set(o,a),a}function getClippingRect(o){let{element:e,boundary:s,rootBoundary:a,strategy:d}=o;const b=[...s==="clippingAncestors"?isTopLayer(e)?[]:getClippingElementAncestors(e,this._c):[].concat(s),a],et=b[0],st=b.reduce(($,it)=>{const g=getClientRectFromClippingAncestor(e,it,d);return $.top=max(g.top,$.top),$.right=min(g.right,$.right),$.bottom=min(g.bottom,$.bottom),$.left=max(g.left,$.left),$},getClientRectFromClippingAncestor(e,et,d));return{width:st.right-st.left,height:st.bottom-st.top,x:st.left,y:st.top}}function getDimensions(o){const{width:e,height:s}=getCssDimensions(o);return{width:e,height:s}}function getRectRelativeToOffsetParent(o,e,s){const a=isHTMLElement(e),d=getDocumentElement(e),h=s==="fixed",b=getBoundingClientRect(o,!0,h,e);let et={scrollLeft:0,scrollTop:0};const st=createCoords(0);if(a||!a&&!h)if((getNodeName(e)!=="body"||isOverflowElement(d))&&(et=getNodeScroll(e)),a){const g=getBoundingClientRect(e,!0,h,e);st.x=g.x+e.clientLeft,st.y=g.y+e.clientTop}else d&&(st.x=getWindowScrollBarX(d));const $=b.left+et.scrollLeft-st.x,it=b.top+et.scrollTop-st.y;return{x:$,y:it,width:b.width,height:b.height}}function isStaticPositioned(o){return getComputedStyle$1(o).position==="static"}function getTrueOffsetParent(o,e){return!isHTMLElement(o)||getComputedStyle$1(o).position==="fixed"?null:e?e(o):o.offsetParent}function getOffsetParent(o,e){const s=getWindow(o);if(isTopLayer(o))return s;if(!isHTMLElement(o)){let d=getParentNode(o);for(;d&&!isLastTraversableNode(d);){if(isElement(d)&&!isStaticPositioned(d))return d;d=getParentNode(d)}return s}let a=getTrueOffsetParent(o,e);for(;a&&isTableElement(a)&&isStaticPositioned(a);)a=getTrueOffsetParent(a,e);return a&&isLastTraversableNode(a)&&isStaticPositioned(a)&&!isContainingBlock(a)?s:a||getContainingBlock(o)||s}const getElementRects=async function(o){const e=this.getOffsetParent||getOffsetParent,s=this.getDimensions,a=await s(o.floating);return{reference:getRectRelativeToOffsetParent(o.reference,await e(o.floating),o.strategy),floating:{x:0,y:0,width:a.width,height:a.height}}};function isRTL(o){return getComputedStyle$1(o).direction==="rtl"}const platform={convertOffsetParentRelativeRectToViewportRelativeRect,getDocumentElement,getClippingRect,getOffsetParent,getElementRects,getClientRects,getDimensions,getScale,isElement,isRTL};function observeMove(o,e){let s=null,a;const d=getDocumentElement(o);function h(){var et;clearTimeout(a),(et=s)==null||et.disconnect(),s=null}function b(et,st){et===void 0&&(et=!1),st===void 0&&(st=1),h();const{left:$,top:it,width:g,height:c}=o.getBoundingClientRect();if(et||e(),!g||!c)return;const _=floor(it),ot=floor(d.clientWidth-($+g)),ct=floor(d.clientHeight-(it+c)),dt=floor($),ft={rootMargin:-_+"px "+-ot+"px "+-ct+"px "+-dt+"px",threshold:max(0,min(1,st))||1};let ht=!0;function bt(mt){const $t=mt[0].intersectionRatio;if($t!==st){if(!ht)return b();$t?b(!1,$t):a=setTimeout(()=>{b(!1,1e-7)},1e3)}ht=!1}try{s=new IntersectionObserver(bt,{...ft,root:d.ownerDocument})}catch{s=new IntersectionObserver(bt,ft)}s.observe(o)}return b(!0),h}function autoUpdate(o,e,s,a){a===void 0&&(a={});const{ancestorScroll:d=!0,ancestorResize:h=!0,elementResize:b=typeof ResizeObserver=="function",layoutShift:et=typeof IntersectionObserver=="function",animationFrame:st=!1}=a,$=unwrapElement(o),it=d||h?[...$?getOverflowAncestors($):[],...getOverflowAncestors(e)]:[];it.forEach(pt=>{d&&pt.addEventListener("scroll",s,{passive:!0}),h&&pt.addEventListener("resize",s)});const g=$&&et?observeMove($,s):null;let c=-1,_=null;b&&(_=new ResizeObserver(pt=>{let[ft]=pt;ft&&ft.target===$&&_&&(_.unobserve(e),cancelAnimationFrame(c),c=requestAnimationFrame(()=>{var ht;(ht=_)==null||ht.observe(e)})),s()}),$&&!st&&_.observe($),_.observe(e));let ot,ct=st?getBoundingClientRect(o):null;st&&dt();function dt(){const pt=getBoundingClientRect(o);ct&&(pt.x!==ct.x||pt.y!==ct.y||pt.width!==ct.width||pt.height!==ct.height)&&s(),ct=pt,ot=requestAnimationFrame(dt)}return s(),()=>{var pt;it.forEach(ft=>{d&&ft.removeEventListener("scroll",s),h&&ft.removeEventListener("resize",s)}),g?.(),(pt=_)==null||pt.disconnect(),_=null,st&&cancelAnimationFrame(ot)}}const offset$1=offset$2,shift$1=shift$2,flip$1=flip$2,size$1=size$2,hide$1=hide$2,arrow$2=arrow$3,limitShift$1=limitShift$2,computePosition=(o,e,s)=>{const a=new Map,d={platform,...s},h={...d.platform,_c:a};return computePosition$1(o,e,{...d,platform:h})};var index=typeof document<"u"?reactExports.useLayoutEffect:reactExports.useEffect;function deepEqual(o,e){if(o===e)return!0;if(typeof o!=typeof e)return!1;if(typeof o=="function"&&o.toString()===e.toString())return!0;let s,a,d;if(o&&e&&typeof o=="object"){if(Array.isArray(o)){if(s=o.length,s!==e.length)return!1;for(a=s;a--!==0;)if(!deepEqual(o[a],e[a]))return!1;return!0}if(d=Object.keys(o),s=d.length,s!==Object.keys(e).length)return!1;for(a=s;a--!==0;)if(!{}.hasOwnProperty.call(e,d[a]))return!1;for(a=s;a--!==0;){const h=d[a];if(!(h==="_owner"&&o.$$typeof)&&!deepEqual(o[h],e[h]))return!1}return!0}return o!==o&&e!==e}function getDPR(o){return typeof window>"u"?1:(o.ownerDocument.defaultView||window).devicePixelRatio||1}function roundByDPR(o,e){const s=getDPR(o);return Math.round(e*s)/s}function useLatestRef(o){const e=reactExports.useRef(o);return index(()=>{e.current=o}),e}function useFloating(o){o===void 0&&(o={});const{placement:e="bottom",strategy:s="absolute",middleware:a=[],platform:d,elements:{reference:h,floating:b}={},transform:et=!0,whileElementsMounted:st,open:$}=o,[it,g]=reactExports.useState({x:0,y:0,strategy:s,placement:e,middlewareData:{},isPositioned:!1}),[c,_]=reactExports.useState(a);deepEqual(c,a)||_(a);const[ot,ct]=reactExports.useState(null),[dt,pt]=reactExports.useState(null),ft=reactExports.useCallback(cn=>{cn!==$t.current&&($t.current=cn,ct(cn))},[]),ht=reactExports.useCallback(cn=>{cn!==Tt.current&&(Tt.current=cn,pt(cn))},[]),bt=h||ot,mt=b||dt,$t=reactExports.useRef(null),Tt=reactExports.useRef(null),Nt=reactExports.useRef(it),Ct=st!=null,Ft=useLatestRef(st),ln=useLatestRef(d),mn=reactExports.useCallback(()=>{if(!$t.current||!Tt.current)return;const cn={placement:e,strategy:s,middleware:c};ln.current&&(cn.platform=ln.current),computePosition($t.current,Tt.current,cn).then(xn=>{const dn={...xn,isPositioned:!0};yn.current&&!deepEqual(Nt.current,dn)&&(Nt.current=dn,reactDomExports.flushSync(()=>{g(dn)}))})},[c,e,s,ln]);index(()=>{$===!1&&Nt.current.isPositioned&&(Nt.current.isPositioned=!1,g(cn=>({...cn,isPositioned:!1})))},[$]);const yn=reactExports.useRef(!1);index(()=>(yn.current=!0,()=>{yn.current=!1}),[]),index(()=>{if(bt&&($t.current=bt),mt&&(Tt.current=mt),bt&&mt){if(Ft.current)return Ft.current(bt,mt,mn);mn()}},[bt,mt,mn,Ft,Ct]);const pn=reactExports.useMemo(()=>({reference:$t,floating:Tt,setReference:ft,setFloating:ht}),[ft,ht]),Ht=reactExports.useMemo(()=>({reference:bt,floating:mt}),[bt,mt]),Gt=reactExports.useMemo(()=>{const cn={position:s,left:0,top:0};if(!Ht.floating)return cn;const xn=roundByDPR(Ht.floating,it.x),dn=roundByDPR(Ht.floating,it.y);return et?{...cn,transform:"translate("+xn+"px, "+dn+"px)",...getDPR(Ht.floating)>=1.5&&{willChange:"transform"}}:{position:s,left:xn,top:dn}},[s,et,Ht.floating,it.x,it.y]);return reactExports.useMemo(()=>({...it,update:mn,refs:pn,elements:Ht,floatingStyles:Gt}),[it,mn,pn,Ht,Gt])}const arrow$1=o=>{function e(s){return{}.hasOwnProperty.call(s,"current")}return{name:"arrow",options:o,fn(s){const{element:a,padding:d}=typeof o=="function"?o(s):o;return a&&e(a)?a.current!=null?arrow$2({element:a.current,padding:d}).fn(s):{}:a?arrow$2({element:a,padding:d}).fn(s):{}}}},offset=(o,e)=>({...offset$1(o),options:[o,e]}),shift=(o,e)=>({...shift$1(o),options:[o,e]}),limitShift=(o,e)=>({...limitShift$1(o),options:[o,e]}),flip=(o,e)=>({...flip$1(o),options:[o,e]}),size=(o,e)=>({...size$1(o),options:[o,e]}),hide=(o,e)=>({...hide$1(o),options:[o,e]}),arrow=(o,e)=>({...arrow$1(o),options:[o,e]});var NAME$1="Arrow",Arrow$1=reactExports.forwardRef((o,e)=>{const{children:s,width:a=10,height:d=5,...h}=o;return jsxRuntimeExports.jsx(Primitive.svg,{...h,ref:e,width:a,height:d,viewBox:"0 0 30 10",preserveAspectRatio:"none",children:o.asChild?s:jsxRuntimeExports.jsx("polygon",{points:"0,0 30,0 15,10"})})});Arrow$1.displayName=NAME$1;var Root$1=Arrow$1;function useSize(o){const[e,s]=reactExports.useState(void 0);return useLayoutEffect2(()=>{if(o){s({width:o.offsetWidth,height:o.offsetHeight});const a=new ResizeObserver(d=>{if(!Array.isArray(d)||!d.length)return;const h=d[0];let b,et;if("borderBoxSize"in h){const st=h.borderBoxSize,$=Array.isArray(st)?st[0]:st;b=$.inlineSize,et=$.blockSize}else b=o.offsetWidth,et=o.offsetHeight;s({width:b,height:et})});return a.observe(o,{box:"border-box"}),()=>a.unobserve(o)}else s(void 0)},[o]),e}var POPPER_NAME="Popper",[createPopperContext,createPopperScope]=createContextScope(POPPER_NAME),[PopperProvider,usePopperContext]=createPopperContext(POPPER_NAME),Popper=o=>{const{__scopePopper:e,children:s}=o,[a,d]=reactExports.useState(null);return jsxRuntimeExports.jsx(PopperProvider,{scope:e,anchor:a,onAnchorChange:d,children:s})};Popper.displayName=POPPER_NAME;var ANCHOR_NAME="PopperAnchor",PopperAnchor=reactExports.forwardRef((o,e)=>{const{__scopePopper:s,virtualRef:a,...d}=o,h=usePopperContext(ANCHOR_NAME,s),b=reactExports.useRef(null),et=useComposedRefs(e,b);return reactExports.useEffect(()=>{h.onAnchorChange(a?.current||b.current)}),a?null:jsxRuntimeExports.jsx(Primitive.div,{...d,ref:et})});PopperAnchor.displayName=ANCHOR_NAME;var CONTENT_NAME$1="PopperContent",[PopperContentProvider,useContentContext]=createPopperContext(CONTENT_NAME$1),PopperContent=reactExports.forwardRef((o,e)=>{const{__scopePopper:s,side:a="bottom",sideOffset:d=0,align:h="center",alignOffset:b=0,arrowPadding:et=0,avoidCollisions:st=!0,collisionBoundary:$=[],collisionPadding:it=0,sticky:g="partial",hideWhenDetached:c=!1,updatePositionStrategy:_="optimized",onPlaced:ot,...ct}=o,dt=usePopperContext(CONTENT_NAME$1,s),[pt,ft]=reactExports.useState(null),ht=useComposedRefs(e,Fr=>ft(Fr)),[bt,mt]=reactExports.useState(null),$t=useSize(bt),Tt=$t?.width??0,Nt=$t?.height??0,Ct=a+(h!=="center"?"-"+h:""),Ft=typeof it=="number"?it:{top:0,right:0,bottom:0,left:0,...it},ln=Array.isArray($)?$:[$],mn=ln.length>0,yn={padding:Ft,boundary:ln.filter(isNotNull),altBoundary:mn},{refs:pn,floatingStyles:Ht,placement:Gt,isPositioned:cn,middlewareData:xn}=useFloating({strategy:"fixed",placement:Ct,whileElementsMounted:(...Fr)=>autoUpdate(...Fr,{animationFrame:_==="always"}),elements:{reference:dt.anchor},middleware:[offset({mainAxis:d+Nt,alignmentAxis:b}),st&&shift({mainAxis:!0,crossAxis:!1,limiter:g==="partial"?limitShift():void 0,...yn}),st&&flip({...yn}),size({...yn,apply:({elements:Fr,rects:_f,availableWidth:h0,availableHeight:Po})=>{const{width:No,height:o0}=_f.reference,t0=Fr.floating.style;t0.setProperty("--radix-popper-available-width",`${h0}px`),t0.setProperty("--radix-popper-available-height",`${Po}px`),t0.setProperty("--radix-popper-anchor-width",`${No}px`),t0.setProperty("--radix-popper-anchor-height",`${o0}px`)}}),bt&&arrow({element:bt,padding:et}),transformOrigin({arrowWidth:Tt,arrowHeight:Nt}),c&&hide({strategy:"referenceHidden",...yn})]}),[dn,wn]=getSideAndAlignFromPlacement(Gt),gn=useCallbackRef(ot);useLayoutEffect2(()=>{cn&&gn?.()},[cn,gn]);const En=xn.arrow?.x,_r=xn.arrow?.y,Sr=xn.arrow?.centerOffset!==0,[xr,Vr]=reactExports.useState();return useLayoutEffect2(()=>{pt&&Vr(window.getComputedStyle(pt).zIndex)},[pt]),jsxRuntimeExports.jsx("div",{ref:pn.setFloating,"data-radix-popper-content-wrapper":"",style:{...Ht,transform:cn?Ht.transform:"translate(0, -200%)",minWidth:"max-content",zIndex:xr,"--radix-popper-transform-origin":[xn.transformOrigin?.x,xn.transformOrigin?.y].join(" "),...xn.hide?.referenceHidden&&{visibility:"hidden",pointerEvents:"none"}},dir:o.dir,children:jsxRuntimeExports.jsx(PopperContentProvider,{scope:s,placedSide:dn,onArrowChange:mt,arrowX:En,arrowY:_r,shouldHideArrow:Sr,children:jsxRuntimeExports.jsx(Primitive.div,{"data-side":dn,"data-align":wn,...ct,ref:ht,style:{...ct.style,animation:cn?void 0:"none"}})})})});PopperContent.displayName=CONTENT_NAME$1;var ARROW_NAME$1="PopperArrow",OPPOSITE_SIDE={top:"bottom",right:"left",bottom:"top",left:"right"},PopperArrow=reactExports.forwardRef(function o(e,s){const{__scopePopper:a,...d}=e,h=useContentContext(ARROW_NAME$1,a),b=OPPOSITE_SIDE[h.placedSide];return jsxRuntimeExports.jsx("span",{ref:h.onArrowChange,style:{position:"absolute",left:h.arrowX,top:h.arrowY,[b]:0,transformOrigin:{top:"",right:"0 0",bottom:"center 0",left:"100% 0"}[h.placedSide],transform:{top:"translateY(100%)",right:"translateY(50%) rotate(90deg) translateX(-50%)",bottom:"rotate(180deg)",left:"translateY(50%) rotate(-90deg) translateX(50%)"}[h.placedSide],visibility:h.shouldHideArrow?"hidden":void 0},children:jsxRuntimeExports.jsx(Root$1,{...d,ref:s,style:{...d.style,display:"block"}})})});PopperArrow.displayName=ARROW_NAME$1;function isNotNull(o){return o!==null}var transformOrigin=o=>({name:"transformOrigin",options:o,fn(e){const{placement:s,rects:a,middlewareData:d}=e,b=d.arrow?.centerOffset!==0,et=b?0:o.arrowWidth,st=b?0:o.arrowHeight,[$,it]=getSideAndAlignFromPlacement(s),g={start:"0%",center:"50%",end:"100%"}[it],c=(d.arrow?.x??0)+et/2,_=(d.arrow?.y??0)+st/2;let ot="",ct="";return $==="bottom"?(ot=b?g:`${c}px`,ct=`${-st}px`):$==="top"?(ot=b?g:`${c}px`,ct=`${a.floating.height+st}px`):$==="right"?(ot=`${-st}px`,ct=b?g:`${_}px`):$==="left"&&(ot=`${a.floating.width+st}px`,ct=b?g:`${_}px`),{data:{x:ot,y:ct}}}});function getSideAndAlignFromPlacement(o){const[e,s="center"]=o.split("-");return[e,s]}var Root2=Popper,Anchor=PopperAnchor,Content=PopperContent,Arrow=PopperArrow,PORTAL_NAME$1="Portal",Portal$1=reactExports.forwardRef((o,e)=>{const{container:s,...a}=o,[d,h]=reactExports.useState(!1);useLayoutEffect2(()=>h(!0),[]);const b=s||d&&globalThis?.document?.body;return b?ReactDOM.createPortal(jsxRuntimeExports.jsx(Primitive.div,{...a,ref:e}),b):null});Portal$1.displayName=PORTAL_NAME$1;function useStateMachine(o,e){return reactExports.useReducer((s,a)=>e[s][a]??s,o)}var Presence=o=>{const{present:e,children:s}=o,a=usePresence(e),d=typeof s=="function"?s({present:a.isPresent}):reactExports.Children.only(s),h=useComposedRefs(a.ref,getElementRef(d));return typeof s=="function"||a.isPresent?reactExports.cloneElement(d,{ref:h}):null};Presence.displayName="Presence";function usePresence(o){const[e,s]=reactExports.useState(),a=reactExports.useRef({}),d=reactExports.useRef(o),h=reactExports.useRef("none"),b=o?"mounted":"unmounted",[et,st]=useStateMachine(b,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return reactExports.useEffect(()=>{const $=getAnimationName(a.current);h.current=et==="mounted"?$:"none"},[et]),useLayoutEffect2(()=>{const $=a.current,it=d.current;if(it!==o){const c=h.current,_=getAnimationName($);o?st("MOUNT"):_==="none"||$?.display==="none"?st("UNMOUNT"):st(it&&c!==_?"ANIMATION_OUT":"UNMOUNT"),d.current=o}},[o,st]),useLayoutEffect2(()=>{if(e){const $=g=>{const _=getAnimationName(a.current).includes(g.animationName);g.target===e&&_&&reactDomExports.flushSync(()=>st("ANIMATION_END"))},it=g=>{g.target===e&&(h.current=getAnimationName(a.current))};return e.addEventListener("animationstart",it),e.addEventListener("animationcancel",$),e.addEventListener("animationend",$),()=>{e.removeEventListener("animationstart",it),e.removeEventListener("animationcancel",$),e.removeEventListener("animationend",$)}}else st("ANIMATION_END")},[e,st]),{isPresent:["mounted","unmountSuspended"].includes(et),ref:reactExports.useCallback($=>{$&&(a.current=getComputedStyle($)),s($)},[])}}function getAnimationName(o){return o?.animationName||"none"}function getElementRef(o){let e=Object.getOwnPropertyDescriptor(o.props,"ref")?.get,s=e&&"isReactWarning"in e&&e.isReactWarning;return s?o.ref:(e=Object.getOwnPropertyDescriptor(o,"ref")?.get,s=e&&"isReactWarning"in e&&e.isReactWarning,s?o.props.ref:o.props.ref||o.ref)}function useControllableState({prop:o,defaultProp:e,onChange:s=()=>{}}){const[a,d]=useUncontrolledState({defaultProp:e,onChange:s}),h=o!==void 0,b=h?o:a,et=useCallbackRef(s),st=reactExports.useCallback($=>{if(h){const g=typeof $=="function"?$(o):$;g!==o&&et(g)}else d($)},[h,o,d,et]);return[b,st]}function useUncontrolledState({defaultProp:o,onChange:e}){const s=reactExports.useState(o),[a]=s,d=reactExports.useRef(a),h=useCallbackRef(e);return reactExports.useEffect(()=>{d.current!==a&&(h(a),d.current=a)},[a,d,h]),s}var NAME="VisuallyHidden",VisuallyHidden=reactExports.forwardRef((o,e)=>jsxRuntimeExports.jsx(Primitive.span,{...o,ref:e,style:{position:"absolute",border:0,width:1,height:1,padding:0,margin:-1,overflow:"hidden",clip:"rect(0, 0, 0, 0)",whiteSpace:"nowrap",wordWrap:"normal",...o.style}}));VisuallyHidden.displayName=NAME;var Root=VisuallyHidden,[createTooltipContext,createTooltipScope]=createContextScope("Tooltip",[createPopperScope]),usePopperScope=createPopperScope(),PROVIDER_NAME="TooltipProvider",DEFAULT_DELAY_DURATION=700,TOOLTIP_OPEN="tooltip.open",[TooltipProviderContextProvider,useTooltipProviderContext]=createTooltipContext(PROVIDER_NAME),TooltipProvider=o=>{const{__scopeTooltip:e,delayDuration:s=DEFAULT_DELAY_DURATION,skipDelayDuration:a=300,disableHoverableContent:d=!1,children:h}=o,[b,et]=reactExports.useState(!0),st=reactExports.useRef(!1),$=reactExports.useRef(0);return reactExports.useEffect(()=>{const it=$.current;return()=>window.clearTimeout(it)},[]),jsxRuntimeExports.jsx(TooltipProviderContextProvider,{scope:e,isOpenDelayed:b,delayDuration:s,onOpen:reactExports.useCallback(()=>{window.clearTimeout($.current),et(!1)},[]),onClose:reactExports.useCallback(()=>{window.clearTimeout($.current),$.current=window.setTimeout(()=>et(!0),a)},[a]),isPointerInTransitRef:st,onPointerInTransitChange:reactExports.useCallback(it=>{st.current=it},[]),disableHoverableContent:d,children:h})};TooltipProvider.displayName=PROVIDER_NAME;var TOOLTIP_NAME="Tooltip",[TooltipContextProvider,useTooltipContext]=createTooltipContext(TOOLTIP_NAME),Tooltip=o=>{const{__scopeTooltip:e,children:s,open:a,defaultOpen:d=!1,onOpenChange:h,disableHoverableContent:b,delayDuration:et}=o,st=useTooltipProviderContext(TOOLTIP_NAME,o.__scopeTooltip),$=usePopperScope(e),[it,g]=reactExports.useState(null),c=useId(),_=reactExports.useRef(0),ot=b??st.disableHoverableContent,ct=et??st.delayDuration,dt=reactExports.useRef(!1),[pt=!1,ft]=useControllableState({prop:a,defaultProp:d,onChange:Tt=>{Tt?(st.onOpen(),document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN))):st.onClose(),h?.(Tt)}}),ht=reactExports.useMemo(()=>pt?dt.current?"delayed-open":"instant-open":"closed",[pt]),bt=reactExports.useCallback(()=>{window.clearTimeout(_.current),dt.current=!1,ft(!0)},[ft]),mt=reactExports.useCallback(()=>{window.clearTimeout(_.current),ft(!1)},[ft]),$t=reactExports.useCallback(()=>{window.clearTimeout(_.current),_.current=window.setTimeout(()=>{dt.current=!0,ft(!0)},ct)},[ct,ft]);return reactExports.useEffect(()=>()=>window.clearTimeout(_.current),[]),jsxRuntimeExports.jsx(Root2,{...$,children:jsxRuntimeExports.jsx(TooltipContextProvider,{scope:e,contentId:c,open:pt,stateAttribute:ht,trigger:it,onTriggerChange:g,onTriggerEnter:reactExports.useCallback(()=>{st.isOpenDelayed?$t():bt()},[st.isOpenDelayed,$t,bt]),onTriggerLeave:reactExports.useCallback(()=>{ot?mt():window.clearTimeout(_.current)},[mt,ot]),onOpen:bt,onClose:mt,disableHoverableContent:ot,children:s})})};Tooltip.displayName=TOOLTIP_NAME;var TRIGGER_NAME="TooltipTrigger",TooltipTrigger=reactExports.forwardRef((o,e)=>{const{__scopeTooltip:s,...a}=o,d=useTooltipContext(TRIGGER_NAME,s),h=useTooltipProviderContext(TRIGGER_NAME,s),b=usePopperScope(s),et=reactExports.useRef(null),st=useComposedRefs(e,et,d.onTriggerChange),$=reactExports.useRef(!1),it=reactExports.useRef(!1),g=reactExports.useCallback(()=>$.current=!1,[]);return reactExports.useEffect(()=>()=>document.removeEventListener("pointerup",g),[g]),jsxRuntimeExports.jsx(Anchor,{asChild:!0,...b,children:jsxRuntimeExports.jsx(Primitive.button,{"aria-describedby":d.open?d.contentId:void 0,"data-state":d.stateAttribute,...a,ref:st,onPointerMove:composeEventHandlers(o.onPointerMove,c=>{c.pointerType!=="touch"&&!it.current&&!h.isPointerInTransitRef.current&&(d.onTriggerEnter(),it.current=!0)}),onPointerLeave:composeEventHandlers(o.onPointerLeave,()=>{d.onTriggerLeave(),it.current=!1}),onPointerDown:composeEventHandlers(o.onPointerDown,()=>{$.current=!0,document.addEventListener("pointerup",g,{once:!0})}),onFocus:composeEventHandlers(o.onFocus,()=>{$.current||d.onOpen()}),onBlur:composeEventHandlers(o.onBlur,d.onClose),onClick:composeEventHandlers(o.onClick,d.onClose)})})});TooltipTrigger.displayName=TRIGGER_NAME;var PORTAL_NAME="TooltipPortal",[PortalProvider,usePortalContext]=createTooltipContext(PORTAL_NAME,{forceMount:void 0}),TooltipPortal=o=>{const{__scopeTooltip:e,forceMount:s,children:a,container:d}=o,h=useTooltipContext(PORTAL_NAME,e);return jsxRuntimeExports.jsx(PortalProvider,{scope:e,forceMount:s,children:jsxRuntimeExports.jsx(Presence,{present:s||h.open,children:jsxRuntimeExports.jsx(Portal$1,{asChild:!0,container:d,children:a})})})};TooltipPortal.displayName=PORTAL_NAME;var CONTENT_NAME="TooltipContent",TooltipContent=reactExports.forwardRef((o,e)=>{const s=usePortalContext(CONTENT_NAME,o.__scopeTooltip),{forceMount:a=s.forceMount,side:d="top",...h}=o,b=useTooltipContext(CONTENT_NAME,o.__scopeTooltip);return jsxRuntimeExports.jsx(Presence,{present:a||b.open,children:b.disableHoverableContent?jsxRuntimeExports.jsx(TooltipContentImpl,{side:d,...h,ref:e}):jsxRuntimeExports.jsx(TooltipContentHoverable,{side:d,...h,ref:e})})}),TooltipContentHoverable=reactExports.forwardRef((o,e)=>{const s=useTooltipContext(CONTENT_NAME,o.__scopeTooltip),a=useTooltipProviderContext(CONTENT_NAME,o.__scopeTooltip),d=reactExports.useRef(null),h=useComposedRefs(e,d),[b,et]=reactExports.useState(null),{trigger:st,onClose:$}=s,it=d.current,{onPointerInTransitChange:g}=a,c=reactExports.useCallback(()=>{et(null),g(!1)},[g]),_=reactExports.useCallback((ot,ct)=>{const dt=ot.currentTarget,pt={x:ot.clientX,y:ot.clientY},ft=getExitSideFromRect(pt,dt.getBoundingClientRect()),ht=getPaddedExitPoints(pt,ft),bt=getPointsFromRect(ct.getBoundingClientRect()),mt=getHull([...ht,...bt]);et(mt),g(!0)},[g]);return reactExports.useEffect(()=>()=>c(),[c]),reactExports.useEffect(()=>{if(st&&it){const ot=dt=>_(dt,it),ct=dt=>_(dt,st);return st.addEventListener("pointerleave",ot),it.addEventListener("pointerleave",ct),()=>{st.removeEventListener("pointerleave",ot),it.removeEventListener("pointerleave",ct)}}},[st,it,_,c]),reactExports.useEffect(()=>{if(b){const ot=ct=>{const dt=ct.target,pt={x:ct.clientX,y:ct.clientY},ft=st?.contains(dt)||it?.contains(dt),ht=!isPointInPolygon(pt,b);ft?c():ht&&(c(),$())};return document.addEventListener("pointermove",ot),()=>document.removeEventListener("pointermove",ot)}},[st,it,b,$,c]),jsxRuntimeExports.jsx(TooltipContentImpl,{...o,ref:h})}),[VisuallyHiddenContentContextProvider,useVisuallyHiddenContentContext]=createTooltipContext(TOOLTIP_NAME,{isInside:!1}),TooltipContentImpl=reactExports.forwardRef((o,e)=>{const{__scopeTooltip:s,children:a,"aria-label":d,onEscapeKeyDown:h,onPointerDownOutside:b,...et}=o,st=useTooltipContext(CONTENT_NAME,s),$=usePopperScope(s),{onClose:it}=st;return reactExports.useEffect(()=>(document.addEventListener(TOOLTIP_OPEN,it),()=>document.removeEventListener(TOOLTIP_OPEN,it)),[it]),reactExports.useEffect(()=>{if(st.trigger){const g=c=>{c.target?.contains(st.trigger)&&it()};return window.addEventListener("scroll",g,{capture:!0}),()=>window.removeEventListener("scroll",g,{capture:!0})}},[st.trigger,it]),jsxRuntimeExports.jsx(DismissableLayer,{asChild:!0,disableOutsidePointerEvents:!1,onEscapeKeyDown:h,onPointerDownOutside:b,onFocusOutside:g=>g.preventDefault(),onDismiss:it,children:jsxRuntimeExports.jsxs(Content,{"data-state":st.stateAttribute,...$,...et,ref:e,style:{...et.style,"--radix-tooltip-content-transform-origin":"var(--radix-popper-transform-origin)","--radix-tooltip-content-available-width":"var(--radix-popper-available-width)","--radix-tooltip-content-available-height":"var(--radix-popper-available-height)","--radix-tooltip-trigger-width":"var(--radix-popper-anchor-width)","--radix-tooltip-trigger-height":"var(--radix-popper-anchor-height)"},children:[jsxRuntimeExports.jsx(Slottable,{children:a}),jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider,{scope:s,isInside:!0,children:jsxRuntimeExports.jsx(Root,{id:st.contentId,role:"tooltip",children:d||a})})]})})});TooltipContent.displayName=CONTENT_NAME;var ARROW_NAME="TooltipArrow",TooltipArrow=reactExports.forwardRef((o,e)=>{const{__scopeTooltip:s,...a}=o,d=usePopperScope(s);return useVisuallyHiddenContentContext(ARROW_NAME,s).isInside?null:jsxRuntimeExports.jsx(Arrow,{...d,...a,ref:e})});TooltipArrow.displayName=ARROW_NAME;function getExitSideFromRect(o,e){const s=Math.abs(e.top-o.y),a=Math.abs(e.bottom-o.y),d=Math.abs(e.right-o.x),h=Math.abs(e.left-o.x);switch(Math.min(s,a,d,h)){case h:return"left";case d:return"right";case s:return"top";case a:return"bottom";default:throw new Error("unreachable")}}function getPaddedExitPoints(o,e,s=5){const a=[];switch(e){case"top":a.push({x:o.x-s,y:o.y+s},{x:o.x+s,y:o.y+s});break;case"bottom":a.push({x:o.x-s,y:o.y-s},{x:o.x+s,y:o.y-s});break;case"left":a.push({x:o.x+s,y:o.y-s},{x:o.x+s,y:o.y+s});break;case"right":a.push({x:o.x-s,y:o.y-s},{x:o.x-s,y:o.y+s});break}return a}function getPointsFromRect(o){const{top:e,right:s,bottom:a,left:d}=o;return[{x:d,y:e},{x:s,y:e},{x:s,y:a},{x:d,y:a}]}function isPointInPolygon(o,e){const{x:s,y:a}=o;let d=!1;for(let h=0,b=e.length-1;h<e.length;b=h++){const et=e[h].x,st=e[h].y,$=e[b].x,it=e[b].y;st>a!=it>a&&s<($-et)*(a-st)/(it-st)+et&&(d=!d)}return d}function getHull(o){const e=o.slice();return e.sort((s,a)=>s.x<a.x?-1:s.x>a.x?1:s.y<a.y?-1:s.y>a.y?1:0),getHullPresorted(e)}function getHullPresorted(o){if(o.length<=1)return o.slice();const e=[];for(let a=0;a<o.length;a++){const d=o[a];for(;e.length>=2;){const h=e[e.length-1],b=e[e.length-2];if((h.x-b.x)*(d.y-b.y)>=(h.y-b.y)*(d.x-b.x))e.pop();else break}e.push(d)}e.pop();const s=[];for(let a=o.length-1;a>=0;a--){const d=o[a];for(;s.length>=2;){const h=s[s.length-1],b=s[s.length-2];if((h.x-b.x)*(d.y-b.y)>=(h.y-b.y)*(d.x-b.x))s.pop();else break}s.push(d)}return s.pop(),e.length===1&&s.length===1&&e[0].x===s[0].x&&e[0].y===s[0].y?e:e.concat(s)}var Provider=TooltipProvider,Root3=Tooltip,Trigger=TooltipTrigger,Portal=TooltipPortal,Content2=TooltipContent,Arrow2=TooltipArrow;const defaultColor="#007AFF",TaskComponent=({task:o,columnId:e,columnPrecent:s,updateTask:a,deleteTask:d,handleDragStart:h,handleDragOver:b,handleDrop:et,isDragging:st})=>{const[$,it]=reactExports.useState(!1),[g,c]=reactExports.useState(null),_=reactExports.useRef(null),ot=()=>o.color?o.color.color:defaultColor,ct=(Ct,Ft)=>{const ln=Ct.split(" ");return ln.length>Ft?ln.slice(0,Ft).join(" ")+"...":Ct},dt=Ct=>{const Ft=Ct.target.files;Ft&&Array.from(Ft).forEach(ln=>{const mn=new FileReader;mn.onload=yn=>{const pn=yn.target.result;a(e,o.id,{attachments:[...o.attachments||[],{name:ln.name,data:pn,type:ln.type}]})},mn.readAsDataURL(ln)})},pt=Ct=>{Ct.preventDefault(),Ct.stopPropagation()},ft=Ct=>{Ct.preventDefault(),Ct.stopPropagation()},ht=Ct=>{Ct.preventDefault(),Ct.stopPropagation()},bt=Ct=>{Ct.preventDefault(),Ct.stopPropagation();const Ft=Ct.dataTransfer.files;Ft&&Ft.length>0&&dt({target:{files:Ft}})},mt=Ct=>{const Ft=Ct.clipboardData.items;for(let ln=0;ln<Ft.length;ln++)if(Ft[ln].type.indexOf("image")!==-1){const mn=Ft[ln].getAsFile();dt({target:{files:[mn]}})}},$t=Ct=>{c(Ct)},Tt=()=>{c(null)},Nt=Ct=>{a(e,o.id,{attachments:o.attachments.filter((Ft,ln)=>ln!==Ct)})};return jsxRuntimeExports.jsx(Provider,{children:jsxRuntimeExports.jsxs("div",{className:`bg-white p-4 mb-3 rounded-xl shadow-sm transition-all duration-300 cursor-move
          ${st?"opacity-50":""}
          ${$?"shadow-md":""}
          ${e==="blocked"?"border-l-4 border-red-500":""}
        `,style:{backdropFilter:"blur(10px)",backgroundColor:"rgba(255, 255, 255, 0.8)",border:"1px solid #E5E5EA",width:"300px"},draggable:!0,onDragStart:Ct=>h(o,Ct),onDragOver:b,onDrop:et,onMouseEnter:()=>it(!0),onMouseLeave:()=>it(!1),onPaste:mt,children:[jsxRuntimeExports.jsxs("div",{className:"flex justify-between items-center mb-3",children:[jsxRuntimeExports.jsxs(Root3,{children:[jsxRuntimeExports.jsx(Trigger,{asChild:!0,children:jsxRuntimeExports.jsx("input",{value:ct(o.title,10),onChange:Ct=>a(e,o.id,{title:Ct.target.value}),style:{color:ot()},className:"font-semibold text-lg w-full mr-2 bg-transparent border-b border-transparent focus:border-blue-300 focus:outline-none transition-all duration-300"})}),jsxRuntimeExports.jsx(Portal,{children:jsxRuntimeExports.jsxs(Content2,{className:"bg-gray-800 text-white p-2 rounded text-sm",sideOffset:5,children:[o.title,jsxRuntimeExports.jsx(Arrow2,{className:"fill-gray-800"})]})})]}),jsxRuntimeExports.jsx("span",{className:"text-xs text-gray-500",children:o.estimatedTime})]}),jsxRuntimeExports.jsxs("div",{className:"text-xs text-gray-500 mb-3",children:[jsxRuntimeExports.jsx("strong",{children:"Main Task:"})," ",o.parentTitle||o.title]}),jsxRuntimeExports.jsxs("div",{className:"text-sm text-gray-700 mb-3",children:["Priority:",jsxRuntimeExports.jsxs("select",{value:o.priority,onChange:Ct=>a(e,o.id,{priority:Ct.target.value}),className:"ml-2 bg-gray-100 rounded-md border-none focus:ring-2 focus:ring-blue-300 transition-all duration-300",children:[jsxRuntimeExports.jsx("option",{children:"Low"}),jsxRuntimeExports.jsx("option",{children:"Medium"}),jsxRuntimeExports.jsx("option",{children:"High"})]})]}),jsxRuntimeExports.jsx("div",{className:"mb-3",children:jsxRuntimeExports.jsxs(Root3,{children:[jsxRuntimeExports.jsx(Trigger,{asChild:!0,children:jsxRuntimeExports.jsx("textarea",{value:ct(o.description,10),onChange:Ct=>a(e,o.id,{description:Ct.target.value}),placeholder:"Task description",className:"w-full p-2 text-sm border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-300 transition-all duration-300",rows:"3"})}),jsxRuntimeExports.jsx(Portal,{children:jsxRuntimeExports.jsxs(Content2,{className:"bg-gray-800 text-white p-2 rounded text-sm max-w-md",sideOffset:5,children:[o.description,jsxRuntimeExports.jsx(Arrow2,{className:"fill-gray-800"})]})})]})}),o.attachments&&o.attachments.length>0&&jsxRuntimeExports.jsx("div",{className:"flex flex-wrap gap-2 mb-3",children:o.attachments.map((Ct,Ft)=>jsxRuntimeExports.jsxs("div",{className:"relative group w-16 h-16 overflow-hidden rounded-lg shadow-sm",children:[Ct.type&&Ct.type.startsWith("image/")?jsxRuntimeExports.jsx("img",{src:Ct.data,alt:Ct.name,className:"w-full h-full object-cover cursor-pointer",onClick:()=>$t(Ct)}):jsxRuntimeExports.jsx("div",{className:"w-full h-full flex items-center justify-center bg-gray-100 cursor-pointer",onClick:()=>$t(Ct),children:jsxRuntimeExports.jsx("span",{className:"text-xs text-center break-words p-1",children:Ct.name})}),jsxRuntimeExports.jsx("button",{onClick:()=>Nt(Ft),className:"absolute top-1 right-1 bg-red-500 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200",children:jsxRuntimeExports.jsx(X,{size:12})})]},Ft))}),jsxRuntimeExports.jsxs("div",{onDragEnter:pt,onDragLeave:ft,onDragOver:ht,onDrop:bt,onClick:()=>_.current.click(),className:"border-2 border-dashed border-gray-200 p-4 rounded-lg mb-3 transition-all duration-300 hover:border-blue-500 hover:bg-blue-50 cursor-pointer",children:[jsxRuntimeExports.jsx("input",{type:"file",ref:_,onChange:dt,className:"hidden",multiple:!0}),jsxRuntimeExports.jsx("p",{className:"text-gray-500 text-sm",children:"Add Attachments"})]}),jsxRuntimeExports.jsxs("div",{className:"flex justify-between items-center",children:[jsxRuntimeExports.jsx("button",{onClick:()=>d(e,o.id),className:"bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded-full text-xs transition-all duration-300",children:"Delete Task"}),e==="blocked"?jsxRuntimeExports.jsx("div",{className:"bg-red-100 text-red-800 text-xs font-semibold px-3 py-1 rounded-full",children:"BLOCKED"}):jsxRuntimeExports.jsx("div",{className:"w-1/2 bg-gray-200 rounded-full h-2",children:jsxRuntimeExports.jsx("div",{className:"h-2 rounded-full",style:{backgroundColor:ot(),width:`${s*100}%`}})})]}),g&&jsxRuntimeExports.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50",children:jsxRuntimeExports.jsxs("div",{className:"relative w-full h-full flex items-center justify-center",children:[g.type&&g.type.startsWith("image/")?jsxRuntimeExports.jsx("img",{src:g.data,alt:g.name,className:"max-w-full max-h-full object-contain"}):jsxRuntimeExports.jsxs("div",{className:"bg-white p-6 rounded-2xl max-w-3xl max-h-[90vh] overflow-auto",children:[jsxRuntimeExports.jsx("h3",{className:"font-bold mb-2",children:g.name}),jsxRuntimeExports.jsx("p",{className:"text-sm text-gray-600",children:"This file cannot be previewed. You can download it to view its contents."}),jsxRuntimeExports.jsx("a",{href:g.data,download:g.name,className:"mt-3 inline-block bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-full text-sm transition-all duration-300",children:"Download"})]}),jsxRuntimeExports.jsx("button",{onClick:Tt,className:"absolute top-4 right-4 bg-white hover:bg-gray-200 text-gray-800 rounded-full p-2 transition-all duration-300",children:jsxRuntimeExports.jsx(X,{size:24})})]})})]})})},Board=({columns:o,tasks:e,setTasks:s,...a})=>{const[d,h]=reactExports.useState(o),[b,et]=reactExports.useState(null),[st,$]=reactExports.useState(null),[it,g]=reactExports.useState(null),c=reactExports.useRef(0),_=mt=>(e.find(Tt=>Tt.id===mt)?.tasks||[]).map(Tt=>({...Tt,column:mt})),ot=reactExports.useCallback((mt,$t)=>{et(mt),$t.dataTransfer.setData("text/plain",mt.id),$t.dataTransfer.effectAllowed="move";const Tt=$t.target.cloneNode(!0);Tt.style.opacity="0.5",Tt.style.position="absolute",Tt.style.top="-1000px",document.body.appendChild(Tt),$t.dataTransfer.setDragImage(Tt,0,0),setTimeout(()=>document.body.removeChild(Tt),0)},[]),ct=reactExports.useCallback((mt,$t)=>{mt.preventDefault(),c.current++,$($t)},[]),dt=reactExports.useCallback(mt=>{mt.preventDefault(),c.current--,c.current===0&&($(null),g(null))},[]),pt=reactExports.useCallback((mt,$t,Tt)=>{mt.preventDefault(),mt.dataTransfer.dropEffect="move",g(Tt)},[]),ft=reactExports.useCallback((mt,$t)=>{if(b){const Tt=e.map(Ct=>({...Ct,tasks:Ct.id===b.column?Ct.tasks.filter(Ft=>Ft.id!==b.id):Ct.tasks})),Nt=Tt.find(Ct=>Ct.id===mt);if(Nt){const Ct={...b,column:mt};Nt.tasks.splice($t,0,Ct)}s(Tt),et(null),$(null),g(null),c.current=0}},[b,e]),ht=reactExports.useCallback((mt,$t,Tt)=>{s(Nt=>Nt.map(Ct=>Ct.id===mt?{...Ct,tasks:Ct.tasks.map(Ft=>Ft.id===$t?{...Ft,...Tt}:Ft)}:Ct))},[]),bt=reactExports.useCallback((mt,$t)=>{s(Tt=>Tt.map(Nt=>Nt.id===mt?{...Nt,tasks:Nt.tasks.filter(Ct=>Ct.id!==$t)}:Nt))},[]);return jsxRuntimeExports.jsx("div",{className:"flex flex-wrap space-x-6 overflow-x-auto pb-8 lg:flex-nowrap",children:d.map(mt=>jsxRuntimeExports.jsxs("div",{className:`bg-white p-6 rounded-2xl shadow-md min-w-[280px] md:min-w-[320px] flex-shrink-0 transition-all duration-300 ${st===mt.id?"ring-2 ring-blue-400 shadow-lg":""}`,onDragEnter:$t=>ct($t,mt.id),onDragLeave:dt,onDragOver:$t=>pt($t,mt.id,e.find(Tt=>Tt.id===mt.id)?.tasks.length||0),onDrop:()=>ft(mt.id,e.find($t=>$t.id===mt.id)?.tasks.length||0),children:[jsxRuntimeExports.jsx("h2",{className:"font-semibold mb-6 text-gray-800 text-lg",children:mt.title}),_(mt.id).map(($t,Tt)=>jsxRuntimeExports.jsxs(React.Fragment,{children:[st===mt.id&&it===Tt&&jsxRuntimeExports.jsx("div",{className:"h-1 bg-blue-200 rounded my-2 transition-all duration-300"}),jsxRuntimeExports.jsx(TaskComponent,{task:$t,columnId:mt.id,columnPrecent:o.findIndex(Nt=>Nt.id==mt.id)/d.length+1/d.length*2,updateTask:ht,deleteTask:bt,handleDragStart:ot,handleDragOver:Nt=>pt(Nt,mt.id,Tt),handleDrop:()=>ft(mt.id,Tt),isDragging:b&&b.id===$t.id,...a})]},$t.id)),st===mt.id&&it===e.find($t=>$t.id===mt.id)?.tasks.length&&jsxRuntimeExports.jsx("div",{className:"h-1 bg-blue-200 rounded my-2 transition-all duration-300"})]},mt.id))})},__vite__wasmUrl="/task-coach-browser/assets/tiktoken_bg-BQaKxjUe.wasm",__vite__initWasm=async(o={},e)=>{let s;if(e.startsWith("data:")){const a=e.replace(/^data:.*?base64,/,"");let d;if(typeof Buffer=="function"&&typeof Buffer.from=="function")d=Buffer.from(a,"base64");else if(typeof atob=="function"){const h=atob(a);d=new Uint8Array(h.length);for(let b=0;b<h.length;b++)d[b]=h.charCodeAt(b)}else throw new Error("Cannot decode base64-encoded data URL");s=await WebAssembly.instantiate(d,o)}else{const a=await fetch(e),d=a.headers.get("Content-Type")||"";if("instantiateStreaming"in WebAssembly&&d.startsWith("application/wasm"))s=await WebAssembly.instantiateStreaming(a,o);else{const h=await a.arrayBuffer();s=await WebAssembly.instantiate(h,o)}}return s.instance.exports};let wasm$1;function __wbg_set_wasm(o){wasm$1=o}const heap=new Array(128).fill(void 0);heap.push(void 0,null,!0,!1);function getObject(o){return heap[o]}let WASM_VECTOR_LEN=0,cachedUint8Memory0=null;function getUint8Memory0(){return(cachedUint8Memory0===null||cachedUint8Memory0.byteLength===0)&&(cachedUint8Memory0=new Uint8Array(wasm$1.memory.buffer)),cachedUint8Memory0}const lTextEncoder=typeof TextEncoder>"u"?(0,module.require)("util").TextEncoder:TextEncoder;let cachedTextEncoder=new lTextEncoder("utf-8");const encodeString=typeof cachedTextEncoder.encodeInto=="function"?function(o,e){return cachedTextEncoder.encodeInto(o,e)}:function(o,e){const s=cachedTextEncoder.encode(o);return e.set(s),{read:o.length,written:s.length}};function passStringToWasm0(o,e,s){if(s===void 0){const et=cachedTextEncoder.encode(o),st=e(et.length,1)>>>0;return getUint8Memory0().subarray(st,st+et.length).set(et),WASM_VECTOR_LEN=et.length,st}let a=o.length,d=e(a,1)>>>0;const h=getUint8Memory0();let b=0;for(;b<a;b++){const et=o.charCodeAt(b);if(et>127)break;h[d+b]=et}if(b!==a){b!==0&&(o=o.slice(b)),d=s(d,a,a=b+o.length*3,1)>>>0;const et=getUint8Memory0().subarray(d+b,d+a),st=encodeString(o,et);b+=st.written,d=s(d,a,b,1)>>>0}return WASM_VECTOR_LEN=b,d}function isLikeNone(o){return o==null}let cachedInt32Memory0=null;function getInt32Memory0(){return(cachedInt32Memory0===null||cachedInt32Memory0.byteLength===0)&&(cachedInt32Memory0=new Int32Array(wasm$1.memory.buffer)),cachedInt32Memory0}let heap_next=heap.length;function dropObject(o){o<132||(heap[o]=heap_next,heap_next=o)}function takeObject(o){const e=getObject(o);return dropObject(o),e}const lTextDecoder=typeof TextDecoder>"u"?(0,module.require)("util").TextDecoder:TextDecoder;let cachedTextDecoder=new lTextDecoder("utf-8",{ignoreBOM:!0,fatal:!0});cachedTextDecoder.decode();function getStringFromWasm0(o,e){return o=o>>>0,cachedTextDecoder.decode(getUint8Memory0().subarray(o,o+e))}function addHeapObject(o){heap_next===heap.length&&heap.push(heap.length+1);const e=heap_next;return heap_next=heap[e],heap[e]=o,e}function handleError(o,e){try{return o.apply(this,e)}catch(s){wasm$1.__wbindgen_export_2(addHeapObject(s))}}let cachedUint32Memory0=null;function getUint32Memory0(){return(cachedUint32Memory0===null||cachedUint32Memory0.byteLength===0)&&(cachedUint32Memory0=new Uint32Array(wasm$1.memory.buffer)),cachedUint32Memory0}function getArrayU32FromWasm0(o,e){return o=o>>>0,getUint32Memory0().subarray(o/4,o/4+e)}function passArray8ToWasm0(o,e){const s=e(o.length*1,1)>>>0;return getUint8Memory0().set(o,s/1),WASM_VECTOR_LEN=o.length,s}function passArray32ToWasm0(o,e){const s=e(o.length*4,4)>>>0;return getUint32Memory0().set(o,s/4),WASM_VECTOR_LEN=o.length,s}function getArrayU8FromWasm0(o,e){return o=o>>>0,getUint8Memory0().subarray(o/1,o/1+e)}function encoding_for_model$1(o,e){if(wasm$1==null)throw new Error("tiktoken: WASM binary has not been propery initialized.");try{const h=wasm$1.__wbindgen_add_to_stack_pointer(-16),b=passStringToWasm0(o,wasm$1.__wbindgen_export_0,wasm$1.__wbindgen_export_1),et=WASM_VECTOR_LEN;wasm$1.encoding_for_model(h,b,et,addHeapObject(e));var s=getInt32Memory0()[h/4+0],a=getInt32Memory0()[h/4+1],d=getInt32Memory0()[h/4+2];if(d)throw takeObject(a);return Tiktoken.__wrap(s)}finally{wasm$1.__wbindgen_add_to_stack_pointer(16)}}const TiktokenFinalization=typeof FinalizationRegistry>"u"?{register:()=>{},unregister:()=>{}}:new FinalizationRegistry(o=>wasm$1.__wbg_tiktoken_free(o>>>0));class Tiktoken{static __wrap(e){e=e>>>0;const s=Object.create(Tiktoken.prototype);return s.__wbg_ptr=e,TiktokenFinalization.register(s,s.__wbg_ptr,s),s}__destroy_into_raw(){const e=this.__wbg_ptr;return this.__wbg_ptr=0,TiktokenFinalization.unregister(this),e}free(){if(wasm$1==null)throw new Error("tiktoken: WASM binary has not been propery initialized.");const e=this.__destroy_into_raw();wasm$1.__wbg_tiktoken_free(e)}constructor(e,s,a){if(wasm$1==null)throw new Error("tiktoken: WASM binary has not been propery initialized.");const d=passStringToWasm0(e,wasm$1.__wbindgen_export_0,wasm$1.__wbindgen_export_1),h=WASM_VECTOR_LEN,b=passStringToWasm0(a,wasm$1.__wbindgen_export_0,wasm$1.__wbindgen_export_1),et=WASM_VECTOR_LEN,st=wasm$1.tiktoken_new(d,h,addHeapObject(s),b,et);return this.__wbg_ptr=st>>>0,this}get name(){try{const a=wasm$1.__wbindgen_add_to_stack_pointer(-16);wasm$1.tiktoken_name(a,this.__wbg_ptr);var e=getInt32Memory0()[a/4+0],s=getInt32Memory0()[a/4+1];let d;return e!==0&&(d=getStringFromWasm0(e,s).slice(),wasm$1.__wbindgen_export_3(e,s*1,1)),d}finally{wasm$1.__wbindgen_add_to_stack_pointer(16)}}encode(e,s,a){if(wasm$1==null)throw new Error("tiktoken: WASM binary has not been propery initialized.");try{const $=wasm$1.__wbindgen_add_to_stack_pointer(-16),it=passStringToWasm0(e,wasm$1.__wbindgen_export_0,wasm$1.__wbindgen_export_1),g=WASM_VECTOR_LEN;wasm$1.tiktoken_encode($,this.__wbg_ptr,it,g,addHeapObject(s),addHeapObject(a));var d=getInt32Memory0()[$/4+0],h=getInt32Memory0()[$/4+1],b=getInt32Memory0()[$/4+2],et=getInt32Memory0()[$/4+3];if(et)throw takeObject(b);var st=getArrayU32FromWasm0(d,h).slice();return wasm$1.__wbindgen_export_3(d,h*4,4),st}finally{wasm$1.__wbindgen_add_to_stack_pointer(16)}}encode_ordinary(e){if(wasm$1==null)throw new Error("tiktoken: WASM binary has not been propery initialized.");try{const h=wasm$1.__wbindgen_add_to_stack_pointer(-16),b=passStringToWasm0(e,wasm$1.__wbindgen_export_0,wasm$1.__wbindgen_export_1),et=WASM_VECTOR_LEN;wasm$1.tiktoken_encode_ordinary(h,this.__wbg_ptr,b,et);var s=getInt32Memory0()[h/4+0],a=getInt32Memory0()[h/4+1],d=getArrayU32FromWasm0(s,a).slice();return wasm$1.__wbindgen_export_3(s,a*4,4),d}finally{wasm$1.__wbindgen_add_to_stack_pointer(16)}}encode_with_unstable(e,s,a){if(wasm$1==null)throw new Error("tiktoken: WASM binary has not been propery initialized.");try{const et=wasm$1.__wbindgen_add_to_stack_pointer(-16),st=passStringToWasm0(e,wasm$1.__wbindgen_export_0,wasm$1.__wbindgen_export_1),$=WASM_VECTOR_LEN;wasm$1.tiktoken_encode_with_unstable(et,this.__wbg_ptr,st,$,addHeapObject(s),addHeapObject(a));var d=getInt32Memory0()[et/4+0],h=getInt32Memory0()[et/4+1],b=getInt32Memory0()[et/4+2];if(b)throw takeObject(h);return takeObject(d)}finally{wasm$1.__wbindgen_add_to_stack_pointer(16)}}encode_single_token(e){if(wasm$1==null)throw new Error("tiktoken: WASM binary has not been propery initialized.");const s=passArray8ToWasm0(e,wasm$1.__wbindgen_export_0),a=WASM_VECTOR_LEN;return wasm$1.tiktoken_encode_single_token(this.__wbg_ptr,s,a)>>>0}decode(e){if(wasm$1==null)throw new Error("tiktoken: WASM binary has not been propery initialized.");try{const h=wasm$1.__wbindgen_add_to_stack_pointer(-16),b=passArray32ToWasm0(e,wasm$1.__wbindgen_export_0),et=WASM_VECTOR_LEN;wasm$1.tiktoken_decode(h,this.__wbg_ptr,b,et);var s=getInt32Memory0()[h/4+0],a=getInt32Memory0()[h/4+1],d=getArrayU8FromWasm0(s,a).slice();return wasm$1.__wbindgen_export_3(s,a*1,1),d}finally{wasm$1.__wbindgen_add_to_stack_pointer(16)}}decode_single_token_bytes(e){if(wasm$1==null)throw new Error("tiktoken: WASM binary has not been propery initialized.");try{const h=wasm$1.__wbindgen_add_to_stack_pointer(-16);wasm$1.tiktoken_decode_single_token_bytes(h,this.__wbg_ptr,e);var s=getInt32Memory0()[h/4+0],a=getInt32Memory0()[h/4+1],d=getArrayU8FromWasm0(s,a).slice();return wasm$1.__wbindgen_export_3(s,a*1,1),d}finally{wasm$1.__wbindgen_add_to_stack_pointer(16)}}token_byte_values(){if(wasm$1==null)throw new Error("tiktoken: WASM binary has not been propery initialized.");const e=wasm$1.tiktoken_token_byte_values(this.__wbg_ptr);return takeObject(e)}}function __wbindgen_string_get(o,e){if(wasm$1==null)throw new Error("tiktoken: WASM binary has not been propery initialized.");const s=getObject(e),a=typeof s=="string"?s:void 0;var d=isLikeNone(a)?0:passStringToWasm0(a,wasm$1.__wbindgen_export_0,wasm$1.__wbindgen_export_1),h=WASM_VECTOR_LEN;getInt32Memory0()[o/4+1]=h,getInt32Memory0()[o/4+0]=d}function __wbindgen_object_drop_ref(o){takeObject(o)}function __wbindgen_is_undefined(o){return getObject(o)===void 0}function __wbg_stringify_8887fe74e1c50d81(){return handleError(function(o){const e=JSON.stringify(getObject(o));return addHeapObject(e)},arguments)}function __wbindgen_error_new(o,e){const s=new Error(getStringFromWasm0(o,e));return addHeapObject(s)}function __wbg_parse_66d1801634e099ac(){return handleError(function(o,e){const s=JSON.parse(getStringFromWasm0(o,e));return addHeapObject(s)},arguments)}function __wbindgen_throw(o,e){throw new Error(getStringFromWasm0(o,e))}URL=globalThis.URL;const __vite__wasmModule=await __vite__initWasm({"./tiktoken_bg.js":{__wbindgen_string_get,__wbindgen_object_drop_ref,__wbindgen_is_undefined,__wbg_stringify_8887fe74e1c50d81,__wbindgen_error_new,__wbg_parse_66d1801634e099ac,__wbindgen_throw}},__vite__wasmUrl),memory=__vite__wasmModule.memory,__wbg_tiktoken_free=__vite__wasmModule.__wbg_tiktoken_free,tiktoken_new=__vite__wasmModule.tiktoken_new,tiktoken_name=__vite__wasmModule.tiktoken_name,tiktoken_encode=__vite__wasmModule.tiktoken_encode,tiktoken_encode_ordinary=__vite__wasmModule.tiktoken_encode_ordinary,tiktoken_encode_with_unstable=__vite__wasmModule.tiktoken_encode_with_unstable,tiktoken_encode_single_token=__vite__wasmModule.tiktoken_encode_single_token,tiktoken_decode=__vite__wasmModule.tiktoken_decode,tiktoken_decode_single_token_bytes=__vite__wasmModule.tiktoken_decode_single_token_bytes,tiktoken_token_byte_values=__vite__wasmModule.tiktoken_token_byte_values,get_encoding=__vite__wasmModule.get_encoding,encoding_for_model=__vite__wasmModule.encoding_for_model,__wbindgen_export_0=__vite__wasmModule.__wbindgen_export_0,__wbindgen_export_1=__vite__wasmModule.__wbindgen_export_1,__wbindgen_export_2=__vite__wasmModule.__wbindgen_export_2,__wbindgen_add_to_stack_pointer=__vite__wasmModule.__wbindgen_add_to_stack_pointer,__wbindgen_export_3=__vite__wasmModule.__wbindgen_export_3,wasm=Object.freeze(Object.defineProperty({__proto__:null,__wbg_tiktoken_free,__wbindgen_add_to_stack_pointer,__wbindgen_export_0,__wbindgen_export_1,__wbindgen_export_2,__wbindgen_export_3,encoding_for_model,get_encoding,memory,tiktoken_decode,tiktoken_decode_single_token_bytes,tiktoken_encode,tiktoken_encode_ordinary,tiktoken_encode_single_token,tiktoken_encode_with_unstable,tiktoken_name,tiktoken_new,tiktoken_token_byte_values},Symbol.toStringTag,{value:"Module"}));__wbg_set_wasm(wasm);function generateColor(){const o={slate:["#f8fafc","#f1f5f9","#e2e8f0","#cbd5e1","#94a3b8","#64748b","#475569","#334155","#1e293b","#0f172a"],gray:["#f9fafb","#f3f4f6","#e5e7eb","#d1d5db","#9ca3af","#6b7280","#4b5563","#374151","#1f2937","#111827"],zinc:["#fafafa","#f4f4f5","#e4e4e7","#d4d4d8","#a1a1aa","#71717a","#52525b","#3f3f46","#27272a","#18181b"],neutral:["#fafafa","#f5f5f5","#e5e5e5","#d4d4d4","#a3a3a3","#737373","#525252","#404040","#262626","#171717"],stone:["#fafaf9","#f5f5f4","#e7e5e4","#d6d3d1","#a8a29e","#78716c","#57534e","#44403c","#292524","#1c1917"],red:["#fef2f2","#fee2e2","#fecaca","#fca5a5","#f87171","#ef4444","#dc2626","#b91c1c","#991b1b","#7f1d1d"],orange:["#fff7ed","#ffedd5","#fed7aa","#fdba74","#fb923c","#f97316","#ea580c","#c2410c","#9a3412","#7c2d12"],amber:["#fffbeb","#fef3c7","#fde68a","#fcd34d","#fbbf24","#f59e0b","#d97706","#b45309","#92400e","#78350f"],yellow:["#fefce8","#fef9c3","#fef08a","#fde047","#facc15","#eab308","#ca8a04","#a16207","#854d0e","#713f12"],lime:["#f7fee7","#ecfccb","#d9f99d","#bef264","#a3e635","#84cc16","#65a30d","#4d7c0f","#3f6212","#365314"],green:["#f0fdf4","#dcfce7","#bbf7d0","#86efac","#4ade80","#22c55e","#16a34a","#15803d","#166534","#14532d"],emerald:["#ecfdf5","#d1fae5","#a7f3d0","#6ee7b7","#34d399","#10b981","#059669","#047857","#065f46","#064e3b"],teal:["#f0fdfa","#ccfbf1","#99f6e4","#5eead4","#2dd4bf","#14b8a6","#0d9488","#0f766e","#115e59","#134e4a"],cyan:["#ecfeff","#cffafe","#a5f3fc","#67e8f9","#22d3ee","#06b6d4","#0891b2","#0e7490","#155e75","#164e63"],sky:["#f0f9ff","#e0f2fe","#bae6fd","#7dd3fc","#38bdf8","#0ea5e9","#0284c7","#0369a1","#075985","#0c4a6e"],blue:["#eff6ff","#dbeafe","#bfdbfe","#93c5fd","#60a5fa","#3b82f6","#2563eb","#1d4ed8","#1e40af","#1e3a8a"],indigo:["#eef2ff","#e0e7ff","#c7d2fe","#a5b4fc","#818cf8","#6366f1","#4f46e5","#4338ca","#3730a3","#312e81"],violet:["#f5f3ff","#ede9fe","#ddd6fe","#c4b5fd","#a78bfa","#8b5cf6","#7c3aed","#6d28d9","#5b21b6","#4c1d95"],purple:["#faf5ff","#f3e8ff","#e9d5ff","#d8b4fe","#c084fc","#a855f7","#9333ea","#7e22ce","#6b21a8","#581c87"],fuchsia:["#fdf4ff","#fae8ff","#f5d0fe","#f0abfc","#e879f9","#d946ef","#c026d3","#a21caf","#86198f","#701a75"],pink:["#fdf2f8","#fce7f3","#fbcfe8","#f9a8d4","#f472b6","#ec4899","#db2777","#be185d","#9d174d","#831843"],rose:["#fff1f2","#ffe4e6","#fecdd3","#fda4af","#fb7185","#f43f5e","#e11d48","#be123c","#9f1239","#881337"]},e=Object.keys(o),s=e[Math.floor(Math.random()*e.length)],a=o[s];return{color:a[Math.floor(Math.random()*a.length)],shade:s}}async function getTokenCount(o,e="gpt-4"){const s=await encoding_for_model$1(e),d=s.encode(o).length;return s.free(),d}const INITIAL_COLUMNS=[{id:"backlog",title:"Backlog",tasks:{}},{id:"todo",title:"To Do",tasks:{}},{id:"in-progress",title:"In Progress",tasks:{}},{id:"review",title:"Review",tasks:{}},{id:"done",title:"Done",tasks:{}},{id:"blocked",title:"Blocked",tasks:{}}],generateTaskObject=({id:o=void 0,color:e=void 0}={})=>({id:o===void 0?v4():o,estimatedTime:"1 hour",title:"",description:"",assignee:void 0,column:INITIAL_COLUMNS[0].id,attachments:void 0,createdTime:new Date().toISOString(),updatedTime:new Date().toISOString(),startedTime:void 0,completedTime:void 0,color:e===void 0?generateColor():e,priority:"Medium",comments:void 0,tags:void 0}),saveBoardState=o=>{localStorage.setItem("kanbanBoard",JSON.stringify(o))},exportBoardState=o=>{const e="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(o)),s=document.createElement("a");s.setAttribute("href",e),s.setAttribute("download","kanban_board_export.json"),document.body.appendChild(s),s.click(),s.remove()},importBoardState=(o,e)=>{const s=o.target.files[0];if(s){const a=new FileReader;a.onload=d=>{try{const h=JSON.parse(d.target.result);e(h),localStorage.setItem("kanbanBoard",JSON.stringify(h)),alert("Board state imported successfully!")}catch{alert("Error importing board state. Please check the file format.")}},a.readAsText(s)}},validateTask=async(o,e,s)=>{const a=`${o.title}${o.description==""?"":`
Description:`+o.description}`;if(!o.bypassValidation){s("Validating task...",15);const d=await e(a,ASSISTANT_SYSTEM_PROMPT_VALIDATE_TASK);if(d.valid===!1)throw new Error(d.explain);s("Done Validating task successfully!",30)}},generateSubtasks=async(o,e,s)=>{const a=o.title;s("Generating subtasks...",0,0);const d=`${a}`;s("Initiating tasks thinking",45),s("Writing tasks..",50);let h=[];try{h=await e(d,ASSISTANT_SYSTEM_PROMPT_WRITE_TASKS_JSON,3,console.log),s("Converting text tasks to JSON",75)}catch(b){throw new Error("Couldn't chatCompletionJSON Error"+b.message)}return s("Converting tasks to JSON, successfully!",100),h},generateTask=async(o,e)=>{const s=`${o.title}${o.description==""?"":`
Description:`+o.description}`,a=await e(s,ASSISTANT_SYSTEM_PROMPT_GENERATE_TASK);return{...o,...a}},getFlatTasksFromTaskRecursively=o=>{const e=[],s=[o];for(;s.length;){const a=s.pop();if(e.push(a),a.subtasks)for(const d of Object.values(a.subtasks))s.push({...d,parentId:a.id})}return e},MAX_TOKENS=15,KanbanBoard=()=>{const{chatCompletion:o,chatCompletionJSON:e,canUseChatCompletion:s}=useModel(),[a,d]=reactExports.useState({id:"board-1",title:"My Inspired Kanban",columns:INITIAL_COLUMNS.reduce((dn,wn)=>(dn[wn.id]=wn,dn),{})}),[h,b]=reactExports.useState(0),[et,st]=reactExports.useState(""),[$,it]=reactExports.useState(null),[g,c]=reactExports.useState(!1),[_,ot]=reactExports.useState(!1),[ct,dt]=reactExports.useState(""),[pt,ft]=reactExports.useState({...generateTaskObject(),bypassValidation:!1,generateSubtasks:!1}),[ht,bt]=reactExports.useState(!1),mt=reactExports.useRef(null),$t=dn=>(saveBoardState(dn),d(dn)),Tt=(dn,wn,gn)=>{const En=gn.target.files[0];if(En){const _r=new FileReader;_r.onload=Sr=>{const xr={id:v4(),name:En.name,type:En.type,data:Sr.target.result};mn(dn,wn,{attachments:[...a.columns[dn].tasks[wn].attachments,xr]})},_r.readAsDataURL(En)}};reactExports.useEffect(()=>{const dn=localStorage.getItem("kanbanBoard");if(dn&&dn!=="undefined"){const wn=JSON.parse(dn);d(wn)}else{const wn=INITIAL_COLUMNS.reduce((gn,En)=>(gn[En.id]={id:En.id,title:En.title,tasks:{}},gn),{});$t(gn=>({...gn,columns:wn}))}},[]),reactExports.useEffect(()=>{s?o("Hello","You are a friendly assistant.",dt):dt("Hello, let's create tasks")},[s]);const Nt=()=>ot(!0),Ct=()=>ot(!1),Ft=async dn=>{const wn=dn.target.type==="checkbox"?dn.target.checked:dn.target.value;let gn={...pt,[dn.target.name]:wn,column:INITIAL_COLUMNS[0].id,id:v4()};if(dn.target.name==="title"||dn.target.name==="description"){const En=await getTokenCount(wn);if(En>MAX_TOKENS)return;gn[`${dn.target.name}Tokens`]=En}ft(gn)},ln=async()=>{bt(!0),Ct(),c(!0);let dn,wn=[];try{await validateTask(pt,e,pn),pt.generateSubtasks&&(wn=await generateSubtasks(pt,e,pn),Array.isArray(wn)||(wn=[wn])),dn=await generateTask(pt,e)}catch(_r){it(_r.message),bt(!1);return}c(!1);const gn={...generateTaskObject(),...dn,id:`task-${v4()}`,isParent:!0},En={...gn,subtasks:wn.reduce((_r,Sr)=>{const xr=`subtask-${v4()}`;return _r[xr]={...generateTaskObject({color:gn.color,id:xr}),...Sr,parentId:gn.id,parentTitle:pt.title},_r},{})};$t({...a,columns:{...a.columns,backlog:{...a.columns.backlog,tasks:{...a.columns.backlog?.tasks||{},[gn.id]:gn,...En.subtasks}}}}),ft(generateTaskObject()),bt(!1)},mn=(dn,wn,gn)=>{$t({...a,columns:{...a.columns,[dn]:{...a.columns[dn],tasks:{...a.columns[dn].tasks,[wn]:{...a.columns[dn].tasks[wn],...gn}}}}})},yn=(dn,wn)=>{const gn={...a.columns[dn].tasks};delete gn[wn],$t({...a,columns:{...a.columns,[dn]:{...a.columns[dn],tasks:gn}}})},pn=(dn,wn=void 0,gn=500)=>{setTimeout(()=>{b(wn),st(dn)},gn)},Ht=()=>{c(!1),bt(!1),b(0),st(""),it("Task generation was cancelled.")},Gt=reactExports.useCallback(()=>Object.entries(a.columns).reduce((dn,[wn,gn])=>{const En=Object.values(gn.tasks).reduce((_r,Sr)=>{const xr=getFlatTasksFromTaskRecursively(Sr);return _r=[..._r,...xr],_r},[]);return dn.push({id:wn,title:gn.title,tasks:En}),dn},[]),[a]),cn=reactExports.useMemo(()=>Gt(),[Gt]),xn=dn=>{const wn={id:a.id,title:a.title,columns:{}};dn.forEach(gn=>{wn.columns[gn.id]={id:gn.id,title:gn.title,tasks:{}},gn.tasks.forEach(En=>{wn.columns[gn.id].tasks[En.id]={id:En.id,title:En.title,description:En.description,priority:En.priority,estimatedTime:En.estimatedTime,column:En.column,parentId:En.parentId,...En}})}),$t(wn),saveBoardState(wn)};return jsxRuntimeExports.jsxs("div",{className:"p-8 bg-gray-50 min-h-screen text-gray-900",children:[jsxRuntimeExports.jsxs("div",{className:`${ht?"opacity-50":""} transition-opacity duration-300`,children:[jsxRuntimeExports.jsx("h1",{className:"text-4xl font-bold mb-6 text-gray-900",children:jsxRuntimeExports.jsx("input",{value:a.title,onChange:dn=>$t({...a,title:dn.target.value}),className:"w-full mr-2 bg-transparent border-b-2 border-gray-200 focus:border-blue-500 focus:outline-none transition-all duration-300"})}),jsxRuntimeExports.jsx("p",{className:"font-medium mb-8 text-gray-600",children:ct})]}),jsxRuntimeExports.jsxs("div",{className:"mb-8 space-x-4",children:[jsxRuntimeExports.jsx("button",{onClick:Nt,className:"bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-full transition duration-300 shadow-sm",children:"Create Task"}),jsxRuntimeExports.jsx("button",{onClick:()=>exportBoardState(a),className:"bg-gray-200 hover:bg-gray-300 text-gray-800 px-6 py-3 rounded-full transition duration-300 shadow-sm",children:"Export Board"}),jsxRuntimeExports.jsx("input",{type:"file",accept:".json",onChange:dn=>importBoardState(dn,$t),className:"hidden",ref:mt}),jsxRuntimeExports.jsx("button",{onClick:()=>mt.current.click(),className:"bg-gray-200 hover:bg-gray-300 text-gray-800 px-6 py-3 rounded-full transition duration-300 shadow-sm",children:"Import Board"})]}),ht&&jsxRuntimeExports.jsx("div",{className:"fixed inset-0 flex items-center justify-center bg-white bg-opacity-80 backdrop-filter backdrop-blur-sm z-50",children:jsxRuntimeExports.jsx("div",{className:"bg-white p-8 rounded-2xl shadow-xl",children:jsxRuntimeExports.jsx(LoadingIndicator,{percentage:h,text:et})})}),g&&jsxRuntimeExports.jsx("button",{onClick:Ht,className:"mt-6 bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-full shadow-sm",children:"Stop Generation"}),$&&jsxRuntimeExports.jsx("p",{className:"mt-6 text-red-500 font-semibold",children:$}),jsxRuntimeExports.jsx(Board,{columns:INITIAL_COLUMNS,tasks:cn,setTasks:xn,updateTask:mn,deleteTask:yn,handleFileUpload:Tt}),_&&jsxRuntimeExports.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-30 flex items-center justify-center z-50 backdrop-filter backdrop-blur-sm",children:jsxRuntimeExports.jsxs("div",{className:"bg-white p-8 rounded-2xl w-96 shadow-2xl",children:[jsxRuntimeExports.jsx("h2",{className:"text-2xl font-bold mb-6 text-gray-900",children:"Add New Task"}),jsxRuntimeExports.jsx("input",{name:"title",value:pt.title,onChange:Ft,placeholder:"Prompt",className:"w-full mb-4 p-3 border border-gray-300 rounded-lg bg-gray-50 text-gray-900 focus:outline-none focus:ring-2 focus:ring-blue-500"}),jsxRuntimeExports.jsxs("p",{className:"text-sm text-gray-500 mb-4",children:["Title Tokens: ",pt.titleTokens,"/",MAX_TOKENS]}),jsxRuntimeExports.jsxs("div",{className:"mb-4",children:[jsxRuntimeExports.jsx("label",{className:"block mb-2 text-gray-700",children:"Priority:"}),jsxRuntimeExports.jsxs("select",{name:"priority",value:pt.priority,onChange:Ft,className:"w-full p-3 border border-gray-300 rounded-lg bg-gray-50 text-gray-900 focus:outline-none focus:ring-2 focus:ring-blue-500",children:[jsxRuntimeExports.jsx("option",{children:"Low"}),jsxRuntimeExports.jsx("option",{children:"Medium"}),jsxRuntimeExports.jsx("option",{children:"High"})]})]}),jsxRuntimeExports.jsx("input",{name:"estimatedTime",value:pt.estimatedTime,onChange:Ft,placeholder:"Estimated time (e.g., 2 hours, 1 day)",className:"w-full mb-4 p-3 border border-gray-300 rounded-lg bg-gray-50 text-gray-900 focus:outline-none focus:ring-2 focus:ring-blue-500"}),jsxRuntimeExports.jsx("div",{className:"mb-4",children:jsxRuntimeExports.jsxs("label",{className:"flex items-center text-gray-700",children:[jsxRuntimeExports.jsx("input",{type:"checkbox",name:"bypassValidation",checked:pt.bypassValidation,onChange:Ft,className:"mr-2 h-5 w-5 text-blue-500 rounded focus:ring-blue-500"}),"Bypass Validation"]})}),jsxRuntimeExports.jsx("div",{className:"mb-6",children:jsxRuntimeExports.jsxs("label",{className:"flex items-center text-gray-700",children:[jsxRuntimeExports.jsx("input",{type:"checkbox",name:"generateSubtasks",checked:pt.generateSubtasks,onChange:Ft,className:"mr-2 h-5 w-5 text-blue-500 rounded focus:ring-blue-500"}),jsxRuntimeExports.jsxs("span",{className:"relative flex items-center",children:["Generate Subtasks",jsxRuntimeExports.jsx("span",{className:"ml-2 px-2 py-1 bg-blue-500 text-white text-xs font-bold rounded-full animate-pulse",children:"New!"})]})]})}),jsxRuntimeExports.jsxs("div",{className:"flex justify-end space-x-4",children:[jsxRuntimeExports.jsx("button",{onClick:Ct,className:"bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full",children:"Cancel"}),jsxRuntimeExports.jsx("button",{onClick:ln,className:"bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full",children:"Add Task"})]})]})})]})},Footer=()=>jsxRuntimeExports.jsx("footer",{className:"bg-gray-200 text-center py-4 mt-auto",children:jsxRuntimeExports.jsx("div",{className:"container mx-auto",children:jsxRuntimeExports.jsx("p",{className:"text-gray-600",children:"© 2024 Coach Goals. All rights reserved."})})});function HuggingFaceComponent(){const{huggingFaceModel:o,setHuggingFaceModel:e}=useModel(),[s,a]=reactExports.useState(null),[d,h]=reactExports.useState(""),[b,et]=reactExports.useState(""),[st,$]=reactExports.useState(!1),it=async()=>{env$1.allowLocalModels=!1,$(!0);try{const c=await getModelFile(o,"onnx/model.onnx",!0,{});debugger;const _=await uc.create(c,{executionProviders:["wasm"]});debugger;const ot=await AutoModelForCausalLM.from_pretrained(o,{progress_callback:console.log,model_file_name:"model",quantized:!1});debugger;a(ot)}catch(c){console.error("Error loading model:",c)}$(!1)},g=async()=>{if(!(!s||!d))try{const c=await s(d,{max_new_tokens:50,temperature:.7});et(c[0].generated_text)}catch(c){console.error("Error generating text:",c),et("Error generating text. Please try again.")}};return jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsx("input",{value:o,onChange:c=>e(c.target.value),className:"text-3xl font-bold mb-4 text-green-800 w-full mr-2 bg-transparent border-b border-transparent focus:border-green-300 focus:outline-none transition-all duration-300"}),jsxRuntimeExports.jsx("h1",{children:"Text Generation (Local Model)"}),jsxRuntimeExports.jsx("textarea",{value:d,onChange:c=>h(c.target.value),placeholder:"Enter text prompt",rows:4,cols:50}),jsxRuntimeExports.jsx("br",{}),jsxRuntimeExports.jsx("button",{onClick:g,disabled:st||!s,children:"Generate Text"}),jsxRuntimeExports.jsx("button",{onClick:it,disabled:st,children:"Load model"}),st&&jsxRuntimeExports.jsx("p",{children:"Loading model..."}),b&&jsxRuntimeExports.jsxs("div",{children:[jsxRuntimeExports.jsx("h2",{children:"Generated Text:"}),jsxRuntimeExports.jsx("p",{children:b})]})]})}const logo="data:image/svg+xml,%3c!--%20./src/assets/CoachGoalsLogo.svg%20--%3e%3csvg%20width='100'%20height='100'%20viewBox='0%200%20100%20100'%20xmlns='http://www.w3.org/2000/svg'%3e%3c!--%20Define%20gradients%20and%20shadow%20--%3e%3cdefs%3e%3clinearGradient%20id='logoGradient'%20x1='0%25'%20y1='0%25'%20x2='100%25'%20y2='100%25'%3e%3cstop%20offset='0%25'%20style='stop-color:%234A90E2;stop-opacity:1'%20/%3e%3cstop%20offset='100%25'%20style='stop-color:%23357ABD;stop-opacity:1'%20/%3e%3c/linearGradient%3e%3cfilter%20id='shadow'%20x='-20%25'%20y='-20%25'%20width='140%25'%20height='140%25'%3e%3cfeDropShadow%20dx='0'%20dy='2'%20stdDeviation='3'%20flood-color='%23000000'%20flood-opacity='0.2'/%3e%3c/filter%3e%3c/defs%3e%3c!--%20Draw%20the%20logo%20circle%20with%20gradient%20and%20shadow%20--%3e%3ccircle%20cx='50'%20cy='50'%20r='45'%20fill='url(%23logoGradient)'%20filter='url(%23shadow)'%20/%3e%3c!--%20Draw%20a%20check%20mark%20for%20goals%20--%3e%3cpath%20d='M30%2050%20L45%2065%20L70%2040'%20stroke='%23fff'%20stroke-width='8'%20fill='none'%20/%3e%3c/svg%3e",CoachGoalsLogo=()=>jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment,{children:jsxRuntimeExports.jsx("img",{src:logo,alt:"Coach Goals Logo",className:"w-12 h-12"})}),Sidebar=({activeTab:o,setActiveTab:e})=>{const[s,a]=reactExports.useState(window.innerWidth>=768);reactExports.useEffect(()=>{const b=()=>{window.innerWidth<768?a(!1):a(!0)};return window.addEventListener("resize",b),b(),()=>window.removeEventListener("resize",b)},[]);const d=()=>a(!s),h=[{id:"kanban",label:"Home",icon:House},{id:"debugger",label:"Prompt Engineering",icon:MessageSquare},{id:"model-settings",label:"Model Control Panel",icon:Settings},{id:"huggingface",label:"HuggingFace Testing",icon:Database}];return jsxRuntimeExports.jsxs("div",{className:`sidebar ${s?"sidebar-open":"sidebar-closed"}`,children:[jsxRuntimeExports.jsxs("div",{className:"flex items-center justify-between p-4",children:[s&&jsxRuntimeExports.jsx(CoachGoalsLogo,{}),jsxRuntimeExports.jsx("button",{onClick:d,className:"sidebar-icon",children:s?jsxRuntimeExports.jsx(X,{size:24}):jsxRuntimeExports.jsx(Menu,{size:24})})]}),jsxRuntimeExports.jsx("nav",{className:"mt-8",children:h.map(b=>jsxRuntimeExports.jsxs("button",{className:`sidebar-item ${o===b.id?"active":""}`,onClick:()=>e(b.id),children:[jsxRuntimeExports.jsx(b.icon,{size:20}),s&&jsxRuntimeExports.jsx("span",{className:"sidebar-tooltip",children:b.label})]},b.id))})]})},App=()=>{const[o,e]=reactExports.useState([]),[s,a]=reactExports.useState(ASSISTANT_SYSTEM_PROMPT_VALIDATE_TASK),{isModelLoaded:d,chatCompletion:h,abortWorker:b}=useModel(),[et,st]=reactExports.useState(!1),$=async(c,_=void 0,ot=void 0)=>{for(;et;)await new Promise(dt=>setTimeout(dt,1e3));const ct=_||s;try{return await h(c,ct,pt=>{e(ft=>[...ft.slice(0,-1),{role:"assistant",content:pt}]),ot&&ot(pt)})}catch(dt){throw st(!1),dt}},[it,g]=reactExports.useState("kanban");return jsxRuntimeExports.jsxs("div",{className:"container-fluid",children:[jsxRuntimeExports.jsx(Sidebar,{activeTab:it,setActiveTab:g}),jsxRuntimeExports.jsx("div",{className:"main-content",children:jsxRuntimeExports.jsxs("div",{children:[it==="kanban"&&jsxRuntimeExports.jsx(KanbanBoard,{}),it==="debugger"&&jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx(SystemPromptEditor,{systemPrompt:s,setSystemPrompt:a}),jsxRuntimeExports.jsx(ChatBot,{isModelLoaded:d,chatHistory:o,setChatHistory:e,onSubmit:$,isGenerating:et,abortWorker:b}),jsxRuntimeExports.jsx(Footer,{})]}),it==="model-settings"&&jsxRuntimeExports.jsx(ModelSettingsEditor,{}),it==="huggingface"&&jsxRuntimeExports.jsx(HuggingFaceComponent,{})]})})]})};client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React.StrictMode,{children:jsxRuntimeExports.jsx(ModelProvider,{children:jsxRuntimeExports.jsx(App,{})})}));
