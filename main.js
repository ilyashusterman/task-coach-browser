var x_=Object.defineProperty;var u_=i=>{throw TypeError(i)};var $_=(i,e,o)=>e in i?x_(i,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):i[e]=o;var ir=(i,e,o)=>$_(i,typeof e!="symbol"?e+"":e,o),T_=(i,e,o)=>e.has(i)||u_("Cannot "+o);var l_=(i,e,o)=>e.has(i)?u_("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(i):e.set(i,o);var zy=(i,e,o)=>(T_(i,e,"access private method"),o);function _mergeNamespaces(i,e){for(var o=0;o<e.length;o++){const a=e[o];if(typeof a!="string"&&!Array.isArray(a)){for(const d in a)if(d!=="default"&&!(d in i)){const g=Object.getOwnPropertyDescriptor(a,d);g&&Object.defineProperty(i,d,g.get?g:{enumerable:!0,get:()=>a[d]})}}}return Object.freeze(Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const d of document.querySelectorAll('link[rel="modulepreload"]'))a(d);new MutationObserver(d=>{for(const g of d)if(g.type==="childList")for(const h of g.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&a(h)}).observe(document,{childList:!0,subtree:!0});function o(d){const g={};return d.integrity&&(g.integrity=d.integrity),d.referrerPolicy&&(g.referrerPolicy=d.referrerPolicy),d.crossOrigin==="use-credentials"?g.credentials="include":d.crossOrigin==="anonymous"?g.credentials="omit":g.credentials="same-origin",g}function a(d){if(d.ep)return;d.ep=!0;const g=o(d);fetch(d.href,g)}})();function getDefaultExportFromCjs(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}function getAugmentedNamespace(i){if(i.__esModule)return i;var e=i.default;if(typeof e=="function"){var o=function a(){return this instanceof a?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};o.prototype=e.prototype}else o={};return Object.defineProperty(o,"__esModule",{value:!0}),Object.keys(i).forEach(function(a){var d=Object.getOwnPropertyDescriptor(i,a);Object.defineProperty(o,a,d.get?d:{enumerable:!0,get:function(){return i[a]}})}),o}var jsxRuntime={exports:{}},reactJsxRuntime_production_min={},react={exports:{}},react_production_min={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$1=Symbol.for("react.element"),n$1=Symbol.for("react.portal"),p$2=Symbol.for("react.fragment"),q$1=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v$1=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z$1=Symbol.iterator;function A$1(i){return i===null||typeof i!="object"?null:(i=z$1&&i[z$1]||i["@@iterator"],typeof i=="function"?i:null)}var B$1={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$1=Object.assign,D$1={};function E$1(i,e,o){this.props=i,this.context=e,this.refs=D$1,this.updater=o||B$1}E$1.prototype.isReactComponent={};E$1.prototype.setState=function(i,e){if(typeof i!="object"&&typeof i!="function"&&i!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,i,e,"setState")};E$1.prototype.forceUpdate=function(i){this.updater.enqueueForceUpdate(this,i,"forceUpdate")};function F(){}F.prototype=E$1.prototype;function G$1(i,e,o){this.props=i,this.context=e,this.refs=D$1,this.updater=o||B$1}var H$1=G$1.prototype=new F;H$1.constructor=G$1;C$1(H$1,E$1.prototype);H$1.isPureReactComponent=!0;var I$1=Array.isArray,J=Object.prototype.hasOwnProperty,K$2={current:null},L$1={key:!0,ref:!0,__self:!0,__source:!0};function M$2(i,e,o){var a,d={},g=null,h=null;if(e!=null)for(a in e.ref!==void 0&&(h=e.ref),e.key!==void 0&&(g=""+e.key),e)J.call(e,a)&&!L$1.hasOwnProperty(a)&&(d[a]=e[a]);var et=arguments.length-2;if(et===1)d.children=o;else if(1<et){for(var ot=Array(et),it=0;it<et;it++)ot[it]=arguments[it+2];d.children=ot}if(i&&i.defaultProps)for(a in et=i.defaultProps,et)d[a]===void 0&&(d[a]=et[a]);return{$$typeof:l$1,type:i,key:g,ref:h,props:d,_owner:K$2.current}}function N$1(i,e){return{$$typeof:l$1,type:i.type,key:e,ref:i.ref,props:i.props,_owner:i._owner}}function O$1(i){return typeof i=="object"&&i!==null&&i.$$typeof===l$1}function escape$2(i){var e={"=":"=0",":":"=2"};return"$"+i.replace(/[=:]/g,function(o){return e[o]})}var P$1=/\/+/g;function Q$1(i,e){return typeof i=="object"&&i!==null&&i.key!=null?escape$2(""+i.key):e.toString(36)}function R$1(i,e,o,a,d){var g=typeof i;(g==="undefined"||g==="boolean")&&(i=null);var h=!1;if(i===null)h=!0;else switch(g){case"string":case"number":h=!0;break;case"object":switch(i.$$typeof){case l$1:case n$1:h=!0}}if(h)return h=i,d=d(h),i=a===""?"."+Q$1(h,0):a,I$1(d)?(o="",i!=null&&(o=i.replace(P$1,"$&/")+"/"),R$1(d,e,o,"",function(it){return it})):d!=null&&(O$1(d)&&(d=N$1(d,o+(!d.key||h&&h.key===d.key?"":(""+d.key).replace(P$1,"$&/")+"/")+i)),e.push(d)),1;if(h=0,a=a===""?".":a+":",I$1(i))for(var et=0;et<i.length;et++){g=i[et];var ot=a+Q$1(g,et);h+=R$1(g,e,o,ot,d)}else if(ot=A$1(i),typeof ot=="function")for(i=ot.call(i),et=0;!(g=i.next()).done;)g=g.value,ot=a+Q$1(g,et++),h+=R$1(g,e,o,ot,d);else if(g==="object")throw e=String(i),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(i).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return h}function S$1(i,e,o){if(i==null)return i;var a=[],d=0;return R$1(i,a,"","",function(g){return e.call(o,g,d++)}),a}function T$1(i){if(i._status===-1){var e=i._result;e=e(),e.then(function(o){(i._status===0||i._status===-1)&&(i._status=1,i._result=o)},function(o){(i._status===0||i._status===-1)&&(i._status=2,i._result=o)}),i._status===-1&&(i._status=0,i._result=e)}if(i._status===1)return i._result.default;throw i._result}var U$2={current:null},V$1={transition:null},W$1={ReactCurrentDispatcher:U$2,ReactCurrentBatchConfig:V$1,ReactCurrentOwner:K$2};function X$2(){throw Error("act(...) is not supported in production builds of React.")}react_production_min.Children={map:S$1,forEach:function(i,e,o){S$1(i,function(){e.apply(this,arguments)},o)},count:function(i){var e=0;return S$1(i,function(){e++}),e},toArray:function(i){return S$1(i,function(e){return e})||[]},only:function(i){if(!O$1(i))throw Error("React.Children.only expected to receive a single React element child.");return i}};react_production_min.Component=E$1;react_production_min.Fragment=p$2;react_production_min.Profiler=r;react_production_min.PureComponent=G$1;react_production_min.StrictMode=q$1;react_production_min.Suspense=w;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$1;react_production_min.act=X$2;react_production_min.cloneElement=function(i,e,o){if(i==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+i+".");var a=C$1({},i.props),d=i.key,g=i.ref,h=i._owner;if(e!=null){if(e.ref!==void 0&&(g=e.ref,h=K$2.current),e.key!==void 0&&(d=""+e.key),i.type&&i.type.defaultProps)var et=i.type.defaultProps;for(ot in e)J.call(e,ot)&&!L$1.hasOwnProperty(ot)&&(a[ot]=e[ot]===void 0&&et!==void 0?et[ot]:e[ot])}var ot=arguments.length-2;if(ot===1)a.children=o;else if(1<ot){et=Array(ot);for(var it=0;it<ot;it++)et[it]=arguments[it+2];a.children=et}return{$$typeof:l$1,type:i.type,key:d,ref:g,props:a,_owner:h}};react_production_min.createContext=function(i){return i={$$typeof:u,_currentValue:i,_currentValue2:i,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},i.Provider={$$typeof:t,_context:i},i.Consumer=i};react_production_min.createElement=M$2;react_production_min.createFactory=function(i){var e=M$2.bind(null,i);return e.type=i,e};react_production_min.createRef=function(){return{current:null}};react_production_min.forwardRef=function(i){return{$$typeof:v$1,render:i}};react_production_min.isValidElement=O$1;react_production_min.lazy=function(i){return{$$typeof:y,_payload:{_status:-1,_result:i},_init:T$1}};react_production_min.memo=function(i,e){return{$$typeof:x,type:i,compare:e===void 0?null:e}};react_production_min.startTransition=function(i){var e=V$1.transition;V$1.transition={};try{i()}finally{V$1.transition=e}};react_production_min.unstable_act=X$2;react_production_min.useCallback=function(i,e){return U$2.current.useCallback(i,e)};react_production_min.useContext=function(i){return U$2.current.useContext(i)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(i){return U$2.current.useDeferredValue(i)};react_production_min.useEffect=function(i,e){return U$2.current.useEffect(i,e)};react_production_min.useId=function(){return U$2.current.useId()};react_production_min.useImperativeHandle=function(i,e,o){return U$2.current.useImperativeHandle(i,e,o)};react_production_min.useInsertionEffect=function(i,e){return U$2.current.useInsertionEffect(i,e)};react_production_min.useLayoutEffect=function(i,e){return U$2.current.useLayoutEffect(i,e)};react_production_min.useMemo=function(i,e){return U$2.current.useMemo(i,e)};react_production_min.useReducer=function(i,e,o){return U$2.current.useReducer(i,e,o)};react_production_min.useRef=function(i){return U$2.current.useRef(i)};react_production_min.useState=function(i){return U$2.current.useState(i)};react_production_min.useSyncExternalStore=function(i,e,o){return U$2.current.useSyncExternalStore(i,e,o)};react_production_min.useTransition=function(){return U$2.current.useTransition()};react_production_min.version="18.3.1";react.exports=react_production_min;var reactExports=react.exports;const React=getDefaultExportFromCjs(reactExports);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f=reactExports,k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m$1=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$1={key:!0,ref:!0,__self:!0,__source:!0};function q(i,e,o){var a,d={},g=null,h=null;o!==void 0&&(g=""+o),e.key!==void 0&&(g=""+e.key),e.ref!==void 0&&(h=e.ref);for(a in e)m$1.call(e,a)&&!p$1.hasOwnProperty(a)&&(d[a]=e[a]);if(i&&i.defaultProps)for(a in e=i.defaultProps,e)d[a]===void 0&&(d[a]=e[a]);return{$$typeof:k,type:i,key:g,ref:h,props:d,_owner:n.current}}reactJsxRuntime_production_min.Fragment=l;reactJsxRuntime_production_min.jsx=q;reactJsxRuntime_production_min.jsxs=q;jsxRuntime.exports=reactJsxRuntime_production_min;var jsxRuntimeExports=jsxRuntime.exports,client={},reactDom={exports:{}},reactDom_production_min={},scheduler={exports:{}},scheduler_production_min={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(i){function e(_n,vn){var Sn=_n.length;_n.push(vn);e:for(;0<Sn;){var hn=Sn-1>>>1,rr=_n[hn];if(0<d(rr,vn))_n[hn]=vn,_n[Sn]=rr,Sn=hn;else break e}}function o(_n){return _n.length===0?null:_n[0]}function a(_n){if(_n.length===0)return null;var vn=_n[0],Sn=_n.pop();if(Sn!==vn){_n[0]=Sn;e:for(var hn=0,rr=_n.length,vr=rr>>>1;hn<vr;){var Ir=2*(hn+1)-1,$r=_n[Ir],Ur=Ir+1,Yr=_n[Ur];if(0>d($r,Sn))Ur<rr&&0>d(Yr,$r)?(_n[hn]=Yr,_n[Ur]=Sn,hn=Ur):(_n[hn]=$r,_n[Ir]=Sn,hn=Ir);else if(Ur<rr&&0>d(Yr,Sn))_n[hn]=Yr,_n[Ur]=Sn,hn=Ur;else break e}}return vn}function d(_n,vn){var Sn=_n.sortIndex-vn.sortIndex;return Sn!==0?Sn:_n.id-vn.id}if(typeof performance=="object"&&typeof performance.now=="function"){var g=performance;i.unstable_now=function(){return g.now()}}else{var h=Date,et=h.now();i.unstable_now=function(){return h.now()-et}}var ot=[],it=[],$=1,c=null,s=3,_=!1,b=!1,st=!1,dt=typeof setTimeout=="function"?setTimeout:null,ct=typeof clearTimeout=="function"?clearTimeout:null,pt=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function ft(_n){for(var vn=o(it);vn!==null;){if(vn.callback===null)a(it);else if(vn.startTime<=_n)a(it),vn.sortIndex=vn.expirationTime,e(ot,vn);else break;vn=o(it)}}function mt(_n){if(st=!1,ft(_n),!b)if(o(ot)!==null)b=!0,Wt(bt);else{var vn=o(it);vn!==null&&Jt(mt,vn.startTime-_n)}}function bt(_n,vn){b=!1,st&&(st=!1,ct(It),It=-1),_=!0;var Sn=s;try{for(ft(vn),c=o(ot);c!==null&&(!(c.expirationTime>vn)||_n&&!dn());){var hn=c.callback;if(typeof hn=="function"){c.callback=null,s=c.priorityLevel;var rr=hn(c.expirationTime<=vn);vn=i.unstable_now(),typeof rr=="function"?c.callback=rr:c===o(ot)&&a(ot),ft(vn)}else a(ot);c=o(ot)}if(c!==null)var vr=!0;else{var Ir=o(it);Ir!==null&&Jt(mt,Ir.startTime-vn),vr=!1}return vr}finally{c=null,s=Sn,_=!1}}var $t=!1,Ct=null,It=-1,Tt=5,jt=-1;function dn(){return!(i.unstable_now()-jt<Tt)}function yn(){if(Ct!==null){var _n=i.unstable_now();jt=_n;var vn=!0;try{vn=Ct(!0,_n)}finally{vn?mn():($t=!1,Ct=null)}}else $t=!1}var mn;if(typeof pt=="function")mn=function(){pt(yn)};else if(typeof MessageChannel<"u"){var fn=new MessageChannel,un=fn.port2;fn.port1.onmessage=yn,mn=function(){un.postMessage(null)}}else mn=function(){dt(yn,0)};function Wt(_n){Ct=_n,$t||($t=!0,mn())}function Jt(_n,vn){It=dt(function(){_n(i.unstable_now())},vn)}i.unstable_IdlePriority=5,i.unstable_ImmediatePriority=1,i.unstable_LowPriority=4,i.unstable_NormalPriority=3,i.unstable_Profiling=null,i.unstable_UserBlockingPriority=2,i.unstable_cancelCallback=function(_n){_n.callback=null},i.unstable_continueExecution=function(){b||_||(b=!0,Wt(bt))},i.unstable_forceFrameRate=function(_n){0>_n||125<_n?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):Tt=0<_n?Math.floor(1e3/_n):5},i.unstable_getCurrentPriorityLevel=function(){return s},i.unstable_getFirstCallbackNode=function(){return o(ot)},i.unstable_next=function(_n){switch(s){case 1:case 2:case 3:var vn=3;break;default:vn=s}var Sn=s;s=vn;try{return _n()}finally{s=Sn}},i.unstable_pauseExecution=function(){},i.unstable_requestPaint=function(){},i.unstable_runWithPriority=function(_n,vn){switch(_n){case 1:case 2:case 3:case 4:case 5:break;default:_n=3}var Sn=s;s=_n;try{return vn()}finally{s=Sn}},i.unstable_scheduleCallback=function(_n,vn,Sn){var hn=i.unstable_now();switch(typeof Sn=="object"&&Sn!==null?(Sn=Sn.delay,Sn=typeof Sn=="number"&&0<Sn?hn+Sn:hn):Sn=hn,_n){case 1:var rr=-1;break;case 2:rr=250;break;case 5:rr=1073741823;break;case 4:rr=1e4;break;default:rr=5e3}return rr=Sn+rr,_n={id:$++,callback:vn,priorityLevel:_n,startTime:Sn,expirationTime:rr,sortIndex:-1},Sn>hn?(_n.sortIndex=Sn,e(it,_n),o(ot)===null&&_n===o(it)&&(st?(ct(It),It=-1):st=!0,Jt(mt,Sn-hn))):(_n.sortIndex=rr,e(ot,_n),b||_||(b=!0,Wt(bt))),_n},i.unstable_shouldYield=dn,i.unstable_wrapCallback=function(_n){var vn=s;return function(){var Sn=s;s=vn;try{return _n.apply(this,arguments)}finally{s=Sn}}}})(scheduler_production_min);scheduler.exports=scheduler_production_min;var schedulerExports=scheduler.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aa$1=reactExports,ca$1=schedulerExports;function p(i){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+i,o=1;o<arguments.length;o++)e+="&args[]="+encodeURIComponent(arguments[o]);return"Minified React error #"+i+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da$1=new Set,ea$1={};function fa$1(i,e){ha$1(i,e),ha$1(i+"Capture",e)}function ha$1(i,e){for(ea$1[i]=e,i=0;i<e.length;i++)da$1.add(e[i])}var ia$1=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la$1={},ma$1={};function oa$1(i){return ja.call(ma$1,i)?!0:ja.call(la$1,i)?!1:ka.test(i)?ma$1[i]=!0:(la$1[i]=!0,!1)}function pa$1(i,e,o,a){if(o!==null&&o.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return a?!1:o!==null?!o.acceptsBooleans:(i=i.toLowerCase().slice(0,5),i!=="data-"&&i!=="aria-");default:return!1}}function qa(i,e,o,a){if(e===null||typeof e>"u"||pa$1(i,e,o,a))return!0;if(a)return!1;if(o!==null)switch(o.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function v(i,e,o,a,d,g,h){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=a,this.attributeNamespace=d,this.mustUseProperty=o,this.propertyName=i,this.type=e,this.sanitizeURL=g,this.removeEmptyString=h}var z={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(i){z[i]=new v(i,0,!1,i,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(i){var e=i[0];z[e]=new v(e,1,!1,i[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(i){z[i]=new v(i,2,!1,i.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(i){z[i]=new v(i,2,!1,i,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(i){z[i]=new v(i,3,!1,i.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(i){z[i]=new v(i,3,!0,i,null,!1,!1)});["capture","download"].forEach(function(i){z[i]=new v(i,4,!1,i,null,!1,!1)});["cols","rows","size","span"].forEach(function(i){z[i]=new v(i,6,!1,i,null,!1,!1)});["rowSpan","start"].forEach(function(i){z[i]=new v(i,5,!1,i.toLowerCase(),null,!1,!1)});var ra$1=/[\-:]([a-z])/g;function sa$1(i){return i[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(i){var e=i.replace(ra$1,sa$1);z[e]=new v(e,1,!1,i,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(i){var e=i.replace(ra$1,sa$1);z[e]=new v(e,1,!1,i,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(i){var e=i.replace(ra$1,sa$1);z[e]=new v(e,1,!1,i,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(i){z[i]=new v(i,1,!1,i.toLowerCase(),null,!1,!1)});z.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(i){z[i]=new v(i,1,!1,i.toLowerCase(),null,!0,!0)});function ta$1(i,e,o,a){var d=z.hasOwnProperty(e)?z[e]:null;(d!==null?d.type!==0:a||!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N")&&(qa(e,o,d,a)&&(o=null),a||d===null?oa$1(e)&&(o===null?i.removeAttribute(e):i.setAttribute(e,""+o)):d.mustUseProperty?i[d.propertyName]=o===null?d.type===3?!1:"":o:(e=d.attributeName,a=d.attributeNamespace,o===null?i.removeAttribute(e):(d=d.type,o=d===3||d===4&&o===!0?"":""+o,a?i.setAttributeNS(a,e,o):i.setAttribute(e,o))))}var ua$1=aa$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va$1=Symbol.for("react.element"),wa$1=Symbol.for("react.portal"),ya$1=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca$1=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy"),Ia$1=Symbol.for("react.offscreen"),Ja=Symbol.iterator;function Ka(i){return i===null||typeof i!="object"?null:(i=Ja&&i[Ja]||i["@@iterator"],typeof i=="function"?i:null)}var A=Object.assign,La;function Ma(i){if(La===void 0)try{throw Error()}catch(o){var e=o.stack.trim().match(/\n( *(at )?)/);La=e&&e[1]||""}return`
`+La+i}var Na=!1;function Oa(i,e){if(!i||Na)return"";Na=!0;var o=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch(it){var a=it}Reflect.construct(i,[],e)}else{try{e.call()}catch(it){a=it}i.call(e.prototype)}else{try{throw Error()}catch(it){a=it}i()}}catch(it){if(it&&a&&typeof it.stack=="string"){for(var d=it.stack.split(`
`),g=a.stack.split(`
`),h=d.length-1,et=g.length-1;1<=h&&0<=et&&d[h]!==g[et];)et--;for(;1<=h&&0<=et;h--,et--)if(d[h]!==g[et]){if(h!==1||et!==1)do if(h--,et--,0>et||d[h]!==g[et]){var ot=`
`+d[h].replace(" at new "," at ");return i.displayName&&ot.includes("<anonymous>")&&(ot=ot.replace("<anonymous>",i.displayName)),ot}while(1<=h&&0<=et);break}}}finally{Na=!1,Error.prepareStackTrace=o}return(i=i?i.displayName||i.name:"")?Ma(i):""}function Pa(i){switch(i.tag){case 5:return Ma(i.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return i=Oa(i.type,!1),i;case 11:return i=Oa(i.type.render,!1),i;case 1:return i=Oa(i.type,!0),i;default:return""}}function Qa(i){if(i==null)return null;if(typeof i=="function")return i.displayName||i.name||null;if(typeof i=="string")return i;switch(i){case ya$1:return"Fragment";case wa$1:return"Portal";case Aa:return"Profiler";case za:return"StrictMode";case Ea:return"Suspense";case Fa:return"SuspenseList"}if(typeof i=="object")switch(i.$$typeof){case Ca$1:return(i.displayName||"Context")+".Consumer";case Ba:return(i._context.displayName||"Context")+".Provider";case Da:var e=i.render;return i=i.displayName,i||(i=e.displayName||e.name||"",i=i!==""?"ForwardRef("+i+")":"ForwardRef"),i;case Ga:return e=i.displayName||null,e!==null?e:Qa(i.type)||"Memo";case Ha:e=i._payload,i=i._init;try{return Qa(i(e))}catch{}}return null}function Ra(i){var e=i.type;switch(i.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return i=e.render,i=i.displayName||i.name||"",e.displayName||(i!==""?"ForwardRef("+i+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa(e);case 8:return e===za?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e}return null}function Sa$1(i){switch(typeof i){case"boolean":case"number":case"string":case"undefined":return i;case"object":return i;default:return""}}function Ta(i){var e=i.type;return(i=i.nodeName)&&i.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function Ua(i){var e=Ta(i)?"checked":"value",o=Object.getOwnPropertyDescriptor(i.constructor.prototype,e),a=""+i[e];if(!i.hasOwnProperty(e)&&typeof o<"u"&&typeof o.get=="function"&&typeof o.set=="function"){var d=o.get,g=o.set;return Object.defineProperty(i,e,{configurable:!0,get:function(){return d.call(this)},set:function(h){a=""+h,g.call(this,h)}}),Object.defineProperty(i,e,{enumerable:o.enumerable}),{getValue:function(){return a},setValue:function(h){a=""+h},stopTracking:function(){i._valueTracker=null,delete i[e]}}}}function Va(i){i._valueTracker||(i._valueTracker=Ua(i))}function Wa(i){if(!i)return!1;var e=i._valueTracker;if(!e)return!0;var o=e.getValue(),a="";return i&&(a=Ta(i)?i.checked?"true":"false":i.value),i=a,i!==o?(e.setValue(i),!0):!1}function Xa(i){if(i=i||(typeof document<"u"?document:void 0),typeof i>"u")return null;try{return i.activeElement||i.body}catch{return i.body}}function Ya(i,e){var o=e.checked;return A({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:o??i._wrapperState.initialChecked})}function Za(i,e){var o=e.defaultValue==null?"":e.defaultValue,a=e.checked!=null?e.checked:e.defaultChecked;o=Sa$1(e.value!=null?e.value:o),i._wrapperState={initialChecked:a,initialValue:o,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function ab(i,e){e=e.checked,e!=null&&ta$1(i,"checked",e,!1)}function bb(i,e){ab(i,e);var o=Sa$1(e.value),a=e.type;if(o!=null)a==="number"?(o===0&&i.value===""||i.value!=o)&&(i.value=""+o):i.value!==""+o&&(i.value=""+o);else if(a==="submit"||a==="reset"){i.removeAttribute("value");return}e.hasOwnProperty("value")?cb(i,e.type,o):e.hasOwnProperty("defaultValue")&&cb(i,e.type,Sa$1(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(i.defaultChecked=!!e.defaultChecked)}function db(i,e,o){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var a=e.type;if(!(a!=="submit"&&a!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+i._wrapperState.initialValue,o||e===i.value||(i.value=e),i.defaultValue=e}o=i.name,o!==""&&(i.name=""),i.defaultChecked=!!i._wrapperState.initialChecked,o!==""&&(i.name=o)}function cb(i,e,o){(e!=="number"||Xa(i.ownerDocument)!==i)&&(o==null?i.defaultValue=""+i._wrapperState.initialValue:i.defaultValue!==""+o&&(i.defaultValue=""+o))}var eb=Array.isArray;function fb(i,e,o,a){if(i=i.options,e){e={};for(var d=0;d<o.length;d++)e["$"+o[d]]=!0;for(o=0;o<i.length;o++)d=e.hasOwnProperty("$"+i[o].value),i[o].selected!==d&&(i[o].selected=d),d&&a&&(i[o].defaultSelected=!0)}else{for(o=""+Sa$1(o),e=null,d=0;d<i.length;d++){if(i[d].value===o){i[d].selected=!0,a&&(i[d].defaultSelected=!0);return}e!==null||i[d].disabled||(e=i[d])}e!==null&&(e.selected=!0)}}function gb(i,e){if(e.dangerouslySetInnerHTML!=null)throw Error(p(91));return A({},e,{value:void 0,defaultValue:void 0,children:""+i._wrapperState.initialValue})}function hb(i,e){var o=e.value;if(o==null){if(o=e.children,e=e.defaultValue,o!=null){if(e!=null)throw Error(p(92));if(eb(o)){if(1<o.length)throw Error(p(93));o=o[0]}e=o}e==null&&(e=""),o=e}i._wrapperState={initialValue:Sa$1(o)}}function ib(i,e){var o=Sa$1(e.value),a=Sa$1(e.defaultValue);o!=null&&(o=""+o,o!==i.value&&(i.value=o),e.defaultValue==null&&i.defaultValue!==o&&(i.defaultValue=o)),a!=null&&(i.defaultValue=""+a)}function jb(i){var e=i.textContent;e===i._wrapperState.initialValue&&e!==""&&e!==null&&(i.value=e)}function kb(i){switch(i){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lb(i,e){return i==null||i==="http://www.w3.org/1999/xhtml"?kb(e):i==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":i}var mb,nb=function(i){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(e,o,a,d){MSApp.execUnsafeLocalFunction(function(){return i(e,o,a,d)})}:i}(function(i,e){if(i.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in i)i.innerHTML=e;else{for(mb=mb||document.createElement("div"),mb.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=mb.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;e.firstChild;)i.appendChild(e.firstChild)}});function ob(i,e){if(e){var o=i.firstChild;if(o&&o===i.lastChild&&o.nodeType===3){o.nodeValue=e;return}}i.textContent=e}var pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(i){qb.forEach(function(e){e=e+i.charAt(0).toUpperCase()+i.substring(1),pb[e]=pb[i]})});function rb(i,e,o){return e==null||typeof e=="boolean"||e===""?"":o||typeof e!="number"||e===0||pb.hasOwnProperty(i)&&pb[i]?(""+e).trim():e+"px"}function sb(i,e){i=i.style;for(var o in e)if(e.hasOwnProperty(o)){var a=o.indexOf("--")===0,d=rb(o,e[o],a);o==="float"&&(o="cssFloat"),a?i.setProperty(o,d):i[o]=d}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ub(i,e){if(e){if(tb[i]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(p(137,i));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(p(60));if(typeof e.dangerouslySetInnerHTML!="object"||!("__html"in e.dangerouslySetInnerHTML))throw Error(p(61))}if(e.style!=null&&typeof e.style!="object")throw Error(p(62))}}function vb(i,e){if(i.indexOf("-")===-1)return typeof e.is=="string";switch(i){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wb=null;function xb(i){return i=i.target||i.srcElement||window,i.correspondingUseElement&&(i=i.correspondingUseElement),i.nodeType===3?i.parentNode:i}var yb=null,zb=null,Ab=null;function Bb(i){if(i=Cb(i)){if(typeof yb!="function")throw Error(p(280));var e=i.stateNode;e&&(e=Db(e),yb(i.stateNode,i.type,e))}}function Eb(i){zb?Ab?Ab.push(i):Ab=[i]:zb=i}function Fb(){if(zb){var i=zb,e=Ab;if(Ab=zb=null,Bb(i),e)for(i=0;i<e.length;i++)Bb(e[i])}}function Gb(i,e){return i(e)}function Hb(){}var Ib=!1;function Jb(i,e,o){if(Ib)return i(e,o);Ib=!0;try{return Gb(i,e,o)}finally{Ib=!1,(zb!==null||Ab!==null)&&(Hb(),Fb())}}function Kb(i,e){var o=i.stateNode;if(o===null)return null;var a=Db(o);if(a===null)return null;o=a[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(i=i.type,a=!(i==="button"||i==="input"||i==="select"||i==="textarea")),i=!a;break e;default:i=!1}if(i)return null;if(o&&typeof o!="function")throw Error(p(231,e,typeof o));return o}var Lb=!1;if(ia$1)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0}}),window.addEventListener("test",Mb,Mb),window.removeEventListener("test",Mb,Mb)}catch{Lb=!1}function Nb(i,e,o,a,d,g,h,et,ot){var it=Array.prototype.slice.call(arguments,3);try{e.apply(o,it)}catch($){this.onError($)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(i){Ob=!0,Pb=i}};function Tb(i,e,o,a,d,g,h,et,ot){Ob=!1,Pb=null,Nb.apply(Sb,arguments)}function Ub(i,e,o,a,d,g,h,et,ot){if(Tb.apply(this,arguments),Ob){if(Ob){var it=Pb;Ob=!1,Pb=null}else throw Error(p(198));Qb||(Qb=!0,Rb=it)}}function Vb(i){var e=i,o=i;if(i.alternate)for(;e.return;)e=e.return;else{i=e;do e=i,e.flags&4098&&(o=e.return),i=e.return;while(i)}return e.tag===3?o:null}function Wb(i){if(i.tag===13){var e=i.memoizedState;if(e===null&&(i=i.alternate,i!==null&&(e=i.memoizedState)),e!==null)return e.dehydrated}return null}function Xb(i){if(Vb(i)!==i)throw Error(p(188))}function Yb(i){var e=i.alternate;if(!e){if(e=Vb(i),e===null)throw Error(p(188));return e!==i?null:i}for(var o=i,a=e;;){var d=o.return;if(d===null)break;var g=d.alternate;if(g===null){if(a=d.return,a!==null){o=a;continue}break}if(d.child===g.child){for(g=d.child;g;){if(g===o)return Xb(d),i;if(g===a)return Xb(d),e;g=g.sibling}throw Error(p(188))}if(o.return!==a.return)o=d,a=g;else{for(var h=!1,et=d.child;et;){if(et===o){h=!0,o=d,a=g;break}if(et===a){h=!0,a=d,o=g;break}et=et.sibling}if(!h){for(et=g.child;et;){if(et===o){h=!0,o=g,a=d;break}if(et===a){h=!0,a=g,o=d;break}et=et.sibling}if(!h)throw Error(p(189))}}if(o.alternate!==a)throw Error(p(190))}if(o.tag!==3)throw Error(p(188));return o.stateNode.current===o?i:e}function Zb(i){return i=Yb(i),i!==null?$b(i):null}function $b(i){if(i.tag===5||i.tag===6)return i;for(i=i.child;i!==null;){var e=$b(i);if(e!==null)return e;i=i.sibling}return null}var ac$1=ca$1.unstable_scheduleCallback,bc$1=ca$1.unstable_cancelCallback,cc$1=ca$1.unstable_shouldYield,dc$1=ca$1.unstable_requestPaint,B=ca$1.unstable_now,ec=ca$1.unstable_getCurrentPriorityLevel,fc$1=ca$1.unstable_ImmediatePriority,gc$1=ca$1.unstable_UserBlockingPriority,hc=ca$1.unstable_NormalPriority,ic$1=ca$1.unstable_LowPriority,jc$1=ca$1.unstable_IdlePriority,kc$1=null,lc$1=null;function mc$1(i){if(lc$1&&typeof lc$1.onCommitFiberRoot=="function")try{lc$1.onCommitFiberRoot(kc$1,i,void 0,(i.current.flags&128)===128)}catch{}}var oc$1=Math.clz32?Math.clz32:nc$1,pc$1=Math.log,qc$1=Math.LN2;function nc$1(i){return i>>>=0,i===0?32:31-(pc$1(i)/qc$1|0)|0}var rc=64,sc$1=4194304;function tc(i){switch(i&-i){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return i&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return i&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return i}}function uc$1(i,e){var o=i.pendingLanes;if(o===0)return 0;var a=0,d=i.suspendedLanes,g=i.pingedLanes,h=o&268435455;if(h!==0){var et=h&~d;et!==0?a=tc(et):(g&=h,g!==0&&(a=tc(g)))}else h=o&~d,h!==0?a=tc(h):g!==0&&(a=tc(g));if(a===0)return 0;if(e!==0&&e!==a&&!(e&d)&&(d=a&-a,g=e&-e,d>=g||d===16&&(g&4194240)!==0))return e;if(a&4&&(a|=o&16),e=i.entangledLanes,e!==0)for(i=i.entanglements,e&=a;0<e;)o=31-oc$1(e),d=1<<o,a|=i[o],e&=~d;return a}function vc$1(i,e){switch(i){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function wc$1(i,e){for(var o=i.suspendedLanes,a=i.pingedLanes,d=i.expirationTimes,g=i.pendingLanes;0<g;){var h=31-oc$1(g),et=1<<h,ot=d[h];ot===-1?(!(et&o)||et&a)&&(d[h]=vc$1(et,e)):ot<=e&&(i.expiredLanes|=et),g&=~et}}function xc$1(i){return i=i.pendingLanes&-1073741825,i!==0?i:i&1073741824?1073741824:0}function yc$1(){var i=rc;return rc<<=1,!(rc&4194240)&&(rc=64),i}function zc$1(i){for(var e=[],o=0;31>o;o++)e.push(i);return e}function Ac$1(i,e,o){i.pendingLanes|=e,e!==536870912&&(i.suspendedLanes=0,i.pingedLanes=0),i=i.eventTimes,e=31-oc$1(e),i[e]=o}function Bc$1(i,e){var o=i.pendingLanes&~e;i.pendingLanes=e,i.suspendedLanes=0,i.pingedLanes=0,i.expiredLanes&=e,i.mutableReadLanes&=e,i.entangledLanes&=e,e=i.entanglements;var a=i.eventTimes;for(i=i.expirationTimes;0<o;){var d=31-oc$1(o),g=1<<d;e[d]=0,a[d]=-1,i[d]=-1,o&=~g}}function Cc$1(i,e){var o=i.entangledLanes|=e;for(i=i.entanglements;o;){var a=31-oc$1(o),d=1<<a;d&e|i[a]&e&&(i[a]|=e),o&=~d}}var C=0;function Dc$1(i){return i&=-i,1<i?4<i?i&268435455?16:536870912:4:1}var Ec$1,Fc$1,Gc$1,Hc$1,Ic$1,Jc$1=!1,Kc$1=[],Lc$1=null,Mc$1=null,Nc$1=null,Oc$1=new Map,Pc$1=new Map,Qc$1=[],Rc$1="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Sc$1(i,e){switch(i){case"focusin":case"focusout":Lc$1=null;break;case"dragenter":case"dragleave":Mc$1=null;break;case"mouseover":case"mouseout":Nc$1=null;break;case"pointerover":case"pointerout":Oc$1.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":Pc$1.delete(e.pointerId)}}function Tc$1(i,e,o,a,d,g){return i===null||i.nativeEvent!==g?(i={blockedOn:e,domEventName:o,eventSystemFlags:a,nativeEvent:g,targetContainers:[d]},e!==null&&(e=Cb(e),e!==null&&Fc$1(e)),i):(i.eventSystemFlags|=a,e=i.targetContainers,d!==null&&e.indexOf(d)===-1&&e.push(d),i)}function Uc$1(i,e,o,a,d){switch(e){case"focusin":return Lc$1=Tc$1(Lc$1,i,e,o,a,d),!0;case"dragenter":return Mc$1=Tc$1(Mc$1,i,e,o,a,d),!0;case"mouseover":return Nc$1=Tc$1(Nc$1,i,e,o,a,d),!0;case"pointerover":var g=d.pointerId;return Oc$1.set(g,Tc$1(Oc$1.get(g)||null,i,e,o,a,d)),!0;case"gotpointercapture":return g=d.pointerId,Pc$1.set(g,Tc$1(Pc$1.get(g)||null,i,e,o,a,d)),!0}return!1}function Vc$1(i){var e=Wc$1(i.target);if(e!==null){var o=Vb(e);if(o!==null){if(e=o.tag,e===13){if(e=Wb(o),e!==null){i.blockedOn=e,Ic$1(i.priority,function(){Gc$1(o)});return}}else if(e===3&&o.stateNode.current.memoizedState.isDehydrated){i.blockedOn=o.tag===3?o.stateNode.containerInfo:null;return}}}i.blockedOn=null}function Xc$1(i){if(i.blockedOn!==null)return!1;for(var e=i.targetContainers;0<e.length;){var o=Yc$1(i.domEventName,i.eventSystemFlags,e[0],i.nativeEvent);if(o===null){o=i.nativeEvent;var a=new o.constructor(o.type,o);wb=a,o.target.dispatchEvent(a),wb=null}else return e=Cb(o),e!==null&&Fc$1(e),i.blockedOn=o,!1;e.shift()}return!0}function Zc$1(i,e,o){Xc$1(i)&&o.delete(e)}function $c$1(){Jc$1=!1,Lc$1!==null&&Xc$1(Lc$1)&&(Lc$1=null),Mc$1!==null&&Xc$1(Mc$1)&&(Mc$1=null),Nc$1!==null&&Xc$1(Nc$1)&&(Nc$1=null),Oc$1.forEach(Zc$1),Pc$1.forEach(Zc$1)}function ad$1(i,e){i.blockedOn===e&&(i.blockedOn=null,Jc$1||(Jc$1=!0,ca$1.unstable_scheduleCallback(ca$1.unstable_NormalPriority,$c$1)))}function bd$1(i){function e(d){return ad$1(d,i)}if(0<Kc$1.length){ad$1(Kc$1[0],i);for(var o=1;o<Kc$1.length;o++){var a=Kc$1[o];a.blockedOn===i&&(a.blockedOn=null)}}for(Lc$1!==null&&ad$1(Lc$1,i),Mc$1!==null&&ad$1(Mc$1,i),Nc$1!==null&&ad$1(Nc$1,i),Oc$1.forEach(e),Pc$1.forEach(e),o=0;o<Qc$1.length;o++)a=Qc$1[o],a.blockedOn===i&&(a.blockedOn=null);for(;0<Qc$1.length&&(o=Qc$1[0],o.blockedOn===null);)Vc$1(o),o.blockedOn===null&&Qc$1.shift()}var cd$1=ua$1.ReactCurrentBatchConfig,dd$1=!0;function ed$1(i,e,o,a){var d=C,g=cd$1.transition;cd$1.transition=null;try{C=1,fd$1(i,e,o,a)}finally{C=d,cd$1.transition=g}}function gd$1(i,e,o,a){var d=C,g=cd$1.transition;cd$1.transition=null;try{C=4,fd$1(i,e,o,a)}finally{C=d,cd$1.transition=g}}function fd$1(i,e,o,a){if(dd$1){var d=Yc$1(i,e,o,a);if(d===null)hd$1(i,e,a,id$1,o),Sc$1(i,a);else if(Uc$1(d,i,e,o,a))a.stopPropagation();else if(Sc$1(i,a),e&4&&-1<Rc$1.indexOf(i)){for(;d!==null;){var g=Cb(d);if(g!==null&&Ec$1(g),g=Yc$1(i,e,o,a),g===null&&hd$1(i,e,a,id$1,o),g===d)break;d=g}d!==null&&a.stopPropagation()}else hd$1(i,e,a,null,o)}}var id$1=null;function Yc$1(i,e,o,a){if(id$1=null,i=xb(a),i=Wc$1(i),i!==null)if(e=Vb(i),e===null)i=null;else if(o=e.tag,o===13){if(i=Wb(e),i!==null)return i;i=null}else if(o===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;i=null}else e!==i&&(i=null);return id$1=i,null}function jd$1(i){switch(i){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(ec()){case fc$1:return 1;case gc$1:return 4;case hc:case ic$1:return 16;case jc$1:return 536870912;default:return 16}default:return 16}}var kd$1=null,ld$1=null,md$1=null;function nd$1(){if(md$1)return md$1;var i,e=ld$1,o=e.length,a,d="value"in kd$1?kd$1.value:kd$1.textContent,g=d.length;for(i=0;i<o&&e[i]===d[i];i++);var h=o-i;for(a=1;a<=h&&e[o-a]===d[g-a];a++);return md$1=d.slice(i,1<a?1-a:void 0)}function od$1(i){var e=i.keyCode;return"charCode"in i?(i=i.charCode,i===0&&e===13&&(i=13)):i=e,i===10&&(i=13),32<=i||i===13?i:0}function pd$1(){return!0}function qd$1(){return!1}function rd$1(i){function e(o,a,d,g,h){this._reactName=o,this._targetInst=d,this.type=a,this.nativeEvent=g,this.target=h,this.currentTarget=null;for(var et in i)i.hasOwnProperty(et)&&(o=i[et],this[et]=o?o(g):g[et]);return this.isDefaultPrevented=(g.defaultPrevented!=null?g.defaultPrevented:g.returnValue===!1)?pd$1:qd$1,this.isPropagationStopped=qd$1,this}return A(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var o=this.nativeEvent;o&&(o.preventDefault?o.preventDefault():typeof o.returnValue!="unknown"&&(o.returnValue=!1),this.isDefaultPrevented=pd$1)},stopPropagation:function(){var o=this.nativeEvent;o&&(o.stopPropagation?o.stopPropagation():typeof o.cancelBubble!="unknown"&&(o.cancelBubble=!0),this.isPropagationStopped=pd$1)},persist:function(){},isPersistent:pd$1}),e}var sd$1={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(i){return i.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td$1=rd$1(sd$1),ud$1=A({},sd$1,{view:0,detail:0}),vd$1=rd$1(ud$1),wd$1,xd$1,yd$1,Ad$1=A({},ud$1,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd$1,button:0,buttons:0,relatedTarget:function(i){return i.relatedTarget===void 0?i.fromElement===i.srcElement?i.toElement:i.fromElement:i.relatedTarget},movementX:function(i){return"movementX"in i?i.movementX:(i!==yd$1&&(yd$1&&i.type==="mousemove"?(wd$1=i.screenX-yd$1.screenX,xd$1=i.screenY-yd$1.screenY):xd$1=wd$1=0,yd$1=i),wd$1)},movementY:function(i){return"movementY"in i?i.movementY:xd$1}}),Bd$1=rd$1(Ad$1),Cd$1=A({},Ad$1,{dataTransfer:0}),Dd$1=rd$1(Cd$1),Ed$1=A({},ud$1,{relatedTarget:0}),Fd$1=rd$1(Ed$1),Gd$1=A({},sd$1,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd$1=rd$1(Gd$1),Id$1=A({},sd$1,{clipboardData:function(i){return"clipboardData"in i?i.clipboardData:window.clipboardData}}),Jd=rd$1(Id$1),Kd$1=A({},sd$1,{data:0}),Ld$1=rd$1(Kd$1),Md$1={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd$1={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od$1={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd$1(i){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(i):(i=Od$1[i])?!!e[i]:!1}function zd$1(){return Pd$1}var Qd=A({},ud$1,{key:function(i){if(i.key){var e=Md$1[i.key]||i.key;if(e!=="Unidentified")return e}return i.type==="keypress"?(i=od$1(i),i===13?"Enter":String.fromCharCode(i)):i.type==="keydown"||i.type==="keyup"?Nd$1[i.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd$1,charCode:function(i){return i.type==="keypress"?od$1(i):0},keyCode:function(i){return i.type==="keydown"||i.type==="keyup"?i.keyCode:0},which:function(i){return i.type==="keypress"?od$1(i):i.type==="keydown"||i.type==="keyup"?i.keyCode:0}}),Rd$1=rd$1(Qd),Sd$1=A({},Ad$1,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td$1=rd$1(Sd$1),Ud$1=A({},ud$1,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd$1}),Vd$1=rd$1(Ud$1),Wd$1=A({},sd$1,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd$1=rd$1(Wd$1),Yd$1=A({},Ad$1,{deltaX:function(i){return"deltaX"in i?i.deltaX:"wheelDeltaX"in i?-i.wheelDeltaX:0},deltaY:function(i){return"deltaY"in i?i.deltaY:"wheelDeltaY"in i?-i.wheelDeltaY:"wheelDelta"in i?-i.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd$1(Yd$1),$d$1=[9,13,27,32],ae=ia$1&&"CompositionEvent"in window,be=null;ia$1&&"documentMode"in document&&(be=document.documentMode);var ce=ia$1&&"TextEvent"in window&&!be,de=ia$1&&(!ae||be&&8<be&&11>=be),ee=" ",fe$1=!1;function ge(i,e){switch(i){case"keyup":return $d$1.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function he(i){return i=i.detail,typeof i=="object"&&"data"in i?i.data:null}var ie=!1;function je(i,e){switch(i){case"compositionend":return he(e);case"keypress":return e.which!==32?null:(fe$1=!0,ee);case"textInput":return i=e.data,i===ee&&fe$1?null:i;default:return null}}function ke$1(i,e){if(ie)return i==="compositionend"||!ae&&ge(i,e)?(i=nd$1(),md$1=ld$1=kd$1=null,ie=!1,i):null;switch(i){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return de&&e.locale!=="ko"?null:e.data;default:return null}}var le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(i){var e=i&&i.nodeName&&i.nodeName.toLowerCase();return e==="input"?!!le[i.type]:e==="textarea"}function ne(i,e,o,a){Eb(a),e=oe(e,"onChange"),0<e.length&&(o=new td$1("onChange","change",null,o,a),i.push({event:o,listeners:e}))}var pe=null,qe$1=null;function re(i){se(i,0)}function te(i){var e=ue(i);if(Wa(e))return i}function ve(i,e){if(i==="change")return e}var we$1=!1;if(ia$1){var xe$1;if(ia$1){var ye$1="oninput"in document;if(!ye$1){var ze=document.createElement("div");ze.setAttribute("oninput","return;"),ye$1=typeof ze.oninput=="function"}xe$1=ye$1}else xe$1=!1;we$1=xe$1&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be$1),qe$1=pe=null)}function Be$1(i){if(i.propertyName==="value"&&te(qe$1)){var e=[];ne(e,qe$1,i,xb(i)),Jb(re,e)}}function Ce(i,e,o){i==="focusin"?(Ae(),pe=e,qe$1=o,pe.attachEvent("onpropertychange",Be$1)):i==="focusout"&&Ae()}function De(i){if(i==="selectionchange"||i==="keyup"||i==="keydown")return te(qe$1)}function Ee(i,e){if(i==="click")return te(e)}function Fe$1(i,e){if(i==="input"||i==="change")return te(e)}function Ge(i,e){return i===e&&(i!==0||1/i===1/e)||i!==i&&e!==e}var He=typeof Object.is=="function"?Object.is:Ge;function Ie(i,e){if(He(i,e))return!0;if(typeof i!="object"||i===null||typeof e!="object"||e===null)return!1;var o=Object.keys(i),a=Object.keys(e);if(o.length!==a.length)return!1;for(a=0;a<o.length;a++){var d=o[a];if(!ja.call(e,d)||!He(i[d],e[d]))return!1}return!0}function Je(i){for(;i&&i.firstChild;)i=i.firstChild;return i}function Ke(i,e){var o=Je(i);i=0;for(var a;o;){if(o.nodeType===3){if(a=i+o.textContent.length,i<=e&&a>=e)return{node:o,offset:e-i};i=a}e:{for(;o;){if(o.nextSibling){o=o.nextSibling;break e}o=o.parentNode}o=void 0}o=Je(o)}}function Le(i,e){return i&&e?i===e?!0:i&&i.nodeType===3?!1:e&&e.nodeType===3?Le(i,e.parentNode):"contains"in i?i.contains(e):i.compareDocumentPosition?!!(i.compareDocumentPosition(e)&16):!1:!1}function Me(){for(var i=window,e=Xa();e instanceof i.HTMLIFrameElement;){try{var o=typeof e.contentWindow.location.href=="string"}catch{o=!1}if(o)i=e.contentWindow;else break;e=Xa(i.document)}return e}function Ne$1(i){var e=i&&i.nodeName&&i.nodeName.toLowerCase();return e&&(e==="input"&&(i.type==="text"||i.type==="search"||i.type==="tel"||i.type==="url"||i.type==="password")||e==="textarea"||i.contentEditable==="true")}function Oe(i){var e=Me(),o=i.focusedElem,a=i.selectionRange;if(e!==o&&o&&o.ownerDocument&&Le(o.ownerDocument.documentElement,o)){if(a!==null&&Ne$1(o)){if(e=a.start,i=a.end,i===void 0&&(i=e),"selectionStart"in o)o.selectionStart=e,o.selectionEnd=Math.min(i,o.value.length);else if(i=(e=o.ownerDocument||document)&&e.defaultView||window,i.getSelection){i=i.getSelection();var d=o.textContent.length,g=Math.min(a.start,d);a=a.end===void 0?g:Math.min(a.end,d),!i.extend&&g>a&&(d=a,a=g,g=d),d=Ke(o,g);var h=Ke(o,a);d&&h&&(i.rangeCount!==1||i.anchorNode!==d.node||i.anchorOffset!==d.offset||i.focusNode!==h.node||i.focusOffset!==h.offset)&&(e=e.createRange(),e.setStart(d.node,d.offset),i.removeAllRanges(),g>a?(i.addRange(e),i.extend(h.node,h.offset)):(e.setEnd(h.node,h.offset),i.addRange(e)))}}for(e=[],i=o;i=i.parentNode;)i.nodeType===1&&e.push({element:i,left:i.scrollLeft,top:i.scrollTop});for(typeof o.focus=="function"&&o.focus(),o=0;o<e.length;o++)i=e[o],i.element.scrollLeft=i.left,i.element.scrollTop=i.top}}var Pe$1=ia$1&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;function Ue$1(i,e,o){var a=o.window===o?o.document:o.nodeType===9?o:o.ownerDocument;Te||Qe==null||Qe!==Xa(a)||(a=Qe,"selectionStart"in a&&Ne$1(a)?a={start:a.selectionStart,end:a.selectionEnd}:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection(),a={anchorNode:a.anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset}),Se&&Ie(Se,a)||(Se=a,a=oe(Re,"onSelect"),0<a.length&&(e=new td$1("onSelect","select",null,e,o),i.push({event:e,listeners:a}),e.target=Qe)))}function Ve(i,e){var o={};return o[i.toLowerCase()]=e.toLowerCase(),o["Webkit"+i]="webkit"+e,o["Moz"+i]="moz"+e,o}var We$1={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye={};ia$1&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We$1.animationend.animation,delete We$1.animationiteration.animation,delete We$1.animationstart.animation),"TransitionEvent"in window||delete We$1.transitionend.transition);function Ze$1(i){if(Xe[i])return Xe[i];if(!We$1[i])return i;var e=We$1[i],o;for(o in e)if(e.hasOwnProperty(o)&&o in Ye)return Xe[i]=e[o];return i}var $e=Ze$1("animationend"),af$1=Ze$1("animationiteration"),bf=Ze$1("animationstart"),cf=Ze$1("transitionend"),df=new Map,ef$1="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ff$1(i,e){df.set(i,e),fa$1(e,[i])}for(var gf=0;gf<ef$1.length;gf++){var hf$1=ef$1[gf],jf=hf$1.toLowerCase(),kf=hf$1[0].toUpperCase()+hf$1.slice(1);ff$1(jf,"on"+kf)}ff$1($e,"onAnimationEnd");ff$1(af$1,"onAnimationIteration");ff$1(bf,"onAnimationStart");ff$1("dblclick","onDoubleClick");ff$1("focusin","onFocus");ff$1("focusout","onBlur");ff$1(cf,"onTransitionEnd");ha$1("onMouseEnter",["mouseout","mouseover"]);ha$1("onMouseLeave",["mouseout","mouseover"]);ha$1("onPointerEnter",["pointerout","pointerover"]);ha$1("onPointerLeave",["pointerout","pointerover"]);fa$1("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa$1("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa$1("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa$1("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa$1("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));fa$1("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf$1="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf$1=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf$1));function nf$1(i,e,o){var a=i.type||"unknown-event";i.currentTarget=o,Ub(a,e,void 0,i),i.currentTarget=null}function se(i,e){e=(e&4)!==0;for(var o=0;o<i.length;o++){var a=i[o],d=a.event;a=a.listeners;e:{var g=void 0;if(e)for(var h=a.length-1;0<=h;h--){var et=a[h],ot=et.instance,it=et.currentTarget;if(et=et.listener,ot!==g&&d.isPropagationStopped())break e;nf$1(d,et,it),g=ot}else for(h=0;h<a.length;h++){if(et=a[h],ot=et.instance,it=et.currentTarget,et=et.listener,ot!==g&&d.isPropagationStopped())break e;nf$1(d,et,it),g=ot}}}if(Qb)throw i=Rb,Qb=!1,Rb=null,i}function D(i,e){var o=e[of$1];o===void 0&&(o=e[of$1]=new Set);var a=i+"__bubble";o.has(a)||(pf$1(e,i,2,!1),o.add(a))}function qf(i,e,o){var a=0;e&&(a|=4),pf$1(o,i,a,e)}var rf$1="_reactListening"+Math.random().toString(36).slice(2);function sf$1(i){if(!i[rf$1]){i[rf$1]=!0,da$1.forEach(function(o){o!=="selectionchange"&&(mf$1.has(o)||qf(o,!1,i),qf(o,!0,i))});var e=i.nodeType===9?i:i.ownerDocument;e===null||e[rf$1]||(e[rf$1]=!0,qf("selectionchange",!1,e))}}function pf$1(i,e,o,a){switch(jd$1(e)){case 1:var d=ed$1;break;case 4:d=gd$1;break;default:d=fd$1}o=d.bind(null,e,o,i),d=void 0,!Lb||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(d=!0),a?d!==void 0?i.addEventListener(e,o,{capture:!0,passive:d}):i.addEventListener(e,o,!0):d!==void 0?i.addEventListener(e,o,{passive:d}):i.addEventListener(e,o,!1)}function hd$1(i,e,o,a,d){var g=a;if(!(e&1)&&!(e&2)&&a!==null)e:for(;;){if(a===null)return;var h=a.tag;if(h===3||h===4){var et=a.stateNode.containerInfo;if(et===d||et.nodeType===8&&et.parentNode===d)break;if(h===4)for(h=a.return;h!==null;){var ot=h.tag;if((ot===3||ot===4)&&(ot=h.stateNode.containerInfo,ot===d||ot.nodeType===8&&ot.parentNode===d))return;h=h.return}for(;et!==null;){if(h=Wc$1(et),h===null)return;if(ot=h.tag,ot===5||ot===6){a=g=h;continue e}et=et.parentNode}}a=a.return}Jb(function(){var it=g,$=xb(o),c=[];e:{var s=df.get(i);if(s!==void 0){var _=td$1,b=i;switch(i){case"keypress":if(od$1(o)===0)break e;case"keydown":case"keyup":_=Rd$1;break;case"focusin":b="focus",_=Fd$1;break;case"focusout":b="blur",_=Fd$1;break;case"beforeblur":case"afterblur":_=Fd$1;break;case"click":if(o.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":_=Bd$1;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":_=Dd$1;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":_=Vd$1;break;case $e:case af$1:case bf:_=Hd$1;break;case cf:_=Xd$1;break;case"scroll":_=vd$1;break;case"wheel":_=Zd;break;case"copy":case"cut":case"paste":_=Jd;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":_=Td$1}var st=(e&4)!==0,dt=!st&&i==="scroll",ct=st?s!==null?s+"Capture":null:s;st=[];for(var pt=it,ft;pt!==null;){ft=pt;var mt=ft.stateNode;if(ft.tag===5&&mt!==null&&(ft=mt,ct!==null&&(mt=Kb(pt,ct),mt!=null&&st.push(tf$1(pt,mt,ft)))),dt)break;pt=pt.return}0<st.length&&(s=new _(s,b,null,o,$),c.push({event:s,listeners:st}))}}if(!(e&7)){e:{if(s=i==="mouseover"||i==="pointerover",_=i==="mouseout"||i==="pointerout",s&&o!==wb&&(b=o.relatedTarget||o.fromElement)&&(Wc$1(b)||b[uf$1]))break e;if((_||s)&&(s=$.window===$?$:(s=$.ownerDocument)?s.defaultView||s.parentWindow:window,_?(b=o.relatedTarget||o.toElement,_=it,b=b?Wc$1(b):null,b!==null&&(dt=Vb(b),b!==dt||b.tag!==5&&b.tag!==6)&&(b=null)):(_=null,b=it),_!==b)){if(st=Bd$1,mt="onMouseLeave",ct="onMouseEnter",pt="mouse",(i==="pointerout"||i==="pointerover")&&(st=Td$1,mt="onPointerLeave",ct="onPointerEnter",pt="pointer"),dt=_==null?s:ue(_),ft=b==null?s:ue(b),s=new st(mt,pt+"leave",_,o,$),s.target=dt,s.relatedTarget=ft,mt=null,Wc$1($)===it&&(st=new st(ct,pt+"enter",b,o,$),st.target=ft,st.relatedTarget=dt,mt=st),dt=mt,_&&b)t:{for(st=_,ct=b,pt=0,ft=st;ft;ft=vf(ft))pt++;for(ft=0,mt=ct;mt;mt=vf(mt))ft++;for(;0<pt-ft;)st=vf(st),pt--;for(;0<ft-pt;)ct=vf(ct),ft--;for(;pt--;){if(st===ct||ct!==null&&st===ct.alternate)break t;st=vf(st),ct=vf(ct)}st=null}else st=null;_!==null&&wf(c,s,_,st,!1),b!==null&&dt!==null&&wf(c,dt,b,st,!0)}}e:{if(s=it?ue(it):window,_=s.nodeName&&s.nodeName.toLowerCase(),_==="select"||_==="input"&&s.type==="file")var bt=ve;else if(me(s))if(we$1)bt=Fe$1;else{bt=De;var $t=Ce}else(_=s.nodeName)&&_.toLowerCase()==="input"&&(s.type==="checkbox"||s.type==="radio")&&(bt=Ee);if(bt&&(bt=bt(i,it))){ne(c,bt,o,$);break e}$t&&$t(i,s,it),i==="focusout"&&($t=s._wrapperState)&&$t.controlled&&s.type==="number"&&cb(s,"number",s.value)}switch($t=it?ue(it):window,i){case"focusin":(me($t)||$t.contentEditable==="true")&&(Qe=$t,Re=it,Se=null);break;case"focusout":Se=Re=Qe=null;break;case"mousedown":Te=!0;break;case"contextmenu":case"mouseup":case"dragend":Te=!1,Ue$1(c,o,$);break;case"selectionchange":if(Pe$1)break;case"keydown":case"keyup":Ue$1(c,o,$)}var Ct;if(ae)e:{switch(i){case"compositionstart":var It="onCompositionStart";break e;case"compositionend":It="onCompositionEnd";break e;case"compositionupdate":It="onCompositionUpdate";break e}It=void 0}else ie?ge(i,o)&&(It="onCompositionEnd"):i==="keydown"&&o.keyCode===229&&(It="onCompositionStart");It&&(de&&o.locale!=="ko"&&(ie||It!=="onCompositionStart"?It==="onCompositionEnd"&&ie&&(Ct=nd$1()):(kd$1=$,ld$1="value"in kd$1?kd$1.value:kd$1.textContent,ie=!0)),$t=oe(it,It),0<$t.length&&(It=new Ld$1(It,i,null,o,$),c.push({event:It,listeners:$t}),Ct?It.data=Ct:(Ct=he(o),Ct!==null&&(It.data=Ct)))),(Ct=ce?je(i,o):ke$1(i,o))&&(it=oe(it,"onBeforeInput"),0<it.length&&($=new Ld$1("onBeforeInput","beforeinput",null,o,$),c.push({event:$,listeners:it}),$.data=Ct))}se(c,e)})}function tf$1(i,e,o){return{instance:i,listener:e,currentTarget:o}}function oe(i,e){for(var o=e+"Capture",a=[];i!==null;){var d=i,g=d.stateNode;d.tag===5&&g!==null&&(d=g,g=Kb(i,o),g!=null&&a.unshift(tf$1(i,g,d)),g=Kb(i,e),g!=null&&a.push(tf$1(i,g,d))),i=i.return}return a}function vf(i){if(i===null)return null;do i=i.return;while(i&&i.tag!==5);return i||null}function wf(i,e,o,a,d){for(var g=e._reactName,h=[];o!==null&&o!==a;){var et=o,ot=et.alternate,it=et.stateNode;if(ot!==null&&ot===a)break;et.tag===5&&it!==null&&(et=it,d?(ot=Kb(o,g),ot!=null&&h.unshift(tf$1(o,ot,et))):d||(ot=Kb(o,g),ot!=null&&h.push(tf$1(o,ot,et)))),o=o.return}h.length!==0&&i.push({event:e,listeners:h})}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(i){return(typeof i=="string"?i:""+i).replace(xf,`
`).replace(yf,"")}function Af(i,e,o){if(e=zf(e),zf(i)!==e&&o)throw Error(p(425))}function Bf(){}var Cf=null,Df=null;function Ef(i,e){return i==="textarea"||i==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var Ff=typeof setTimeout=="function"?setTimeout:void 0,Gf=typeof clearTimeout=="function"?clearTimeout:void 0,Hf=typeof Promise=="function"?Promise:void 0,Jf=typeof queueMicrotask=="function"?queueMicrotask:typeof Hf<"u"?function(i){return Hf.resolve(null).then(i).catch(If$1)}:Ff;function If$1(i){setTimeout(function(){throw i})}function Kf(i,e){var o=e,a=0;do{var d=o.nextSibling;if(i.removeChild(o),d&&d.nodeType===8)if(o=d.data,o==="/$"){if(a===0){i.removeChild(d),bd$1(e);return}a--}else o!=="$"&&o!=="$?"&&o!=="$!"||a++;o=d}while(o);bd$1(e)}function Lf(i){for(;i!=null;i=i.nextSibling){var e=i.nodeType;if(e===1||e===3)break;if(e===8){if(e=i.data,e==="$"||e==="$!"||e==="$?")break;if(e==="/$")return null}}return i}function Mf(i){i=i.previousSibling;for(var e=0;i;){if(i.nodeType===8){var o=i.data;if(o==="$"||o==="$!"||o==="$?"){if(e===0)return i;e--}else o==="/$"&&e++}i=i.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf$1="__reactContainer$"+Nf,of$1="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;function Wc$1(i){var e=i[Of];if(e)return e;for(var o=i.parentNode;o;){if(e=o[uf$1]||o[Of]){if(o=e.alternate,e.child!==null||o!==null&&o.child!==null)for(i=Mf(i);i!==null;){if(o=i[Of])return o;i=Mf(i)}return e}i=o,o=i.parentNode}return null}function Cb(i){return i=i[Of]||i[uf$1],!i||i.tag!==5&&i.tag!==6&&i.tag!==13&&i.tag!==3?null:i}function ue(i){if(i.tag===5||i.tag===6)return i.stateNode;throw Error(p(33))}function Db(i){return i[Pf]||null}var Sf=[],Tf=-1;function Uf(i){return{current:i}}function E(i){0>Tf||(i.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(i,e){Tf++,Sf[Tf]=i.current,i.current=e}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(i,e){var o=i.type.contextTypes;if(!o)return Vf;var a=i.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===e)return a.__reactInternalMemoizedMaskedChildContext;var d={},g;for(g in o)d[g]=e[g];return a&&(i=i.stateNode,i.__reactInternalMemoizedUnmaskedChildContext=e,i.__reactInternalMemoizedMaskedChildContext=d),d}function Zf(i){return i=i.childContextTypes,i!=null}function $f(){E(Wf),E(H)}function ag(i,e,o){if(H.current!==Vf)throw Error(p(168));G(H,e),G(Wf,o)}function bg(i,e,o){var a=i.stateNode;if(e=e.childContextTypes,typeof a.getChildContext!="function")return o;a=a.getChildContext();for(var d in a)if(!(d in e))throw Error(p(108,Ra(i)||"Unknown",d));return A({},o,a)}function cg(i){return i=(i=i.stateNode)&&i.__reactInternalMemoizedMergedChildContext||Vf,Xf=H.current,G(H,i),G(Wf,Wf.current),!0}function dg(i,e,o){var a=i.stateNode;if(!a)throw Error(p(169));o?(i=bg(i,e,Xf),a.__reactInternalMemoizedMergedChildContext=i,E(Wf),E(H),G(H,i)):E(Wf),G(Wf,o)}var eg=null,fg=!1,gg=!1;function hg(i){eg===null?eg=[i]:eg.push(i)}function ig(i){fg=!0,hg(i)}function jg(){if(!gg&&eg!==null){gg=!0;var i=0,e=C;try{var o=eg;for(C=1;i<o.length;i++){var a=o[i];do a=a(!0);while(a!==null)}eg=null,fg=!1}catch(d){throw eg!==null&&(eg=eg.slice(i+1)),ac$1(fc$1,jg),d}finally{C=e,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(i,e){kg[lg++]=ng,kg[lg++]=mg,mg=i,ng=e}function ug(i,e,o){og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,qg=i;var a=rg;i=sg;var d=32-oc$1(a)-1;a&=~(1<<d),o+=1;var g=32-oc$1(e)+d;if(30<g){var h=d-d%5;g=(a&(1<<h)-1).toString(32),a>>=h,d-=h,rg=1<<32-oc$1(e)+d|o<<d|a,sg=g+i}else rg=1<<g|o<<d|a,sg=i}function vg(i){i.return!==null&&(tg(i,1),ug(i,1,0))}function wg(i){for(;i===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;i===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;function Ag(i,e){var o=Bg(5,null,null,0);o.elementType="DELETED",o.stateNode=e,o.return=i,e=i.deletions,e===null?(i.deletions=[o],i.flags|=16):e.push(o)}function Cg(i,e){switch(i.tag){case 5:var o=i.type;return e=e.nodeType!==1||o.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(i.stateNode=e,xg=i,yg=Lf(e.firstChild),!0):!1;case 6:return e=i.pendingProps===""||e.nodeType!==3?null:e,e!==null?(i.stateNode=e,xg=i,yg=null,!0):!1;case 13:return e=e.nodeType!==8?null:e,e!==null?(o=qg!==null?{id:rg,overflow:sg}:null,i.memoizedState={dehydrated:e,treeContext:o,retryLane:1073741824},o=Bg(18,null,null,0),o.stateNode=e,o.return=i,i.child=o,xg=i,yg=null,!0):!1;default:return!1}}function Dg(i){return(i.mode&1)!==0&&(i.flags&128)===0}function Eg(i){if(I){var e=yg;if(e){var o=e;if(!Cg(i,e)){if(Dg(i))throw Error(p(418));e=Lf(o.nextSibling);var a=xg;e&&Cg(i,e)?Ag(a,o):(i.flags=i.flags&-4097|2,I=!1,xg=i)}}else{if(Dg(i))throw Error(p(418));i.flags=i.flags&-4097|2,I=!1,xg=i}}}function Fg(i){for(i=i.return;i!==null&&i.tag!==5&&i.tag!==3&&i.tag!==13;)i=i.return;xg=i}function Gg(i){if(i!==xg)return!1;if(!I)return Fg(i),I=!0,!1;var e;if((e=i.tag!==3)&&!(e=i.tag!==5)&&(e=i.type,e=e!=="head"&&e!=="body"&&!Ef(i.type,i.memoizedProps)),e&&(e=yg)){if(Dg(i))throw Hg(),Error(p(418));for(;e;)Ag(i,e),e=Lf(e.nextSibling)}if(Fg(i),i.tag===13){if(i=i.memoizedState,i=i!==null?i.dehydrated:null,!i)throw Error(p(317));e:{for(i=i.nextSibling,e=0;i;){if(i.nodeType===8){var o=i.data;if(o==="/$"){if(e===0){yg=Lf(i.nextSibling);break e}e--}else o!=="$"&&o!=="$!"&&o!=="$?"||e++}i=i.nextSibling}yg=null}}else yg=xg?Lf(i.stateNode.nextSibling):null;return!0}function Hg(){for(var i=yg;i;)i=Lf(i.nextSibling)}function Ig(){yg=xg=null,I=!1}function Jg(i){zg===null?zg=[i]:zg.push(i)}var Kg=ua$1.ReactCurrentBatchConfig;function Lg(i,e,o){if(i=o.ref,i!==null&&typeof i!="function"&&typeof i!="object"){if(o._owner){if(o=o._owner,o){if(o.tag!==1)throw Error(p(309));var a=o.stateNode}if(!a)throw Error(p(147,i));var d=a,g=""+i;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===g?e.ref:(e=function(h){var et=d.refs;h===null?delete et[g]:et[g]=h},e._stringRef=g,e)}if(typeof i!="string")throw Error(p(284));if(!o._owner)throw Error(p(290,i))}return i}function Mg(i,e){throw i=Object.prototype.toString.call(e),Error(p(31,i==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":i))}function Ng(i){var e=i._init;return e(i._payload)}function Og(i){function e(ct,pt){if(i){var ft=ct.deletions;ft===null?(ct.deletions=[pt],ct.flags|=16):ft.push(pt)}}function o(ct,pt){if(!i)return null;for(;pt!==null;)e(ct,pt),pt=pt.sibling;return null}function a(ct,pt){for(ct=new Map;pt!==null;)pt.key!==null?ct.set(pt.key,pt):ct.set(pt.index,pt),pt=pt.sibling;return ct}function d(ct,pt){return ct=Pg(ct,pt),ct.index=0,ct.sibling=null,ct}function g(ct,pt,ft){return ct.index=ft,i?(ft=ct.alternate,ft!==null?(ft=ft.index,ft<pt?(ct.flags|=2,pt):ft):(ct.flags|=2,pt)):(ct.flags|=1048576,pt)}function h(ct){return i&&ct.alternate===null&&(ct.flags|=2),ct}function et(ct,pt,ft,mt){return pt===null||pt.tag!==6?(pt=Qg(ft,ct.mode,mt),pt.return=ct,pt):(pt=d(pt,ft),pt.return=ct,pt)}function ot(ct,pt,ft,mt){var bt=ft.type;return bt===ya$1?$(ct,pt,ft.props.children,mt,ft.key):pt!==null&&(pt.elementType===bt||typeof bt=="object"&&bt!==null&&bt.$$typeof===Ha&&Ng(bt)===pt.type)?(mt=d(pt,ft.props),mt.ref=Lg(ct,pt,ft),mt.return=ct,mt):(mt=Rg(ft.type,ft.key,ft.props,null,ct.mode,mt),mt.ref=Lg(ct,pt,ft),mt.return=ct,mt)}function it(ct,pt,ft,mt){return pt===null||pt.tag!==4||pt.stateNode.containerInfo!==ft.containerInfo||pt.stateNode.implementation!==ft.implementation?(pt=Sg(ft,ct.mode,mt),pt.return=ct,pt):(pt=d(pt,ft.children||[]),pt.return=ct,pt)}function $(ct,pt,ft,mt,bt){return pt===null||pt.tag!==7?(pt=Tg(ft,ct.mode,mt,bt),pt.return=ct,pt):(pt=d(pt,ft),pt.return=ct,pt)}function c(ct,pt,ft){if(typeof pt=="string"&&pt!==""||typeof pt=="number")return pt=Qg(""+pt,ct.mode,ft),pt.return=ct,pt;if(typeof pt=="object"&&pt!==null){switch(pt.$$typeof){case va$1:return ft=Rg(pt.type,pt.key,pt.props,null,ct.mode,ft),ft.ref=Lg(ct,null,pt),ft.return=ct,ft;case wa$1:return pt=Sg(pt,ct.mode,ft),pt.return=ct,pt;case Ha:var mt=pt._init;return c(ct,mt(pt._payload),ft)}if(eb(pt)||Ka(pt))return pt=Tg(pt,ct.mode,ft,null),pt.return=ct,pt;Mg(ct,pt)}return null}function s(ct,pt,ft,mt){var bt=pt!==null?pt.key:null;if(typeof ft=="string"&&ft!==""||typeof ft=="number")return bt!==null?null:et(ct,pt,""+ft,mt);if(typeof ft=="object"&&ft!==null){switch(ft.$$typeof){case va$1:return ft.key===bt?ot(ct,pt,ft,mt):null;case wa$1:return ft.key===bt?it(ct,pt,ft,mt):null;case Ha:return bt=ft._init,s(ct,pt,bt(ft._payload),mt)}if(eb(ft)||Ka(ft))return bt!==null?null:$(ct,pt,ft,mt,null);Mg(ct,ft)}return null}function _(ct,pt,ft,mt,bt){if(typeof mt=="string"&&mt!==""||typeof mt=="number")return ct=ct.get(ft)||null,et(pt,ct,""+mt,bt);if(typeof mt=="object"&&mt!==null){switch(mt.$$typeof){case va$1:return ct=ct.get(mt.key===null?ft:mt.key)||null,ot(pt,ct,mt,bt);case wa$1:return ct=ct.get(mt.key===null?ft:mt.key)||null,it(pt,ct,mt,bt);case Ha:var $t=mt._init;return _(ct,pt,ft,$t(mt._payload),bt)}if(eb(mt)||Ka(mt))return ct=ct.get(ft)||null,$(pt,ct,mt,bt,null);Mg(pt,mt)}return null}function b(ct,pt,ft,mt){for(var bt=null,$t=null,Ct=pt,It=pt=0,Tt=null;Ct!==null&&It<ft.length;It++){Ct.index>It?(Tt=Ct,Ct=null):Tt=Ct.sibling;var jt=s(ct,Ct,ft[It],mt);if(jt===null){Ct===null&&(Ct=Tt);break}i&&Ct&&jt.alternate===null&&e(ct,Ct),pt=g(jt,pt,It),$t===null?bt=jt:$t.sibling=jt,$t=jt,Ct=Tt}if(It===ft.length)return o(ct,Ct),I&&tg(ct,It),bt;if(Ct===null){for(;It<ft.length;It++)Ct=c(ct,ft[It],mt),Ct!==null&&(pt=g(Ct,pt,It),$t===null?bt=Ct:$t.sibling=Ct,$t=Ct);return I&&tg(ct,It),bt}for(Ct=a(ct,Ct);It<ft.length;It++)Tt=_(Ct,ct,It,ft[It],mt),Tt!==null&&(i&&Tt.alternate!==null&&Ct.delete(Tt.key===null?It:Tt.key),pt=g(Tt,pt,It),$t===null?bt=Tt:$t.sibling=Tt,$t=Tt);return i&&Ct.forEach(function(dn){return e(ct,dn)}),I&&tg(ct,It),bt}function st(ct,pt,ft,mt){var bt=Ka(ft);if(typeof bt!="function")throw Error(p(150));if(ft=bt.call(ft),ft==null)throw Error(p(151));for(var $t=bt=null,Ct=pt,It=pt=0,Tt=null,jt=ft.next();Ct!==null&&!jt.done;It++,jt=ft.next()){Ct.index>It?(Tt=Ct,Ct=null):Tt=Ct.sibling;var dn=s(ct,Ct,jt.value,mt);if(dn===null){Ct===null&&(Ct=Tt);break}i&&Ct&&dn.alternate===null&&e(ct,Ct),pt=g(dn,pt,It),$t===null?bt=dn:$t.sibling=dn,$t=dn,Ct=Tt}if(jt.done)return o(ct,Ct),I&&tg(ct,It),bt;if(Ct===null){for(;!jt.done;It++,jt=ft.next())jt=c(ct,jt.value,mt),jt!==null&&(pt=g(jt,pt,It),$t===null?bt=jt:$t.sibling=jt,$t=jt);return I&&tg(ct,It),bt}for(Ct=a(ct,Ct);!jt.done;It++,jt=ft.next())jt=_(Ct,ct,It,jt.value,mt),jt!==null&&(i&&jt.alternate!==null&&Ct.delete(jt.key===null?It:jt.key),pt=g(jt,pt,It),$t===null?bt=jt:$t.sibling=jt,$t=jt);return i&&Ct.forEach(function(yn){return e(ct,yn)}),I&&tg(ct,It),bt}function dt(ct,pt,ft,mt){if(typeof ft=="object"&&ft!==null&&ft.type===ya$1&&ft.key===null&&(ft=ft.props.children),typeof ft=="object"&&ft!==null){switch(ft.$$typeof){case va$1:e:{for(var bt=ft.key,$t=pt;$t!==null;){if($t.key===bt){if(bt=ft.type,bt===ya$1){if($t.tag===7){o(ct,$t.sibling),pt=d($t,ft.props.children),pt.return=ct,ct=pt;break e}}else if($t.elementType===bt||typeof bt=="object"&&bt!==null&&bt.$$typeof===Ha&&Ng(bt)===$t.type){o(ct,$t.sibling),pt=d($t,ft.props),pt.ref=Lg(ct,$t,ft),pt.return=ct,ct=pt;break e}o(ct,$t);break}else e(ct,$t);$t=$t.sibling}ft.type===ya$1?(pt=Tg(ft.props.children,ct.mode,mt,ft.key),pt.return=ct,ct=pt):(mt=Rg(ft.type,ft.key,ft.props,null,ct.mode,mt),mt.ref=Lg(ct,pt,ft),mt.return=ct,ct=mt)}return h(ct);case wa$1:e:{for($t=ft.key;pt!==null;){if(pt.key===$t)if(pt.tag===4&&pt.stateNode.containerInfo===ft.containerInfo&&pt.stateNode.implementation===ft.implementation){o(ct,pt.sibling),pt=d(pt,ft.children||[]),pt.return=ct,ct=pt;break e}else{o(ct,pt);break}else e(ct,pt);pt=pt.sibling}pt=Sg(ft,ct.mode,mt),pt.return=ct,ct=pt}return h(ct);case Ha:return $t=ft._init,dt(ct,pt,$t(ft._payload),mt)}if(eb(ft))return b(ct,pt,ft,mt);if(Ka(ft))return st(ct,pt,ft,mt);Mg(ct,ft)}return typeof ft=="string"&&ft!==""||typeof ft=="number"?(ft=""+ft,pt!==null&&pt.tag===6?(o(ct,pt.sibling),pt=d(pt,ft),pt.return=ct,ct=pt):(o(ct,pt),pt=Qg(ft,ct.mode,mt),pt.return=ct,ct=pt),h(ct)):o(ct,pt)}return dt}var Ug=Og(!0),Vg=Og(!1),Wg=Uf(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null}function ah(i){var e=Wg.current;E(Wg),i._currentValue=e}function bh(i,e,o){for(;i!==null;){var a=i.alternate;if((i.childLanes&e)!==e?(i.childLanes|=e,a!==null&&(a.childLanes|=e)):a!==null&&(a.childLanes&e)!==e&&(a.childLanes|=e),i===o)break;i=i.return}}function ch(i,e){Xg=i,Zg=Yg=null,i=i.dependencies,i!==null&&i.firstContext!==null&&(i.lanes&e&&(dh=!0),i.firstContext=null)}function eh(i){var e=i._currentValue;if(Zg!==i)if(i={context:i,memoizedValue:e,next:null},Yg===null){if(Xg===null)throw Error(p(308));Yg=i,Xg.dependencies={lanes:0,firstContext:i}}else Yg=Yg.next=i;return e}var fh=null;function gh(i){fh===null?fh=[i]:fh.push(i)}function hh(i,e,o,a){var d=e.interleaved;return d===null?(o.next=o,gh(e)):(o.next=d.next,d.next=o),e.interleaved=o,ih(i,a)}function ih(i,e){i.lanes|=e;var o=i.alternate;for(o!==null&&(o.lanes|=e),o=i,i=i.return;i!==null;)i.childLanes|=e,o=i.alternate,o!==null&&(o.childLanes|=e),o=i,i=i.return;return o.tag===3?o.stateNode:null}var jh=!1;function kh(i){i.updateQueue={baseState:i.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function lh(i,e){i=i.updateQueue,e.updateQueue===i&&(e.updateQueue={baseState:i.baseState,firstBaseUpdate:i.firstBaseUpdate,lastBaseUpdate:i.lastBaseUpdate,shared:i.shared,effects:i.effects})}function mh(i,e){return{eventTime:i,lane:e,tag:0,payload:null,callback:null,next:null}}function nh(i,e,o){var a=i.updateQueue;if(a===null)return null;if(a=a.shared,K$1&2){var d=a.pending;return d===null?e.next=e:(e.next=d.next,d.next=e),a.pending=e,ih(i,o)}return d=a.interleaved,d===null?(e.next=e,gh(a)):(e.next=d.next,d.next=e),a.interleaved=e,ih(i,o)}function oh(i,e,o){if(e=e.updateQueue,e!==null&&(e=e.shared,(o&4194240)!==0)){var a=e.lanes;a&=i.pendingLanes,o|=a,e.lanes=o,Cc$1(i,o)}}function ph(i,e){var o=i.updateQueue,a=i.alternate;if(a!==null&&(a=a.updateQueue,o===a)){var d=null,g=null;if(o=o.firstBaseUpdate,o!==null){do{var h={eventTime:o.eventTime,lane:o.lane,tag:o.tag,payload:o.payload,callback:o.callback,next:null};g===null?d=g=h:g=g.next=h,o=o.next}while(o!==null);g===null?d=g=e:g=g.next=e}else d=g=e;o={baseState:a.baseState,firstBaseUpdate:d,lastBaseUpdate:g,shared:a.shared,effects:a.effects},i.updateQueue=o;return}i=o.lastBaseUpdate,i===null?o.firstBaseUpdate=e:i.next=e,o.lastBaseUpdate=e}function qh(i,e,o,a){var d=i.updateQueue;jh=!1;var g=d.firstBaseUpdate,h=d.lastBaseUpdate,et=d.shared.pending;if(et!==null){d.shared.pending=null;var ot=et,it=ot.next;ot.next=null,h===null?g=it:h.next=it,h=ot;var $=i.alternate;$!==null&&($=$.updateQueue,et=$.lastBaseUpdate,et!==h&&(et===null?$.firstBaseUpdate=it:et.next=it,$.lastBaseUpdate=ot))}if(g!==null){var c=d.baseState;h=0,$=it=ot=null,et=g;do{var s=et.lane,_=et.eventTime;if((a&s)===s){$!==null&&($=$.next={eventTime:_,lane:0,tag:et.tag,payload:et.payload,callback:et.callback,next:null});e:{var b=i,st=et;switch(s=e,_=o,st.tag){case 1:if(b=st.payload,typeof b=="function"){c=b.call(_,c,s);break e}c=b;break e;case 3:b.flags=b.flags&-65537|128;case 0:if(b=st.payload,s=typeof b=="function"?b.call(_,c,s):b,s==null)break e;c=A({},c,s);break e;case 2:jh=!0}}et.callback!==null&&et.lane!==0&&(i.flags|=64,s=d.effects,s===null?d.effects=[et]:s.push(et))}else _={eventTime:_,lane:s,tag:et.tag,payload:et.payload,callback:et.callback,next:null},$===null?(it=$=_,ot=c):$=$.next=_,h|=s;if(et=et.next,et===null){if(et=d.shared.pending,et===null)break;s=et,et=s.next,s.next=null,d.lastBaseUpdate=s,d.shared.pending=null}}while(!0);if($===null&&(ot=c),d.baseState=ot,d.firstBaseUpdate=it,d.lastBaseUpdate=$,e=d.shared.interleaved,e!==null){d=e;do h|=d.lane,d=d.next;while(d!==e)}else g===null&&(d.shared.lanes=0);rh|=h,i.lanes=h,i.memoizedState=c}}function sh(i,e,o){if(i=e.effects,e.effects=null,i!==null)for(e=0;e<i.length;e++){var a=i[e],d=a.callback;if(d!==null){if(a.callback=null,a=o,typeof d!="function")throw Error(p(191,d));d.call(a)}}}var th={},uh=Uf(th),vh=Uf(th),wh=Uf(th);function xh(i){if(i===th)throw Error(p(174));return i}function yh(i,e){switch(G(wh,e),G(vh,i),G(uh,th),i=e.nodeType,i){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:lb(null,"");break;default:i=i===8?e.parentNode:e,e=i.namespaceURI||null,i=i.tagName,e=lb(e,i)}E(uh),G(uh,e)}function zh(){E(uh),E(vh),E(wh)}function Ah(i){xh(wh.current);var e=xh(uh.current),o=lb(e,i.type);e!==o&&(G(vh,i),G(uh,o))}function Bh(i){vh.current===i&&(E(uh),E(vh))}var L=Uf(0);function Ch(i){for(var e=i;e!==null;){if(e.tag===13){var o=e.memoizedState;if(o!==null&&(o=o.dehydrated,o===null||o.data==="$?"||o.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if(e.flags&128)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===i)break;for(;e.sibling===null;){if(e.return===null||e.return===i)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var Dh=[];function Eh(){for(var i=0;i<Dh.length;i++)Dh[i]._workInProgressVersionPrimary=null;Dh.length=0}var Fh=ua$1.ReactCurrentDispatcher,Gh=ua$1.ReactCurrentBatchConfig,Hh=0,M$1=null,N=null,O=null,Ih=!1,Jh=!1,Kh=0,Lh=0;function P(){throw Error(p(321))}function Mh(i,e){if(e===null)return!1;for(var o=0;o<e.length&&o<i.length;o++)if(!He(i[o],e[o]))return!1;return!0}function Nh(i,e,o,a,d,g){if(Hh=g,M$1=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,Fh.current=i===null||i.memoizedState===null?Oh:Ph,i=o(a,d),Jh){g=0;do{if(Jh=!1,Kh=0,25<=g)throw Error(p(301));g+=1,O=N=null,e.updateQueue=null,Fh.current=Qh,i=o(a,d)}while(Jh)}if(Fh.current=Rh,e=N!==null&&N.next!==null,Hh=0,O=N=M$1=null,Ih=!1,e)throw Error(p(300));return i}function Sh(){var i=Kh!==0;return Kh=0,i}function Th(){var i={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return O===null?M$1.memoizedState=O=i:O=O.next=i,O}function Uh(){if(N===null){var i=M$1.alternate;i=i!==null?i.memoizedState:null}else i=N.next;var e=O===null?M$1.memoizedState:O.next;if(e!==null)O=e,N=i;else{if(i===null)throw Error(p(310));N=i,i={memoizedState:N.memoizedState,baseState:N.baseState,baseQueue:N.baseQueue,queue:N.queue,next:null},O===null?M$1.memoizedState=O=i:O=O.next=i}return O}function Vh(i,e){return typeof e=="function"?e(i):e}function Wh(i){var e=Uh(),o=e.queue;if(o===null)throw Error(p(311));o.lastRenderedReducer=i;var a=N,d=a.baseQueue,g=o.pending;if(g!==null){if(d!==null){var h=d.next;d.next=g.next,g.next=h}a.baseQueue=d=g,o.pending=null}if(d!==null){g=d.next,a=a.baseState;var et=h=null,ot=null,it=g;do{var $=it.lane;if((Hh&$)===$)ot!==null&&(ot=ot.next={lane:0,action:it.action,hasEagerState:it.hasEagerState,eagerState:it.eagerState,next:null}),a=it.hasEagerState?it.eagerState:i(a,it.action);else{var c={lane:$,action:it.action,hasEagerState:it.hasEagerState,eagerState:it.eagerState,next:null};ot===null?(et=ot=c,h=a):ot=ot.next=c,M$1.lanes|=$,rh|=$}it=it.next}while(it!==null&&it!==g);ot===null?h=a:ot.next=et,He(a,e.memoizedState)||(dh=!0),e.memoizedState=a,e.baseState=h,e.baseQueue=ot,o.lastRenderedState=a}if(i=o.interleaved,i!==null){d=i;do g=d.lane,M$1.lanes|=g,rh|=g,d=d.next;while(d!==i)}else d===null&&(o.lanes=0);return[e.memoizedState,o.dispatch]}function Xh(i){var e=Uh(),o=e.queue;if(o===null)throw Error(p(311));o.lastRenderedReducer=i;var a=o.dispatch,d=o.pending,g=e.memoizedState;if(d!==null){o.pending=null;var h=d=d.next;do g=i(g,h.action),h=h.next;while(h!==d);He(g,e.memoizedState)||(dh=!0),e.memoizedState=g,e.baseQueue===null&&(e.baseState=g),o.lastRenderedState=g}return[g,a]}function Yh(){}function Zh(i,e){var o=M$1,a=Uh(),d=e(),g=!He(a.memoizedState,d);if(g&&(a.memoizedState=d,dh=!0),a=a.queue,$h(ai$1.bind(null,o,a,i),[i]),a.getSnapshot!==e||g||O!==null&&O.memoizedState.tag&1){if(o.flags|=2048,bi(9,ci$1.bind(null,o,a,d,e),void 0,null),Q===null)throw Error(p(349));Hh&30||di$1(o,e,d)}return d}function di$1(i,e,o){i.flags|=16384,i={getSnapshot:e,value:o},e=M$1.updateQueue,e===null?(e={lastEffect:null,stores:null},M$1.updateQueue=e,e.stores=[i]):(o=e.stores,o===null?e.stores=[i]:o.push(i))}function ci$1(i,e,o,a){e.value=o,e.getSnapshot=a,ei$1(e)&&fi$1(i)}function ai$1(i,e,o){return o(function(){ei$1(e)&&fi$1(i)})}function ei$1(i){var e=i.getSnapshot;i=i.value;try{var o=e();return!He(i,o)}catch{return!0}}function fi$1(i){var e=ih(i,1);e!==null&&gi(e,i,1,-1)}function hi$1(i){var e=Th();return typeof i=="function"&&(i=i()),e.memoizedState=e.baseState=i,i={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:i},e.queue=i,i=i.dispatch=ii$1.bind(null,M$1,i),[e.memoizedState,i]}function bi(i,e,o,a){return i={tag:i,create:e,destroy:o,deps:a,next:null},e=M$1.updateQueue,e===null?(e={lastEffect:null,stores:null},M$1.updateQueue=e,e.lastEffect=i.next=i):(o=e.lastEffect,o===null?e.lastEffect=i.next=i:(a=o.next,o.next=i,i.next=a,e.lastEffect=i)),i}function ji$1(){return Uh().memoizedState}function ki(i,e,o,a){var d=Th();M$1.flags|=i,d.memoizedState=bi(1|e,o,void 0,a===void 0?null:a)}function li$1(i,e,o,a){var d=Uh();a=a===void 0?null:a;var g=void 0;if(N!==null){var h=N.memoizedState;if(g=h.destroy,a!==null&&Mh(a,h.deps)){d.memoizedState=bi(e,o,g,a);return}}M$1.flags|=i,d.memoizedState=bi(1|e,o,g,a)}function mi$1(i,e){return ki(8390656,8,i,e)}function $h(i,e){return li$1(2048,8,i,e)}function ni$1(i,e){return li$1(4,2,i,e)}function oi$1(i,e){return li$1(4,4,i,e)}function pi$1(i,e){if(typeof e=="function")return i=i(),e(i),function(){e(null)};if(e!=null)return i=i(),e.current=i,function(){e.current=null}}function qi$1(i,e,o){return o=o!=null?o.concat([i]):null,li$1(4,4,pi$1.bind(null,e,i),o)}function ri$1(){}function si$1(i,e){var o=Uh();e=e===void 0?null:e;var a=o.memoizedState;return a!==null&&e!==null&&Mh(e,a[1])?a[0]:(o.memoizedState=[i,e],i)}function ti$1(i,e){var o=Uh();e=e===void 0?null:e;var a=o.memoizedState;return a!==null&&e!==null&&Mh(e,a[1])?a[0]:(i=i(),o.memoizedState=[i,e],i)}function ui$1(i,e,o){return Hh&21?(He(o,e)||(o=yc$1(),M$1.lanes|=o,rh|=o,i.baseState=!0),e):(i.baseState&&(i.baseState=!1,dh=!0),i.memoizedState=o)}function vi(i,e){var o=C;C=o!==0&&4>o?o:4,i(!0);var a=Gh.transition;Gh.transition={};try{i(!1),e()}finally{C=o,Gh.transition=a}}function wi(){return Uh().memoizedState}function xi(i,e,o){var a=yi(i);if(o={lane:a,action:o,hasEagerState:!1,eagerState:null,next:null},zi$1(i))Ai(e,o);else if(o=hh(i,e,o,a),o!==null){var d=R();gi(o,i,a,d),Bi$1(o,e,a)}}function ii$1(i,e,o){var a=yi(i),d={lane:a,action:o,hasEagerState:!1,eagerState:null,next:null};if(zi$1(i))Ai(e,d);else{var g=i.alternate;if(i.lanes===0&&(g===null||g.lanes===0)&&(g=e.lastRenderedReducer,g!==null))try{var h=e.lastRenderedState,et=g(h,o);if(d.hasEagerState=!0,d.eagerState=et,He(et,h)){var ot=e.interleaved;ot===null?(d.next=d,gh(e)):(d.next=ot.next,ot.next=d),e.interleaved=d;return}}catch{}finally{}o=hh(i,e,d,a),o!==null&&(d=R(),gi(o,i,a,d),Bi$1(o,e,a))}}function zi$1(i){var e=i.alternate;return i===M$1||e!==null&&e===M$1}function Ai(i,e){Jh=Ih=!0;var o=i.pending;o===null?e.next=e:(e.next=o.next,o.next=e),i.pending=e}function Bi$1(i,e,o){if(o&4194240){var a=e.lanes;a&=i.pendingLanes,o|=a,e.lanes=o,Cc$1(i,o)}}var Rh={readContext:eh,useCallback:P,useContext:P,useEffect:P,useImperativeHandle:P,useInsertionEffect:P,useLayoutEffect:P,useMemo:P,useReducer:P,useRef:P,useState:P,useDebugValue:P,useDeferredValue:P,useTransition:P,useMutableSource:P,useSyncExternalStore:P,useId:P,unstable_isNewReconciler:!1},Oh={readContext:eh,useCallback:function(i,e){return Th().memoizedState=[i,e===void 0?null:e],i},useContext:eh,useEffect:mi$1,useImperativeHandle:function(i,e,o){return o=o!=null?o.concat([i]):null,ki(4194308,4,pi$1.bind(null,e,i),o)},useLayoutEffect:function(i,e){return ki(4194308,4,i,e)},useInsertionEffect:function(i,e){return ki(4,2,i,e)},useMemo:function(i,e){var o=Th();return e=e===void 0?null:e,i=i(),o.memoizedState=[i,e],i},useReducer:function(i,e,o){var a=Th();return e=o!==void 0?o(e):e,a.memoizedState=a.baseState=e,i={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:i,lastRenderedState:e},a.queue=i,i=i.dispatch=xi.bind(null,M$1,i),[a.memoizedState,i]},useRef:function(i){var e=Th();return i={current:i},e.memoizedState=i},useState:hi$1,useDebugValue:ri$1,useDeferredValue:function(i){return Th().memoizedState=i},useTransition:function(){var i=hi$1(!1),e=i[0];return i=vi.bind(null,i[1]),Th().memoizedState=i,[e,i]},useMutableSource:function(){},useSyncExternalStore:function(i,e,o){var a=M$1,d=Th();if(I){if(o===void 0)throw Error(p(407));o=o()}else{if(o=e(),Q===null)throw Error(p(349));Hh&30||di$1(a,e,o)}d.memoizedState=o;var g={value:o,getSnapshot:e};return d.queue=g,mi$1(ai$1.bind(null,a,g,i),[i]),a.flags|=2048,bi(9,ci$1.bind(null,a,g,o,e),void 0,null),o},useId:function(){var i=Th(),e=Q.identifierPrefix;if(I){var o=sg,a=rg;o=(a&~(1<<32-oc$1(a)-1)).toString(32)+o,e=":"+e+"R"+o,o=Kh++,0<o&&(e+="H"+o.toString(32)),e+=":"}else o=Lh++,e=":"+e+"r"+o.toString(32)+":";return i.memoizedState=e},unstable_isNewReconciler:!1},Ph={readContext:eh,useCallback:si$1,useContext:eh,useEffect:$h,useImperativeHandle:qi$1,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti$1,useReducer:Wh,useRef:ji$1,useState:function(){return Wh(Vh)},useDebugValue:ri$1,useDeferredValue:function(i){var e=Uh();return ui$1(e,N.memoizedState,i)},useTransition:function(){var i=Wh(Vh)[0],e=Uh().memoizedState;return[i,e]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1},Qh={readContext:eh,useCallback:si$1,useContext:eh,useEffect:$h,useImperativeHandle:qi$1,useInsertionEffect:ni$1,useLayoutEffect:oi$1,useMemo:ti$1,useReducer:Xh,useRef:ji$1,useState:function(){return Xh(Vh)},useDebugValue:ri$1,useDeferredValue:function(i){var e=Uh();return N===null?e.memoizedState=i:ui$1(e,N.memoizedState,i)},useTransition:function(){var i=Xh(Vh)[0],e=Uh().memoizedState;return[i,e]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1};function Ci(i,e){if(i&&i.defaultProps){e=A({},e),i=i.defaultProps;for(var o in i)e[o]===void 0&&(e[o]=i[o]);return e}return e}function Di$1(i,e,o,a){e=i.memoizedState,o=o(a,e),o=o==null?e:A({},e,o),i.memoizedState=o,i.lanes===0&&(i.updateQueue.baseState=o)}var Ei={isMounted:function(i){return(i=i._reactInternals)?Vb(i)===i:!1},enqueueSetState:function(i,e,o){i=i._reactInternals;var a=R(),d=yi(i),g=mh(a,d);g.payload=e,o!=null&&(g.callback=o),e=nh(i,g,d),e!==null&&(gi(e,i,d,a),oh(e,i,d))},enqueueReplaceState:function(i,e,o){i=i._reactInternals;var a=R(),d=yi(i),g=mh(a,d);g.tag=1,g.payload=e,o!=null&&(g.callback=o),e=nh(i,g,d),e!==null&&(gi(e,i,d,a),oh(e,i,d))},enqueueForceUpdate:function(i,e){i=i._reactInternals;var o=R(),a=yi(i),d=mh(o,a);d.tag=2,e!=null&&(d.callback=e),e=nh(i,d,a),e!==null&&(gi(e,i,a,o),oh(e,i,a))}};function Fi$1(i,e,o,a,d,g,h){return i=i.stateNode,typeof i.shouldComponentUpdate=="function"?i.shouldComponentUpdate(a,g,h):e.prototype&&e.prototype.isPureReactComponent?!Ie(o,a)||!Ie(d,g):!0}function Gi$1(i,e,o){var a=!1,d=Vf,g=e.contextType;return typeof g=="object"&&g!==null?g=eh(g):(d=Zf(e)?Xf:H.current,a=e.contextTypes,g=(a=a!=null)?Yf(i,d):Vf),e=new e(o,g),i.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=Ei,i.stateNode=e,e._reactInternals=i,a&&(i=i.stateNode,i.__reactInternalMemoizedUnmaskedChildContext=d,i.__reactInternalMemoizedMaskedChildContext=g),e}function Hi$1(i,e,o,a){i=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(o,a),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(o,a),e.state!==i&&Ei.enqueueReplaceState(e,e.state,null)}function Ii(i,e,o,a){var d=i.stateNode;d.props=o,d.state=i.memoizedState,d.refs={},kh(i);var g=e.contextType;typeof g=="object"&&g!==null?d.context=eh(g):(g=Zf(e)?Xf:H.current,d.context=Yf(i,g)),d.state=i.memoizedState,g=e.getDerivedStateFromProps,typeof g=="function"&&(Di$1(i,e,g,o),d.state=i.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof d.getSnapshotBeforeUpdate=="function"||typeof d.UNSAFE_componentWillMount!="function"&&typeof d.componentWillMount!="function"||(e=d.state,typeof d.componentWillMount=="function"&&d.componentWillMount(),typeof d.UNSAFE_componentWillMount=="function"&&d.UNSAFE_componentWillMount(),e!==d.state&&Ei.enqueueReplaceState(d,d.state,null),qh(i,o,d,a),d.state=i.memoizedState),typeof d.componentDidMount=="function"&&(i.flags|=4194308)}function Ji$1(i,e){try{var o="",a=e;do o+=Pa(a),a=a.return;while(a);var d=o}catch(g){d=`
Error generating stack: `+g.message+`
`+g.stack}return{value:i,source:e,stack:d,digest:null}}function Ki$1(i,e,o){return{value:i,source:null,stack:o??null,digest:e??null}}function Li$1(i,e){try{console.error(e.value)}catch(o){setTimeout(function(){throw o})}}var Mi$1=typeof WeakMap=="function"?WeakMap:Map;function Ni(i,e,o){o=mh(-1,o),o.tag=3,o.payload={element:null};var a=e.value;return o.callback=function(){Oi$1||(Oi$1=!0,Pi$1=a),Li$1(i,e)},o}function Qi$1(i,e,o){o=mh(-1,o),o.tag=3;var a=i.type.getDerivedStateFromError;if(typeof a=="function"){var d=e.value;o.payload=function(){return a(d)},o.callback=function(){Li$1(i,e)}}var g=i.stateNode;return g!==null&&typeof g.componentDidCatch=="function"&&(o.callback=function(){Li$1(i,e),typeof a!="function"&&(Ri$1===null?Ri$1=new Set([this]):Ri$1.add(this));var h=e.stack;this.componentDidCatch(e.value,{componentStack:h!==null?h:""})}),o}function Si(i,e,o){var a=i.pingCache;if(a===null){a=i.pingCache=new Mi$1;var d=new Set;a.set(e,d)}else d=a.get(e),d===void 0&&(d=new Set,a.set(e,d));d.has(o)||(d.add(o),i=Ti.bind(null,i,e,o),e.then(i,i))}function Ui$1(i){do{var e;if((e=i.tag===13)&&(e=i.memoizedState,e=e!==null?e.dehydrated!==null:!0),e)return i;i=i.return}while(i!==null);return null}function Vi(i,e,o,a,d){return i.mode&1?(i.flags|=65536,i.lanes=d,i):(i===e?i.flags|=65536:(i.flags|=128,o.flags|=131072,o.flags&=-52805,o.tag===1&&(o.alternate===null?o.tag=17:(e=mh(-1,1),e.tag=2,nh(o,e,1))),o.lanes|=1),i)}var Wi$1=ua$1.ReactCurrentOwner,dh=!1;function Xi$1(i,e,o,a){e.child=i===null?Vg(e,null,o,a):Ug(e,i.child,o,a)}function Yi$1(i,e,o,a,d){o=o.render;var g=e.ref;return ch(e,d),a=Nh(i,e,o,a,g,d),o=Sh(),i!==null&&!dh?(e.updateQueue=i.updateQueue,e.flags&=-2053,i.lanes&=~d,Zi$1(i,e,d)):(I&&o&&vg(e),e.flags|=1,Xi$1(i,e,a,d),e.child)}function $i(i,e,o,a,d){if(i===null){var g=o.type;return typeof g=="function"&&!aj(g)&&g.defaultProps===void 0&&o.compare===null&&o.defaultProps===void 0?(e.tag=15,e.type=g,bj(i,e,g,a,d)):(i=Rg(o.type,null,a,e,e.mode,d),i.ref=e.ref,i.return=e,e.child=i)}if(g=i.child,!(i.lanes&d)){var h=g.memoizedProps;if(o=o.compare,o=o!==null?o:Ie,o(h,a)&&i.ref===e.ref)return Zi$1(i,e,d)}return e.flags|=1,i=Pg(g,a),i.ref=e.ref,i.return=e,e.child=i}function bj(i,e,o,a,d){if(i!==null){var g=i.memoizedProps;if(Ie(g,a)&&i.ref===e.ref)if(dh=!1,e.pendingProps=a=g,(i.lanes&d)!==0)i.flags&131072&&(dh=!0);else return e.lanes=i.lanes,Zi$1(i,e,d)}return cj(i,e,o,a,d)}function dj(i,e,o){var a=e.pendingProps,d=a.children,g=i!==null?i.memoizedState:null;if(a.mode==="hidden")if(!(e.mode&1))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(ej,fj),fj|=o;else{if(!(o&1073741824))return i=g!==null?g.baseLanes|o:o,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:i,cachePool:null,transitions:null},e.updateQueue=null,G(ej,fj),fj|=i,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},a=g!==null?g.baseLanes:o,G(ej,fj),fj|=a}else g!==null?(a=g.baseLanes|o,e.memoizedState=null):a=o,G(ej,fj),fj|=a;return Xi$1(i,e,d,o),e.child}function gj(i,e){var o=e.ref;(i===null&&o!==null||i!==null&&i.ref!==o)&&(e.flags|=512,e.flags|=2097152)}function cj(i,e,o,a,d){var g=Zf(o)?Xf:H.current;return g=Yf(e,g),ch(e,d),o=Nh(i,e,o,a,g,d),a=Sh(),i!==null&&!dh?(e.updateQueue=i.updateQueue,e.flags&=-2053,i.lanes&=~d,Zi$1(i,e,d)):(I&&a&&vg(e),e.flags|=1,Xi$1(i,e,o,d),e.child)}function hj(i,e,o,a,d){if(Zf(o)){var g=!0;cg(e)}else g=!1;if(ch(e,d),e.stateNode===null)ij(i,e),Gi$1(e,o,a),Ii(e,o,a,d),a=!0;else if(i===null){var h=e.stateNode,et=e.memoizedProps;h.props=et;var ot=h.context,it=o.contextType;typeof it=="object"&&it!==null?it=eh(it):(it=Zf(o)?Xf:H.current,it=Yf(e,it));var $=o.getDerivedStateFromProps,c=typeof $=="function"||typeof h.getSnapshotBeforeUpdate=="function";c||typeof h.UNSAFE_componentWillReceiveProps!="function"&&typeof h.componentWillReceiveProps!="function"||(et!==a||ot!==it)&&Hi$1(e,h,a,it),jh=!1;var s=e.memoizedState;h.state=s,qh(e,a,h,d),ot=e.memoizedState,et!==a||s!==ot||Wf.current||jh?(typeof $=="function"&&(Di$1(e,o,$,a),ot=e.memoizedState),(et=jh||Fi$1(e,o,et,a,s,ot,it))?(c||typeof h.UNSAFE_componentWillMount!="function"&&typeof h.componentWillMount!="function"||(typeof h.componentWillMount=="function"&&h.componentWillMount(),typeof h.UNSAFE_componentWillMount=="function"&&h.UNSAFE_componentWillMount()),typeof h.componentDidMount=="function"&&(e.flags|=4194308)):(typeof h.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=a,e.memoizedState=ot),h.props=a,h.state=ot,h.context=it,a=et):(typeof h.componentDidMount=="function"&&(e.flags|=4194308),a=!1)}else{h=e.stateNode,lh(i,e),et=e.memoizedProps,it=e.type===e.elementType?et:Ci(e.type,et),h.props=it,c=e.pendingProps,s=h.context,ot=o.contextType,typeof ot=="object"&&ot!==null?ot=eh(ot):(ot=Zf(o)?Xf:H.current,ot=Yf(e,ot));var _=o.getDerivedStateFromProps;($=typeof _=="function"||typeof h.getSnapshotBeforeUpdate=="function")||typeof h.UNSAFE_componentWillReceiveProps!="function"&&typeof h.componentWillReceiveProps!="function"||(et!==c||s!==ot)&&Hi$1(e,h,a,ot),jh=!1,s=e.memoizedState,h.state=s,qh(e,a,h,d);var b=e.memoizedState;et!==c||s!==b||Wf.current||jh?(typeof _=="function"&&(Di$1(e,o,_,a),b=e.memoizedState),(it=jh||Fi$1(e,o,it,a,s,b,ot)||!1)?($||typeof h.UNSAFE_componentWillUpdate!="function"&&typeof h.componentWillUpdate!="function"||(typeof h.componentWillUpdate=="function"&&h.componentWillUpdate(a,b,ot),typeof h.UNSAFE_componentWillUpdate=="function"&&h.UNSAFE_componentWillUpdate(a,b,ot)),typeof h.componentDidUpdate=="function"&&(e.flags|=4),typeof h.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof h.componentDidUpdate!="function"||et===i.memoizedProps&&s===i.memoizedState||(e.flags|=4),typeof h.getSnapshotBeforeUpdate!="function"||et===i.memoizedProps&&s===i.memoizedState||(e.flags|=1024),e.memoizedProps=a,e.memoizedState=b),h.props=a,h.state=b,h.context=ot,a=it):(typeof h.componentDidUpdate!="function"||et===i.memoizedProps&&s===i.memoizedState||(e.flags|=4),typeof h.getSnapshotBeforeUpdate!="function"||et===i.memoizedProps&&s===i.memoizedState||(e.flags|=1024),a=!1)}return jj(i,e,o,a,g,d)}function jj(i,e,o,a,d,g){gj(i,e);var h=(e.flags&128)!==0;if(!a&&!h)return d&&dg(e,o,!1),Zi$1(i,e,g);a=e.stateNode,Wi$1.current=e;var et=h&&typeof o.getDerivedStateFromError!="function"?null:a.render();return e.flags|=1,i!==null&&h?(e.child=Ug(e,i.child,null,g),e.child=Ug(e,null,et,g)):Xi$1(i,e,et,g),e.memoizedState=a.state,d&&dg(e,o,!0),e.child}function kj(i){var e=i.stateNode;e.pendingContext?ag(i,e.pendingContext,e.pendingContext!==e.context):e.context&&ag(i,e.context,!1),yh(i,e.containerInfo)}function lj(i,e,o,a,d){return Ig(),Jg(d),e.flags|=256,Xi$1(i,e,o,a),e.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(i){return{baseLanes:i,cachePool:null,transitions:null}}function oj(i,e,o){var a=e.pendingProps,d=L.current,g=!1,h=(e.flags&128)!==0,et;if((et=h)||(et=i!==null&&i.memoizedState===null?!1:(d&2)!==0),et?(g=!0,e.flags&=-129):(i===null||i.memoizedState!==null)&&(d|=1),G(L,d&1),i===null)return Eg(e),i=e.memoizedState,i!==null&&(i=i.dehydrated,i!==null)?(e.mode&1?i.data==="$!"?e.lanes=8:e.lanes=1073741824:e.lanes=1,null):(h=a.children,i=a.fallback,g?(a=e.mode,g=e.child,h={mode:"hidden",children:h},!(a&1)&&g!==null?(g.childLanes=0,g.pendingProps=h):g=pj(h,a,0,null),i=Tg(i,a,o,null),g.return=e,i.return=e,g.sibling=i,e.child=g,e.child.memoizedState=nj(o),e.memoizedState=mj,i):qj(e,h));if(d=i.memoizedState,d!==null&&(et=d.dehydrated,et!==null))return rj(i,e,h,a,et,d,o);if(g){g=a.fallback,h=e.mode,d=i.child,et=d.sibling;var ot={mode:"hidden",children:a.children};return!(h&1)&&e.child!==d?(a=e.child,a.childLanes=0,a.pendingProps=ot,e.deletions=null):(a=Pg(d,ot),a.subtreeFlags=d.subtreeFlags&14680064),et!==null?g=Pg(et,g):(g=Tg(g,h,o,null),g.flags|=2),g.return=e,a.return=e,a.sibling=g,e.child=a,a=g,g=e.child,h=i.child.memoizedState,h=h===null?nj(o):{baseLanes:h.baseLanes|o,cachePool:null,transitions:h.transitions},g.memoizedState=h,g.childLanes=i.childLanes&~o,e.memoizedState=mj,a}return g=i.child,i=g.sibling,a=Pg(g,{mode:"visible",children:a.children}),!(e.mode&1)&&(a.lanes=o),a.return=e,a.sibling=null,i!==null&&(o=e.deletions,o===null?(e.deletions=[i],e.flags|=16):o.push(i)),e.child=a,e.memoizedState=null,a}function qj(i,e){return e=pj({mode:"visible",children:e},i.mode,0,null),e.return=i,i.child=e}function sj(i,e,o,a){return a!==null&&Jg(a),Ug(e,i.child,null,o),i=qj(e,e.pendingProps.children),i.flags|=2,e.memoizedState=null,i}function rj(i,e,o,a,d,g,h){if(o)return e.flags&256?(e.flags&=-257,a=Ki$1(Error(p(422))),sj(i,e,h,a)):e.memoizedState!==null?(e.child=i.child,e.flags|=128,null):(g=a.fallback,d=e.mode,a=pj({mode:"visible",children:a.children},d,0,null),g=Tg(g,d,h,null),g.flags|=2,a.return=e,g.return=e,a.sibling=g,e.child=a,e.mode&1&&Ug(e,i.child,null,h),e.child.memoizedState=nj(h),e.memoizedState=mj,g);if(!(e.mode&1))return sj(i,e,h,null);if(d.data==="$!"){if(a=d.nextSibling&&d.nextSibling.dataset,a)var et=a.dgst;return a=et,g=Error(p(419)),a=Ki$1(g,a,void 0),sj(i,e,h,a)}if(et=(h&i.childLanes)!==0,dh||et){if(a=Q,a!==null){switch(h&-h){case 4:d=2;break;case 16:d=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:d=32;break;case 536870912:d=268435456;break;default:d=0}d=d&(a.suspendedLanes|h)?0:d,d!==0&&d!==g.retryLane&&(g.retryLane=d,ih(i,d),gi(a,i,d,-1))}return tj(),a=Ki$1(Error(p(421))),sj(i,e,h,a)}return d.data==="$?"?(e.flags|=128,e.child=i.child,e=uj.bind(null,i),d._reactRetry=e,null):(i=g.treeContext,yg=Lf(d.nextSibling),xg=e,I=!0,zg=null,i!==null&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=i.id,sg=i.overflow,qg=e),e=qj(e,a.children),e.flags|=4096,e)}function vj(i,e,o){i.lanes|=e;var a=i.alternate;a!==null&&(a.lanes|=e),bh(i.return,e,o)}function wj(i,e,o,a,d){var g=i.memoizedState;g===null?i.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:a,tail:o,tailMode:d}:(g.isBackwards=e,g.rendering=null,g.renderingStartTime=0,g.last=a,g.tail=o,g.tailMode=d)}function xj(i,e,o){var a=e.pendingProps,d=a.revealOrder,g=a.tail;if(Xi$1(i,e,a.children,o),a=L.current,a&2)a=a&1|2,e.flags|=128;else{if(i!==null&&i.flags&128)e:for(i=e.child;i!==null;){if(i.tag===13)i.memoizedState!==null&&vj(i,o,e);else if(i.tag===19)vj(i,o,e);else if(i.child!==null){i.child.return=i,i=i.child;continue}if(i===e)break e;for(;i.sibling===null;){if(i.return===null||i.return===e)break e;i=i.return}i.sibling.return=i.return,i=i.sibling}a&=1}if(G(L,a),!(e.mode&1))e.memoizedState=null;else switch(d){case"forwards":for(o=e.child,d=null;o!==null;)i=o.alternate,i!==null&&Ch(i)===null&&(d=o),o=o.sibling;o=d,o===null?(d=e.child,e.child=null):(d=o.sibling,o.sibling=null),wj(e,!1,d,o,g);break;case"backwards":for(o=null,d=e.child,e.child=null;d!==null;){if(i=d.alternate,i!==null&&Ch(i)===null){e.child=d;break}i=d.sibling,d.sibling=o,o=d,d=i}wj(e,!0,o,null,g);break;case"together":wj(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function ij(i,e){!(e.mode&1)&&i!==null&&(i.alternate=null,e.alternate=null,e.flags|=2)}function Zi$1(i,e,o){if(i!==null&&(e.dependencies=i.dependencies),rh|=e.lanes,!(o&e.childLanes))return null;if(i!==null&&e.child!==i.child)throw Error(p(153));if(e.child!==null){for(i=e.child,o=Pg(i,i.pendingProps),e.child=o,o.return=e;i.sibling!==null;)i=i.sibling,o=o.sibling=Pg(i,i.pendingProps),o.return=e;o.sibling=null}return e.child}function yj(i,e,o){switch(e.tag){case 3:kj(e),Ig();break;case 5:Ah(e);break;case 1:Zf(e.type)&&cg(e);break;case 4:yh(e,e.stateNode.containerInfo);break;case 10:var a=e.type._context,d=e.memoizedProps.value;G(Wg,a._currentValue),a._currentValue=d;break;case 13:if(a=e.memoizedState,a!==null)return a.dehydrated!==null?(G(L,L.current&1),e.flags|=128,null):o&e.child.childLanes?oj(i,e,o):(G(L,L.current&1),i=Zi$1(i,e,o),i!==null?i.sibling:null);G(L,L.current&1);break;case 19:if(a=(o&e.childLanes)!==0,i.flags&128){if(a)return xj(i,e,o);e.flags|=128}if(d=e.memoizedState,d!==null&&(d.rendering=null,d.tail=null,d.lastEffect=null),G(L,L.current),a)break;return null;case 22:case 23:return e.lanes=0,dj(i,e,o)}return Zi$1(i,e,o)}var zj,Aj,Bj,Cj;zj=function(i,e){for(var o=e.child;o!==null;){if(o.tag===5||o.tag===6)i.appendChild(o.stateNode);else if(o.tag!==4&&o.child!==null){o.child.return=o,o=o.child;continue}if(o===e)break;for(;o.sibling===null;){if(o.return===null||o.return===e)return;o=o.return}o.sibling.return=o.return,o=o.sibling}};Aj=function(){};Bj=function(i,e,o,a){var d=i.memoizedProps;if(d!==a){i=e.stateNode,xh(uh.current);var g=null;switch(o){case"input":d=Ya(i,d),a=Ya(i,a),g=[];break;case"select":d=A({},d,{value:void 0}),a=A({},a,{value:void 0}),g=[];break;case"textarea":d=gb(i,d),a=gb(i,a),g=[];break;default:typeof d.onClick!="function"&&typeof a.onClick=="function"&&(i.onclick=Bf)}ub(o,a);var h;o=null;for(it in d)if(!a.hasOwnProperty(it)&&d.hasOwnProperty(it)&&d[it]!=null)if(it==="style"){var et=d[it];for(h in et)et.hasOwnProperty(h)&&(o||(o={}),o[h]="")}else it!=="dangerouslySetInnerHTML"&&it!=="children"&&it!=="suppressContentEditableWarning"&&it!=="suppressHydrationWarning"&&it!=="autoFocus"&&(ea$1.hasOwnProperty(it)?g||(g=[]):(g=g||[]).push(it,null));for(it in a){var ot=a[it];if(et=d!=null?d[it]:void 0,a.hasOwnProperty(it)&&ot!==et&&(ot!=null||et!=null))if(it==="style")if(et){for(h in et)!et.hasOwnProperty(h)||ot&&ot.hasOwnProperty(h)||(o||(o={}),o[h]="");for(h in ot)ot.hasOwnProperty(h)&&et[h]!==ot[h]&&(o||(o={}),o[h]=ot[h])}else o||(g||(g=[]),g.push(it,o)),o=ot;else it==="dangerouslySetInnerHTML"?(ot=ot?ot.__html:void 0,et=et?et.__html:void 0,ot!=null&&et!==ot&&(g=g||[]).push(it,ot)):it==="children"?typeof ot!="string"&&typeof ot!="number"||(g=g||[]).push(it,""+ot):it!=="suppressContentEditableWarning"&&it!=="suppressHydrationWarning"&&(ea$1.hasOwnProperty(it)?(ot!=null&&it==="onScroll"&&D("scroll",i),g||et===ot||(g=[])):(g=g||[]).push(it,ot))}o&&(g=g||[]).push("style",o);var it=g;(e.updateQueue=it)&&(e.flags|=4)}};Cj=function(i,e,o,a){o!==a&&(e.flags|=4)};function Dj(i,e){if(!I)switch(i.tailMode){case"hidden":e=i.tail;for(var o=null;e!==null;)e.alternate!==null&&(o=e),e=e.sibling;o===null?i.tail=null:o.sibling=null;break;case"collapsed":o=i.tail;for(var a=null;o!==null;)o.alternate!==null&&(a=o),o=o.sibling;a===null?e||i.tail===null?i.tail=null:i.tail.sibling=null:a.sibling=null}}function S(i){var e=i.alternate!==null&&i.alternate.child===i.child,o=0,a=0;if(e)for(var d=i.child;d!==null;)o|=d.lanes|d.childLanes,a|=d.subtreeFlags&14680064,a|=d.flags&14680064,d.return=i,d=d.sibling;else for(d=i.child;d!==null;)o|=d.lanes|d.childLanes,a|=d.subtreeFlags,a|=d.flags,d.return=i,d=d.sibling;return i.subtreeFlags|=a,i.childLanes=o,e}function Ej(i,e,o){var a=e.pendingProps;switch(wg(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(e),null;case 1:return Zf(e.type)&&$f(),S(e),null;case 3:return a=e.stateNode,zh(),E(Wf),E(H),Eh(),a.pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),(i===null||i.child===null)&&(Gg(e)?e.flags|=4:i===null||i.memoizedState.isDehydrated&&!(e.flags&256)||(e.flags|=1024,zg!==null&&(Fj(zg),zg=null))),Aj(i,e),S(e),null;case 5:Bh(e);var d=xh(wh.current);if(o=e.type,i!==null&&e.stateNode!=null)Bj(i,e,o,a,d),i.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!a){if(e.stateNode===null)throw Error(p(166));return S(e),null}if(i=xh(uh.current),Gg(e)){a=e.stateNode,o=e.type;var g=e.memoizedProps;switch(a[Of]=e,a[Pf]=g,i=(e.mode&1)!==0,o){case"dialog":D("cancel",a),D("close",a);break;case"iframe":case"object":case"embed":D("load",a);break;case"video":case"audio":for(d=0;d<lf$1.length;d++)D(lf$1[d],a);break;case"source":D("error",a);break;case"img":case"image":case"link":D("error",a),D("load",a);break;case"details":D("toggle",a);break;case"input":Za(a,g),D("invalid",a);break;case"select":a._wrapperState={wasMultiple:!!g.multiple},D("invalid",a);break;case"textarea":hb(a,g),D("invalid",a)}ub(o,g),d=null;for(var h in g)if(g.hasOwnProperty(h)){var et=g[h];h==="children"?typeof et=="string"?a.textContent!==et&&(g.suppressHydrationWarning!==!0&&Af(a.textContent,et,i),d=["children",et]):typeof et=="number"&&a.textContent!==""+et&&(g.suppressHydrationWarning!==!0&&Af(a.textContent,et,i),d=["children",""+et]):ea$1.hasOwnProperty(h)&&et!=null&&h==="onScroll"&&D("scroll",a)}switch(o){case"input":Va(a),db(a,g,!0);break;case"textarea":Va(a),jb(a);break;case"select":case"option":break;default:typeof g.onClick=="function"&&(a.onclick=Bf)}a=d,e.updateQueue=a,a!==null&&(e.flags|=4)}else{h=d.nodeType===9?d:d.ownerDocument,i==="http://www.w3.org/1999/xhtml"&&(i=kb(o)),i==="http://www.w3.org/1999/xhtml"?o==="script"?(i=h.createElement("div"),i.innerHTML="<script><\/script>",i=i.removeChild(i.firstChild)):typeof a.is=="string"?i=h.createElement(o,{is:a.is}):(i=h.createElement(o),o==="select"&&(h=i,a.multiple?h.multiple=!0:a.size&&(h.size=a.size))):i=h.createElementNS(i,o),i[Of]=e,i[Pf]=a,zj(i,e,!1,!1),e.stateNode=i;e:{switch(h=vb(o,a),o){case"dialog":D("cancel",i),D("close",i),d=a;break;case"iframe":case"object":case"embed":D("load",i),d=a;break;case"video":case"audio":for(d=0;d<lf$1.length;d++)D(lf$1[d],i);d=a;break;case"source":D("error",i),d=a;break;case"img":case"image":case"link":D("error",i),D("load",i),d=a;break;case"details":D("toggle",i),d=a;break;case"input":Za(i,a),d=Ya(i,a),D("invalid",i);break;case"option":d=a;break;case"select":i._wrapperState={wasMultiple:!!a.multiple},d=A({},a,{value:void 0}),D("invalid",i);break;case"textarea":hb(i,a),d=gb(i,a),D("invalid",i);break;default:d=a}ub(o,d),et=d;for(g in et)if(et.hasOwnProperty(g)){var ot=et[g];g==="style"?sb(i,ot):g==="dangerouslySetInnerHTML"?(ot=ot?ot.__html:void 0,ot!=null&&nb(i,ot)):g==="children"?typeof ot=="string"?(o!=="textarea"||ot!=="")&&ob(i,ot):typeof ot=="number"&&ob(i,""+ot):g!=="suppressContentEditableWarning"&&g!=="suppressHydrationWarning"&&g!=="autoFocus"&&(ea$1.hasOwnProperty(g)?ot!=null&&g==="onScroll"&&D("scroll",i):ot!=null&&ta$1(i,g,ot,h))}switch(o){case"input":Va(i),db(i,a,!1);break;case"textarea":Va(i),jb(i);break;case"option":a.value!=null&&i.setAttribute("value",""+Sa$1(a.value));break;case"select":i.multiple=!!a.multiple,g=a.value,g!=null?fb(i,!!a.multiple,g,!1):a.defaultValue!=null&&fb(i,!!a.multiple,a.defaultValue,!0);break;default:typeof d.onClick=="function"&&(i.onclick=Bf)}switch(o){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break e;case"img":a=!0;break e;default:a=!1}}a&&(e.flags|=4)}e.ref!==null&&(e.flags|=512,e.flags|=2097152)}return S(e),null;case 6:if(i&&e.stateNode!=null)Cj(i,e,i.memoizedProps,a);else{if(typeof a!="string"&&e.stateNode===null)throw Error(p(166));if(o=xh(wh.current),xh(uh.current),Gg(e)){if(a=e.stateNode,o=e.memoizedProps,a[Of]=e,(g=a.nodeValue!==o)&&(i=xg,i!==null))switch(i.tag){case 3:Af(a.nodeValue,o,(i.mode&1)!==0);break;case 5:i.memoizedProps.suppressHydrationWarning!==!0&&Af(a.nodeValue,o,(i.mode&1)!==0)}g&&(e.flags|=4)}else a=(o.nodeType===9?o:o.ownerDocument).createTextNode(a),a[Of]=e,e.stateNode=a}return S(e),null;case 13:if(E(L),a=e.memoizedState,i===null||i.memoizedState!==null&&i.memoizedState.dehydrated!==null){if(I&&yg!==null&&e.mode&1&&!(e.flags&128))Hg(),Ig(),e.flags|=98560,g=!1;else if(g=Gg(e),a!==null&&a.dehydrated!==null){if(i===null){if(!g)throw Error(p(318));if(g=e.memoizedState,g=g!==null?g.dehydrated:null,!g)throw Error(p(317));g[Of]=e}else Ig(),!(e.flags&128)&&(e.memoizedState=null),e.flags|=4;S(e),g=!1}else zg!==null&&(Fj(zg),zg=null),g=!0;if(!g)return e.flags&65536?e:null}return e.flags&128?(e.lanes=o,e):(a=a!==null,a!==(i!==null&&i.memoizedState!==null)&&a&&(e.child.flags|=8192,e.mode&1&&(i===null||L.current&1?T===0&&(T=3):tj())),e.updateQueue!==null&&(e.flags|=4),S(e),null);case 4:return zh(),Aj(i,e),i===null&&sf$1(e.stateNode.containerInfo),S(e),null;case 10:return ah(e.type._context),S(e),null;case 17:return Zf(e.type)&&$f(),S(e),null;case 19:if(E(L),g=e.memoizedState,g===null)return S(e),null;if(a=(e.flags&128)!==0,h=g.rendering,h===null)if(a)Dj(g,!1);else{if(T!==0||i!==null&&i.flags&128)for(i=e.child;i!==null;){if(h=Ch(i),h!==null){for(e.flags|=128,Dj(g,!1),a=h.updateQueue,a!==null&&(e.updateQueue=a,e.flags|=4),e.subtreeFlags=0,a=o,o=e.child;o!==null;)g=o,i=a,g.flags&=14680066,h=g.alternate,h===null?(g.childLanes=0,g.lanes=i,g.child=null,g.subtreeFlags=0,g.memoizedProps=null,g.memoizedState=null,g.updateQueue=null,g.dependencies=null,g.stateNode=null):(g.childLanes=h.childLanes,g.lanes=h.lanes,g.child=h.child,g.subtreeFlags=0,g.deletions=null,g.memoizedProps=h.memoizedProps,g.memoizedState=h.memoizedState,g.updateQueue=h.updateQueue,g.type=h.type,i=h.dependencies,g.dependencies=i===null?null:{lanes:i.lanes,firstContext:i.firstContext}),o=o.sibling;return G(L,L.current&1|2),e.child}i=i.sibling}g.tail!==null&&B()>Gj&&(e.flags|=128,a=!0,Dj(g,!1),e.lanes=4194304)}else{if(!a)if(i=Ch(h),i!==null){if(e.flags|=128,a=!0,o=i.updateQueue,o!==null&&(e.updateQueue=o,e.flags|=4),Dj(g,!0),g.tail===null&&g.tailMode==="hidden"&&!h.alternate&&!I)return S(e),null}else 2*B()-g.renderingStartTime>Gj&&o!==1073741824&&(e.flags|=128,a=!0,Dj(g,!1),e.lanes=4194304);g.isBackwards?(h.sibling=e.child,e.child=h):(o=g.last,o!==null?o.sibling=h:e.child=h,g.last=h)}return g.tail!==null?(e=g.tail,g.rendering=e,g.tail=e.sibling,g.renderingStartTime=B(),e.sibling=null,o=L.current,G(L,a?o&1|2:o&1),e):(S(e),null);case 22:case 23:return Hj(),a=e.memoizedState!==null,i!==null&&i.memoizedState!==null!==a&&(e.flags|=8192),a&&e.mode&1?fj&1073741824&&(S(e),e.subtreeFlags&6&&(e.flags|=8192)):S(e),null;case 24:return null;case 25:return null}throw Error(p(156,e.tag))}function Ij(i,e){switch(wg(e),e.tag){case 1:return Zf(e.type)&&$f(),i=e.flags,i&65536?(e.flags=i&-65537|128,e):null;case 3:return zh(),E(Wf),E(H),Eh(),i=e.flags,i&65536&&!(i&128)?(e.flags=i&-65537|128,e):null;case 5:return Bh(e),null;case 13:if(E(L),i=e.memoizedState,i!==null&&i.dehydrated!==null){if(e.alternate===null)throw Error(p(340));Ig()}return i=e.flags,i&65536?(e.flags=i&-65537|128,e):null;case 19:return E(L),null;case 4:return zh(),null;case 10:return ah(e.type._context),null;case 22:case 23:return Hj(),null;case 24:return null;default:return null}}var Jj=!1,U$1=!1,Kj=typeof WeakSet=="function"?WeakSet:Set,V=null;function Lj(i,e){var o=i.ref;if(o!==null)if(typeof o=="function")try{o(null)}catch(a){W(i,e,a)}else o.current=null}function Mj(i,e,o){try{o()}catch(a){W(i,e,a)}}var Nj=!1;function Oj(i,e){if(Cf=dd$1,i=Me(),Ne$1(i)){if("selectionStart"in i)var o={start:i.selectionStart,end:i.selectionEnd};else e:{o=(o=i.ownerDocument)&&o.defaultView||window;var a=o.getSelection&&o.getSelection();if(a&&a.rangeCount!==0){o=a.anchorNode;var d=a.anchorOffset,g=a.focusNode;a=a.focusOffset;try{o.nodeType,g.nodeType}catch{o=null;break e}var h=0,et=-1,ot=-1,it=0,$=0,c=i,s=null;t:for(;;){for(var _;c!==o||d!==0&&c.nodeType!==3||(et=h+d),c!==g||a!==0&&c.nodeType!==3||(ot=h+a),c.nodeType===3&&(h+=c.nodeValue.length),(_=c.firstChild)!==null;)s=c,c=_;for(;;){if(c===i)break t;if(s===o&&++it===d&&(et=h),s===g&&++$===a&&(ot=h),(_=c.nextSibling)!==null)break;c=s,s=c.parentNode}c=_}o=et===-1||ot===-1?null:{start:et,end:ot}}else o=null}o=o||{start:0,end:0}}else o=null;for(Df={focusedElem:i,selectionRange:o},dd$1=!1,V=e;V!==null;)if(e=V,i=e.child,(e.subtreeFlags&1028)!==0&&i!==null)i.return=e,V=i;else for(;V!==null;){e=V;try{var b=e.alternate;if(e.flags&1024)switch(e.tag){case 0:case 11:case 15:break;case 1:if(b!==null){var st=b.memoizedProps,dt=b.memoizedState,ct=e.stateNode,pt=ct.getSnapshotBeforeUpdate(e.elementType===e.type?st:Ci(e.type,st),dt);ct.__reactInternalSnapshotBeforeUpdate=pt}break;case 3:var ft=e.stateNode.containerInfo;ft.nodeType===1?ft.textContent="":ft.nodeType===9&&ft.documentElement&&ft.removeChild(ft.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163))}}catch(mt){W(e,e.return,mt)}if(i=e.sibling,i!==null){i.return=e.return,V=i;break}V=e.return}return b=Nj,Nj=!1,b}function Pj(i,e,o){var a=e.updateQueue;if(a=a!==null?a.lastEffect:null,a!==null){var d=a=a.next;do{if((d.tag&i)===i){var g=d.destroy;d.destroy=void 0,g!==void 0&&Mj(e,o,g)}d=d.next}while(d!==a)}}function Qj(i,e){if(e=e.updateQueue,e=e!==null?e.lastEffect:null,e!==null){var o=e=e.next;do{if((o.tag&i)===i){var a=o.create;o.destroy=a()}o=o.next}while(o!==e)}}function Rj(i){var e=i.ref;if(e!==null){var o=i.stateNode;switch(i.tag){case 5:i=o;break;default:i=o}typeof e=="function"?e(i):e.current=i}}function Sj(i){var e=i.alternate;e!==null&&(i.alternate=null,Sj(e)),i.child=null,i.deletions=null,i.sibling=null,i.tag===5&&(e=i.stateNode,e!==null&&(delete e[Of],delete e[Pf],delete e[of$1],delete e[Qf],delete e[Rf])),i.stateNode=null,i.return=null,i.dependencies=null,i.memoizedProps=null,i.memoizedState=null,i.pendingProps=null,i.stateNode=null,i.updateQueue=null}function Tj(i){return i.tag===5||i.tag===3||i.tag===4}function Uj(i){e:for(;;){for(;i.sibling===null;){if(i.return===null||Tj(i.return))return null;i=i.return}for(i.sibling.return=i.return,i=i.sibling;i.tag!==5&&i.tag!==6&&i.tag!==18;){if(i.flags&2||i.child===null||i.tag===4)continue e;i.child.return=i,i=i.child}if(!(i.flags&2))return i.stateNode}}function Vj(i,e,o){var a=i.tag;if(a===5||a===6)i=i.stateNode,e?o.nodeType===8?o.parentNode.insertBefore(i,e):o.insertBefore(i,e):(o.nodeType===8?(e=o.parentNode,e.insertBefore(i,o)):(e=o,e.appendChild(i)),o=o._reactRootContainer,o!=null||e.onclick!==null||(e.onclick=Bf));else if(a!==4&&(i=i.child,i!==null))for(Vj(i,e,o),i=i.sibling;i!==null;)Vj(i,e,o),i=i.sibling}function Wj(i,e,o){var a=i.tag;if(a===5||a===6)i=i.stateNode,e?o.insertBefore(i,e):o.appendChild(i);else if(a!==4&&(i=i.child,i!==null))for(Wj(i,e,o),i=i.sibling;i!==null;)Wj(i,e,o),i=i.sibling}var X$1=null,Xj=!1;function Yj(i,e,o){for(o=o.child;o!==null;)Zj(i,e,o),o=o.sibling}function Zj(i,e,o){if(lc$1&&typeof lc$1.onCommitFiberUnmount=="function")try{lc$1.onCommitFiberUnmount(kc$1,o)}catch{}switch(o.tag){case 5:U$1||Lj(o,e);case 6:var a=X$1,d=Xj;X$1=null,Yj(i,e,o),X$1=a,Xj=d,X$1!==null&&(Xj?(i=X$1,o=o.stateNode,i.nodeType===8?i.parentNode.removeChild(o):i.removeChild(o)):X$1.removeChild(o.stateNode));break;case 18:X$1!==null&&(Xj?(i=X$1,o=o.stateNode,i.nodeType===8?Kf(i.parentNode,o):i.nodeType===1&&Kf(i,o),bd$1(i)):Kf(X$1,o.stateNode));break;case 4:a=X$1,d=Xj,X$1=o.stateNode.containerInfo,Xj=!0,Yj(i,e,o),X$1=a,Xj=d;break;case 0:case 11:case 14:case 15:if(!U$1&&(a=o.updateQueue,a!==null&&(a=a.lastEffect,a!==null))){d=a=a.next;do{var g=d,h=g.destroy;g=g.tag,h!==void 0&&(g&2||g&4)&&Mj(o,e,h),d=d.next}while(d!==a)}Yj(i,e,o);break;case 1:if(!U$1&&(Lj(o,e),a=o.stateNode,typeof a.componentWillUnmount=="function"))try{a.props=o.memoizedProps,a.state=o.memoizedState,a.componentWillUnmount()}catch(et){W(o,e,et)}Yj(i,e,o);break;case 21:Yj(i,e,o);break;case 22:o.mode&1?(U$1=(a=U$1)||o.memoizedState!==null,Yj(i,e,o),U$1=a):Yj(i,e,o);break;default:Yj(i,e,o)}}function ak(i){var e=i.updateQueue;if(e!==null){i.updateQueue=null;var o=i.stateNode;o===null&&(o=i.stateNode=new Kj),e.forEach(function(a){var d=bk.bind(null,i,a);o.has(a)||(o.add(a),a.then(d,d))})}}function ck(i,e){var o=e.deletions;if(o!==null)for(var a=0;a<o.length;a++){var d=o[a];try{var g=i,h=e,et=h;e:for(;et!==null;){switch(et.tag){case 5:X$1=et.stateNode,Xj=!1;break e;case 3:X$1=et.stateNode.containerInfo,Xj=!0;break e;case 4:X$1=et.stateNode.containerInfo,Xj=!0;break e}et=et.return}if(X$1===null)throw Error(p(160));Zj(g,h,d),X$1=null,Xj=!1;var ot=d.alternate;ot!==null&&(ot.return=null),d.return=null}catch(it){W(d,e,it)}}if(e.subtreeFlags&12854)for(e=e.child;e!==null;)dk(e,i),e=e.sibling}function dk(i,e){var o=i.alternate,a=i.flags;switch(i.tag){case 0:case 11:case 14:case 15:if(ck(e,i),ek(i),a&4){try{Pj(3,i,i.return),Qj(3,i)}catch(st){W(i,i.return,st)}try{Pj(5,i,i.return)}catch(st){W(i,i.return,st)}}break;case 1:ck(e,i),ek(i),a&512&&o!==null&&Lj(o,o.return);break;case 5:if(ck(e,i),ek(i),a&512&&o!==null&&Lj(o,o.return),i.flags&32){var d=i.stateNode;try{ob(d,"")}catch(st){W(i,i.return,st)}}if(a&4&&(d=i.stateNode,d!=null)){var g=i.memoizedProps,h=o!==null?o.memoizedProps:g,et=i.type,ot=i.updateQueue;if(i.updateQueue=null,ot!==null)try{et==="input"&&g.type==="radio"&&g.name!=null&&ab(d,g),vb(et,h);var it=vb(et,g);for(h=0;h<ot.length;h+=2){var $=ot[h],c=ot[h+1];$==="style"?sb(d,c):$==="dangerouslySetInnerHTML"?nb(d,c):$==="children"?ob(d,c):ta$1(d,$,c,it)}switch(et){case"input":bb(d,g);break;case"textarea":ib(d,g);break;case"select":var s=d._wrapperState.wasMultiple;d._wrapperState.wasMultiple=!!g.multiple;var _=g.value;_!=null?fb(d,!!g.multiple,_,!1):s!==!!g.multiple&&(g.defaultValue!=null?fb(d,!!g.multiple,g.defaultValue,!0):fb(d,!!g.multiple,g.multiple?[]:"",!1))}d[Pf]=g}catch(st){W(i,i.return,st)}}break;case 6:if(ck(e,i),ek(i),a&4){if(i.stateNode===null)throw Error(p(162));d=i.stateNode,g=i.memoizedProps;try{d.nodeValue=g}catch(st){W(i,i.return,st)}}break;case 3:if(ck(e,i),ek(i),a&4&&o!==null&&o.memoizedState.isDehydrated)try{bd$1(e.containerInfo)}catch(st){W(i,i.return,st)}break;case 4:ck(e,i),ek(i);break;case 13:ck(e,i),ek(i),d=i.child,d.flags&8192&&(g=d.memoizedState!==null,d.stateNode.isHidden=g,!g||d.alternate!==null&&d.alternate.memoizedState!==null||(fk=B())),a&4&&ak(i);break;case 22:if($=o!==null&&o.memoizedState!==null,i.mode&1?(U$1=(it=U$1)||$,ck(e,i),U$1=it):ck(e,i),ek(i),a&8192){if(it=i.memoizedState!==null,(i.stateNode.isHidden=it)&&!$&&i.mode&1)for(V=i,$=i.child;$!==null;){for(c=V=$;V!==null;){switch(s=V,_=s.child,s.tag){case 0:case 11:case 14:case 15:Pj(4,s,s.return);break;case 1:Lj(s,s.return);var b=s.stateNode;if(typeof b.componentWillUnmount=="function"){a=s,o=s.return;try{e=a,b.props=e.memoizedProps,b.state=e.memoizedState,b.componentWillUnmount()}catch(st){W(a,o,st)}}break;case 5:Lj(s,s.return);break;case 22:if(s.memoizedState!==null){gk(c);continue}}_!==null?(_.return=s,V=_):gk(c)}$=$.sibling}e:for($=null,c=i;;){if(c.tag===5){if($===null){$=c;try{d=c.stateNode,it?(g=d.style,typeof g.setProperty=="function"?g.setProperty("display","none","important"):g.display="none"):(et=c.stateNode,ot=c.memoizedProps.style,h=ot!=null&&ot.hasOwnProperty("display")?ot.display:null,et.style.display=rb("display",h))}catch(st){W(i,i.return,st)}}}else if(c.tag===6){if($===null)try{c.stateNode.nodeValue=it?"":c.memoizedProps}catch(st){W(i,i.return,st)}}else if((c.tag!==22&&c.tag!==23||c.memoizedState===null||c===i)&&c.child!==null){c.child.return=c,c=c.child;continue}if(c===i)break e;for(;c.sibling===null;){if(c.return===null||c.return===i)break e;$===c&&($=null),c=c.return}$===c&&($=null),c.sibling.return=c.return,c=c.sibling}}break;case 19:ck(e,i),ek(i),a&4&&ak(i);break;case 21:break;default:ck(e,i),ek(i)}}function ek(i){var e=i.flags;if(e&2){try{e:{for(var o=i.return;o!==null;){if(Tj(o)){var a=o;break e}o=o.return}throw Error(p(160))}switch(a.tag){case 5:var d=a.stateNode;a.flags&32&&(ob(d,""),a.flags&=-33);var g=Uj(i);Wj(i,g,d);break;case 3:case 4:var h=a.stateNode.containerInfo,et=Uj(i);Vj(i,et,h);break;default:throw Error(p(161))}}catch(ot){W(i,i.return,ot)}i.flags&=-3}e&4096&&(i.flags&=-4097)}function hk(i,e,o){V=i,ik(i)}function ik(i,e,o){for(var a=(i.mode&1)!==0;V!==null;){var d=V,g=d.child;if(d.tag===22&&a){var h=d.memoizedState!==null||Jj;if(!h){var et=d.alternate,ot=et!==null&&et.memoizedState!==null||U$1;et=Jj;var it=U$1;if(Jj=h,(U$1=ot)&&!it)for(V=d;V!==null;)h=V,ot=h.child,h.tag===22&&h.memoizedState!==null?jk(d):ot!==null?(ot.return=h,V=ot):jk(d);for(;g!==null;)V=g,ik(g),g=g.sibling;V=d,Jj=et,U$1=it}kk(i)}else d.subtreeFlags&8772&&g!==null?(g.return=d,V=g):kk(i)}}function kk(i){for(;V!==null;){var e=V;if(e.flags&8772){var o=e.alternate;try{if(e.flags&8772)switch(e.tag){case 0:case 11:case 15:U$1||Qj(5,e);break;case 1:var a=e.stateNode;if(e.flags&4&&!U$1)if(o===null)a.componentDidMount();else{var d=e.elementType===e.type?o.memoizedProps:Ci(e.type,o.memoizedProps);a.componentDidUpdate(d,o.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}var g=e.updateQueue;g!==null&&sh(e,g,a);break;case 3:var h=e.updateQueue;if(h!==null){if(o=null,e.child!==null)switch(e.child.tag){case 5:o=e.child.stateNode;break;case 1:o=e.child.stateNode}sh(e,h,o)}break;case 5:var et=e.stateNode;if(o===null&&e.flags&4){o=et;var ot=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":ot.autoFocus&&o.focus();break;case"img":ot.src&&(o.src=ot.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(e.memoizedState===null){var it=e.alternate;if(it!==null){var $=it.memoizedState;if($!==null){var c=$.dehydrated;c!==null&&bd$1(c)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(p(163))}U$1||e.flags&512&&Rj(e)}catch(s){W(e,e.return,s)}}if(e===i){V=null;break}if(o=e.sibling,o!==null){o.return=e.return,V=o;break}V=e.return}}function gk(i){for(;V!==null;){var e=V;if(e===i){V=null;break}var o=e.sibling;if(o!==null){o.return=e.return,V=o;break}V=e.return}}function jk(i){for(;V!==null;){var e=V;try{switch(e.tag){case 0:case 11:case 15:var o=e.return;try{Qj(4,e)}catch(ot){W(e,o,ot)}break;case 1:var a=e.stateNode;if(typeof a.componentDidMount=="function"){var d=e.return;try{a.componentDidMount()}catch(ot){W(e,d,ot)}}var g=e.return;try{Rj(e)}catch(ot){W(e,g,ot)}break;case 5:var h=e.return;try{Rj(e)}catch(ot){W(e,h,ot)}}}catch(ot){W(e,e.return,ot)}if(e===i){V=null;break}var et=e.sibling;if(et!==null){et.return=e.return,V=et;break}V=e.return}}var lk=Math.ceil,mk=ua$1.ReactCurrentDispatcher,nk=ua$1.ReactCurrentOwner,ok=ua$1.ReactCurrentBatchConfig,K$1=0,Q=null,Y=null,Z=0,fj=0,ej=Uf(0),T=0,pk=null,rh=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=1/0,uk=null,Oi$1=!1,Pi$1=null,Ri$1=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R(){return K$1&6?B():Ak!==-1?Ak:Ak=B()}function yi(i){return i.mode&1?K$1&2&&Z!==0?Z&-Z:Kg.transition!==null?(Bk===0&&(Bk=yc$1()),Bk):(i=C,i!==0||(i=window.event,i=i===void 0?16:jd$1(i.type)),i):1}function gi(i,e,o,a){if(50<yk)throw yk=0,zk=null,Error(p(185));Ac$1(i,o,a),(!(K$1&2)||i!==Q)&&(i===Q&&(!(K$1&2)&&(qk|=o),T===4&&Ck(i,Z)),Dk(i,a),o===1&&K$1===0&&!(e.mode&1)&&(Gj=B()+500,fg&&jg()))}function Dk(i,e){var o=i.callbackNode;wc$1(i,e);var a=uc$1(i,i===Q?Z:0);if(a===0)o!==null&&bc$1(o),i.callbackNode=null,i.callbackPriority=0;else if(e=a&-a,i.callbackPriority!==e){if(o!=null&&bc$1(o),e===1)i.tag===0?ig(Ek.bind(null,i)):hg(Ek.bind(null,i)),Jf(function(){!(K$1&6)&&jg()}),o=null;else{switch(Dc$1(a)){case 1:o=fc$1;break;case 4:o=gc$1;break;case 16:o=hc;break;case 536870912:o=jc$1;break;default:o=hc}o=Fk(o,Gk.bind(null,i))}i.callbackPriority=e,i.callbackNode=o}}function Gk(i,e){if(Ak=-1,Bk=0,K$1&6)throw Error(p(327));var o=i.callbackNode;if(Hk()&&i.callbackNode!==o)return null;var a=uc$1(i,i===Q?Z:0);if(a===0)return null;if(a&30||a&i.expiredLanes||e)e=Ik(i,a);else{e=a;var d=K$1;K$1|=2;var g=Jk();(Q!==i||Z!==e)&&(uk=null,Gj=B()+500,Kk(i,e));do try{Lk();break}catch(et){Mk(i,et)}while(!0);$g(),mk.current=g,K$1=d,Y!==null?e=0:(Q=null,Z=0,e=T)}if(e!==0){if(e===2&&(d=xc$1(i),d!==0&&(a=d,e=Nk(i,d))),e===1)throw o=pk,Kk(i,0),Ck(i,a),Dk(i,B()),o;if(e===6)Ck(i,a);else{if(d=i.current.alternate,!(a&30)&&!Ok(d)&&(e=Ik(i,a),e===2&&(g=xc$1(i),g!==0&&(a=g,e=Nk(i,g))),e===1))throw o=pk,Kk(i,0),Ck(i,a),Dk(i,B()),o;switch(i.finishedWork=d,i.finishedLanes=a,e){case 0:case 1:throw Error(p(345));case 2:Pk(i,tk,uk);break;case 3:if(Ck(i,a),(a&130023424)===a&&(e=fk+500-B(),10<e)){if(uc$1(i,0)!==0)break;if(d=i.suspendedLanes,(d&a)!==a){R(),i.pingedLanes|=i.suspendedLanes&d;break}i.timeoutHandle=Ff(Pk.bind(null,i,tk,uk),e);break}Pk(i,tk,uk);break;case 4:if(Ck(i,a),(a&4194240)===a)break;for(e=i.eventTimes,d=-1;0<a;){var h=31-oc$1(a);g=1<<h,h=e[h],h>d&&(d=h),a&=~g}if(a=d,a=B()-a,a=(120>a?120:480>a?480:1080>a?1080:1920>a?1920:3e3>a?3e3:4320>a?4320:1960*lk(a/1960))-a,10<a){i.timeoutHandle=Ff(Pk.bind(null,i,tk,uk),a);break}Pk(i,tk,uk);break;case 5:Pk(i,tk,uk);break;default:throw Error(p(329))}}}return Dk(i,B()),i.callbackNode===o?Gk.bind(null,i):null}function Nk(i,e){var o=sk;return i.current.memoizedState.isDehydrated&&(Kk(i,e).flags|=256),i=Ik(i,e),i!==2&&(e=tk,tk=o,e!==null&&Fj(e)),i}function Fj(i){tk===null?tk=i:tk.push.apply(tk,i)}function Ok(i){for(var e=i;;){if(e.flags&16384){var o=e.updateQueue;if(o!==null&&(o=o.stores,o!==null))for(var a=0;a<o.length;a++){var d=o[a],g=d.getSnapshot;d=d.value;try{if(!He(g(),d))return!1}catch{return!1}}}if(o=e.child,e.subtreeFlags&16384&&o!==null)o.return=e,e=o;else{if(e===i)break;for(;e.sibling===null;){if(e.return===null||e.return===i)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function Ck(i,e){for(e&=~rk,e&=~qk,i.suspendedLanes|=e,i.pingedLanes&=~e,i=i.expirationTimes;0<e;){var o=31-oc$1(e),a=1<<o;i[o]=-1,e&=~a}}function Ek(i){if(K$1&6)throw Error(p(327));Hk();var e=uc$1(i,0);if(!(e&1))return Dk(i,B()),null;var o=Ik(i,e);if(i.tag!==0&&o===2){var a=xc$1(i);a!==0&&(e=a,o=Nk(i,a))}if(o===1)throw o=pk,Kk(i,0),Ck(i,e),Dk(i,B()),o;if(o===6)throw Error(p(345));return i.finishedWork=i.current.alternate,i.finishedLanes=e,Pk(i,tk,uk),Dk(i,B()),null}function Qk(i,e){var o=K$1;K$1|=1;try{return i(e)}finally{K$1=o,K$1===0&&(Gj=B()+500,fg&&jg())}}function Rk(i){wk!==null&&wk.tag===0&&!(K$1&6)&&Hk();var e=K$1;K$1|=1;var o=ok.transition,a=C;try{if(ok.transition=null,C=1,i)return i()}finally{C=a,ok.transition=o,K$1=e,!(K$1&6)&&jg()}}function Hj(){fj=ej.current,E(ej)}function Kk(i,e){i.finishedWork=null,i.finishedLanes=0;var o=i.timeoutHandle;if(o!==-1&&(i.timeoutHandle=-1,Gf(o)),Y!==null)for(o=Y.return;o!==null;){var a=o;switch(wg(a),a.tag){case 1:a=a.type.childContextTypes,a!=null&&$f();break;case 3:zh(),E(Wf),E(H),Eh();break;case 5:Bh(a);break;case 4:zh();break;case 13:E(L);break;case 19:E(L);break;case 10:ah(a.type._context);break;case 22:case 23:Hj()}o=o.return}if(Q=i,Y=i=Pg(i.current,null),Z=fj=e,T=0,pk=null,rk=qk=rh=0,tk=sk=null,fh!==null){for(e=0;e<fh.length;e++)if(o=fh[e],a=o.interleaved,a!==null){o.interleaved=null;var d=a.next,g=o.pending;if(g!==null){var h=g.next;g.next=d,a.next=h}o.pending=a}fh=null}return i}function Mk(i,e){do{var o=Y;try{if($g(),Fh.current=Rh,Ih){for(var a=M$1.memoizedState;a!==null;){var d=a.queue;d!==null&&(d.pending=null),a=a.next}Ih=!1}if(Hh=0,O=N=M$1=null,Jh=!1,Kh=0,nk.current=null,o===null||o.return===null){T=1,pk=e,Y=null;break}e:{var g=i,h=o.return,et=o,ot=e;if(e=Z,et.flags|=32768,ot!==null&&typeof ot=="object"&&typeof ot.then=="function"){var it=ot,$=et,c=$.tag;if(!($.mode&1)&&(c===0||c===11||c===15)){var s=$.alternate;s?($.updateQueue=s.updateQueue,$.memoizedState=s.memoizedState,$.lanes=s.lanes):($.updateQueue=null,$.memoizedState=null)}var _=Ui$1(h);if(_!==null){_.flags&=-257,Vi(_,h,et,g,e),_.mode&1&&Si(g,it,e),e=_,ot=it;var b=e.updateQueue;if(b===null){var st=new Set;st.add(ot),e.updateQueue=st}else b.add(ot);break e}else{if(!(e&1)){Si(g,it,e),tj();break e}ot=Error(p(426))}}else if(I&&et.mode&1){var dt=Ui$1(h);if(dt!==null){!(dt.flags&65536)&&(dt.flags|=256),Vi(dt,h,et,g,e),Jg(Ji$1(ot,et));break e}}g=ot=Ji$1(ot,et),T!==4&&(T=2),sk===null?sk=[g]:sk.push(g),g=h;do{switch(g.tag){case 3:g.flags|=65536,e&=-e,g.lanes|=e;var ct=Ni(g,ot,e);ph(g,ct);break e;case 1:et=ot;var pt=g.type,ft=g.stateNode;if(!(g.flags&128)&&(typeof pt.getDerivedStateFromError=="function"||ft!==null&&typeof ft.componentDidCatch=="function"&&(Ri$1===null||!Ri$1.has(ft)))){g.flags|=65536,e&=-e,g.lanes|=e;var mt=Qi$1(g,et,e);ph(g,mt);break e}}g=g.return}while(g!==null)}Sk(o)}catch(bt){e=bt,Y===o&&o!==null&&(Y=o=o.return);continue}break}while(!0)}function Jk(){var i=mk.current;return mk.current=Rh,i===null?Rh:i}function tj(){(T===0||T===3||T===2)&&(T=4),Q===null||!(rh&268435455)&&!(qk&268435455)||Ck(Q,Z)}function Ik(i,e){var o=K$1;K$1|=2;var a=Jk();(Q!==i||Z!==e)&&(uk=null,Kk(i,e));do try{Tk();break}catch(d){Mk(i,d)}while(!0);if($g(),K$1=o,mk.current=a,Y!==null)throw Error(p(261));return Q=null,Z=0,T}function Tk(){for(;Y!==null;)Uk(Y)}function Lk(){for(;Y!==null&&!cc$1();)Uk(Y)}function Uk(i){var e=Vk(i.alternate,i,fj);i.memoizedProps=i.pendingProps,e===null?Sk(i):Y=e,nk.current=null}function Sk(i){var e=i;do{var o=e.alternate;if(i=e.return,e.flags&32768){if(o=Ij(o,e),o!==null){o.flags&=32767,Y=o;return}if(i!==null)i.flags|=32768,i.subtreeFlags=0,i.deletions=null;else{T=6,Y=null;return}}else if(o=Ej(o,e,fj),o!==null){Y=o;return}if(e=e.sibling,e!==null){Y=e;return}Y=e=i}while(e!==null);T===0&&(T=5)}function Pk(i,e,o){var a=C,d=ok.transition;try{ok.transition=null,C=1,Wk(i,e,o,a)}finally{ok.transition=d,C=a}return null}function Wk(i,e,o,a){do Hk();while(wk!==null);if(K$1&6)throw Error(p(327));o=i.finishedWork;var d=i.finishedLanes;if(o===null)return null;if(i.finishedWork=null,i.finishedLanes=0,o===i.current)throw Error(p(177));i.callbackNode=null,i.callbackPriority=0;var g=o.lanes|o.childLanes;if(Bc$1(i,g),i===Q&&(Y=Q=null,Z=0),!(o.subtreeFlags&2064)&&!(o.flags&2064)||vk||(vk=!0,Fk(hc,function(){return Hk(),null})),g=(o.flags&15990)!==0,o.subtreeFlags&15990||g){g=ok.transition,ok.transition=null;var h=C;C=1;var et=K$1;K$1|=4,nk.current=null,Oj(i,o),dk(o,i),Oe(Df),dd$1=!!Cf,Df=Cf=null,i.current=o,hk(o),dc$1(),K$1=et,C=h,ok.transition=g}else i.current=o;if(vk&&(vk=!1,wk=i,xk=d),g=i.pendingLanes,g===0&&(Ri$1=null),mc$1(o.stateNode),Dk(i,B()),e!==null)for(a=i.onRecoverableError,o=0;o<e.length;o++)d=e[o],a(d.value,{componentStack:d.stack,digest:d.digest});if(Oi$1)throw Oi$1=!1,i=Pi$1,Pi$1=null,i;return xk&1&&i.tag!==0&&Hk(),g=i.pendingLanes,g&1?i===zk?yk++:(yk=0,zk=i):yk=0,jg(),null}function Hk(){if(wk!==null){var i=Dc$1(xk),e=ok.transition,o=C;try{if(ok.transition=null,C=16>i?16:i,wk===null)var a=!1;else{if(i=wk,wk=null,xk=0,K$1&6)throw Error(p(331));var d=K$1;for(K$1|=4,V=i.current;V!==null;){var g=V,h=g.child;if(V.flags&16){var et=g.deletions;if(et!==null){for(var ot=0;ot<et.length;ot++){var it=et[ot];for(V=it;V!==null;){var $=V;switch($.tag){case 0:case 11:case 15:Pj(8,$,g)}var c=$.child;if(c!==null)c.return=$,V=c;else for(;V!==null;){$=V;var s=$.sibling,_=$.return;if(Sj($),$===it){V=null;break}if(s!==null){s.return=_,V=s;break}V=_}}}var b=g.alternate;if(b!==null){var st=b.child;if(st!==null){b.child=null;do{var dt=st.sibling;st.sibling=null,st=dt}while(st!==null)}}V=g}}if(g.subtreeFlags&2064&&h!==null)h.return=g,V=h;else e:for(;V!==null;){if(g=V,g.flags&2048)switch(g.tag){case 0:case 11:case 15:Pj(9,g,g.return)}var ct=g.sibling;if(ct!==null){ct.return=g.return,V=ct;break e}V=g.return}}var pt=i.current;for(V=pt;V!==null;){h=V;var ft=h.child;if(h.subtreeFlags&2064&&ft!==null)ft.return=h,V=ft;else e:for(h=pt;V!==null;){if(et=V,et.flags&2048)try{switch(et.tag){case 0:case 11:case 15:Qj(9,et)}}catch(bt){W(et,et.return,bt)}if(et===h){V=null;break e}var mt=et.sibling;if(mt!==null){mt.return=et.return,V=mt;break e}V=et.return}}if(K$1=d,jg(),lc$1&&typeof lc$1.onPostCommitFiberRoot=="function")try{lc$1.onPostCommitFiberRoot(kc$1,i)}catch{}a=!0}return a}finally{C=o,ok.transition=e}}return!1}function Xk(i,e,o){e=Ji$1(o,e),e=Ni(i,e,1),i=nh(i,e,1),e=R(),i!==null&&(Ac$1(i,1,e),Dk(i,e))}function W(i,e,o){if(i.tag===3)Xk(i,i,o);else for(;e!==null;){if(e.tag===3){Xk(e,i,o);break}else if(e.tag===1){var a=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof a.componentDidCatch=="function"&&(Ri$1===null||!Ri$1.has(a))){i=Ji$1(o,i),i=Qi$1(e,i,1),e=nh(e,i,1),i=R(),e!==null&&(Ac$1(e,1,i),Dk(e,i));break}}e=e.return}}function Ti(i,e,o){var a=i.pingCache;a!==null&&a.delete(e),e=R(),i.pingedLanes|=i.suspendedLanes&o,Q===i&&(Z&o)===o&&(T===4||T===3&&(Z&130023424)===Z&&500>B()-fk?Kk(i,0):rk|=o),Dk(i,e)}function Yk(i,e){e===0&&(i.mode&1?(e=sc$1,sc$1<<=1,!(sc$1&130023424)&&(sc$1=4194304)):e=1);var o=R();i=ih(i,e),i!==null&&(Ac$1(i,e,o),Dk(i,o))}function uj(i){var e=i.memoizedState,o=0;e!==null&&(o=e.retryLane),Yk(i,o)}function bk(i,e){var o=0;switch(i.tag){case 13:var a=i.stateNode,d=i.memoizedState;d!==null&&(o=d.retryLane);break;case 19:a=i.stateNode;break;default:throw Error(p(314))}a!==null&&a.delete(e),Yk(i,o)}var Vk;Vk=function(i,e,o){if(i!==null)if(i.memoizedProps!==e.pendingProps||Wf.current)dh=!0;else{if(!(i.lanes&o)&&!(e.flags&128))return dh=!1,yj(i,e,o);dh=!!(i.flags&131072)}else dh=!1,I&&e.flags&1048576&&ug(e,ng,e.index);switch(e.lanes=0,e.tag){case 2:var a=e.type;ij(i,e),i=e.pendingProps;var d=Yf(e,H.current);ch(e,o),d=Nh(null,e,a,i,d,o);var g=Sh();return e.flags|=1,typeof d=="object"&&d!==null&&typeof d.render=="function"&&d.$$typeof===void 0?(e.tag=1,e.memoizedState=null,e.updateQueue=null,Zf(a)?(g=!0,cg(e)):g=!1,e.memoizedState=d.state!==null&&d.state!==void 0?d.state:null,kh(e),d.updater=Ei,e.stateNode=d,d._reactInternals=e,Ii(e,a,i,o),e=jj(null,e,a,!0,g,o)):(e.tag=0,I&&g&&vg(e),Xi$1(null,e,d,o),e=e.child),e;case 16:a=e.elementType;e:{switch(ij(i,e),i=e.pendingProps,d=a._init,a=d(a._payload),e.type=a,d=e.tag=Zk(a),i=Ci(a,i),d){case 0:e=cj(null,e,a,i,o);break e;case 1:e=hj(null,e,a,i,o);break e;case 11:e=Yi$1(null,e,a,i,o);break e;case 14:e=$i(null,e,a,Ci(a.type,i),o);break e}throw Error(p(306,a,""))}return e;case 0:return a=e.type,d=e.pendingProps,d=e.elementType===a?d:Ci(a,d),cj(i,e,a,d,o);case 1:return a=e.type,d=e.pendingProps,d=e.elementType===a?d:Ci(a,d),hj(i,e,a,d,o);case 3:e:{if(kj(e),i===null)throw Error(p(387));a=e.pendingProps,g=e.memoizedState,d=g.element,lh(i,e),qh(e,a,null,o);var h=e.memoizedState;if(a=h.element,g.isDehydrated)if(g={element:a,isDehydrated:!1,cache:h.cache,pendingSuspenseBoundaries:h.pendingSuspenseBoundaries,transitions:h.transitions},e.updateQueue.baseState=g,e.memoizedState=g,e.flags&256){d=Ji$1(Error(p(423)),e),e=lj(i,e,a,o,d);break e}else if(a!==d){d=Ji$1(Error(p(424)),e),e=lj(i,e,a,o,d);break e}else for(yg=Lf(e.stateNode.containerInfo.firstChild),xg=e,I=!0,zg=null,o=Vg(e,null,a,o),e.child=o;o;)o.flags=o.flags&-3|4096,o=o.sibling;else{if(Ig(),a===d){e=Zi$1(i,e,o);break e}Xi$1(i,e,a,o)}e=e.child}return e;case 5:return Ah(e),i===null&&Eg(e),a=e.type,d=e.pendingProps,g=i!==null?i.memoizedProps:null,h=d.children,Ef(a,d)?h=null:g!==null&&Ef(a,g)&&(e.flags|=32),gj(i,e),Xi$1(i,e,h,o),e.child;case 6:return i===null&&Eg(e),null;case 13:return oj(i,e,o);case 4:return yh(e,e.stateNode.containerInfo),a=e.pendingProps,i===null?e.child=Ug(e,null,a,o):Xi$1(i,e,a,o),e.child;case 11:return a=e.type,d=e.pendingProps,d=e.elementType===a?d:Ci(a,d),Yi$1(i,e,a,d,o);case 7:return Xi$1(i,e,e.pendingProps,o),e.child;case 8:return Xi$1(i,e,e.pendingProps.children,o),e.child;case 12:return Xi$1(i,e,e.pendingProps.children,o),e.child;case 10:e:{if(a=e.type._context,d=e.pendingProps,g=e.memoizedProps,h=d.value,G(Wg,a._currentValue),a._currentValue=h,g!==null)if(He(g.value,h)){if(g.children===d.children&&!Wf.current){e=Zi$1(i,e,o);break e}}else for(g=e.child,g!==null&&(g.return=e);g!==null;){var et=g.dependencies;if(et!==null){h=g.child;for(var ot=et.firstContext;ot!==null;){if(ot.context===a){if(g.tag===1){ot=mh(-1,o&-o),ot.tag=2;var it=g.updateQueue;if(it!==null){it=it.shared;var $=it.pending;$===null?ot.next=ot:(ot.next=$.next,$.next=ot),it.pending=ot}}g.lanes|=o,ot=g.alternate,ot!==null&&(ot.lanes|=o),bh(g.return,o,e),et.lanes|=o;break}ot=ot.next}}else if(g.tag===10)h=g.type===e.type?null:g.child;else if(g.tag===18){if(h=g.return,h===null)throw Error(p(341));h.lanes|=o,et=h.alternate,et!==null&&(et.lanes|=o),bh(h,o,e),h=g.sibling}else h=g.child;if(h!==null)h.return=g;else for(h=g;h!==null;){if(h===e){h=null;break}if(g=h.sibling,g!==null){g.return=h.return,h=g;break}h=h.return}g=h}Xi$1(i,e,d.children,o),e=e.child}return e;case 9:return d=e.type,a=e.pendingProps.children,ch(e,o),d=eh(d),a=a(d),e.flags|=1,Xi$1(i,e,a,o),e.child;case 14:return a=e.type,d=Ci(a,e.pendingProps),d=Ci(a.type,d),$i(i,e,a,d,o);case 15:return bj(i,e,e.type,e.pendingProps,o);case 17:return a=e.type,d=e.pendingProps,d=e.elementType===a?d:Ci(a,d),ij(i,e),e.tag=1,Zf(a)?(i=!0,cg(e)):i=!1,ch(e,o),Gi$1(e,a,d),Ii(e,a,d,o),jj(null,e,a,!0,i,o);case 19:return xj(i,e,o);case 22:return dj(i,e,o)}throw Error(p(156,e.tag))};function Fk(i,e){return ac$1(i,e)}function $k(i,e,o,a){this.tag=i,this.key=o,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Bg(i,e,o,a){return new $k(i,e,o,a)}function aj(i){return i=i.prototype,!(!i||!i.isReactComponent)}function Zk(i){if(typeof i=="function")return aj(i)?1:0;if(i!=null){if(i=i.$$typeof,i===Da)return 11;if(i===Ga)return 14}return 2}function Pg(i,e){var o=i.alternate;return o===null?(o=Bg(i.tag,e,i.key,i.mode),o.elementType=i.elementType,o.type=i.type,o.stateNode=i.stateNode,o.alternate=i,i.alternate=o):(o.pendingProps=e,o.type=i.type,o.flags=0,o.subtreeFlags=0,o.deletions=null),o.flags=i.flags&14680064,o.childLanes=i.childLanes,o.lanes=i.lanes,o.child=i.child,o.memoizedProps=i.memoizedProps,o.memoizedState=i.memoizedState,o.updateQueue=i.updateQueue,e=i.dependencies,o.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},o.sibling=i.sibling,o.index=i.index,o.ref=i.ref,o}function Rg(i,e,o,a,d,g){var h=2;if(a=i,typeof i=="function")aj(i)&&(h=1);else if(typeof i=="string")h=5;else e:switch(i){case ya$1:return Tg(o.children,d,g,e);case za:h=8,d|=8;break;case Aa:return i=Bg(12,o,e,d|2),i.elementType=Aa,i.lanes=g,i;case Ea:return i=Bg(13,o,e,d),i.elementType=Ea,i.lanes=g,i;case Fa:return i=Bg(19,o,e,d),i.elementType=Fa,i.lanes=g,i;case Ia$1:return pj(o,d,g,e);default:if(typeof i=="object"&&i!==null)switch(i.$$typeof){case Ba:h=10;break e;case Ca$1:h=9;break e;case Da:h=11;break e;case Ga:h=14;break e;case Ha:h=16,a=null;break e}throw Error(p(130,i==null?i:typeof i,""))}return e=Bg(h,o,e,d),e.elementType=i,e.type=a,e.lanes=g,e}function Tg(i,e,o,a){return i=Bg(7,i,a,e),i.lanes=o,i}function pj(i,e,o,a){return i=Bg(22,i,a,e),i.elementType=Ia$1,i.lanes=o,i.stateNode={isHidden:!1},i}function Qg(i,e,o){return i=Bg(6,i,null,e),i.lanes=o,i}function Sg(i,e,o){return e=Bg(4,i.children!==null?i.children:[],i.key,e),e.lanes=o,e.stateNode={containerInfo:i.containerInfo,pendingChildren:null,implementation:i.implementation},e}function al$1(i,e,o,a,d){this.tag=e,this.containerInfo=i,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=zc$1(0),this.expirationTimes=zc$1(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zc$1(0),this.identifierPrefix=a,this.onRecoverableError=d,this.mutableSourceEagerHydrationData=null}function bl$1(i,e,o,a,d,g,h,et,ot){return i=new al$1(i,e,o,et,ot),e===1?(e=1,g===!0&&(e|=8)):e=0,g=Bg(3,null,null,e),i.current=g,g.stateNode=i,g.memoizedState={element:a,isDehydrated:o,cache:null,transitions:null,pendingSuspenseBoundaries:null},kh(g),i}function cl$1(i,e,o){var a=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:wa$1,key:a==null?null:""+a,children:i,containerInfo:e,implementation:o}}function dl$1(i){if(!i)return Vf;i=i._reactInternals;e:{if(Vb(i)!==i||i.tag!==1)throw Error(p(170));var e=i;do{switch(e.tag){case 3:e=e.stateNode.context;break e;case 1:if(Zf(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break e}}e=e.return}while(e!==null);throw Error(p(171))}if(i.tag===1){var o=i.type;if(Zf(o))return bg(i,o,e)}return e}function el$1(i,e,o,a,d,g,h,et,ot){return i=bl$1(o,a,!0,i,d,g,h,et,ot),i.context=dl$1(null),o=i.current,a=R(),d=yi(o),g=mh(a,d),g.callback=e??null,nh(o,g,d),i.current.lanes=d,Ac$1(i,d,a),Dk(i,a),i}function fl$1(i,e,o,a){var d=e.current,g=R(),h=yi(d);return o=dl$1(o),e.context===null?e.context=o:e.pendingContext=o,e=mh(g,h),e.payload={element:i},a=a===void 0?null:a,a!==null&&(e.callback=a),i=nh(d,e,h),i!==null&&(gi(i,d,h,g),oh(i,d,h)),h}function gl$1(i){if(i=i.current,!i.child)return null;switch(i.child.tag){case 5:return i.child.stateNode;default:return i.child.stateNode}}function hl$1(i,e){if(i=i.memoizedState,i!==null&&i.dehydrated!==null){var o=i.retryLane;i.retryLane=o!==0&&o<e?o:e}}function il$1(i,e){hl$1(i,e),(i=i.alternate)&&hl$1(i,e)}function jl$1(){return null}var kl$1=typeof reportError=="function"?reportError:function(i){console.error(i)};function ll$1(i){this._internalRoot=i}ml$1.prototype.render=ll$1.prototype.render=function(i){var e=this._internalRoot;if(e===null)throw Error(p(409));fl$1(i,e,null,null)};ml$1.prototype.unmount=ll$1.prototype.unmount=function(){var i=this._internalRoot;if(i!==null){this._internalRoot=null;var e=i.containerInfo;Rk(function(){fl$1(null,i,null,null)}),e[uf$1]=null}};function ml$1(i){this._internalRoot=i}ml$1.prototype.unstable_scheduleHydration=function(i){if(i){var e=Hc$1();i={blockedOn:null,target:i,priority:e};for(var o=0;o<Qc$1.length&&e!==0&&e<Qc$1[o].priority;o++);Qc$1.splice(o,0,i),o===0&&Vc$1(i)}};function nl$1(i){return!(!i||i.nodeType!==1&&i.nodeType!==9&&i.nodeType!==11)}function ol$1(i){return!(!i||i.nodeType!==1&&i.nodeType!==9&&i.nodeType!==11&&(i.nodeType!==8||i.nodeValue!==" react-mount-point-unstable "))}function pl$1(){}function ql$1(i,e,o,a,d){if(d){if(typeof a=="function"){var g=a;a=function(){var it=gl$1(h);g.call(it)}}var h=el$1(e,a,i,0,null,!1,!1,"",pl$1);return i._reactRootContainer=h,i[uf$1]=h.current,sf$1(i.nodeType===8?i.parentNode:i),Rk(),h}for(;d=i.lastChild;)i.removeChild(d);if(typeof a=="function"){var et=a;a=function(){var it=gl$1(ot);et.call(it)}}var ot=bl$1(i,0,!1,null,null,!1,!1,"",pl$1);return i._reactRootContainer=ot,i[uf$1]=ot.current,sf$1(i.nodeType===8?i.parentNode:i),Rk(function(){fl$1(e,ot,o,a)}),ot}function rl$1(i,e,o,a,d){var g=o._reactRootContainer;if(g){var h=g;if(typeof d=="function"){var et=d;d=function(){var ot=gl$1(h);et.call(ot)}}fl$1(e,h,i,d)}else h=ql$1(o,e,i,d,a);return gl$1(h)}Ec$1=function(i){switch(i.tag){case 3:var e=i.stateNode;if(e.current.memoizedState.isDehydrated){var o=tc(e.pendingLanes);o!==0&&(Cc$1(e,o|1),Dk(e,B()),!(K$1&6)&&(Gj=B()+500,jg()))}break;case 13:Rk(function(){var a=ih(i,1);if(a!==null){var d=R();gi(a,i,1,d)}}),il$1(i,1)}};Fc$1=function(i){if(i.tag===13){var e=ih(i,134217728);if(e!==null){var o=R();gi(e,i,134217728,o)}il$1(i,134217728)}};Gc$1=function(i){if(i.tag===13){var e=yi(i),o=ih(i,e);if(o!==null){var a=R();gi(o,i,e,a)}il$1(i,e)}};Hc$1=function(){return C};Ic$1=function(i,e){var o=C;try{return C=i,e()}finally{C=o}};yb=function(i,e,o){switch(e){case"input":if(bb(i,o),e=o.name,o.type==="radio"&&e!=null){for(o=i;o.parentNode;)o=o.parentNode;for(o=o.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<o.length;e++){var a=o[e];if(a!==i&&a.form===i.form){var d=Db(a);if(!d)throw Error(p(90));Wa(a),bb(a,d)}}}break;case"textarea":ib(i,o);break;case"select":e=o.value,e!=null&&fb(i,!!o.multiple,e,!1)}};Gb=Qk;Hb=Rk;var sl$1={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Qk]},tl$1={findFiberByHostInstance:Wc$1,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},ul$1={bundleType:tl$1.bundleType,version:tl$1.version,rendererPackageName:tl$1.rendererPackageName,rendererConfig:tl$1.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua$1.ReactCurrentDispatcher,findHostInstanceByFiber:function(i){return i=Zb(i),i===null?null:i.stateNode},findFiberByHostInstance:tl$1.findFiberByHostInstance||jl$1,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var vl$1=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl$1.isDisabled&&vl$1.supportsFiber)try{kc$1=vl$1.inject(ul$1),lc$1=vl$1}catch{}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl$1;reactDom_production_min.createPortal=function(i,e){var o=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!nl$1(e))throw Error(p(200));return cl$1(i,e,null,o)};reactDom_production_min.createRoot=function(i,e){if(!nl$1(i))throw Error(p(299));var o=!1,a="",d=kl$1;return e!=null&&(e.unstable_strictMode===!0&&(o=!0),e.identifierPrefix!==void 0&&(a=e.identifierPrefix),e.onRecoverableError!==void 0&&(d=e.onRecoverableError)),e=bl$1(i,1,!1,null,null,o,!1,a,d),i[uf$1]=e.current,sf$1(i.nodeType===8?i.parentNode:i),new ll$1(e)};reactDom_production_min.findDOMNode=function(i){if(i==null)return null;if(i.nodeType===1)return i;var e=i._reactInternals;if(e===void 0)throw typeof i.render=="function"?Error(p(188)):(i=Object.keys(i).join(","),Error(p(268,i)));return i=Zb(e),i=i===null?null:i.stateNode,i};reactDom_production_min.flushSync=function(i){return Rk(i)};reactDom_production_min.hydrate=function(i,e,o){if(!ol$1(e))throw Error(p(200));return rl$1(null,i,e,!0,o)};reactDom_production_min.hydrateRoot=function(i,e,o){if(!nl$1(i))throw Error(p(405));var a=o!=null&&o.hydratedSources||null,d=!1,g="",h=kl$1;if(o!=null&&(o.unstable_strictMode===!0&&(d=!0),o.identifierPrefix!==void 0&&(g=o.identifierPrefix),o.onRecoverableError!==void 0&&(h=o.onRecoverableError)),e=el$1(e,null,i,1,o??null,d,!1,g,h),i[uf$1]=e.current,sf$1(i),a)for(i=0;i<a.length;i++)o=a[i],d=o._getVersion,d=d(o._source),e.mutableSourceEagerHydrationData==null?e.mutableSourceEagerHydrationData=[o,d]:e.mutableSourceEagerHydrationData.push(o,d);return new ml$1(e)};reactDom_production_min.render=function(i,e,o){if(!ol$1(e))throw Error(p(200));return rl$1(null,i,e,!1,o)};reactDom_production_min.unmountComponentAtNode=function(i){if(!ol$1(i))throw Error(p(40));return i._reactRootContainer?(Rk(function(){rl$1(null,null,i,!1,function(){i._reactRootContainer=null,i[uf$1]=null})}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Qk;reactDom_production_min.unstable_renderSubtreeIntoContainer=function(i,e,o,a){if(!ol$1(o))throw Error(p(200));if(i==null||i._reactInternals===void 0)throw Error(p(38));return rl$1(i,e,o,!1,a)};reactDom_production_min.version="18.3.1-next-f1338f8080-20240426";function checkDCE(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)}catch(i){console.error(i)}}checkDCE(),reactDom.exports=reactDom_production_min;var reactDomExports=reactDom.exports,m=reactDomExports;client.createRoot=m.createRoot,client.hydrateRoot=m.hydrateRoot;function _getDefaults(){return{async:!1,breaks:!1,extensions:null,gfm:!0,hooks:null,pedantic:!1,renderer:null,silent:!1,tokenizer:null,walkTokens:null}}let _defaults=_getDefaults();function changeDefaults(i){_defaults=i}const escapeTest=/[&<>"']/,escapeReplace=new RegExp(escapeTest.source,"g"),escapeTestNoEncode=/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,escapeReplaceNoEncode=new RegExp(escapeTestNoEncode.source,"g"),escapeReplacements={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},getEscapeReplacement=i=>escapeReplacements[i];function escape$1(i,e){if(e){if(escapeTest.test(i))return i.replace(escapeReplace,getEscapeReplacement)}else if(escapeTestNoEncode.test(i))return i.replace(escapeReplaceNoEncode,getEscapeReplacement);return i}const unescapeTest=/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;function unescape(i){return i.replace(unescapeTest,(e,o)=>(o=o.toLowerCase(),o==="colon"?":":o.charAt(0)==="#"?o.charAt(1)==="x"?String.fromCharCode(parseInt(o.substring(2),16)):String.fromCharCode(+o.substring(1)):""))}const caret=/(^|[^\[])\^/g;function edit(i,e){let o=typeof i=="string"?i:i.source;e=e||"";const a={replace:(d,g)=>{let h=typeof g=="string"?g:g.source;return h=h.replace(caret,"$1"),o=o.replace(d,h),a},getRegex:()=>new RegExp(o,e)};return a}function cleanUrl(i){try{i=encodeURI(i).replace(/%25/g,"%")}catch{return null}return i}const noopTest={exec:()=>null};function splitCells(i,e){const o=i.replace(/\|/g,(g,h,et)=>{let ot=!1,it=h;for(;--it>=0&&et[it]==="\\";)ot=!ot;return ot?"|":" |"}),a=o.split(/ \|/);let d=0;if(a[0].trim()||a.shift(),a.length>0&&!a[a.length-1].trim()&&a.pop(),e)if(a.length>e)a.splice(e);else for(;a.length<e;)a.push("");for(;d<a.length;d++)a[d]=a[d].trim().replace(/\\\|/g,"|");return a}function rtrim(i,e,o){const a=i.length;if(a===0)return"";let d=0;for(;d<a;){const g=i.charAt(a-d-1);if(g===e&&!o)d++;else if(g!==e&&o)d++;else break}return i.slice(0,a-d)}function findClosingBracket(i,e){if(i.indexOf(e[1])===-1)return-1;let o=0;for(let a=0;a<i.length;a++)if(i[a]==="\\")a++;else if(i[a]===e[0])o++;else if(i[a]===e[1]&&(o--,o<0))return a;return-1}function outputLink(i,e,o,a){const d=e.href,g=e.title?escape$1(e.title):null,h=i[1].replace(/\\([\[\]])/g,"$1");if(i[0].charAt(0)!=="!"){a.state.inLink=!0;const et={type:"link",raw:o,href:d,title:g,text:h,tokens:a.inlineTokens(h)};return a.state.inLink=!1,et}return{type:"image",raw:o,href:d,title:g,text:escape$1(h)}}function indentCodeCompensation(i,e){const o=i.match(/^(\s+)(?:```)/);if(o===null)return e;const a=o[1];return e.split(`
`).map(d=>{const g=d.match(/^\s+/);if(g===null)return d;const[h]=g;return h.length>=a.length?d.slice(a.length):d}).join(`
`)}class _Tokenizer{constructor(e){ir(this,"options");ir(this,"rules");ir(this,"lexer");this.options=e||_defaults}space(e){const o=this.rules.block.newline.exec(e);if(o&&o[0].length>0)return{type:"space",raw:o[0]}}code(e){const o=this.rules.block.code.exec(e);if(o){const a=o[0].replace(/^ {1,4}/gm,"");return{type:"code",raw:o[0],codeBlockStyle:"indented",text:this.options.pedantic?a:rtrim(a,`
`)}}}fences(e){const o=this.rules.block.fences.exec(e);if(o){const a=o[0],d=indentCodeCompensation(a,o[3]||"");return{type:"code",raw:a,lang:o[2]?o[2].trim().replace(this.rules.inline.anyPunctuation,"$1"):o[2],text:d}}}heading(e){const o=this.rules.block.heading.exec(e);if(o){let a=o[2].trim();if(/#$/.test(a)){const d=rtrim(a,"#");(this.options.pedantic||!d||/ $/.test(d))&&(a=d.trim())}return{type:"heading",raw:o[0],depth:o[1].length,text:a,tokens:this.lexer.inline(a)}}}hr(e){const o=this.rules.block.hr.exec(e);if(o)return{type:"hr",raw:o[0]}}blockquote(e){const o=this.rules.block.blockquote.exec(e);if(o){let a=o[0].replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,`
    $1`);a=rtrim(a.replace(/^ *>[ \t]?/gm,""),`
`);const d=this.lexer.state.top;this.lexer.state.top=!0;const g=this.lexer.blockTokens(a);return this.lexer.state.top=d,{type:"blockquote",raw:o[0],tokens:g,text:a}}}list(e){let o=this.rules.block.list.exec(e);if(o){let a=o[1].trim();const d=a.length>1,g={type:"list",raw:"",ordered:d,start:d?+a.slice(0,-1):"",loose:!1,items:[]};a=d?`\\d{1,9}\\${a.slice(-1)}`:`\\${a}`,this.options.pedantic&&(a=d?a:"[*+-]");const h=new RegExp(`^( {0,3}${a})((?:[	 ][^\\n]*)?(?:\\n|$))`);let et="",ot="",it=!1;for(;e;){let $=!1;if(!(o=h.exec(e))||this.rules.block.hr.test(e))break;et=o[0],e=e.substring(et.length);let c=o[2].split(`
`,1)[0].replace(/^\t+/,ct=>" ".repeat(3*ct.length)),s=e.split(`
`,1)[0],_=0;this.options.pedantic?(_=2,ot=c.trimStart()):(_=o[2].search(/[^ ]/),_=_>4?1:_,ot=c.slice(_),_+=o[1].length);let b=!1;if(!c&&/^ *$/.test(s)&&(et+=s+`
`,e=e.substring(s.length+1),$=!0),!$){const ct=new RegExp(`^ {0,${Math.min(3,_-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),pt=new RegExp(`^ {0,${Math.min(3,_-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),ft=new RegExp(`^ {0,${Math.min(3,_-1)}}(?:\`\`\`|~~~)`),mt=new RegExp(`^ {0,${Math.min(3,_-1)}}#`);for(;e;){const bt=e.split(`
`,1)[0];if(s=bt,this.options.pedantic&&(s=s.replace(/^ {1,4}(?=( {4})*[^ ])/g,"  ")),ft.test(s)||mt.test(s)||ct.test(s)||pt.test(e))break;if(s.search(/[^ ]/)>=_||!s.trim())ot+=`
`+s.slice(_);else{if(b||c.search(/[^ ]/)>=4||ft.test(c)||mt.test(c)||pt.test(c))break;ot+=`
`+s}!b&&!s.trim()&&(b=!0),et+=bt+`
`,e=e.substring(bt.length+1),c=s.slice(_)}}g.loose||(it?g.loose=!0:/\n *\n *$/.test(et)&&(it=!0));let st=null,dt;this.options.gfm&&(st=/^\[[ xX]\] /.exec(ot),st&&(dt=st[0]!=="[ ] ",ot=ot.replace(/^\[[ xX]\] +/,""))),g.items.push({type:"list_item",raw:et,task:!!st,checked:dt,loose:!1,text:ot,tokens:[]}),g.raw+=et}g.items[g.items.length-1].raw=et.trimEnd(),g.items[g.items.length-1].text=ot.trimEnd(),g.raw=g.raw.trimEnd();for(let $=0;$<g.items.length;$++)if(this.lexer.state.top=!1,g.items[$].tokens=this.lexer.blockTokens(g.items[$].text,[]),!g.loose){const c=g.items[$].tokens.filter(_=>_.type==="space"),s=c.length>0&&c.some(_=>/\n.*\n/.test(_.raw));g.loose=s}if(g.loose)for(let $=0;$<g.items.length;$++)g.items[$].loose=!0;return g}}html(e){const o=this.rules.block.html.exec(e);if(o)return{type:"html",block:!0,raw:o[0],pre:o[1]==="pre"||o[1]==="script"||o[1]==="style",text:o[0]}}def(e){const o=this.rules.block.def.exec(e);if(o){const a=o[1].toLowerCase().replace(/\s+/g," "),d=o[2]?o[2].replace(/^<(.*)>$/,"$1").replace(this.rules.inline.anyPunctuation,"$1"):"",g=o[3]?o[3].substring(1,o[3].length-1).replace(this.rules.inline.anyPunctuation,"$1"):o[3];return{type:"def",tag:a,raw:o[0],href:d,title:g}}}table(e){const o=this.rules.block.table.exec(e);if(!o||!/[:|]/.test(o[2]))return;const a=splitCells(o[1]),d=o[2].replace(/^\||\| *$/g,"").split("|"),g=o[3]&&o[3].trim()?o[3].replace(/\n[ \t]*$/,"").split(`
`):[],h={type:"table",raw:o[0],header:[],align:[],rows:[]};if(a.length===d.length){for(const et of d)/^ *-+: *$/.test(et)?h.align.push("right"):/^ *:-+: *$/.test(et)?h.align.push("center"):/^ *:-+ *$/.test(et)?h.align.push("left"):h.align.push(null);for(const et of a)h.header.push({text:et,tokens:this.lexer.inline(et)});for(const et of g)h.rows.push(splitCells(et,h.header.length).map(ot=>({text:ot,tokens:this.lexer.inline(ot)})));return h}}lheading(e){const o=this.rules.block.lheading.exec(e);if(o)return{type:"heading",raw:o[0],depth:o[2].charAt(0)==="="?1:2,text:o[1],tokens:this.lexer.inline(o[1])}}paragraph(e){const o=this.rules.block.paragraph.exec(e);if(o){const a=o[1].charAt(o[1].length-1)===`
`?o[1].slice(0,-1):o[1];return{type:"paragraph",raw:o[0],text:a,tokens:this.lexer.inline(a)}}}text(e){const o=this.rules.block.text.exec(e);if(o)return{type:"text",raw:o[0],text:o[0],tokens:this.lexer.inline(o[0])}}escape(e){const o=this.rules.inline.escape.exec(e);if(o)return{type:"escape",raw:o[0],text:escape$1(o[1])}}tag(e){const o=this.rules.inline.tag.exec(e);if(o)return!this.lexer.state.inLink&&/^<a /i.test(o[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&/^<\/a>/i.test(o[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(o[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(o[0])&&(this.lexer.state.inRawBlock=!1),{type:"html",raw:o[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:!1,text:o[0]}}link(e){const o=this.rules.inline.link.exec(e);if(o){const a=o[2].trim();if(!this.options.pedantic&&/^</.test(a)){if(!/>$/.test(a))return;const h=rtrim(a.slice(0,-1),"\\");if((a.length-h.length)%2===0)return}else{const h=findClosingBracket(o[2],"()");if(h>-1){const ot=(o[0].indexOf("!")===0?5:4)+o[1].length+h;o[2]=o[2].substring(0,h),o[0]=o[0].substring(0,ot).trim(),o[3]=""}}let d=o[2],g="";if(this.options.pedantic){const h=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(d);h&&(d=h[1],g=h[3])}else g=o[3]?o[3].slice(1,-1):"";return d=d.trim(),/^</.test(d)&&(this.options.pedantic&&!/>$/.test(a)?d=d.slice(1):d=d.slice(1,-1)),outputLink(o,{href:d&&d.replace(this.rules.inline.anyPunctuation,"$1"),title:g&&g.replace(this.rules.inline.anyPunctuation,"$1")},o[0],this.lexer)}}reflink(e,o){let a;if((a=this.rules.inline.reflink.exec(e))||(a=this.rules.inline.nolink.exec(e))){const d=(a[2]||a[1]).replace(/\s+/g," "),g=o[d.toLowerCase()];if(!g){const h=a[0].charAt(0);return{type:"text",raw:h,text:h}}return outputLink(a,g,a[0],this.lexer)}}emStrong(e,o,a=""){let d=this.rules.inline.emStrongLDelim.exec(e);if(!d||d[3]&&a.match(/[\p{L}\p{N}]/u))return;if(!(d[1]||d[2]||"")||!a||this.rules.inline.punctuation.exec(a)){const h=[...d[0]].length-1;let et,ot,it=h,$=0;const c=d[0][0]==="*"?this.rules.inline.emStrongRDelimAst:this.rules.inline.emStrongRDelimUnd;for(c.lastIndex=0,o=o.slice(-1*e.length+h);(d=c.exec(o))!=null;){if(et=d[1]||d[2]||d[3]||d[4]||d[5]||d[6],!et)continue;if(ot=[...et].length,d[3]||d[4]){it+=ot;continue}else if((d[5]||d[6])&&h%3&&!((h+ot)%3)){$+=ot;continue}if(it-=ot,it>0)continue;ot=Math.min(ot,ot+it+$);const s=[...d[0]][0].length,_=e.slice(0,h+d.index+s+ot);if(Math.min(h,ot)%2){const st=_.slice(1,-1);return{type:"em",raw:_,text:st,tokens:this.lexer.inlineTokens(st)}}const b=_.slice(2,-2);return{type:"strong",raw:_,text:b,tokens:this.lexer.inlineTokens(b)}}}}codespan(e){const o=this.rules.inline.code.exec(e);if(o){let a=o[2].replace(/\n/g," ");const d=/[^ ]/.test(a),g=/^ /.test(a)&&/ $/.test(a);return d&&g&&(a=a.substring(1,a.length-1)),a=escape$1(a,!0),{type:"codespan",raw:o[0],text:a}}}br(e){const o=this.rules.inline.br.exec(e);if(o)return{type:"br",raw:o[0]}}del(e){const o=this.rules.inline.del.exec(e);if(o)return{type:"del",raw:o[0],text:o[2],tokens:this.lexer.inlineTokens(o[2])}}autolink(e){const o=this.rules.inline.autolink.exec(e);if(o){let a,d;return o[2]==="@"?(a=escape$1(o[1]),d="mailto:"+a):(a=escape$1(o[1]),d=a),{type:"link",raw:o[0],text:a,href:d,tokens:[{type:"text",raw:a,text:a}]}}}url(e){var a;let o;if(o=this.rules.inline.url.exec(e)){let d,g;if(o[2]==="@")d=escape$1(o[0]),g="mailto:"+d;else{let h;do h=o[0],o[0]=((a=this.rules.inline._backpedal.exec(o[0]))==null?void 0:a[0])??"";while(h!==o[0]);d=escape$1(o[0]),o[1]==="www."?g="http://"+o[0]:g=o[0]}return{type:"link",raw:o[0],text:d,href:g,tokens:[{type:"text",raw:d,text:d}]}}}inlineText(e){const o=this.rules.inline.text.exec(e);if(o){let a;return this.lexer.state.inRawBlock?a=o[0]:a=escape$1(o[0]),{type:"text",raw:o[0],text:a}}}}const newline=/^(?: *(?:\n|$))+/,blockCode=/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,fences=/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,hr$1=/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,heading=/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,bullet=/(?:[*+-]|\d{1,9}[.)])/,lheading=edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g,bullet).replace(/blockCode/g,/ {4}/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).getRegex(),_paragraph=/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,blockText=/^[^\n]+/,_blockLabel=/(?!\s*\])(?:\\.|[^\[\]\\])+/,def=edit(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label",_blockLabel).replace("title",/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(),list=edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g,bullet).getRegex(),_tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",_comment=/<!--(?:-?>|[\s\S]*?(?:-->|$))/,html=edit("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))","i").replace("comment",_comment).replace("tag",_tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),paragraph=edit(_paragraph).replace("hr",hr$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",_tag).getRegex(),blockquote=edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph",paragraph).getRegex(),blockNormal={blockquote,code:blockCode,def,fences,heading,hr:hr$1,html,lheading,list,newline,paragraph,table:noopTest,text:blockText},gfmTable=edit("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr",hr$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("blockquote"," {0,3}>").replace("code"," {4}[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",_tag).getRegex(),blockGfm={...blockNormal,table:gfmTable,paragraph:edit(_paragraph).replace("hr",hr$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("table",gfmTable).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",_tag).getRegex()},blockPedantic={...blockNormal,html:edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",_comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:noopTest,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:edit(_paragraph).replace("hr",hr$1).replace("heading",` *#{1,6} *[^
]`).replace("lheading",lheading).replace("|table","").replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").replace("|tag","").getRegex()},escape=/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,inlineCode=/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br=/^( {2,}|\\)\n(?!\s*$)/,inlineText=/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,_punctuation="\\p{P}\\p{S}",punctuation=edit(/^((?![*_])[\spunctuation])/,"u").replace(/punctuation/g,_punctuation).getRegex(),blockSkip=/\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g,emStrongLDelim=edit(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,"u").replace(/punct/g,_punctuation).getRegex(),emStrongRDelimAst=edit("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])","gu").replace(/punct/g,_punctuation).getRegex(),emStrongRDelimUnd=edit("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])","gu").replace(/punct/g,_punctuation).getRegex(),anyPunctuation=edit(/\\([punct])/,"gu").replace(/punct/g,_punctuation).getRegex(),autolink=edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme",/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email",/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),_inlineComment=edit(_comment).replace("(?:-->|$)","-->").getRegex(),tag=edit("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment",_inlineComment).replace("attribute",/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(),_inlineLabel=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,link=edit(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label",_inlineLabel).replace("href",/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title",/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(),reflink=edit(/^!?\[(label)\]\[(ref)\]/).replace("label",_inlineLabel).replace("ref",_blockLabel).getRegex(),nolink=edit(/^!?\[(ref)\](?:\[\])?/).replace("ref",_blockLabel).getRegex(),reflinkSearch=edit("reflink|nolink(?!\\()","g").replace("reflink",reflink).replace("nolink",nolink).getRegex(),inlineNormal={_backpedal:noopTest,anyPunctuation,autolink,blockSkip,br,code:inlineCode,del:noopTest,emStrongLDelim,emStrongRDelimAst,emStrongRDelimUnd,escape,link,nolink,punctuation,reflink,reflinkSearch,tag,text:inlineText,url:noopTest},inlinePedantic={...inlineNormal,link:edit(/^!?\[(label)\]\((.*?)\)/).replace("label",_inlineLabel).getRegex(),reflink:edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",_inlineLabel).getRegex()},inlineGfm={...inlineNormal,escape:edit(escape).replace("])","~|])").getRegex(),url:edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,"i").replace("email",/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/},inlineBreaks={...inlineGfm,br:edit(br).replace("{2,}","*").getRegex(),text:edit(inlineGfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()},block={normal:blockNormal,gfm:blockGfm,pedantic:blockPedantic},inline={normal:inlineNormal,gfm:inlineGfm,breaks:inlineBreaks,pedantic:inlinePedantic};class _Lexer{constructor(e){ir(this,"tokens");ir(this,"options");ir(this,"state");ir(this,"tokenizer");ir(this,"inlineQueue");this.tokens=[],this.tokens.links=Object.create(null),this.options=e||_defaults,this.options.tokenizer=this.options.tokenizer||new _Tokenizer,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};const o={block:block.normal,inline:inline.normal};this.options.pedantic?(o.block=block.pedantic,o.inline=inline.pedantic):this.options.gfm&&(o.block=block.gfm,this.options.breaks?o.inline=inline.breaks:o.inline=inline.gfm),this.tokenizer.rules=o}static get rules(){return{block,inline}}static lex(e,o){return new _Lexer(o).lex(e)}static lexInline(e,o){return new _Lexer(o).inlineTokens(e)}lex(e){e=e.replace(/\r\n|\r/g,`
`),this.blockTokens(e,this.tokens);for(let o=0;o<this.inlineQueue.length;o++){const a=this.inlineQueue[o];this.inlineTokens(a.src,a.tokens)}return this.inlineQueue=[],this.tokens}blockTokens(e,o=[]){this.options.pedantic?e=e.replace(/\t/g,"    ").replace(/^ +$/gm,""):e=e.replace(/^( *)(\t+)/gm,(et,ot,it)=>ot+"    ".repeat(it.length));let a,d,g,h;for(;e;)if(!(this.options.extensions&&this.options.extensions.block&&this.options.extensions.block.some(et=>(a=et.call({lexer:this},e,o))?(e=e.substring(a.raw.length),o.push(a),!0):!1))){if(a=this.tokenizer.space(e)){e=e.substring(a.raw.length),a.raw.length===1&&o.length>0?o[o.length-1].raw+=`
`:o.push(a);continue}if(a=this.tokenizer.code(e)){e=e.substring(a.raw.length),d=o[o.length-1],d&&(d.type==="paragraph"||d.type==="text")?(d.raw+=`
`+a.raw,d.text+=`
`+a.text,this.inlineQueue[this.inlineQueue.length-1].src=d.text):o.push(a);continue}if(a=this.tokenizer.fences(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.heading(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.hr(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.blockquote(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.list(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.html(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.def(e)){e=e.substring(a.raw.length),d=o[o.length-1],d&&(d.type==="paragraph"||d.type==="text")?(d.raw+=`
`+a.raw,d.text+=`
`+a.raw,this.inlineQueue[this.inlineQueue.length-1].src=d.text):this.tokens.links[a.tag]||(this.tokens.links[a.tag]={href:a.href,title:a.title});continue}if(a=this.tokenizer.table(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.lheading(e)){e=e.substring(a.raw.length),o.push(a);continue}if(g=e,this.options.extensions&&this.options.extensions.startBlock){let et=1/0;const ot=e.slice(1);let it;this.options.extensions.startBlock.forEach($=>{it=$.call({lexer:this},ot),typeof it=="number"&&it>=0&&(et=Math.min(et,it))}),et<1/0&&et>=0&&(g=e.substring(0,et+1))}if(this.state.top&&(a=this.tokenizer.paragraph(g))){d=o[o.length-1],h&&d.type==="paragraph"?(d.raw+=`
`+a.raw,d.text+=`
`+a.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=d.text):o.push(a),h=g.length!==e.length,e=e.substring(a.raw.length);continue}if(a=this.tokenizer.text(e)){e=e.substring(a.raw.length),d=o[o.length-1],d&&d.type==="text"?(d.raw+=`
`+a.raw,d.text+=`
`+a.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=d.text):o.push(a);continue}if(e){const et="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(et);break}else throw new Error(et)}}return this.state.top=!0,o}inline(e,o=[]){return this.inlineQueue.push({src:e,tokens:o}),o}inlineTokens(e,o=[]){let a,d,g,h=e,et,ot,it;if(this.tokens.links){const $=Object.keys(this.tokens.links);if($.length>0)for(;(et=this.tokenizer.rules.inline.reflinkSearch.exec(h))!=null;)$.includes(et[0].slice(et[0].lastIndexOf("[")+1,-1))&&(h=h.slice(0,et.index)+"["+"a".repeat(et[0].length-2)+"]"+h.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;(et=this.tokenizer.rules.inline.blockSkip.exec(h))!=null;)h=h.slice(0,et.index)+"["+"a".repeat(et[0].length-2)+"]"+h.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;(et=this.tokenizer.rules.inline.anyPunctuation.exec(h))!=null;)h=h.slice(0,et.index)+"++"+h.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);for(;e;)if(ot||(it=""),ot=!1,!(this.options.extensions&&this.options.extensions.inline&&this.options.extensions.inline.some($=>(a=$.call({lexer:this},e,o))?(e=e.substring(a.raw.length),o.push(a),!0):!1))){if(a=this.tokenizer.escape(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.tag(e)){e=e.substring(a.raw.length),d=o[o.length-1],d&&a.type==="text"&&d.type==="text"?(d.raw+=a.raw,d.text+=a.text):o.push(a);continue}if(a=this.tokenizer.link(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.reflink(e,this.tokens.links)){e=e.substring(a.raw.length),d=o[o.length-1],d&&a.type==="text"&&d.type==="text"?(d.raw+=a.raw,d.text+=a.text):o.push(a);continue}if(a=this.tokenizer.emStrong(e,h,it)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.codespan(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.br(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.del(e)){e=e.substring(a.raw.length),o.push(a);continue}if(a=this.tokenizer.autolink(e)){e=e.substring(a.raw.length),o.push(a);continue}if(!this.state.inLink&&(a=this.tokenizer.url(e))){e=e.substring(a.raw.length),o.push(a);continue}if(g=e,this.options.extensions&&this.options.extensions.startInline){let $=1/0;const c=e.slice(1);let s;this.options.extensions.startInline.forEach(_=>{s=_.call({lexer:this},c),typeof s=="number"&&s>=0&&($=Math.min($,s))}),$<1/0&&$>=0&&(g=e.substring(0,$+1))}if(a=this.tokenizer.inlineText(g)){e=e.substring(a.raw.length),a.raw.slice(-1)!=="_"&&(it=a.raw.slice(-1)),ot=!0,d=o[o.length-1],d&&d.type==="text"?(d.raw+=a.raw,d.text+=a.text):o.push(a);continue}if(e){const $="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error($);break}else throw new Error($)}}return o}}class _Renderer{constructor(e){ir(this,"options");this.options=e||_defaults}code(e,o,a){var g;const d=(g=(o||"").match(/^\S*/))==null?void 0:g[0];return e=e.replace(/\n$/,"")+`
`,d?'<pre><code class="language-'+escape$1(d)+'">'+(a?e:escape$1(e,!0))+`</code></pre>
`:"<pre><code>"+(a?e:escape$1(e,!0))+`</code></pre>
`}blockquote(e){return`<blockquote>
${e}</blockquote>
`}html(e,o){return e}heading(e,o,a){return`<h${o}>${e}</h${o}>
`}hr(){return`<hr>
`}list(e,o,a){const d=o?"ol":"ul",g=o&&a!==1?' start="'+a+'"':"";return"<"+d+g+`>
`+e+"</"+d+`>
`}listitem(e,o,a){return`<li>${e}</li>
`}checkbox(e){return"<input "+(e?'checked="" ':"")+'disabled="" type="checkbox">'}paragraph(e){return`<p>${e}</p>
`}table(e,o){return o&&(o=`<tbody>${o}</tbody>`),`<table>
<thead>
`+e+`</thead>
`+o+`</table>
`}tablerow(e){return`<tr>
${e}</tr>
`}tablecell(e,o){const a=o.header?"th":"td";return(o.align?`<${a} align="${o.align}">`:`<${a}>`)+e+`</${a}>
`}strong(e){return`<strong>${e}</strong>`}em(e){return`<em>${e}</em>`}codespan(e){return`<code>${e}</code>`}br(){return"<br>"}del(e){return`<del>${e}</del>`}link(e,o,a){const d=cleanUrl(e);if(d===null)return a;e=d;let g='<a href="'+e+'"';return o&&(g+=' title="'+o+'"'),g+=">"+a+"</a>",g}image(e,o,a){const d=cleanUrl(e);if(d===null)return a;e=d;let g=`<img src="${e}" alt="${a}"`;return o&&(g+=` title="${o}"`),g+=">",g}text(e){return e}}class _TextRenderer{strong(e){return e}em(e){return e}codespan(e){return e}del(e){return e}html(e){return e}text(e){return e}link(e,o,a){return""+a}image(e,o,a){return""+a}br(){return""}}class _Parser{constructor(e){ir(this,"options");ir(this,"renderer");ir(this,"textRenderer");this.options=e||_defaults,this.options.renderer=this.options.renderer||new _Renderer,this.renderer=this.options.renderer,this.renderer.options=this.options,this.textRenderer=new _TextRenderer}static parse(e,o){return new _Parser(o).parse(e)}static parseInline(e,o){return new _Parser(o).parseInline(e)}parse(e,o=!0){let a="";for(let d=0;d<e.length;d++){const g=e[d];if(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[g.type]){const h=g,et=this.options.extensions.renderers[h.type].call({parser:this},h);if(et!==!1||!["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(h.type)){a+=et||"";continue}}switch(g.type){case"space":continue;case"hr":{a+=this.renderer.hr();continue}case"heading":{const h=g;a+=this.renderer.heading(this.parseInline(h.tokens),h.depth,unescape(this.parseInline(h.tokens,this.textRenderer)));continue}case"code":{const h=g;a+=this.renderer.code(h.text,h.lang,!!h.escaped);continue}case"table":{const h=g;let et="",ot="";for(let $=0;$<h.header.length;$++)ot+=this.renderer.tablecell(this.parseInline(h.header[$].tokens),{header:!0,align:h.align[$]});et+=this.renderer.tablerow(ot);let it="";for(let $=0;$<h.rows.length;$++){const c=h.rows[$];ot="";for(let s=0;s<c.length;s++)ot+=this.renderer.tablecell(this.parseInline(c[s].tokens),{header:!1,align:h.align[s]});it+=this.renderer.tablerow(ot)}a+=this.renderer.table(et,it);continue}case"blockquote":{const h=g,et=this.parse(h.tokens);a+=this.renderer.blockquote(et);continue}case"list":{const h=g,et=h.ordered,ot=h.start,it=h.loose;let $="";for(let c=0;c<h.items.length;c++){const s=h.items[c],_=s.checked,b=s.task;let st="";if(s.task){const dt=this.renderer.checkbox(!!_);it?s.tokens.length>0&&s.tokens[0].type==="paragraph"?(s.tokens[0].text=dt+" "+s.tokens[0].text,s.tokens[0].tokens&&s.tokens[0].tokens.length>0&&s.tokens[0].tokens[0].type==="text"&&(s.tokens[0].tokens[0].text=dt+" "+s.tokens[0].tokens[0].text)):s.tokens.unshift({type:"text",text:dt+" "}):st+=dt+" "}st+=this.parse(s.tokens,it),$+=this.renderer.listitem(st,b,!!_)}a+=this.renderer.list($,et,ot);continue}case"html":{const h=g;a+=this.renderer.html(h.text,h.block);continue}case"paragraph":{const h=g;a+=this.renderer.paragraph(this.parseInline(h.tokens));continue}case"text":{let h=g,et=h.tokens?this.parseInline(h.tokens):h.text;for(;d+1<e.length&&e[d+1].type==="text";)h=e[++d],et+=`
`+(h.tokens?this.parseInline(h.tokens):h.text);a+=o?this.renderer.paragraph(et):et;continue}default:{const h='Token with "'+g.type+'" type was not found.';if(this.options.silent)return console.error(h),"";throw new Error(h)}}}return a}parseInline(e,o){o=o||this.renderer;let a="";for(let d=0;d<e.length;d++){const g=e[d];if(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[g.type]){const h=this.options.extensions.renderers[g.type].call({parser:this},g);if(h!==!1||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(g.type)){a+=h||"";continue}}switch(g.type){case"escape":{const h=g;a+=o.text(h.text);break}case"html":{const h=g;a+=o.html(h.text);break}case"link":{const h=g;a+=o.link(h.href,h.title,this.parseInline(h.tokens,o));break}case"image":{const h=g;a+=o.image(h.href,h.title,h.text);break}case"strong":{const h=g;a+=o.strong(this.parseInline(h.tokens,o));break}case"em":{const h=g;a+=o.em(this.parseInline(h.tokens,o));break}case"codespan":{const h=g;a+=o.codespan(h.text);break}case"br":{a+=o.br();break}case"del":{const h=g;a+=o.del(this.parseInline(h.tokens,o));break}case"text":{const h=g;a+=o.text(h.text);break}default:{const h='Token with "'+g.type+'" type was not found.';if(this.options.silent)return console.error(h),"";throw new Error(h)}}}return a}}class _Hooks{constructor(e){ir(this,"options");this.options=e||_defaults}preprocess(e){return e}postprocess(e){return e}processAllTokens(e){return e}}ir(_Hooks,"passThroughHooks",new Set(["preprocess","postprocess","processAllTokens"]));var Sy,jy,d_;class Marked{constructor(...e){l_(this,Sy);ir(this,"defaults",_getDefaults());ir(this,"options",this.setOptions);ir(this,"parse",zy(this,Sy,jy).call(this,_Lexer.lex,_Parser.parse));ir(this,"parseInline",zy(this,Sy,jy).call(this,_Lexer.lexInline,_Parser.parseInline));ir(this,"Parser",_Parser);ir(this,"Renderer",_Renderer);ir(this,"TextRenderer",_TextRenderer);ir(this,"Lexer",_Lexer);ir(this,"Tokenizer",_Tokenizer);ir(this,"Hooks",_Hooks);this.use(...e)}walkTokens(e,o){var d,g;let a=[];for(const h of e)switch(a=a.concat(o.call(this,h)),h.type){case"table":{const et=h;for(const ot of et.header)a=a.concat(this.walkTokens(ot.tokens,o));for(const ot of et.rows)for(const it of ot)a=a.concat(this.walkTokens(it.tokens,o));break}case"list":{const et=h;a=a.concat(this.walkTokens(et.items,o));break}default:{const et=h;(g=(d=this.defaults.extensions)==null?void 0:d.childTokens)!=null&&g[et.type]?this.defaults.extensions.childTokens[et.type].forEach(ot=>{const it=et[ot].flat(1/0);a=a.concat(this.walkTokens(it,o))}):et.tokens&&(a=a.concat(this.walkTokens(et.tokens,o)))}}return a}use(...e){const o=this.defaults.extensions||{renderers:{},childTokens:{}};return e.forEach(a=>{const d={...a};if(d.async=this.defaults.async||d.async||!1,a.extensions&&(a.extensions.forEach(g=>{if(!g.name)throw new Error("extension name required");if("renderer"in g){const h=o.renderers[g.name];h?o.renderers[g.name]=function(...et){let ot=g.renderer.apply(this,et);return ot===!1&&(ot=h.apply(this,et)),ot}:o.renderers[g.name]=g.renderer}if("tokenizer"in g){if(!g.level||g.level!=="block"&&g.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");const h=o[g.level];h?h.unshift(g.tokenizer):o[g.level]=[g.tokenizer],g.start&&(g.level==="block"?o.startBlock?o.startBlock.push(g.start):o.startBlock=[g.start]:g.level==="inline"&&(o.startInline?o.startInline.push(g.start):o.startInline=[g.start]))}"childTokens"in g&&g.childTokens&&(o.childTokens[g.name]=g.childTokens)}),d.extensions=o),a.renderer){const g=this.defaults.renderer||new _Renderer(this.defaults);for(const h in a.renderer){if(!(h in g))throw new Error(`renderer '${h}' does not exist`);if(h==="options")continue;const et=h,ot=a.renderer[et],it=g[et];g[et]=(...$)=>{let c=ot.apply(g,$);return c===!1&&(c=it.apply(g,$)),c||""}}d.renderer=g}if(a.tokenizer){const g=this.defaults.tokenizer||new _Tokenizer(this.defaults);for(const h in a.tokenizer){if(!(h in g))throw new Error(`tokenizer '${h}' does not exist`);if(["options","rules","lexer"].includes(h))continue;const et=h,ot=a.tokenizer[et],it=g[et];g[et]=(...$)=>{let c=ot.apply(g,$);return c===!1&&(c=it.apply(g,$)),c}}d.tokenizer=g}if(a.hooks){const g=this.defaults.hooks||new _Hooks;for(const h in a.hooks){if(!(h in g))throw new Error(`hook '${h}' does not exist`);if(h==="options")continue;const et=h,ot=a.hooks[et],it=g[et];_Hooks.passThroughHooks.has(h)?g[et]=$=>{if(this.defaults.async)return Promise.resolve(ot.call(g,$)).then(s=>it.call(g,s));const c=ot.call(g,$);return it.call(g,c)}:g[et]=(...$)=>{let c=ot.apply(g,$);return c===!1&&(c=it.apply(g,$)),c}}d.hooks=g}if(a.walkTokens){const g=this.defaults.walkTokens,h=a.walkTokens;d.walkTokens=function(et){let ot=[];return ot.push(h.call(this,et)),g&&(ot=ot.concat(g.call(this,et))),ot}}this.defaults={...this.defaults,...d}}),this}setOptions(e){return this.defaults={...this.defaults,...e},this}lexer(e,o){return _Lexer.lex(e,o??this.defaults)}parser(e,o){return _Parser.parse(e,o??this.defaults)}}Sy=new WeakSet,jy=function(e,o){return(a,d)=>{const g={...d},h={...this.defaults,...g};this.defaults.async===!0&&g.async===!1&&(h.silent||console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored."),h.async=!0);const et=zy(this,Sy,d_).call(this,!!h.silent,!!h.async);if(typeof a>"u"||a===null)return et(new Error("marked(): input parameter is undefined or null"));if(typeof a!="string")return et(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(a)+", string expected"));if(h.hooks&&(h.hooks.options=h),h.async)return Promise.resolve(h.hooks?h.hooks.preprocess(a):a).then(ot=>e(ot,h)).then(ot=>h.hooks?h.hooks.processAllTokens(ot):ot).then(ot=>h.walkTokens?Promise.all(this.walkTokens(ot,h.walkTokens)).then(()=>ot):ot).then(ot=>o(ot,h)).then(ot=>h.hooks?h.hooks.postprocess(ot):ot).catch(et);try{h.hooks&&(a=h.hooks.preprocess(a));let ot=e(a,h);h.hooks&&(ot=h.hooks.processAllTokens(ot)),h.walkTokens&&this.walkTokens(ot,h.walkTokens);let it=o(ot,h);return h.hooks&&(it=h.hooks.postprocess(it)),it}catch(ot){return et(ot)}}},d_=function(e,o){return a=>{if(a.message+=`
Please report this to https://github.com/markedjs/marked.`,e){const d="<p>An error occurred:</p><pre>"+escape$1(a.message+"",!0)+"</pre>";return o?Promise.resolve(d):d}if(o)return Promise.reject(a);throw a}};const markedInstance=new Marked;function marked(i,e){return markedInstance.parse(i,e)}marked.options=marked.setOptions=function(i){return markedInstance.setOptions(i),marked.defaults=markedInstance.defaults,changeDefaults(marked.defaults),marked};marked.getDefaults=_getDefaults;marked.defaults=_defaults;marked.use=function(...i){return markedInstance.use(...i),marked.defaults=markedInstance.defaults,changeDefaults(marked.defaults),marked};marked.walkTokens=function(i,e){return markedInstance.walkTokens(i,e)};marked.parseInline=markedInstance.parseInline;marked.Parser=_Parser;marked.parser=_Parser.parse;marked.Renderer=_Renderer;marked.TextRenderer=_TextRenderer;marked.Lexer=_Lexer;marked.lexer=_Lexer.lex;marked.Tokenizer=_Tokenizer;marked.Hooks=_Hooks;marked.parse=marked;marked.options;marked.setOptions;marked.use;marked.walkTokens;marked.parseInline;_Parser.parse;_Lexer.lex;marked.use({mangle:!1,headerIds:!1});const ChatBot=({chatHistory:i,setChatHistory:e,onSubmit:o,isGenerating:a})=>{const[d,g]=reactExports.useState(""),h=reactExports.useRef(null);reactExports.useEffect(()=>{var it;(it=h.current)==null||it.scrollIntoView({behavior:"smooth"})},[i]);const et=it=>{if(it.preventDefault(),d.trim()!==""){if(a){g("");return}e($=>[...$,{role:"user",content:d},{role:"assistant",content:".."}]),o(d),g("")}},ot=()=>a?"Generating...":"Send";return jsxRuntimeExports.jsxs("div",{className:"chat-container",children:[jsxRuntimeExports.jsxs("div",{className:"chat-history",children:[i.map((it,$)=>jsxRuntimeExports.jsx("div",{className:`message ${it.role}`,children:jsxRuntimeExports.jsx("div",{dangerouslySetInnerHTML:{__html:marked(it.content)}})},$)),jsxRuntimeExports.jsx("div",{ref:h})]}),jsxRuntimeExports.jsxs("form",{onSubmit:et,children:[jsxRuntimeExports.jsx("input",{type:"text",value:d,onChange:it=>g(it.target.value),disabled:a}),jsxRuntimeExports.jsx("button",{type:"submit",disabled:a,children:ot()})]})]})};function dispatchCallback(i,e){i&&i(e)}function reverseDictionary(i){return Object.fromEntries(Object.entries(i).map(([e,o])=>[o,e]))}function escapeRegExp(i){return i.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}const Callable=class{constructor(){let i=function(...e){return i._call(...e)};return Object.setPrototypeOf(i,new.target.prototype)}_call(...i){throw Error("Must implement _call method in subclass")}};function isTypedArray(i){var e,o,a;return((a=(o=(e=i==null?void 0:i.prototype)==null?void 0:e.__proto__)==null?void 0:o.constructor)==null?void 0:a.name)==="TypedArray"}function isIntegralNumber(i){return Number.isInteger(i)||typeof i=="bigint"}function exists(i){return i!=null}function mergeArrays(...i){return Array.prototype.concat.apply([],i)}const sharp={},ONNX_NODE=Object.freeze(Object.defineProperty({__proto__:null,default:sharp},Symbol.toStringTag,{value:"Module"}));var ortWeb_min$1={exports:{}};const backends={},backendsSortedByPriority=[],registerBackend=(i,e,o)=>{if(e&&typeof e.init=="function"&&typeof e.createSessionHandler=="function"){const a=backends[i];if(a===void 0)backends[i]={backend:e,priority:o};else{if(a.priority>o)return;if(a.priority===o&&a.backend!==e)throw new Error(`cannot register backend "${i}" using priority ${o}`)}if(o>=0){const d=backendsSortedByPriority.indexOf(i);d!==-1&&backendsSortedByPriority.splice(d,1);for(let g=0;g<backendsSortedByPriority.length;g++)if(backends[backendsSortedByPriority[g]].priority<=o){backendsSortedByPriority.splice(g,0,i);return}backendsSortedByPriority.push(i)}return}throw new TypeError("not a valid backend")},resolveBackend=async i=>{const e=i.length===0?backendsSortedByPriority:i,o=[];for(const a of e){const d=backends[a];if(d){if(d.initialized)return d.backend;if(d.aborted)continue;const g=!!d.initPromise;try{return g||(d.initPromise=d.backend.init()),await d.initPromise,d.initialized=!0,d.backend}catch(h){g||o.push({name:a,err:h}),d.aborted=!0}finally{delete d.initPromise}}}throw new Error(`no available backend found. ERR: ${o.map(a=>`[${a.name}] ${a.err}`).join(", ")}`)};class EnvImpl{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}}const env$2=new EnvImpl,isBigInt64ArrayAvailable=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",isBigUint64ArrayAvailable=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function",NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);isBigInt64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array,"int64"));isBigUint64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array,"uint64"));const calculateSize=i=>{let e=1;for(let o=0;o<i.length;o++){const a=i[o];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${o}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${o}] must be a non-negative integer, got: ${a}`);e*=a}return e};let Tensor$2=class Ty{constructor(e,o,a){let d,g,h;if(typeof e=="string")if(d=e,h=a,e==="string"){if(!Array.isArray(o))throw new TypeError("A string tensor's data must be a string array.");g=o}else{const ot=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(e);if(ot===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(o))g=ot.from(o);else if(o instanceof ot)g=o;else throw new TypeError(`A ${d} tensor's data must be type of ${ot}`)}else if(h=o,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const ot=typeof e[0];if(ot==="string")d="string",g=e;else if(ot==="boolean")d="bool",g=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${ot}.`)}else{const ot=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(e.constructor);if(ot===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);d=ot,g=e}if(h===void 0)h=[g.length];else if(!Array.isArray(h))throw new TypeError("A tensor's dims must be a number array");const et=calculateSize(h);if(et!==g.length)throw new Error(`Tensor's size(${et}) does not match data length(${g.length}).`);this.dims=h,this.type=d,this.data=g,this.size=et}static bufferToTensor(e,o){if(e===void 0)throw new Error("Image buffer must be defined");if(o.height===void 0||o.width===void 0)throw new Error("Image height and width must be defined");const{height:a,width:d}=o,g=o.norm;let h,et;g===void 0||g.mean===void 0?h=255:h=g.mean,g===void 0||g.bias===void 0?et=0:et=g.bias;const ot=o.bitmapFormat!==void 0?o.bitmapFormat:"RGBA",it=o.tensorFormat!==void 0&&o.tensorFormat!==void 0?o.tensorFormat:"RGB",$=a*d,c=it==="RGBA"?new Float32Array($*4):new Float32Array($*3);let s=4,_=0,b=1,st=2,dt=3,ct=0,pt=$,ft=$*2,mt=-1;ot==="RGB"&&(s=3,_=0,b=1,st=2,dt=-1),it==="RGBA"?mt=$*3:it==="RBG"?(ct=0,ft=$,pt=$*2):it==="BGR"&&(ft=0,pt=$,ct=$*2);for(let $t=0;$t<$;$t++,_+=s,st+=s,b+=s,dt+=s)c[ct++]=(e[_]+et)/h,c[pt++]=(e[b]+et)/h,c[ft++]=(e[st]+et)/h,mt!==-1&&dt!==-1&&(c[mt++]=(e[dt]+et)/h);return it==="RGBA"?new Ty("float32",c,[1,4,a,d]):new Ty("float32",c,[1,3,a,d])}static async fromImage(e,o){const a=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,d=typeof ImageData<"u"&&e instanceof ImageData,g=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,h=typeof String<"u"&&(e instanceof String||typeof e=="string");let et,ot={};if(a){const it=document.createElement("canvas"),$=it.getContext("2d");if($!=null){let c=e.naturalHeight,s=e.naturalWidth;if(o!==void 0&&o.resizedHeight!==void 0&&o.resizedWidth!==void 0&&(c=o.resizedHeight,s=o.resizedWidth),o!==void 0){if(ot=o,o.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(ot.tensorFormat="RGBA",o.height!==void 0&&o.height!==c)throw new Error("Image input config height doesn't match HTMLImageElement height");if(ot.height=c,o.width!==void 0&&o.width!==s)throw new Error("Image input config width doesn't match HTMLImageElement width");ot.width=s}else ot.tensorFormat="RGBA",ot.height=c,ot.width=s;it.width=s,it.height=c,$.drawImage(e,0,0,s,c),et=$.getImageData(0,0,s,c).data}else throw new Error("Can not access image data")}else if(d){const it="RGBA";let $,c;if(o!==void 0&&o.resizedWidth!==void 0&&o.resizedHeight!==void 0?($=o.resizedHeight,c=o.resizedWidth):($=e.height,c=e.width),o!==void 0){if(ot=o,o.bitmapFormat!==void 0&&o.bitmapFormat!==it)throw new Error("Image input config format must be RGBA for ImageData");ot.bitmapFormat="RGBA"}else ot.bitmapFormat="RGBA";if(ot.height=$,ot.width=c,o!==void 0){const s=document.createElement("canvas");s.width=c,s.height=$;const _=s.getContext("2d");if(_!=null)_.putImageData(e,0,0),et=_.getImageData(0,0,c,$).data;else throw new Error("Can not access image data")}else et=e.data}else if(g){if(o===void 0)throw new Error("Please provide image config with format for Imagebitmap");if(o.bitmapFormat!==void 0)throw new Error("Image input config format must be defined for ImageBitmap");const it=document.createElement("canvas").getContext("2d");if(it!=null){const $=e.height,c=e.width;if(it.drawImage(e,0,0,c,$),et=it.getImageData(0,0,c,$).data,o!==void 0){if(o.height!==void 0&&o.height!==$)throw new Error("Image input config height doesn't match ImageBitmap height");if(ot.height=$,o.width!==void 0&&o.width!==c)throw new Error("Image input config width doesn't match ImageBitmap width");ot.width=c}else ot.height=$,ot.width=c;return Ty.bufferToTensor(et,ot)}else throw new Error("Can not access image data")}else{if(h)return new Promise((it,$)=>{const c=document.createElement("canvas"),s=c.getContext("2d");if(!e||!s)return $();const _=new Image;_.crossOrigin="Anonymous",_.src=e,_.onload=()=>{c.width=_.width,c.height=_.height,s.drawImage(_,0,0,c.width,c.height);const b=s.getImageData(0,0,c.width,c.height);if(o!==void 0){if(o.height!==void 0&&o.height!==c.height)throw new Error("Image input config height doesn't match ImageBitmap height");if(ot.height=c.height,o.width!==void 0&&o.width!==c.width)throw new Error("Image input config width doesn't match ImageBitmap width");ot.width=c.width}else ot.height=c.height,ot.width=c.width;it(Ty.bufferToTensor(b.data,ot))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(et!==void 0)return Ty.bufferToTensor(et,ot);throw new Error("Input data provided is not supported - aborted tensor creation")}toImageData(e){var o,a;const d=document.createElement("canvas").getContext("2d");let g;if(d!=null){const h=this.dims[3],et=this.dims[2],ot=this.dims[1],it=e!==void 0&&e.format!==void 0?e.format:"RGB",$=e!==void 0&&((o=e.norm)===null||o===void 0?void 0:o.mean)!==void 0?e.norm.mean:255,c=e!==void 0&&((a=e.norm)===null||a===void 0?void 0:a.bias)!==void 0?e.norm.bias:0,s=et*h;if(e!==void 0){if(e.height!==void 0&&e.height!==et)throw new Error("Image output config height doesn't match tensor height");if(e.width!==void 0&&e.width!==h)throw new Error("Image output config width doesn't match tensor width");if(e.format!==void 0&&ot===4&&e.format!=="RGBA"||ot===3&&e.format!=="RGB"&&e.format!=="BGR")throw new Error("Tensor format doesn't match input tensor dims")}const _=4;let b=0,st=1,dt=2,ct=3,pt=0,ft=s,mt=s*2,bt=-1;it==="RGBA"?(pt=0,ft=s,mt=s*2,bt=s*3):it==="RGB"?(pt=0,ft=s,mt=s*2):it==="RBG"&&(pt=0,mt=s,ft=s*2),g=d.createImageData(h,et);for(let $t=0;$t<et*h;b+=_,st+=_,dt+=_,ct+=_,$t++)g.data[b]=(this.data[pt++]-c)*$,g.data[st]=(this.data[ft++]-c)*$,g.data[dt]=(this.data[mt++]-c)*$,g.data[ct]=bt===-1?255:(this.data[bt++]-c)*$}else throw new Error("Can not access image data");return g}reshape(e){return new Ty(this.type,this.data,e)}};const Tensor$1=Tensor$2;let InferenceSession$2=class p_{constructor(e){this.handler=e}async run(e,o,a){const d={};let g={};if(typeof e!="object"||e===null||e instanceof Tensor$1||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let h=!0;if(typeof o=="object"){if(o===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(o instanceof Tensor$1)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(o)){if(o.length===0)throw new TypeError("'fetches' cannot be an empty array.");h=!1;for(const it of o){if(typeof it!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(it)===-1)throw new RangeError(`'fetches' contains invalid output name: ${it}.`);d[it]=null}if(typeof a=="object"&&a!==null)g=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let it=!1;const $=Object.getOwnPropertyNames(o);for(const c of this.outputNames)if($.indexOf(c)!==-1){const s=o[c];(s===null||s instanceof Tensor$1)&&(it=!0,h=!1,d[c]=s)}if(it){if(typeof a=="object"&&a!==null)g=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else g=o}}else if(typeof o<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const it of this.inputNames)if(typeof e[it]>"u")throw new Error(`input '${it}' is missing in 'feeds'.`);if(h)for(const it of this.outputNames)d[it]=null;const et=await this.handler.run(e,d,g),ot={};for(const it in et)Object.hasOwnProperty.call(et,it)&&(ot[it]=new Tensor$1(et[it].type,et[it].data,et[it].dims));return ot}static async create(e,o,a,d){let g,h={};if(typeof e=="string"){if(g=e,typeof o=="object"&&o!==null)h=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(g=e,typeof o=="object"&&o!==null)h=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){const c=e;let s=0,_=e.byteLength;if(typeof o=="object"&&o!==null)h=o;else if(typeof o=="number"){if(s=o,!Number.isSafeInteger(s))throw new RangeError("'byteOffset' must be an integer.");if(s<0||s>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(_=e.byteLength-s,typeof a=="number"){if(_=a,!Number.isSafeInteger(_))throw new RangeError("'byteLength' must be an integer.");if(_<=0||s+_>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-s}].`);if(typeof d=="object"&&d!==null)h=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof o<"u")throw new TypeError("'options' must be an object.");g=new Uint8Array(c,s,_)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const ot=(h.executionProviders||[]).map(c=>typeof c=="string"?c:c.name),$=await(await resolveBackend(ot)).createSessionHandler(g,h);return new p_($)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const InferenceSession$1=InferenceSession$2,lib=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:InferenceSession$1,Tensor:Tensor$1,env:env$2,registerBackend},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(lib);/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/(function(module,exports){(function(i,e){module.exports=e(require$$0)})(self,__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(i,e,o)=>{var a,d=(a=(a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(g){function h(){return vn.buffer!=hn&&Po(vn.buffer),rr}function et(){return vn.buffer!=hn&&Po(vn.buffer),vr}function ot(){return vn.buffer!=hn&&Po(vn.buffer),Ir}function it(){return vn.buffer!=hn&&Po(vn.buffer),$r}function $(){return vn.buffer!=hn&&Po(vn.buffer),Ur}var c,s,_;g=g||{},c||(c=g!==void 0?g:{}),c.ready=new Promise(function(Nt,Lt){s=Nt,_=Lt});var b,st,dt,ct,pt,ft,mt=Object.assign({},c),bt="./this.program",$t=(Nt,Lt)=>{throw Lt},Ct=typeof window=="object",It=typeof importScripts=="function",Tt=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",jt=c.ENVIRONMENT_IS_PTHREAD||!1,dn="";function yn(Nt){return c.locateFile?c.locateFile(Nt,dn):dn+Nt}if(Tt){let Nt;dn=It?o(908).dirname(dn)+"/":"//",ft=()=>{pt||(ct=o(1384),pt=o(908))},b=function(Lt,qt){return ft(),Lt=pt.normalize(Lt),ct.readFileSync(Lt,qt?void 0:"utf8")},dt=Lt=>((Lt=b(Lt,!0)).buffer||(Lt=new Uint8Array(Lt)),Lt),st=(Lt,qt,ln)=>{ft(),Lt=pt.normalize(Lt),ct.readFile(Lt,function(xn,Cn){xn?ln(xn):qt(Cn.buffer)})},1<process.argv.length&&(bt=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(Lt){if(!(Lt instanceof D0))throw Lt}),process.on("unhandledRejection",function(Lt){throw Lt}),$t=(Lt,qt)=>{if(w0())throw process.exitCode=Lt,qt;qt instanceof D0||Jt("exiting due to exception: "+qt),process.exit(Lt)},c.inspect=function(){return"[Emscripten Module object]"};try{Nt=o(9925)}catch(Lt){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Lt}o.g.Worker=Nt.Worker}else(Ct||It)&&(It?dn=self.location.href:typeof document<"u"&&document.currentScript&&(dn=document.currentScript.src),a&&(dn=a),dn=dn.indexOf("blob:")!==0?dn.substr(0,dn.replace(/[?#].*/,"").lastIndexOf("/")+1):"",Tt||(b=Nt=>{var Lt=new XMLHttpRequest;return Lt.open("GET",Nt,!1),Lt.send(null),Lt.responseText},It&&(dt=Nt=>{var Lt=new XMLHttpRequest;return Lt.open("GET",Nt,!1),Lt.responseType="arraybuffer",Lt.send(null),new Uint8Array(Lt.response)}),st=(Nt,Lt,qt)=>{var ln=new XMLHttpRequest;ln.open("GET",Nt,!0),ln.responseType="arraybuffer",ln.onload=()=>{ln.status==200||ln.status==0&&ln.response?Lt(ln.response):qt()},ln.onerror=qt,ln.send(null)}));Tt&&typeof performance>"u"&&(o.g.performance=o(6953).performance);var mn=console.log.bind(console),fn=console.warn.bind(console);Tt&&(ft(),mn=Nt=>ct.writeSync(1,Nt+`
`),fn=Nt=>ct.writeSync(2,Nt+`
`));var un,Wt=c.print||mn,Jt=c.printErr||fn;Object.assign(c,mt),mt=null,c.thisProgram&&(bt=c.thisProgram),c.quit&&($t=c.quit),c.wasmBinary&&(un=c.wasmBinary);var _n=c.noExitRuntime||!1;typeof WebAssembly!="object"&&qr("no native wasm support detected");var vn,Sn,hn,rr,vr,Ir,$r,Ur,Yr=!1,r0=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function b0(Nt,Lt,qt){var ln=(Lt>>>=0)+qt;for(qt=Lt;Nt[qt]&&!(qt>=ln);)++qt;if(16<qt-Lt&&Nt.buffer&&r0)return r0.decode(Nt.buffer instanceof SharedArrayBuffer?Nt.slice(Lt,qt):Nt.subarray(Lt,qt));for(ln="";Lt<qt;){var xn=Nt[Lt++];if(128&xn){var Cn=63&Nt[Lt++];if((224&xn)==192)ln+=String.fromCharCode((31&xn)<<6|Cn);else{var xr=63&Nt[Lt++];65536>(xn=(240&xn)==224?(15&xn)<<12|Cn<<6|xr:(7&xn)<<18|Cn<<12|xr<<6|63&Nt[Lt++])?ln+=String.fromCharCode(xn):(xn-=65536,ln+=String.fromCharCode(55296|xn>>10,56320|1023&xn))}}else ln+=String.fromCharCode(xn)}return ln}function t0(Nt,Lt){return(Nt>>>=0)?b0(et(),Nt,Lt):""}function l0(Nt,Lt,qt,ln){if(!(0<ln))return 0;var xn=qt>>>=0;ln=qt+ln-1;for(var Cn=0;Cn<Nt.length;++Cn){var xr=Nt.charCodeAt(Cn);if(55296<=xr&&57343>=xr&&(xr=65536+((1023&xr)<<10)|1023&Nt.charCodeAt(++Cn)),127>=xr){if(qt>=ln)break;Lt[qt++>>>0]=xr}else{if(2047>=xr){if(qt+1>=ln)break;Lt[qt++>>>0]=192|xr>>6}else{if(65535>=xr){if(qt+2>=ln)break;Lt[qt++>>>0]=224|xr>>12}else{if(qt+3>=ln)break;Lt[qt++>>>0]=240|xr>>18,Lt[qt++>>>0]=128|xr>>12&63}Lt[qt++>>>0]=128|xr>>6&63}Lt[qt++>>>0]=128|63&xr}}return Lt[qt>>>0]=0,qt-xn}function _i(Nt){for(var Lt=0,qt=0;qt<Nt.length;++qt){var ln=Nt.charCodeAt(qt);127>=ln?Lt++:2047>=ln?Lt+=2:55296<=ln&&57343>=ln?(Lt+=4,++qt):Lt+=3}return Lt}function Po(Nt){hn=Nt,c.HEAP8=rr=new Int8Array(Nt),c.HEAP16=new Int16Array(Nt),c.HEAP32=Ir=new Int32Array(Nt),c.HEAPU8=vr=new Uint8Array(Nt),c.HEAPU16=new Uint16Array(Nt),c.HEAPU32=$r=new Uint32Array(Nt),c.HEAPF32=new Float32Array(Nt),c.HEAPF64=Ur=new Float64Array(Nt)}jt&&(hn=c.buffer);var vm=c.INITIAL_MEMORY||16777216;if(jt)vn=c.wasmMemory,hn=c.buffer;else if(c.wasmMemory)vn=c.wasmMemory;else if(!((vn=new WebAssembly.Memory({initial:vm/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw Jt("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Tt&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");vn&&(hn=vn.buffer),vm=hn.byteLength,Po(hn);var s0,k0=[],E0=[],O0=[],U0=[];function w0(){return _n||!1}function v0(){var Nt=c.preRun.shift();k0.unshift(Nt)}var a0,e0=0,C0=null;function qr(Nt){throw jt?postMessage({cmd:"onAbort",arg:Nt}):c.onAbort&&c.onAbort(Nt),Jt(Nt="Aborted("+Nt+")"),Yr=!0,Nt=new WebAssembly.RuntimeError(Nt+". Build with -sASSERTIONS for more info."),_(Nt),Nt}function L0(){return a0.startsWith("data:application/octet-stream;base64,")}function $0(){var Nt=a0;try{if(Nt==a0&&un)return new Uint8Array(un);if(dt)return dt(Nt);throw"both async and sync fetching of the wasm failed"}catch(Lt){qr(Lt)}}a0="ort-wasm-threaded.wasm",L0()||(a0=yn(a0));var ry={};function D0(Nt){this.name="ExitStatus",this.message="Program terminated with exit("+Nt+")",this.status=Nt}function P0(Nt){(Nt=jr.Vb[Nt])||qr(),jr.mc(Nt)}function G0(Nt){var Lt=jr.Cc();if(!Lt)return 6;jr.ac.push(Lt),jr.Vb[Nt.Ub]=Lt,Lt.Ub=Nt.Ub;var qt={cmd:"run",start_routine:Nt.Ic,arg:Nt.zc,pthread_ptr:Nt.Ub};return Lt.$b=()=>{qt.time=performance.now(),Lt.postMessage(qt,Nt.Nc)},Lt.loaded&&(Lt.$b(),delete Lt.$b),0}function i0(Nt){if(jt)return Sr(1,1,Nt);w0()||(jr.oc(),c.onExit&&c.onExit(Nt),Yr=!0),$t(Nt,new D0(Nt))}function B0(Nt,Lt){if(!Lt&&jt)throw eo(Nt),"unwind";w0()||jt||(vy(),p0(O0),Wr(0),R0[1].length&&uy(1,10),R0[2].length&&uy(2,10),jr.oc()),i0(Nt)}var jr={Yb:[],ac:[],qc:[],Vb:{},fc:function(){jt&&jr.Ec()},Pc:function(){},Ec:function(){jr.receiveObjectTransfer=jr.Gc,jr.threadInitTLS=jr.pc,jr.setExitStatus=jr.nc,_n=!1},nc:function(){},oc:function(){for(var Nt of Object.values(jr.Vb))jr.mc(Nt);for(Nt of jr.Yb)Nt.terminate();jr.Yb=[]},mc:function(Nt){var Lt=Nt.Ub;delete jr.Vb[Lt],jr.Yb.push(Nt),jr.ac.splice(jr.ac.indexOf(Nt),1),Nt.Ub=0,_y(Lt)},Gc:function(){},pc:function(){jr.qc.forEach(Nt=>Nt())},Fc:function(Nt,Lt){Nt.onmessage=qt=>{var ln=(qt=qt.data).cmd;if(Nt.Ub&&(jr.Bc=Nt.Ub),qt.targetThread&&qt.targetThread!=my()){var xn=jr.Vb[qt.Qc];xn?xn.postMessage(qt,qt.transferList):Jt('Internal error! Worker sent a message "'+ln+'" to target pthread '+qt.targetThread+", but that thread no longer exists!")}else ln==="processProxyingQueue"?bn(qt.queue):ln==="spawnThread"?G0(qt):ln==="cleanupThread"?P0(qt.thread):ln==="killThread"?(qt=qt.thread,ln=jr.Vb[qt],delete jr.Vb[qt],ln.terminate(),_y(qt),jr.ac.splice(jr.ac.indexOf(ln),1),ln.Ub=0):ln==="cancelThread"?jr.Vb[qt.thread].postMessage({cmd:"cancel"}):ln==="loaded"?(Nt.loaded=!0,Lt&&Lt(Nt),Nt.$b&&(Nt.$b(),delete Nt.$b)):ln==="print"?Wt("Thread "+qt.threadId+": "+qt.text):ln==="printErr"?Jt("Thread "+qt.threadId+": "+qt.text):ln==="alert"?alert("Thread "+qt.threadId+": "+qt.text):qt.target==="setimmediate"?Nt.postMessage(qt):ln==="onAbort"?c.onAbort&&c.onAbort(qt.arg):ln&&Jt("worker sent an unknown command "+ln);jr.Bc=void 0},Nt.onerror=qt=>{throw Jt("worker sent an error! "+qt.filename+":"+qt.lineno+": "+qt.message),qt},Tt&&(Nt.on("message",function(qt){Nt.onmessage({data:qt})}),Nt.on("error",function(qt){Nt.onerror(qt)}),Nt.on("detachedExit",function(){})),Nt.postMessage({cmd:"load",urlOrBlob:c.mainScriptUrlOrBlob||a,wasmMemory:vn,wasmModule:Sn})},yc:function(){var Nt=yn("ort-wasm-threaded.worker.js");jr.Yb.push(new Worker(Nt))},Cc:function(){return jr.Yb.length==0&&(jr.yc(),jr.Fc(jr.Yb[0])),jr.Yb.pop()}};function p0(Nt){for(;0<Nt.length;)Nt.shift()(c)}function iy(Nt){var Lt=Gr();return Nt=Nt(),Zr(Lt),Nt}function eo(Nt){if(jt)return Sr(2,0,Nt);try{B0(Nt)}catch(Lt){Lt instanceof D0||Lt=="unwind"||$t(1,Lt)}}c.PThread=jr,c.establishStackSpace=function(){var Nt=my(),Lt=ot()[Nt+44>>2>>>0];Nt=ot()[Nt+48>>2>>>0],F0(Lt,Lt-Nt),Zr(Lt)};var y0=[];function bp(Nt){var Lt=y0[Nt];return Lt||(Nt>=y0.length&&(y0.length=Nt+1),y0[Nt]=Lt=s0.get(Nt)),Lt}c.invokeEntryPoint=function(Nt,Lt){Nt=bp(Nt)(Lt),w0()?jr.nc(Nt):cy(Nt)};var Q0,oy,H0=[],_r=0,Vr=0;function Kr(Nt){this.Zb=Nt,this.Sb=Nt-24,this.xc=function(Lt){it()[this.Sb+4>>2>>>0]=Lt},this.bc=function(){return it()[this.Sb+4>>2>>>0]},this.wc=function(Lt){it()[this.Sb+8>>2>>>0]=Lt},this.Dc=function(){return it()[this.Sb+8>>2>>>0]},this.rc=function(){ot()[this.Sb>>2>>>0]=0},this.hc=function(Lt){Lt=Lt?1:0,h()[this.Sb+12>>0>>>0]=Lt},this.uc=function(){return h()[this.Sb+12>>0>>>0]!=0},this.ic=function(Lt){Lt=Lt?1:0,h()[this.Sb+13>>0>>>0]=Lt},this.kc=function(){return h()[this.Sb+13>>0>>>0]!=0},this.fc=function(Lt,qt){this.cc(0),this.xc(Lt),this.wc(qt),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(ot(),this.Sb>>2,1)},this.Hc=function(){return Atomics.sub(ot(),this.Sb>>2,1)===1},this.cc=function(Lt){it()[this.Sb+16>>2>>>0]=Lt},this.tc=function(){return it()[this.Sb+16>>2>>>0]},this.vc=function(){if(wt(this.bc()))return it()[this.Zb>>2>>>0];var Lt=this.tc();return Lt!==0?Lt:this.Zb}}function hy(Nt){return Oy(new Kr(Nt).Sb)}function q0(Nt,Lt,qt,ln){return jt?Sr(3,1,Nt,Lt,qt,ln):ay(Nt,Lt,qt,ln)}function ay(Nt,Lt,qt,ln){if(typeof SharedArrayBuffer>"u")return Jt("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var xn=[];return jt&&xn.length===0?q0(Nt,Lt,qt,ln):(Nt={Ic:qt,Ub:Nt,zc:ln,Nc:xn},jt?(Nt.Oc="spawnThread",postMessage(Nt,xn),0):G0(Nt))}function K0(Nt,Lt,qt){return jt?Sr(4,1,Nt,Lt,qt):0}function Z0(Nt,Lt){if(jt)return Sr(5,1,Nt,Lt)}function j0(Nt,Lt){if(jt)return Sr(6,1,Nt,Lt)}function f0(Nt,Lt,qt){if(jt)return Sr(7,1,Nt,Lt,qt)}function sy(Nt,Lt,qt){return jt?Sr(8,1,Nt,Lt,qt):0}function I0(Nt,Lt){if(jt)return Sr(9,1,Nt,Lt)}function T0(Nt,Lt,qt){if(jt)return Sr(10,1,Nt,Lt,qt)}function J0(Nt,Lt,qt,ln){if(jt)return Sr(11,1,Nt,Lt,qt,ln)}function M0(Nt,Lt,qt,ln){if(jt)return Sr(12,1,Nt,Lt,qt,ln)}function ey(Nt,Lt,qt,ln){if(jt)return Sr(13,1,Nt,Lt,qt,ln)}function ty(Nt){if(jt)return Sr(14,1,Nt)}function Ht(Nt,Lt){if(jt)return Sr(15,1,Nt,Lt)}function cn(Nt,Lt,qt){if(jt)return Sr(16,1,Nt,Lt,qt)}function bn(Nt){Atomics.store(ot(),Nt>>2,1),my()&&yy(Nt),Atomics.compareExchange(ot(),Nt>>2,1,0)}function $n(Nt){return it()[Nt>>>2]+4294967296*ot()[Nt+4>>>2]}function Tn(Nt,Lt,qt,ln,xn,Cn){return jt?Sr(17,1,Nt,Lt,qt,ln,xn,Cn):-52}function In(Nt,Lt,qt,ln,xn,Cn){if(jt)return Sr(18,1,Nt,Lt,qt,ln,xn,Cn)}function wr(Nt){var Lt=_i(Nt)+1,qt=ly(Lt);return qt&&l0(Nt,h(),qt,Lt),qt}function Dr(Nt,Lt,qt){function ln(_h){return(_h=_h.toTimeString().match(/\(([A-Za-z ]+)\)$/))?_h[1]:"GMT"}if(jt)return Sr(19,1,Nt,Lt,qt);var xn=new Date().getFullYear(),Cn=new Date(xn,0,1),xr=new Date(xn,6,1);xn=Cn.getTimezoneOffset();var Nr=xr.getTimezoneOffset(),xu=Math.max(xn,Nr);ot()[Nt>>2>>>0]=60*xu,ot()[Lt>>2>>>0]=+(xn!=Nr),Nt=ln(Cn),Lt=ln(xr),Nt=wr(Nt),Lt=wr(Lt),Nr<xn?(it()[qt>>2>>>0]=Nt,it()[qt+4>>2>>>0]=Lt):(it()[qt>>2>>>0]=Lt,it()[qt+4>>2>>>0]=Nt)}function Sr(Nt,Lt){var qt=arguments.length-2,ln=arguments;return iy(()=>{for(var xn=V0(8*qt),Cn=xn>>3,xr=0;xr<qt;xr++){var Nr=ln[2+xr];$()[Cn+xr>>>0]=Nr}return gy(Nt,qt,xn,Lt)})}c.executeNotifiedProxyingQueue=bn,oy=Tt?()=>{var Nt=process.hrtime();return 1e3*Nt[0]+Nt[1]/1e6}:jt?()=>performance.now()-c.__performance_now_clock_drift:()=>performance.now();var Xr,Ro=[],_0={};function g0(){if(!Xr){var Nt,Lt={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:bt||"./this.program"};for(Nt in _0)_0[Nt]===void 0?delete Lt[Nt]:Lt[Nt]=_0[Nt];var qt=[];for(Nt in Lt)qt.push(Nt+"="+Lt[Nt]);Xr=qt}return Xr}function An(Nt,Lt){if(jt)return Sr(20,1,Nt,Lt);var qt=0;return g0().forEach(function(ln,xn){var Cn=Lt+qt;for(xn=it()[Nt+4*xn>>2>>>0]=Cn,Cn=0;Cn<ln.length;++Cn)h()[xn++>>0>>>0]=ln.charCodeAt(Cn);h()[xn>>0>>>0]=0,qt+=ln.length+1}),0}function _f(Nt,Lt){if(jt)return Sr(21,1,Nt,Lt);var qt=g0();it()[Nt>>2>>>0]=qt.length;var ln=0;return qt.forEach(function(xn){ln+=xn.length+1}),it()[Lt>>2>>>0]=ln,0}function No(Nt){return jt?Sr(22,1,Nt):52}function A0(Nt,Lt,qt,ln){return jt?Sr(23,1,Nt,Lt,qt,ln):52}function z0(Nt,Lt,qt,ln,xn){return jt?Sr(24,1,Nt,Lt,qt,ln,xn):70}var R0=[null,[],[]];function uy(Nt,Lt){var qt=R0[Nt];Lt===0||Lt===10?((Nt===1?Wt:Jt)(b0(qt,0)),qt.length=0):qt.push(Lt)}function x0(Nt,Lt,qt,ln){if(jt)return Sr(25,1,Nt,Lt,qt,ln);for(var xn=0,Cn=0;Cn<qt;Cn++){var xr=it()[Lt>>2>>>0],Nr=it()[Lt+4>>2>>>0];Lt+=8;for(var xu=0;xu<Nr;xu++)uy(Nt,et()[xr+xu>>>0]);xn+=Nr}return it()[ln>>2>>>0]=xn,0}var c0=0;function Y0(Nt){return Nt%4==0&&(Nt%100!=0||Nt%400==0)}var ky=[31,29,31,30,31,30,31,31,30,31,30,31],xy=[31,28,31,30,31,30,31,31,30,31,30,31];function wy(Nt,Lt,qt,ln){function xn(er,_g,m0){for(er=typeof er=="number"?er.toString():er||"";er.length<_g;)er=m0[0]+er;return er}function Cn(er,_g){return xn(er,_g,"0")}function xr(er,_g){function m0(by){return 0>by?-1:0<by?1:0}var X0;return(X0=m0(er.getFullYear()-_g.getFullYear()))===0&&(X0=m0(er.getMonth()-_g.getMonth()))===0&&(X0=m0(er.getDate()-_g.getDate())),X0}function Nr(er){switch(er.getDay()){case 0:return new Date(er.getFullYear()-1,11,29);case 1:return er;case 2:return new Date(er.getFullYear(),0,3);case 3:return new Date(er.getFullYear(),0,2);case 4:return new Date(er.getFullYear(),0,1);case 5:return new Date(er.getFullYear()-1,11,31);case 6:return new Date(er.getFullYear()-1,11,30)}}function xu(er){var _g=er.Wb;for(er=new Date(new Date(er.Xb+1900,0,1).getTime());0<_g;){var m0=er.getMonth(),X0=(Y0(er.getFullYear())?ky:xy)[m0];if(!(_g>X0-er.getDate())){er.setDate(er.getDate()+_g);break}_g-=X0-er.getDate()+1,er.setDate(1),11>m0?er.setMonth(m0+1):(er.setMonth(0),er.setFullYear(er.getFullYear()+1))}return m0=new Date(er.getFullYear()+1,0,4),_g=Nr(new Date(er.getFullYear(),0,4)),m0=Nr(m0),0>=xr(_g,er)?0>=xr(m0,er)?er.getFullYear()+1:er.getFullYear():er.getFullYear()-1}var _h=ot()[ln+40>>2>>>0];for(var h0 in ln={Lc:ot()[ln>>2>>>0],Kc:ot()[ln+4>>2>>>0],dc:ot()[ln+8>>2>>>0],jc:ot()[ln+12>>2>>>0],ec:ot()[ln+16>>2>>>0],Xb:ot()[ln+20>>2>>>0],Tb:ot()[ln+24>>2>>>0],Wb:ot()[ln+28>>2>>>0],Rc:ot()[ln+32>>2>>>0],Jc:ot()[ln+36>>2>>>0],Mc:_h?t0(_h):""},qt=t0(qt),_h={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})qt=qt.replace(new RegExp(h0,"g"),_h[h0]);var W0="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),N0="January February March April May June July August September October November December".split(" ");for(h0 in _h={"%a":function(er){return W0[er.Tb].substring(0,3)},"%A":function(er){return W0[er.Tb]},"%b":function(er){return N0[er.ec].substring(0,3)},"%B":function(er){return N0[er.ec]},"%C":function(er){return Cn((er.Xb+1900)/100|0,2)},"%d":function(er){return Cn(er.jc,2)},"%e":function(er){return xn(er.jc,2," ")},"%g":function(er){return xu(er).toString().substring(2)},"%G":function(er){return xu(er)},"%H":function(er){return Cn(er.dc,2)},"%I":function(er){return(er=er.dc)==0?er=12:12<er&&(er-=12),Cn(er,2)},"%j":function(er){for(var _g=0,m0=0;m0<=er.ec-1;_g+=(Y0(er.Xb+1900)?ky:xy)[m0++]);return Cn(er.jc+_g,3)},"%m":function(er){return Cn(er.ec+1,2)},"%M":function(er){return Cn(er.Kc,2)},"%n":function(){return`
`},"%p":function(er){return 0<=er.dc&&12>er.dc?"AM":"PM"},"%S":function(er){return Cn(er.Lc,2)},"%t":function(){return"	"},"%u":function(er){return er.Tb||7},"%U":function(er){return Cn(Math.floor((er.Wb+7-er.Tb)/7),2)},"%V":function(er){var _g=Math.floor((er.Wb+7-(er.Tb+6)%7)/7);if(2>=(er.Tb+371-er.Wb-2)%7&&_g++,_g)_g==53&&((m0=(er.Tb+371-er.Wb)%7)==4||m0==3&&Y0(er.Xb)||(_g=1));else{_g=52;var m0=(er.Tb+7-er.Wb-1)%7;(m0==4||m0==5&&Y0(er.Xb%400-1))&&_g++}return Cn(_g,2)},"%w":function(er){return er.Tb},"%W":function(er){return Cn(Math.floor((er.Wb+7-(er.Tb+6)%7)/7),2)},"%y":function(er){return(er.Xb+1900).toString().substring(2)},"%Y":function(er){return er.Xb+1900},"%z":function(er){var _g=0<=(er=er.Jc);return er=Math.abs(er)/60,(_g?"+":"-")+("0000"+(er/60*100+er%60)).slice(-4)},"%Z":function(er){return er.Mc},"%%":function(){return"%"}},qt=qt.replace(/%%/g,"\0\0"),_h)qt.includes(h0)&&(qt=qt.replace(new RegExp(h0,"g"),_h[h0](ln)));return h0=function(er){var _g=Array(_i(er)+1);return l0(er,_g,0,_g.length),_g}(qt=qt.replace(/\0\0/g,"%")),h0.length>Lt?0:(function(er,_g){h().set(er,_g>>>0)}(h0,Nt),h0.length-1)}jr.fc();var Ay=[null,i0,eo,q0,K0,Z0,j0,f0,sy,I0,T0,J0,M0,ey,ty,Ht,cn,Tn,In,Dr,An,_f,No,A0,z0,x0],Ey={b:function(Nt){return ly(Nt+24)+24},n:function(Nt){return(Nt=new Kr(Nt)).uc()||(Nt.hc(!0),_r--),Nt.ic(!1),H0.push(Nt),Nt.sc(),Nt.vc()},ma:function(Nt){throw Jt("Unexpected exception thrown, this is not properly supported - aborting"),Yr=!0,Nt},x:function(){Wo(0);var Nt=H0.pop();if(Nt.Hc()&&!Nt.kc()){var Lt=Nt.Dc();Lt&&bp(Lt)(Nt.Zb),hy(Nt.Zb)}Vr=0},e:function(){var Nt=Vr;if(!Nt)return c0=0;var Lt=new Kr(Nt);Lt.cc(Nt);var qt=Lt.bc();if(!qt)return c0=0,Nt;for(var ln=Array.prototype.slice.call(arguments),xn=0;xn<ln.length;xn++){var Cn=ln[xn];if(Cn===0||Cn===qt)break;if(dy(Cn,qt,Lt.Sb+16))return c0=Cn,Nt}return c0=qt,Nt},l:function(){var Nt=Vr;if(!Nt)return c0=0;var Lt=new Kr(Nt);Lt.cc(Nt);var qt=Lt.bc();if(!qt)return c0=0,Nt;for(var ln=Array.prototype.slice.call(arguments),xn=0;xn<ln.length;xn++){var Cn=ln[xn];if(Cn===0||Cn===qt)break;if(dy(Cn,qt,Lt.Sb+16))return c0=Cn,Nt}return c0=qt,Nt},h:function(){var Nt=Vr;if(!Nt)return c0=0;var Lt=new Kr(Nt);Lt.cc(Nt);var qt=Lt.bc();if(!qt)return c0=0,Nt;for(var ln=Array.prototype.slice.call(arguments),xn=0;xn<ln.length;xn++){var Cn=ln[xn];if(Cn===0||Cn===qt)break;if(dy(Cn,qt,Lt.Sb+16))return c0=Cn,Nt}return c0=qt,Nt},t:hy,M:function(){var Nt=H0.pop();Nt||qr("no exception to throw");var Lt=Nt.Zb;throw Nt.kc()||(H0.push(Nt),Nt.ic(!0),Nt.hc(!1),_r++),Vr=Lt,Lt},c:function(Nt,Lt,qt){throw new Kr(Nt).fc(Lt,qt),Vr=Nt,_r++,Nt},pa:function(){return _r},Fa:function(Nt){ny(Nt,!It,1,!Ct),jr.pc()},T:function(Nt){jt?postMessage({cmd:"cleanupThread",thread:Nt}):P0(Nt)},xa:ay,j:function(Nt){throw Vr||(Vr=Nt),Nt},H:K0,Ma:Z0,ua:j0,wa:f0,oa:sy,Ka:I0,Ca:T0,Ja:J0,V:M0,va:ey,sa:ty,La:Ht,ta:cn,Ta:function(){},X:function(){qr("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){qr("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(Nt,Lt,qt,ln){if(Nt==Lt)setTimeout(()=>bn(ln));else if(jt)postMessage({targetThread:Nt,cmd:"processProxyingQueue",queue:ln});else{if(!(Nt=jr.Vb[Nt]))return;Nt.postMessage({cmd:"processProxyingQueue",queue:ln})}return 1},Ea:function(){return-1},Pa:function(Nt,Lt){Nt=new Date(1e3*$n(Nt)),ot()[Lt>>2>>>0]=Nt.getUTCSeconds(),ot()[Lt+4>>2>>>0]=Nt.getUTCMinutes(),ot()[Lt+8>>2>>>0]=Nt.getUTCHours(),ot()[Lt+12>>2>>>0]=Nt.getUTCDate(),ot()[Lt+16>>2>>>0]=Nt.getUTCMonth(),ot()[Lt+20>>2>>>0]=Nt.getUTCFullYear()-1900,ot()[Lt+24>>2>>>0]=Nt.getUTCDay(),Nt=(Nt.getTime()-Date.UTC(Nt.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,ot()[Lt+28>>2>>>0]=Nt},Qa:function(Nt,Lt){Nt=new Date(1e3*$n(Nt)),ot()[Lt>>2>>>0]=Nt.getSeconds(),ot()[Lt+4>>2>>>0]=Nt.getMinutes(),ot()[Lt+8>>2>>>0]=Nt.getHours(),ot()[Lt+12>>2>>>0]=Nt.getDate(),ot()[Lt+16>>2>>>0]=Nt.getMonth(),ot()[Lt+20>>2>>>0]=Nt.getFullYear()-1900,ot()[Lt+24>>2>>>0]=Nt.getDay();var qt=new Date(Nt.getFullYear(),0,1),ln=(Nt.getTime()-qt.getTime())/864e5|0;ot()[Lt+28>>2>>>0]=ln,ot()[Lt+36>>2>>>0]=-60*Nt.getTimezoneOffset(),ln=new Date(Nt.getFullYear(),6,1).getTimezoneOffset(),Nt=0|(ln!=(qt=qt.getTimezoneOffset())&&Nt.getTimezoneOffset()==Math.min(qt,ln)),ot()[Lt+32>>2>>>0]=Nt},Ra:function(Nt){var Lt=new Date(ot()[Nt+20>>2>>>0]+1900,ot()[Nt+16>>2>>>0],ot()[Nt+12>>2>>>0],ot()[Nt+8>>2>>>0],ot()[Nt+4>>2>>>0],ot()[Nt>>2>>>0],0),qt=ot()[Nt+32>>2>>>0],ln=Lt.getTimezoneOffset(),xn=new Date(Lt.getFullYear(),0,1),Cn=new Date(Lt.getFullYear(),6,1).getTimezoneOffset(),xr=xn.getTimezoneOffset(),Nr=Math.min(xr,Cn);return 0>qt?ot()[Nt+32>>2>>>0]=+(Cn!=xr&&Nr==ln):0<qt!=(Nr==ln)&&(Cn=Math.max(xr,Cn),Lt.setTime(Lt.getTime()+6e4*((0<qt?Nr:Cn)-ln))),ot()[Nt+24>>2>>>0]=Lt.getDay(),qt=(Lt.getTime()-xn.getTime())/864e5|0,ot()[Nt+28>>2>>>0]=qt,ot()[Nt>>2>>>0]=Lt.getSeconds(),ot()[Nt+4>>2>>>0]=Lt.getMinutes(),ot()[Nt+8>>2>>>0]=Lt.getHours(),ot()[Nt+12>>2>>>0]=Lt.getDate(),ot()[Nt+16>>2>>>0]=Lt.getMonth(),Lt.getTime()/1e3|0},Aa:Tn,Ba:In,Sa:function Nt(Lt,qt,ln){Nt.Ac||(Nt.Ac=!0,Dr(Lt,qt,ln))},y:function(){qr("")},U:function(){if(!Tt&&!It){var Nt="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";Q0||(Q0={}),Q0[Nt]||(Q0[Nt]=1,Tt&&(Nt="warning: "+Nt),Jt(Nt))}},ra:function(){return 4294901760},B:oy,Ia:function(Nt,Lt,qt){et().copyWithin(Nt>>>0,Lt>>>0,Lt+qt>>>0)},F:function(){return Tt?o(3993).cpus().length:navigator.hardwareConcurrency},Da:function(Nt,Lt,qt){Ro.length=Lt,qt>>=3;for(var ln=0;ln<Lt;ln++)Ro[ln]=$()[qt+ln>>>0];return(0>Nt?ry[-Nt-1]:Ay[Nt]).apply(null,Ro)},qa:function(Nt){var Lt=et().length;if((Nt>>>=0)<=Lt||4294901760<Nt)return!1;for(var qt=1;4>=qt;qt*=2){var ln=Lt*(1+.2/qt);ln=Math.min(ln,Nt+100663296);var xn=Math;ln=Math.max(Nt,ln),xn=xn.min.call(xn,4294901760,ln+(65536-ln%65536)%65536);e:{try{vn.grow(xn-hn.byteLength+65535>>>16),Po(vn.buffer);var Cn=1;break e}catch{}Cn=void 0}if(Cn)return!0}return!1},Na:function(){throw"unwind"},Ga:An,Ha:_f,J:B0,I:No,S:A0,ga:z0,R:x0,d:function(){return c0},na:function Nt(Lt,qt){Nt.lc||(Nt.lc=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var xn=new Uint8Array(1);return()=>(crypto.getRandomValues(xn),xn[0])}if(Tt)try{var Cn=o(Object(function(){var xr=new Error("Cannot find module 'crypto'");throw xr.code="MODULE_NOT_FOUND",xr}()));return()=>Cn.randomBytes(1)[0]}catch{}return()=>qr("randomDevice")}());for(var ln=0;ln<qt;ln++)h()[Lt+ln>>0>>>0]=Nt.lc();return 0},ia:function(Nt,Lt,qt){var ln=Gr();try{return bp(Nt)(Lt,qt)}catch(xn){if(Zr(ln),xn!==xn+0)throw xn;Wo(1,0)}},ja:function(Nt,Lt,qt){var ln=Gr();try{return bp(Nt)(Lt,qt)}catch(xn){if(Zr(ln),xn!==xn+0)throw xn;Wo(1,0)}},K:function(Nt){var Lt=Gr();try{return bp(Nt)()}catch(qt){if(Zr(Lt),qt!==qt+0)throw qt;Wo(1,0)}},f:function(Nt,Lt){var qt=Gr();try{return bp(Nt)(Lt)}catch(ln){if(Zr(qt),ln!==ln+0)throw ln;Wo(1,0)}},P:function(Nt,Lt,qt){var ln=Gr();try{return bp(Nt)(Lt,qt)}catch(xn){if(Zr(ln),xn!==xn+0)throw xn;Wo(1,0)}},Q:function(Nt,Lt,qt){var ln=Gr();try{return bp(Nt)(Lt,qt)}catch(xn){if(Zr(ln),xn!==xn+0)throw xn;Wo(1,0)}},k:function(Nt,Lt,qt){var ln=Gr();try{return bp(Nt)(Lt,qt)}catch(xn){if(Zr(ln),xn!==xn+0)throw xn;Wo(1,0)}},p:function(Nt,Lt,qt,ln){var xn=Gr();try{return bp(Nt)(Lt,qt,ln)}catch(Cn){if(Zr(xn),Cn!==Cn+0)throw Cn;Wo(1,0)}},q:function(Nt,Lt,qt,ln,xn){var Cn=Gr();try{return bp(Nt)(Lt,qt,ln,xn)}catch(xr){if(Zr(Cn),xr!==xr+0)throw xr;Wo(1,0)}},N:function(Nt,Lt,qt,ln,xn,Cn){var xr=Gr();try{return bp(Nt)(Lt,qt,ln,xn,Cn)}catch(Nr){if(Zr(xr),Nr!==Nr+0)throw Nr;Wo(1,0)}},s:function(Nt,Lt,qt,ln,xn,Cn){var xr=Gr();try{return bp(Nt)(Lt,qt,ln,xn,Cn)}catch(Nr){if(Zr(xr),Nr!==Nr+0)throw Nr;Wo(1,0)}},w:function(Nt,Lt,qt,ln,xn,Cn,xr){var Nr=Gr();try{return bp(Nt)(Lt,qt,ln,xn,Cn,xr)}catch(xu){if(Zr(Nr),xu!==xu+0)throw xu;Wo(1,0)}},L:function(Nt,Lt,qt,ln,xn,Cn,xr,Nr){var xu=Gr();try{return bp(Nt)(Lt,qt,ln,xn,Cn,xr,Nr)}catch(_h){if(Zr(xu),_h!==_h+0)throw _h;Wo(1,0)}},E:function(Nt,Lt,qt,ln,xn,Cn,xr,Nr,xu,_h,h0,W0){var N0=Gr();try{return bp(Nt)(Lt,qt,ln,xn,Cn,xr,Nr,xu,_h,h0,W0)}catch(er){if(Zr(N0),er!==er+0)throw er;Wo(1,0)}},aa:function(Nt,Lt,qt,ln,xn,Cn,xr,Nr){var xu=Gr();try{return Tr(Nt,Lt,qt,ln,xn,Cn,xr,Nr)}catch(_h){if(Zr(xu),_h!==_h+0)throw _h;Wo(1,0)}},_:function(Nt,Lt,qt,ln,xn,Cn,xr){var Nr=Gr();try{return Vt(Nt,Lt,qt,ln,xn,Cn,xr)}catch(xu){if(Zr(Nr),xu!==xu+0)throw xu;Wo(1,0)}},Z:function(Nt,Lt,qt,ln,xn){var Cn=Gr();try{return Fr(Nt,Lt,qt,ln,xn)}catch(xr){if(Zr(Cn),xr!==xr+0)throw xr;Wo(1,0)}},ca:function(Nt,Lt,qt,ln){var xn=Gr();try{return yr(Nt,Lt,qt,ln)}catch(Cn){if(Zr(xn),Cn!==Cn+0)throw Cn;Wo(1,0)}},$:function(Nt){var Lt=Gr();try{return Pt(Nt)}catch(qt){if(Zr(Lt),qt!==qt+0)throw qt;Wo(1,0)}},ba:function(Nt,Lt){var qt=Gr();try{return Cr(Nt,Lt)}catch(ln){if(Zr(qt),ln!==ln+0)throw ln;Wo(1,0)}},Y:function(Nt,Lt,qt){var ln=Gr();try{return Qt(Nt,Lt,qt)}catch(xn){if(Zr(ln),xn!==xn+0)throw xn;Wo(1,0)}},g:function(Nt){var Lt=Gr();try{bp(Nt)()}catch(qt){if(Zr(Lt),qt!==qt+0)throw qt;Wo(1,0)}},r:function(Nt,Lt){var qt=Gr();try{bp(Nt)(Lt)}catch(ln){if(Zr(qt),ln!==ln+0)throw ln;Wo(1,0)}},i:function(Nt,Lt,qt){var ln=Gr();try{bp(Nt)(Lt,qt)}catch(xn){if(Zr(ln),xn!==xn+0)throw xn;Wo(1,0)}},ha:function(Nt,Lt,qt,ln){var xn=Gr();try{bp(Nt)(Lt,qt,ln)}catch(Cn){if(Zr(xn),Cn!==Cn+0)throw Cn;Wo(1,0)}},m:function(Nt,Lt,qt,ln){var xn=Gr();try{bp(Nt)(Lt,qt,ln)}catch(Cn){if(Zr(xn),Cn!==Cn+0)throw Cn;Wo(1,0)}},v:function(Nt,Lt,qt,ln,xn){var Cn=Gr();try{bp(Nt)(Lt,qt,ln,xn)}catch(xr){if(Zr(Cn),xr!==xr+0)throw xr;Wo(1,0)}},u:function(Nt,Lt,qt,ln,xn,Cn){var xr=Gr();try{bp(Nt)(Lt,qt,ln,xn,Cn)}catch(Nr){if(Zr(xr),Nr!==Nr+0)throw Nr;Wo(1,0)}},O:function(Nt,Lt,qt,ln,xn,Cn,xr){var Nr=Gr();try{bp(Nt)(Lt,qt,ln,xn,Cn,xr)}catch(xu){if(Zr(Nr),xu!==xu+0)throw xu;Wo(1,0)}},A:function(Nt,Lt,qt,ln,xn,Cn,xr,Nr){var xu=Gr();try{bp(Nt)(Lt,qt,ln,xn,Cn,xr,Nr)}catch(_h){if(Zr(xu),_h!==_h+0)throw _h;Wo(1,0)}},ka:function(Nt,Lt,qt,ln,xn,Cn,xr,Nr,xu){var _h=Gr();try{bp(Nt)(Lt,qt,ln,xn,Cn,xr,Nr,xu)}catch(h0){if(Zr(_h),h0!==h0+0)throw h0;Wo(1,0)}},C:function(Nt,Lt,qt,ln,xn,Cn,xr,Nr,xu,_h,h0){var W0=Gr();try{bp(Nt)(Lt,qt,ln,xn,Cn,xr,Nr,xu,_h,h0)}catch(N0){if(Zr(W0),N0!==N0+0)throw N0;Wo(1,0)}},D:function(Nt,Lt,qt,ln,xn,Cn,xr,Nr,xu,_h,h0,W0,N0,er,_g,m0){var X0=Gr();try{bp(Nt)(Lt,qt,ln,xn,Cn,xr,Nr,xu,_h,h0,W0,N0,er,_g,m0)}catch(by){if(Zr(X0),by!==by+0)throw by;Wo(1,0)}},fa:function(Nt,Lt,qt,ln,xn,Cn,xr,Nr){var xu=Gr();try{gn(Nt,Lt,qt,ln,xn,Cn,xr,Nr)}catch(_h){if(Zr(xu),_h!==_h+0)throw _h;Wo(1,0)}},da:function(Nt,Lt,qt,ln,xn,Cn,xr,Nr,xu,_h,h0,W0){var N0=Gr();try{or(Nt,Lt,qt,ln,xn,Cn,xr,Nr,xu,_h,h0,W0)}catch(er){if(Zr(N0),er!==er+0)throw er;Wo(1,0)}},ea:function(Nt,Lt,qt,ln,xn,Cn){var xr=Gr();try{En(Nt,Lt,qt,ln,xn,Cn)}catch(Nr){if(Zr(xr),Nr!==Nr+0)throw Nr;Wo(1,0)}},o:function(Nt){return Nt},a:vn||c.wasmMemory,G:function(Nt){c0=Nt},la:wy,z:function(Nt,Lt,qt,ln){return wy(Nt,Lt,qt,ln)}};(function(){function Nt(xn,Cn){c.asm=xn.exports,jr.qc.push(c.asm.sb),s0=c.asm.ub,E0.unshift(c.asm.Va),Sn=Cn,jt||(e0--,c.monitorRunDependencies&&c.monitorRunDependencies(e0),e0==0&&C0&&(xn=C0,C0=null,xn()))}function Lt(xn){Nt(xn.instance,xn.module)}function qt(xn){return function(){if(!un&&(Ct||It)){if(typeof fetch=="function"&&!a0.startsWith("file://"))return fetch(a0,{credentials:"same-origin"}).then(function(Cn){if(!Cn.ok)throw"failed to load wasm binary file at '"+a0+"'";return Cn.arrayBuffer()}).catch(function(){return $0()});if(st)return new Promise(function(Cn,xr){st(a0,function(Nr){Cn(new Uint8Array(Nr))},xr)})}return Promise.resolve().then(function(){return $0()})}().then(function(Cn){return WebAssembly.instantiate(Cn,ln)}).then(function(Cn){return Cn}).then(xn,function(Cn){Jt("failed to asynchronously prepare wasm: "+Cn),qr(Cn)})}var ln={a:Ey};if(jt||(e0++,c.monitorRunDependencies&&c.monitorRunDependencies(e0)),c.instantiateWasm)try{return c.instantiateWasm(ln,Nt)}catch(xn){return Jt("Module.instantiateWasm callback failed with error: "+xn),!1}(un||typeof WebAssembly.instantiateStreaming!="function"||L0()||a0.startsWith("file://")||Tt||typeof fetch!="function"?qt(Lt):fetch(a0,{credentials:"same-origin"}).then(function(xn){return WebAssembly.instantiateStreaming(xn,ln).then(Lt,function(Cn){return Jt("wasm streaming compile failed: "+Cn),Jt("falling back to ArrayBuffer instantiation"),qt(Lt)})})).catch(_)})(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.Va).apply(null,arguments)},c._OrtInit=function(){return(c._OrtInit=c.asm.Wa).apply(null,arguments)},c._OrtCreateSessionOptions=function(){return(c._OrtCreateSessionOptions=c.asm.Xa).apply(null,arguments)},c._OrtAppendExecutionProvider=function(){return(c._OrtAppendExecutionProvider=c.asm.Ya).apply(null,arguments)},c._OrtAddSessionConfigEntry=function(){return(c._OrtAddSessionConfigEntry=c.asm.Za).apply(null,arguments)},c._OrtReleaseSessionOptions=function(){return(c._OrtReleaseSessionOptions=c.asm._a).apply(null,arguments)},c._OrtCreateSession=function(){return(c._OrtCreateSession=c.asm.$a).apply(null,arguments)},c._OrtReleaseSession=function(){return(c._OrtReleaseSession=c.asm.ab).apply(null,arguments)},c._OrtGetInputCount=function(){return(c._OrtGetInputCount=c.asm.bb).apply(null,arguments)},c._OrtGetOutputCount=function(){return(c._OrtGetOutputCount=c.asm.cb).apply(null,arguments)},c._OrtGetInputName=function(){return(c._OrtGetInputName=c.asm.db).apply(null,arguments)},c._OrtGetOutputName=function(){return(c._OrtGetOutputName=c.asm.eb).apply(null,arguments)},c._OrtFree=function(){return(c._OrtFree=c.asm.fb).apply(null,arguments)},c._OrtCreateTensor=function(){return(c._OrtCreateTensor=c.asm.gb).apply(null,arguments)},c._OrtGetTensorData=function(){return(c._OrtGetTensorData=c.asm.hb).apply(null,arguments)},c._OrtReleaseTensor=function(){return(c._OrtReleaseTensor=c.asm.ib).apply(null,arguments)},c._OrtCreateRunOptions=function(){return(c._OrtCreateRunOptions=c.asm.jb).apply(null,arguments)},c._OrtAddRunConfigEntry=function(){return(c._OrtAddRunConfigEntry=c.asm.kb).apply(null,arguments)},c._OrtReleaseRunOptions=function(){return(c._OrtReleaseRunOptions=c.asm.lb).apply(null,arguments)},c._OrtRun=function(){return(c._OrtRun=c.asm.mb).apply(null,arguments)},c._OrtEndProfiling=function(){return(c._OrtEndProfiling=c.asm.nb).apply(null,arguments)};var my=c._pthread_self=function(){return(my=c._pthread_self=c.asm.ob).apply(null,arguments)},ly=c._malloc=function(){return(ly=c._malloc=c.asm.pb).apply(null,arguments)},Oy=c._free=function(){return(Oy=c._free=c.asm.qb).apply(null,arguments)},Wr=c._fflush=function(){return(Wr=c._fflush=c.asm.rb).apply(null,arguments)};c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm.sb).apply(null,arguments)};var vy=c.___funcs_on_exit=function(){return(vy=c.___funcs_on_exit=c.asm.tb).apply(null,arguments)},ny=c.__emscripten_thread_init=function(){return(ny=c.__emscripten_thread_init=c.asm.vb).apply(null,arguments)};c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm.wb).apply(null,arguments)};var S0,gy=c._emscripten_run_in_main_runtime_thread_js=function(){return(gy=c._emscripten_run_in_main_runtime_thread_js=c.asm.xb).apply(null,arguments)},yy=c.__emscripten_proxy_execute_task_queue=function(){return(yy=c.__emscripten_proxy_execute_task_queue=c.asm.yb).apply(null,arguments)},_y=c.__emscripten_thread_free_data=function(){return(_y=c.__emscripten_thread_free_data=c.asm.zb).apply(null,arguments)},cy=c.__emscripten_thread_exit=function(){return(cy=c.__emscripten_thread_exit=c.asm.Ab).apply(null,arguments)},Wo=c._setThrew=function(){return(Wo=c._setThrew=c.asm.Bb).apply(null,arguments)},F0=c._emscripten_stack_set_limits=function(){return(F0=c._emscripten_stack_set_limits=c.asm.Cb).apply(null,arguments)},Gr=c.stackSave=function(){return(Gr=c.stackSave=c.asm.Db).apply(null,arguments)},Zr=c.stackRestore=function(){return(Zr=c.stackRestore=c.asm.Eb).apply(null,arguments)},V0=c.stackAlloc=function(){return(V0=c.stackAlloc=c.asm.Fb).apply(null,arguments)},dy=c.___cxa_can_catch=function(){return(dy=c.___cxa_can_catch=c.asm.Gb).apply(null,arguments)},wt=c.___cxa_is_pointer_type=function(){return(wt=c.___cxa_is_pointer_type=c.asm.Hb).apply(null,arguments)},Pt=c.dynCall_j=function(){return(Pt=c.dynCall_j=c.asm.Ib).apply(null,arguments)},Vt=c.dynCall_iiiiij=function(){return(Vt=c.dynCall_iiiiij=c.asm.Jb).apply(null,arguments)},Qt=c.dynCall_jii=function(){return(Qt=c.dynCall_jii=c.asm.Kb).apply(null,arguments)},gn=c.dynCall_viiiiij=function(){return(gn=c.dynCall_viiiiij=c.asm.Lb).apply(null,arguments)},En=c.dynCall_vjji=function(){return(En=c.dynCall_vjji=c.asm.Mb).apply(null,arguments)},or=c.dynCall_viiijjjii=function(){return(or=c.dynCall_viiijjjii=c.asm.Nb).apply(null,arguments)},yr=c.dynCall_iij=function(){return(yr=c.dynCall_iij=c.asm.Ob).apply(null,arguments)},Cr=c.dynCall_ji=function(){return(Cr=c.dynCall_ji=c.asm.Pb).apply(null,arguments)},Tr=c.dynCall_iiiiiij=function(){return(Tr=c.dynCall_iiiiiij=c.asm.Qb).apply(null,arguments)},Fr=c.dynCall_iiij=function(){return(Fr=c.dynCall_iiij=c.asm.Rb).apply(null,arguments)};function n0(){function Nt(){if(!S0&&(S0=!0,c.calledRun=!0,!Yr)&&(jt||p0(E0),s(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!jt)){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;){var Lt=c.postRun.shift();U0.unshift(Lt)}p0(U0)}}if(!(0<e0))if(jt)s(c),jt||p0(E0),postMessage({cmd:"loaded"});else{if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)v0();p0(k0),0<e0||(c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),Nt()},1)):Nt())}}if(c.UTF8ToString=t0,c.stringToUTF8=function(Nt,Lt,qt){return l0(Nt,et(),Lt,qt)},c.lengthBytesUTF8=_i,c.keepRuntimeAlive=w0,c.wasmMemory=vn,c.stackSave=Gr,c.stackRestore=Zr,c.stackAlloc=V0,c.ExitStatus=D0,c.PThread=jr,C0=function Nt(){S0||n0(),S0||(C0=Nt)},c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return n0(),g.ready});i.exports=d},932:(i,e,o)=>{var a,d=(a=(a=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(g){var h,et,ot;g=g||{},h||(h=g!==void 0?g:{}),h.ready=new Promise(function(Ht,cn){et=Ht,ot=cn});var it,$,c,s,_,b,st=Object.assign({},h),dt="./this.program",ct=(Ht,cn)=>{throw cn},pt=typeof window=="object",ft=typeof importScripts=="function",mt=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",bt="";mt?(bt=ft?o(908).dirname(bt)+"/":"//",b=()=>{_||(s=o(1384),_=o(908))},it=function(Ht,cn){return b(),Ht=_.normalize(Ht),s.readFileSync(Ht,cn?void 0:"utf8")},c=Ht=>((Ht=it(Ht,!0)).buffer||(Ht=new Uint8Array(Ht)),Ht),$=(Ht,cn,bn)=>{b(),Ht=_.normalize(Ht),s.readFile(Ht,function($n,Tn){$n?bn($n):cn(Tn.buffer)})},1<process.argv.length&&(dt=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(Ht){if(!(Ht instanceof E0))throw Ht}),process.on("unhandledRejection",function(Ht){throw Ht}),ct=(Ht,cn)=>{if(Tt||0<r0)throw process.exitCode=Ht,cn;cn instanceof E0||It("exiting due to exception: "+cn),process.exit(Ht)},h.inspect=function(){return"[Emscripten Module object]"}):(pt||ft)&&(ft?bt=self.location.href:typeof document<"u"&&document.currentScript&&(bt=document.currentScript.src),a&&(bt=a),bt=bt.indexOf("blob:")!==0?bt.substr(0,bt.replace(/[?#].*/,"").lastIndexOf("/")+1):"",it=Ht=>{var cn=new XMLHttpRequest;return cn.open("GET",Ht,!1),cn.send(null),cn.responseText},ft&&(c=Ht=>{var cn=new XMLHttpRequest;return cn.open("GET",Ht,!1),cn.responseType="arraybuffer",cn.send(null),new Uint8Array(cn.response)}),$=(Ht,cn,bn)=>{var $n=new XMLHttpRequest;$n.open("GET",Ht,!0),$n.responseType="arraybuffer",$n.onload=()=>{$n.status==200||$n.status==0&&$n.response?cn($n.response):bn()},$n.onerror=bn,$n.send(null)});var $t,Ct=h.print||console.log.bind(console),It=h.printErr||console.warn.bind(console);Object.assign(h,st),st=null,h.thisProgram&&(dt=h.thisProgram),h.quit&&(ct=h.quit),h.wasmBinary&&($t=h.wasmBinary);var Tt=h.noExitRuntime||!1;typeof WebAssembly!="object"&&Po("no native wasm support detected");var jt,dn,yn,mn,fn,un,Wt=!1,Jt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function _n(Ht,cn,bn){var $n=(cn>>>=0)+bn;for(bn=cn;Ht[bn]&&!(bn>=$n);)++bn;if(16<bn-cn&&Ht.buffer&&Jt)return Jt.decode(Ht.subarray(cn,bn));for($n="";cn<bn;){var Tn=Ht[cn++];if(128&Tn){var In=63&Ht[cn++];if((224&Tn)==192)$n+=String.fromCharCode((31&Tn)<<6|In);else{var wr=63&Ht[cn++];65536>(Tn=(240&Tn)==224?(15&Tn)<<12|In<<6|wr:(7&Tn)<<18|In<<12|wr<<6|63&Ht[cn++])?$n+=String.fromCharCode(Tn):(Tn-=65536,$n+=String.fromCharCode(55296|Tn>>10,56320|1023&Tn))}}else $n+=String.fromCharCode(Tn)}return $n}function vn(Ht,cn){return(Ht>>>=0)?_n(mn,Ht,cn):""}function Sn(Ht,cn,bn,$n){if(!(0<$n))return 0;var Tn=bn>>>=0;$n=bn+$n-1;for(var In=0;In<Ht.length;++In){var wr=Ht.charCodeAt(In);if(55296<=wr&&57343>=wr&&(wr=65536+((1023&wr)<<10)|1023&Ht.charCodeAt(++In)),127>=wr){if(bn>=$n)break;cn[bn++>>>0]=wr}else{if(2047>=wr){if(bn+1>=$n)break;cn[bn++>>>0]=192|wr>>6}else{if(65535>=wr){if(bn+2>=$n)break;cn[bn++>>>0]=224|wr>>12}else{if(bn+3>=$n)break;cn[bn++>>>0]=240|wr>>18,cn[bn++>>>0]=128|wr>>12&63}cn[bn++>>>0]=128|wr>>6&63}cn[bn++>>>0]=128|63&wr}}return cn[bn>>>0]=0,bn-Tn}function hn(Ht){for(var cn=0,bn=0;bn<Ht.length;++bn){var $n=Ht.charCodeAt(bn);127>=$n?cn++:2047>=$n?cn+=2:55296<=$n&&57343>=$n?(cn+=4,++bn):cn+=3}return cn}function rr(){var Ht=jt.buffer;dn=Ht,h.HEAP8=yn=new Int8Array(Ht),h.HEAP16=new Int16Array(Ht),h.HEAP32=fn=new Int32Array(Ht),h.HEAPU8=mn=new Uint8Array(Ht),h.HEAPU16=new Uint16Array(Ht),h.HEAPU32=un=new Uint32Array(Ht),h.HEAPF32=new Float32Array(Ht),h.HEAPF64=new Float64Array(Ht)}var vr,Ir=[],$r=[],Ur=[],Yr=[],r0=0;function b0(){var Ht=h.preRun.shift();Ir.unshift(Ht)}var t0,l0=0,_i=null;function Po(Ht){throw h.onAbort&&h.onAbort(Ht),It(Ht="Aborted("+Ht+")"),Wt=!0,Ht=new WebAssembly.RuntimeError(Ht+". Build with -sASSERTIONS for more info."),ot(Ht),Ht}function vm(){return t0.startsWith("data:application/octet-stream;base64,")}if(t0="ort-wasm.wasm",!vm()){var s0=t0;t0=h.locateFile?h.locateFile(s0,bt):bt+s0}function k0(){var Ht=t0;try{if(Ht==t0&&$t)return new Uint8Array($t);if(c)return c(Ht);throw"both async and sync fetching of the wasm failed"}catch(cn){Po(cn)}}function E0(Ht){this.name="ExitStatus",this.message="Program terminated with exit("+Ht+")",this.status=Ht}function O0(Ht){for(;0<Ht.length;)Ht.shift()(h)}var U0=[],w0=0,v0=0;function a0(Ht){this.Db=Ht,this.zb=Ht-24,this.Ub=function(cn){un[this.zb+4>>2>>>0]=cn},this.Eb=function(){return un[this.zb+4>>2>>>0]},this.Sb=function(cn){un[this.zb+8>>2>>>0]=cn},this.Wb=function(){return un[this.zb+8>>2>>>0]},this.Tb=function(){fn[this.zb>>2>>>0]=0},this.Ib=function(cn){yn[this.zb+12>>0>>>0]=cn?1:0},this.Pb=function(){return yn[this.zb+12>>0>>>0]!=0},this.Jb=function(cn){yn[this.zb+13>>0>>>0]=cn?1:0},this.Lb=function(){return yn[this.zb+13>>0>>>0]!=0},this.Rb=function(cn,bn){this.Fb(0),this.Ub(cn),this.Sb(bn),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){fn[this.zb>>2>>>0]+=1},this.Xb=function(){var cn=fn[this.zb>>2>>>0];return fn[this.zb>>2>>>0]=cn-1,cn===1},this.Fb=function(cn){un[this.zb+16>>2>>>0]=cn},this.Ob=function(){return un[this.zb+16>>2>>>0]},this.Qb=function(){if(ay(this.Eb()))return un[this.Db>>2>>>0];var cn=this.Ob();return cn!==0?cn:this.Db}}function e0(Ht){return Q0(new a0(Ht).zb)}var C0=[];function qr(Ht){var cn=C0[Ht];return cn||(Ht>=C0.length&&(C0.length=Ht+1),C0[Ht]=cn=vr.get(Ht)),cn}function L0(Ht){var cn=hn(Ht)+1,bn=bp(cn);return bn&&Sn(Ht,yn,bn,cn),bn}var $0={};function ry(){if(!D0){var Ht,cn={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:dt||"./this.program"};for(Ht in $0)$0[Ht]===void 0?delete cn[Ht]:cn[Ht]=$0[Ht];var bn=[];for(Ht in cn)bn.push(Ht+"="+cn[Ht]);D0=bn}return D0}var D0,P0=[null,[],[]];function G0(Ht,cn){var bn=P0[Ht];cn===0||cn===10?((Ht===1?Ct:It)(_n(bn,0)),bn.length=0):bn.push(cn)}var i0=0;function B0(Ht){return Ht%4==0&&(Ht%100!=0||Ht%400==0)}var jr=[31,29,31,30,31,30,31,31,30,31,30,31],p0=[31,28,31,30,31,30,31,31,30,31,30,31];function iy(Ht,cn,bn,$n){function Tn(An,_f,No){for(An=typeof An=="number"?An.toString():An||"";An.length<_f;)An=No[0]+An;return An}function In(An,_f){return Tn(An,_f,"0")}function wr(An,_f){function No(z0){return 0>z0?-1:0<z0?1:0}var A0;return(A0=No(An.getFullYear()-_f.getFullYear()))===0&&(A0=No(An.getMonth()-_f.getMonth()))===0&&(A0=No(An.getDate()-_f.getDate())),A0}function Dr(An){switch(An.getDay()){case 0:return new Date(An.getFullYear()-1,11,29);case 1:return An;case 2:return new Date(An.getFullYear(),0,3);case 3:return new Date(An.getFullYear(),0,2);case 4:return new Date(An.getFullYear(),0,1);case 5:return new Date(An.getFullYear()-1,11,31);case 6:return new Date(An.getFullYear()-1,11,30)}}function Sr(An){var _f=An.Bb;for(An=new Date(new Date(An.Cb+1900,0,1).getTime());0<_f;){var No=An.getMonth(),A0=(B0(An.getFullYear())?jr:p0)[No];if(!(_f>A0-An.getDate())){An.setDate(An.getDate()+_f);break}_f-=A0-An.getDate()+1,An.setDate(1),11>No?An.setMonth(No+1):(An.setMonth(0),An.setFullYear(An.getFullYear()+1))}return No=new Date(An.getFullYear()+1,0,4),_f=Dr(new Date(An.getFullYear(),0,4)),No=Dr(No),0>=wr(_f,An)?0>=wr(No,An)?An.getFullYear()+1:An.getFullYear():An.getFullYear()-1}var Xr=fn[$n+40>>2>>>0];for(var Ro in $n={$b:fn[$n>>2>>>0],Zb:fn[$n+4>>2>>>0],Gb:fn[$n+8>>2>>>0],Kb:fn[$n+12>>2>>>0],Hb:fn[$n+16>>2>>>0],Cb:fn[$n+20>>2>>>0],Ab:fn[$n+24>>2>>>0],Bb:fn[$n+28>>2>>>0],bc:fn[$n+32>>2>>>0],Yb:fn[$n+36>>2>>>0],ac:Xr?vn(Xr):""},bn=vn(bn),Xr={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})bn=bn.replace(new RegExp(Ro,"g"),Xr[Ro]);var _0="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),g0="January February March April May June July August September October November December".split(" ");for(Ro in Xr={"%a":function(An){return _0[An.Ab].substring(0,3)},"%A":function(An){return _0[An.Ab]},"%b":function(An){return g0[An.Hb].substring(0,3)},"%B":function(An){return g0[An.Hb]},"%C":function(An){return In((An.Cb+1900)/100|0,2)},"%d":function(An){return In(An.Kb,2)},"%e":function(An){return Tn(An.Kb,2," ")},"%g":function(An){return Sr(An).toString().substring(2)},"%G":function(An){return Sr(An)},"%H":function(An){return In(An.Gb,2)},"%I":function(An){return(An=An.Gb)==0?An=12:12<An&&(An-=12),In(An,2)},"%j":function(An){for(var _f=0,No=0;No<=An.Hb-1;_f+=(B0(An.Cb+1900)?jr:p0)[No++]);return In(An.Kb+_f,3)},"%m":function(An){return In(An.Hb+1,2)},"%M":function(An){return In(An.Zb,2)},"%n":function(){return`
`},"%p":function(An){return 0<=An.Gb&&12>An.Gb?"AM":"PM"},"%S":function(An){return In(An.$b,2)},"%t":function(){return"	"},"%u":function(An){return An.Ab||7},"%U":function(An){return In(Math.floor((An.Bb+7-An.Ab)/7),2)},"%V":function(An){var _f=Math.floor((An.Bb+7-(An.Ab+6)%7)/7);if(2>=(An.Ab+371-An.Bb-2)%7&&_f++,_f)_f==53&&((No=(An.Ab+371-An.Bb)%7)==4||No==3&&B0(An.Cb)||(_f=1));else{_f=52;var No=(An.Ab+7-An.Bb-1)%7;(No==4||No==5&&B0(An.Cb%400-1))&&_f++}return In(_f,2)},"%w":function(An){return An.Ab},"%W":function(An){return In(Math.floor((An.Bb+7-(An.Ab+6)%7)/7),2)},"%y":function(An){return(An.Cb+1900).toString().substring(2)},"%Y":function(An){return An.Cb+1900},"%z":function(An){var _f=0<=(An=An.Yb);return An=Math.abs(An)/60,(_f?"+":"-")+("0000"+(An/60*100+An%60)).slice(-4)},"%Z":function(An){return An.ac},"%%":function(){return"%"}},bn=bn.replace(/%%/g,"\0\0"),Xr)bn.includes(Ro)&&(bn=bn.replace(new RegExp(Ro,"g"),Xr[Ro]($n)));return Ro=function(An){var _f=Array(hn(An)+1);return Sn(An,_f,0,_f.length),_f}(bn=bn.replace(/\0\0/g,"%")),Ro.length>cn?0:(yn.set(Ro,Ht>>>0),Ro.length-1)}var eo={a:function(Ht){return bp(Ht+24)+24},m:function(Ht){return(Ht=new a0(Ht)).Pb()||(Ht.Ib(!0),w0--),Ht.Jb(!1),U0.push(Ht),Ht.Nb(),Ht.Qb()},ia:function(Ht){throw It("Unexpected exception thrown, this is not properly supported - aborting"),Wt=!0,Ht},w:function(){_r(0);var Ht=U0.pop();if(Ht.Xb()&&!Ht.Lb()){var cn=Ht.Wb();cn&&qr(cn)(Ht.Db),e0(Ht.Db)}v0=0},d:function(){var Ht=v0;if(!Ht)return i0=0;var cn=new a0(Ht);cn.Fb(Ht);var bn=cn.Eb();if(!bn)return i0=0,Ht;for(var $n=Array.prototype.slice.call(arguments),Tn=0;Tn<$n.length;Tn++){var In=$n[Tn];if(In===0||In===bn)break;if(q0(In,bn,cn.zb+16))return i0=In,Ht}return i0=bn,Ht},k:function(){var Ht=v0;if(!Ht)return i0=0;var cn=new a0(Ht);cn.Fb(Ht);var bn=cn.Eb();if(!bn)return i0=0,Ht;for(var $n=Array.prototype.slice.call(arguments),Tn=0;Tn<$n.length;Tn++){var In=$n[Tn];if(In===0||In===bn)break;if(q0(In,bn,cn.zb+16))return i0=In,Ht}return i0=bn,Ht},g:function(){var Ht=v0;if(!Ht)return i0=0;var cn=new a0(Ht);cn.Fb(Ht);var bn=cn.Eb();if(!bn)return i0=0,Ht;for(var $n=Array.prototype.slice.call(arguments),Tn=0;Tn<$n.length;Tn++){var In=$n[Tn];if(In===0||In===bn)break;if(q0(In,bn,cn.zb+16))return i0=In,Ht}return i0=bn,Ht},s:e0,L:function(){var Ht=U0.pop();Ht||Po("no exception to throw");var cn=Ht.Db;throw Ht.Lb()||(U0.push(Ht),Ht.Jb(!0),Ht.Ib(!1),w0++),v0=cn,cn},b:function(Ht,cn,bn){throw new a0(Ht).Rb(cn,bn),v0=Ht,w0++,Ht},la:function(){return w0},i:function(Ht){throw v0||(v0=Ht),Ht},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){Po("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){Po("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(Ht,cn){Ht=new Date(1e3*(un[Ht>>>2]+4294967296*fn[Ht+4>>>2])),fn[cn>>2>>>0]=Ht.getUTCSeconds(),fn[cn+4>>2>>>0]=Ht.getUTCMinutes(),fn[cn+8>>2>>>0]=Ht.getUTCHours(),fn[cn+12>>2>>>0]=Ht.getUTCDate(),fn[cn+16>>2>>>0]=Ht.getUTCMonth(),fn[cn+20>>2>>>0]=Ht.getUTCFullYear()-1900,fn[cn+24>>2>>>0]=Ht.getUTCDay(),fn[cn+28>>2>>>0]=(Ht.getTime()-Date.UTC(Ht.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(Ht,cn){Ht=new Date(1e3*(un[Ht>>>2]+4294967296*fn[Ht+4>>>2])),fn[cn>>2>>>0]=Ht.getSeconds(),fn[cn+4>>2>>>0]=Ht.getMinutes(),fn[cn+8>>2>>>0]=Ht.getHours(),fn[cn+12>>2>>>0]=Ht.getDate(),fn[cn+16>>2>>>0]=Ht.getMonth(),fn[cn+20>>2>>>0]=Ht.getFullYear()-1900,fn[cn+24>>2>>>0]=Ht.getDay();var bn=new Date(Ht.getFullYear(),0,1);fn[cn+28>>2>>>0]=(Ht.getTime()-bn.getTime())/864e5|0,fn[cn+36>>2>>>0]=-60*Ht.getTimezoneOffset();var $n=new Date(Ht.getFullYear(),6,1).getTimezoneOffset();bn=bn.getTimezoneOffset(),fn[cn+32>>2>>>0]=0|($n!=bn&&Ht.getTimezoneOffset()==Math.min(bn,$n))},Fa:function(Ht){var cn=new Date(fn[Ht+20>>2>>>0]+1900,fn[Ht+16>>2>>>0],fn[Ht+12>>2>>>0],fn[Ht+8>>2>>>0],fn[Ht+4>>2>>>0],fn[Ht>>2>>>0],0),bn=fn[Ht+32>>2>>>0],$n=cn.getTimezoneOffset(),Tn=new Date(cn.getFullYear(),0,1),In=new Date(cn.getFullYear(),6,1).getTimezoneOffset(),wr=Tn.getTimezoneOffset(),Dr=Math.min(wr,In);return 0>bn?fn[Ht+32>>2>>>0]=+(In!=wr&&Dr==$n):0<bn!=(Dr==$n)&&(In=Math.max(wr,In),cn.setTime(cn.getTime()+6e4*((0<bn?Dr:In)-$n))),fn[Ht+24>>2>>>0]=cn.getDay(),fn[Ht+28>>2>>>0]=(cn.getTime()-Tn.getTime())/864e5|0,fn[Ht>>2>>>0]=cn.getSeconds(),fn[Ht+4>>2>>>0]=cn.getMinutes(),fn[Ht+8>>2>>>0]=cn.getHours(),fn[Ht+12>>2>>>0]=cn.getDate(),fn[Ht+16>>2>>>0]=cn.getMonth(),cn.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function Ht(cn,bn,$n){Ht.Vb||(Ht.Vb=!0,function(Tn,In,wr){function Dr(g0){return(g0=g0.toTimeString().match(/\(([A-Za-z ]+)\)$/))?g0[1]:"GMT"}var Sr=new Date().getFullYear(),Xr=new Date(Sr,0,1),Ro=new Date(Sr,6,1);Sr=Xr.getTimezoneOffset();var _0=Ro.getTimezoneOffset();fn[Tn>>2>>>0]=60*Math.max(Sr,_0),fn[In>>2>>>0]=+(Sr!=_0),Tn=Dr(Xr),In=Dr(Ro),Tn=L0(Tn),In=L0(In),_0<Sr?(un[wr>>2>>>0]=Tn,un[wr+4>>2>>>0]=In):(un[wr>>2>>>0]=In,un[wr+4>>2>>>0]=Tn)}(cn,bn,$n))},B:function(){Po("")},ma:function(){return 4294901760},I:mt?()=>{var Ht=process.hrtime();return 1e3*Ht[0]+Ht[1]/1e6}:()=>performance.now(),xa:function(Ht,cn,bn){mn.copyWithin(Ht>>>0,cn>>>0,cn+bn>>>0)},G:function(Ht){var cn=mn.length;if(4294901760<(Ht>>>=0))return!1;for(var bn=1;4>=bn;bn*=2){var $n=cn*(1+.2/bn);$n=Math.min($n,Ht+100663296);var Tn=Math;$n=Math.max(Ht,$n),Tn=Tn.min.call(Tn,4294901760,$n+(65536-$n%65536)%65536);e:{try{jt.grow(Tn-dn.byteLength+65535>>>16),rr();var In=1;break e}catch{}In=void 0}if(In)return!0}return!1},va:function(Ht,cn){var bn=0;return ry().forEach(function($n,Tn){var In=cn+bn;for(Tn=un[Ht+4*Tn>>2>>>0]=In,In=0;In<$n.length;++In)yn[Tn++>>0>>>0]=$n.charCodeAt(In);yn[Tn>>0>>>0]=0,bn+=$n.length+1}),0},wa:function(Ht,cn){var bn=ry();un[Ht>>2>>>0]=bn.length;var $n=0;return bn.forEach(function(Tn){$n+=Tn.length+1}),un[cn>>2>>>0]=$n,0},ba:function(Ht){Tt||0<r0||(H0(),O0(Ur),oy(0),P0[1].length&&G0(1,10),P0[2].length&&G0(2,10)),Tt||0<r0||(h.onExit&&h.onExit(Ht),Wt=!0),ct(Ht,new E0(Ht))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(Ht,cn,bn,$n){for(var Tn=0,In=0;In<bn;In++){var wr=un[cn>>2>>>0],Dr=un[cn+4>>2>>>0];cn+=8;for(var Sr=0;Sr<Dr;Sr++)G0(Ht,mn[wr+Sr>>>0]);Tn+=Dr}return un[$n>>2>>>0]=Tn,0},c:function(){return i0},ja:function Ht(cn,bn){Ht.Mb||(Ht.Mb=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var Tn=new Uint8Array(1);return()=>(crypto.getRandomValues(Tn),Tn[0])}if(mt)try{var In=o(Object(function(){var wr=new Error("Cannot find module 'crypto'");throw wr.code="MODULE_NOT_FOUND",wr}()));return()=>In.randomBytes(1)[0]}catch{}return()=>Po("randomDevice")}());for(var $n=0;$n<bn;$n++)yn[cn+$n>>0>>>0]=Ht.Mb();return 0},ea:function(Ht,cn,bn){var $n=Vr();try{return qr(Ht)(cn,bn)}catch(Tn){if(Kr($n),Tn!==Tn+0)throw Tn;_r(1,0)}},fa:function(Ht,cn,bn){var $n=Vr();try{return qr(Ht)(cn,bn)}catch(Tn){if(Kr($n),Tn!==Tn+0)throw Tn;_r(1,0)}},J:function(Ht){var cn=Vr();try{return qr(Ht)()}catch(bn){if(Kr(cn),bn!==bn+0)throw bn;_r(1,0)}},e:function(Ht,cn){var bn=Vr();try{return qr(Ht)(cn)}catch($n){if(Kr(bn),$n!==$n+0)throw $n;_r(1,0)}},N:function(Ht,cn,bn){var $n=Vr();try{return qr(Ht)(cn,bn)}catch(Tn){if(Kr($n),Tn!==Tn+0)throw Tn;_r(1,0)}},O:function(Ht,cn,bn){var $n=Vr();try{return qr(Ht)(cn,bn)}catch(Tn){if(Kr($n),Tn!==Tn+0)throw Tn;_r(1,0)}},j:function(Ht,cn,bn){var $n=Vr();try{return qr(Ht)(cn,bn)}catch(Tn){if(Kr($n),Tn!==Tn+0)throw Tn;_r(1,0)}},o:function(Ht,cn,bn,$n){var Tn=Vr();try{return qr(Ht)(cn,bn,$n)}catch(In){if(Kr(Tn),In!==In+0)throw In;_r(1,0)}},p:function(Ht,cn,bn,$n,Tn){var In=Vr();try{return qr(Ht)(cn,bn,$n,Tn)}catch(wr){if(Kr(In),wr!==wr+0)throw wr;_r(1,0)}},M:function(Ht,cn,bn,$n,Tn,In){var wr=Vr();try{return qr(Ht)(cn,bn,$n,Tn,In)}catch(Dr){if(Kr(wr),Dr!==Dr+0)throw Dr;_r(1,0)}},r:function(Ht,cn,bn,$n,Tn,In){var wr=Vr();try{return qr(Ht)(cn,bn,$n,Tn,In)}catch(Dr){if(Kr(wr),Dr!==Dr+0)throw Dr;_r(1,0)}},v:function(Ht,cn,bn,$n,Tn,In,wr){var Dr=Vr();try{return qr(Ht)(cn,bn,$n,Tn,In,wr)}catch(Sr){if(Kr(Dr),Sr!==Sr+0)throw Sr;_r(1,0)}},K:function(Ht,cn,bn,$n,Tn,In,wr,Dr){var Sr=Vr();try{return qr(Ht)(cn,bn,$n,Tn,In,wr,Dr)}catch(Xr){if(Kr(Sr),Xr!==Xr+0)throw Xr;_r(1,0)}},D:function(Ht,cn,bn,$n,Tn,In,wr,Dr,Sr,Xr,Ro,_0){var g0=Vr();try{return qr(Ht)(cn,bn,$n,Tn,In,wr,Dr,Sr,Xr,Ro,_0)}catch(An){if(Kr(g0),An!==An+0)throw An;_r(1,0)}},X:function(Ht,cn,bn,$n,Tn,In,wr,Dr){var Sr=Vr();try{return M0(Ht,cn,bn,$n,Tn,In,wr,Dr)}catch(Xr){if(Kr(Sr),Xr!==Xr+0)throw Xr;_r(1,0)}},V:function(Ht,cn,bn,$n,Tn,In,wr){var Dr=Vr();try{return Z0(Ht,cn,bn,$n,Tn,In,wr)}catch(Sr){if(Kr(Dr),Sr!==Sr+0)throw Sr;_r(1,0)}},U:function(Ht,cn,bn,$n,Tn){var In=Vr();try{return ey(Ht,cn,bn,$n,Tn)}catch(wr){if(Kr(In),wr!==wr+0)throw wr;_r(1,0)}},Z:function(Ht,cn,bn,$n){var Tn=Vr();try{return T0(Ht,cn,bn,$n)}catch(In){if(Kr(Tn),In!==In+0)throw In;_r(1,0)}},W:function(Ht){var cn=Vr();try{return K0(Ht)}catch(bn){if(Kr(cn),bn!==bn+0)throw bn;_r(1,0)}},Y:function(Ht,cn){var bn=Vr();try{return J0(Ht,cn)}catch($n){if(Kr(bn),$n!==$n+0)throw $n;_r(1,0)}},T:function(Ht,cn,bn){var $n=Vr();try{return j0(Ht,cn,bn)}catch(Tn){if(Kr($n),Tn!==Tn+0)throw Tn;_r(1,0)}},f:function(Ht){var cn=Vr();try{qr(Ht)()}catch(bn){if(Kr(cn),bn!==bn+0)throw bn;_r(1,0)}},q:function(Ht,cn){var bn=Vr();try{qr(Ht)(cn)}catch($n){if(Kr(bn),$n!==$n+0)throw $n;_r(1,0)}},h:function(Ht,cn,bn){var $n=Vr();try{qr(Ht)(cn,bn)}catch(Tn){if(Kr($n),Tn!==Tn+0)throw Tn;_r(1,0)}},da:function(Ht,cn,bn,$n){var Tn=Vr();try{qr(Ht)(cn,bn,$n)}catch(In){if(Kr(Tn),In!==In+0)throw In;_r(1,0)}},l:function(Ht,cn,bn,$n){var Tn=Vr();try{qr(Ht)(cn,bn,$n)}catch(In){if(Kr(Tn),In!==In+0)throw In;_r(1,0)}},t:function(Ht,cn,bn,$n,Tn){var In=Vr();try{qr(Ht)(cn,bn,$n,Tn)}catch(wr){if(Kr(In),wr!==wr+0)throw wr;_r(1,0)}},u:function(Ht,cn,bn,$n,Tn,In){var wr=Vr();try{qr(Ht)(cn,bn,$n,Tn,In)}catch(Dr){if(Kr(wr),Dr!==Dr+0)throw Dr;_r(1,0)}},x:function(Ht,cn,bn,$n,Tn,In,wr){var Dr=Vr();try{qr(Ht)(cn,bn,$n,Tn,In,wr)}catch(Sr){if(Kr(Dr),Sr!==Sr+0)throw Sr;_r(1,0)}},z:function(Ht,cn,bn,$n,Tn,In,wr,Dr){var Sr=Vr();try{qr(Ht)(cn,bn,$n,Tn,In,wr,Dr)}catch(Xr){if(Kr(Sr),Xr!==Xr+0)throw Xr;_r(1,0)}},ga:function(Ht,cn,bn,$n,Tn,In,wr,Dr,Sr){var Xr=Vr();try{qr(Ht)(cn,bn,$n,Tn,In,wr,Dr,Sr)}catch(Ro){if(Kr(Xr),Ro!==Ro+0)throw Ro;_r(1,0)}},A:function(Ht,cn,bn,$n,Tn,In,wr,Dr,Sr,Xr,Ro){var _0=Vr();try{qr(Ht)(cn,bn,$n,Tn,In,wr,Dr,Sr,Xr,Ro)}catch(g0){if(Kr(_0),g0!==g0+0)throw g0;_r(1,0)}},C:function(Ht,cn,bn,$n,Tn,In,wr,Dr,Sr,Xr,Ro,_0,g0,An,_f,No){var A0=Vr();try{qr(Ht)(cn,bn,$n,Tn,In,wr,Dr,Sr,Xr,Ro,_0,g0,An,_f,No)}catch(z0){if(Kr(A0),z0!==z0+0)throw z0;_r(1,0)}},aa:function(Ht,cn,bn,$n,Tn,In,wr,Dr){var Sr=Vr();try{f0(Ht,cn,bn,$n,Tn,In,wr,Dr)}catch(Xr){if(Kr(Sr),Xr!==Xr+0)throw Xr;_r(1,0)}},_:function(Ht,cn,bn,$n,Tn,In,wr,Dr,Sr,Xr,Ro,_0){var g0=Vr();try{I0(Ht,cn,bn,$n,Tn,In,wr,Dr,Sr,Xr,Ro,_0)}catch(An){if(Kr(g0),An!==An+0)throw An;_r(1,0)}},$:function(Ht,cn,bn,$n,Tn,In){var wr=Vr();try{sy(Ht,cn,bn,$n,Tn,In)}catch(Dr){if(Kr(wr),Dr!==Dr+0)throw Dr;_r(1,0)}},n:function(Ht){return Ht},F:function(Ht){i0=Ht},ha:iy,y:function(Ht,cn,bn,$n){return iy(Ht,cn,bn,$n)}};(function(){function Ht(Tn){h.asm=Tn.exports,jt=h.asm.Ka,rr(),vr=h.asm.ib,$r.unshift(h.asm.La),l0--,h.monitorRunDependencies&&h.monitorRunDependencies(l0),l0==0&&_i&&(Tn=_i,_i=null,Tn())}function cn(Tn){Ht(Tn.instance)}function bn(Tn){return function(){if(!$t&&(pt||ft)){if(typeof fetch=="function"&&!t0.startsWith("file://"))return fetch(t0,{credentials:"same-origin"}).then(function(In){if(!In.ok)throw"failed to load wasm binary file at '"+t0+"'";return In.arrayBuffer()}).catch(function(){return k0()});if($)return new Promise(function(In,wr){$(t0,function(Dr){In(new Uint8Array(Dr))},wr)})}return Promise.resolve().then(function(){return k0()})}().then(function(In){return WebAssembly.instantiate(In,$n)}).then(function(In){return In}).then(Tn,function(In){It("failed to asynchronously prepare wasm: "+In),Po(In)})}var $n={a:eo};if(l0++,h.monitorRunDependencies&&h.monitorRunDependencies(l0),h.instantiateWasm)try{return h.instantiateWasm($n,Ht)}catch(Tn){return It("Module.instantiateWasm callback failed with error: "+Tn),!1}($t||typeof WebAssembly.instantiateStreaming!="function"||vm()||t0.startsWith("file://")||mt||typeof fetch!="function"?bn(cn):fetch(t0,{credentials:"same-origin"}).then(function(Tn){return WebAssembly.instantiateStreaming(Tn,$n).then(cn,function(In){return It("wasm streaming compile failed: "+In),It("falling back to ArrayBuffer instantiation"),bn(cn)})})).catch(ot)})(),h.___wasm_call_ctors=function(){return(h.___wasm_call_ctors=h.asm.La).apply(null,arguments)},h._OrtInit=function(){return(h._OrtInit=h.asm.Ma).apply(null,arguments)},h._OrtCreateSessionOptions=function(){return(h._OrtCreateSessionOptions=h.asm.Na).apply(null,arguments)},h._OrtAppendExecutionProvider=function(){return(h._OrtAppendExecutionProvider=h.asm.Oa).apply(null,arguments)},h._OrtAddSessionConfigEntry=function(){return(h._OrtAddSessionConfigEntry=h.asm.Pa).apply(null,arguments)},h._OrtReleaseSessionOptions=function(){return(h._OrtReleaseSessionOptions=h.asm.Qa).apply(null,arguments)},h._OrtCreateSession=function(){return(h._OrtCreateSession=h.asm.Ra).apply(null,arguments)},h._OrtReleaseSession=function(){return(h._OrtReleaseSession=h.asm.Sa).apply(null,arguments)},h._OrtGetInputCount=function(){return(h._OrtGetInputCount=h.asm.Ta).apply(null,arguments)},h._OrtGetOutputCount=function(){return(h._OrtGetOutputCount=h.asm.Ua).apply(null,arguments)},h._OrtGetInputName=function(){return(h._OrtGetInputName=h.asm.Va).apply(null,arguments)},h._OrtGetOutputName=function(){return(h._OrtGetOutputName=h.asm.Wa).apply(null,arguments)},h._OrtFree=function(){return(h._OrtFree=h.asm.Xa).apply(null,arguments)},h._OrtCreateTensor=function(){return(h._OrtCreateTensor=h.asm.Ya).apply(null,arguments)},h._OrtGetTensorData=function(){return(h._OrtGetTensorData=h.asm.Za).apply(null,arguments)},h._OrtReleaseTensor=function(){return(h._OrtReleaseTensor=h.asm._a).apply(null,arguments)},h._OrtCreateRunOptions=function(){return(h._OrtCreateRunOptions=h.asm.$a).apply(null,arguments)},h._OrtAddRunConfigEntry=function(){return(h._OrtAddRunConfigEntry=h.asm.ab).apply(null,arguments)},h._OrtReleaseRunOptions=function(){return(h._OrtReleaseRunOptions=h.asm.bb).apply(null,arguments)},h._OrtRun=function(){return(h._OrtRun=h.asm.cb).apply(null,arguments)},h._OrtEndProfiling=function(){return(h._OrtEndProfiling=h.asm.db).apply(null,arguments)};var y0,bp=h._malloc=function(){return(bp=h._malloc=h.asm.eb).apply(null,arguments)},Q0=h._free=function(){return(Q0=h._free=h.asm.fb).apply(null,arguments)},oy=h._fflush=function(){return(oy=h._fflush=h.asm.gb).apply(null,arguments)},H0=h.___funcs_on_exit=function(){return(H0=h.___funcs_on_exit=h.asm.hb).apply(null,arguments)},_r=h._setThrew=function(){return(_r=h._setThrew=h.asm.jb).apply(null,arguments)},Vr=h.stackSave=function(){return(Vr=h.stackSave=h.asm.kb).apply(null,arguments)},Kr=h.stackRestore=function(){return(Kr=h.stackRestore=h.asm.lb).apply(null,arguments)},hy=h.stackAlloc=function(){return(hy=h.stackAlloc=h.asm.mb).apply(null,arguments)},q0=h.___cxa_can_catch=function(){return(q0=h.___cxa_can_catch=h.asm.nb).apply(null,arguments)},ay=h.___cxa_is_pointer_type=function(){return(ay=h.___cxa_is_pointer_type=h.asm.ob).apply(null,arguments)},K0=h.dynCall_j=function(){return(K0=h.dynCall_j=h.asm.pb).apply(null,arguments)},Z0=h.dynCall_iiiiij=function(){return(Z0=h.dynCall_iiiiij=h.asm.qb).apply(null,arguments)},j0=h.dynCall_jii=function(){return(j0=h.dynCall_jii=h.asm.rb).apply(null,arguments)},f0=h.dynCall_viiiiij=function(){return(f0=h.dynCall_viiiiij=h.asm.sb).apply(null,arguments)},sy=h.dynCall_vjji=function(){return(sy=h.dynCall_vjji=h.asm.tb).apply(null,arguments)},I0=h.dynCall_viiijjjii=function(){return(I0=h.dynCall_viiijjjii=h.asm.ub).apply(null,arguments)},T0=h.dynCall_iij=function(){return(T0=h.dynCall_iij=h.asm.vb).apply(null,arguments)},J0=h.dynCall_ji=function(){return(J0=h.dynCall_ji=h.asm.wb).apply(null,arguments)},M0=h.dynCall_iiiiiij=function(){return(M0=h.dynCall_iiiiiij=h.asm.xb).apply(null,arguments)},ey=h.dynCall_iiij=function(){return(ey=h.dynCall_iiij=h.asm.yb).apply(null,arguments)};function ty(){function Ht(){if(!y0&&(y0=!0,h.calledRun=!0,!Wt)){if(O0($r),et(h),h.onRuntimeInitialized&&h.onRuntimeInitialized(),h.postRun)for(typeof h.postRun=="function"&&(h.postRun=[h.postRun]);h.postRun.length;){var cn=h.postRun.shift();Yr.unshift(cn)}O0(Yr)}}if(!(0<l0)){if(h.preRun)for(typeof h.preRun=="function"&&(h.preRun=[h.preRun]);h.preRun.length;)b0();O0(Ir),0<l0||(h.setStatus?(h.setStatus("Running..."),setTimeout(function(){setTimeout(function(){h.setStatus("")},1),Ht()},1)):Ht())}}if(h.UTF8ToString=vn,h.stringToUTF8=function(Ht,cn,bn){return Sn(Ht,mn,cn,bn)},h.lengthBytesUTF8=hn,h.stackSave=Vr,h.stackRestore=Kr,h.stackAlloc=hy,_i=function Ht(){y0||ty(),y0||(_i=Ht)},h.preInit)for(typeof h.preInit=="function"&&(h.preInit=[h.preInit]);0<h.preInit.length;)h.preInit.pop()();return ty(),g.ready});i.exports=d},4537:i=>{i.exports=function(e,o){for(var a=new Array(arguments.length-1),d=0,g=2,h=!0;g<arguments.length;)a[d++]=arguments[g++];return new Promise(function(et,ot){a[d]=function(it){if(h)if(h=!1,it)ot(it);else{for(var $=new Array(arguments.length-1),c=0;c<$.length;)$[c++]=arguments[c];et.apply(null,$)}};try{e.apply(o||null,a)}catch(it){h&&(h=!1,ot(it))}})}},7419:(i,e)=>{var o=e;o.length=function(et){var ot=et.length;if(!ot)return 0;for(var it=0;--ot%4>1&&et.charAt(ot)==="=";)++it;return Math.ceil(3*et.length)/4-it};for(var a=new Array(64),d=new Array(123),g=0;g<64;)d[a[g]=g<26?g+65:g<52?g+71:g<62?g-4:g-59|43]=g++;o.encode=function(et,ot,it){for(var $,c=null,s=[],_=0,b=0;ot<it;){var st=et[ot++];switch(b){case 0:s[_++]=a[st>>2],$=(3&st)<<4,b=1;break;case 1:s[_++]=a[$|st>>4],$=(15&st)<<2,b=2;break;case 2:s[_++]=a[$|st>>6],s[_++]=a[63&st],b=0}_>8191&&((c||(c=[])).push(String.fromCharCode.apply(String,s)),_=0)}return b&&(s[_++]=a[$],s[_++]=61,b===1&&(s[_++]=61)),c?(_&&c.push(String.fromCharCode.apply(String,s.slice(0,_))),c.join("")):String.fromCharCode.apply(String,s.slice(0,_))};var h="invalid encoding";o.decode=function(et,ot,it){for(var $,c=it,s=0,_=0;_<et.length;){var b=et.charCodeAt(_++);if(b===61&&s>1)break;if((b=d[b])===void 0)throw Error(h);switch(s){case 0:$=b,s=1;break;case 1:ot[it++]=$<<2|(48&b)>>4,$=b,s=2;break;case 2:ot[it++]=(15&$)<<4|(60&b)>>2,$=b,s=3;break;case 3:ot[it++]=(3&$)<<6|b,s=0}}if(s===1)throw Error(h);return it-c},o.test=function(et){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(et)}},9211:i=>{function e(){this._listeners={}}i.exports=e,e.prototype.on=function(o,a,d){return(this._listeners[o]||(this._listeners[o]=[])).push({fn:a,ctx:d||this}),this},e.prototype.off=function(o,a){if(o===void 0)this._listeners={};else if(a===void 0)this._listeners[o]=[];else for(var d=this._listeners[o],g=0;g<d.length;)d[g].fn===a?d.splice(g,1):++g;return this},e.prototype.emit=function(o){var a=this._listeners[o];if(a){for(var d=[],g=1;g<arguments.length;)d.push(arguments[g++]);for(g=0;g<a.length;)a[g].fn.apply(a[g++].ctx,d)}return this}},945:i=>{function e(h){return typeof Float32Array<"u"?function(){var et=new Float32Array([-0]),ot=new Uint8Array(et.buffer),it=ot[3]===128;function $(b,st,dt){et[0]=b,st[dt]=ot[0],st[dt+1]=ot[1],st[dt+2]=ot[2],st[dt+3]=ot[3]}function c(b,st,dt){et[0]=b,st[dt]=ot[3],st[dt+1]=ot[2],st[dt+2]=ot[1],st[dt+3]=ot[0]}function s(b,st){return ot[0]=b[st],ot[1]=b[st+1],ot[2]=b[st+2],ot[3]=b[st+3],et[0]}function _(b,st){return ot[3]=b[st],ot[2]=b[st+1],ot[1]=b[st+2],ot[0]=b[st+3],et[0]}h.writeFloatLE=it?$:c,h.writeFloatBE=it?c:$,h.readFloatLE=it?s:_,h.readFloatBE=it?_:s}():function(){function et(it,$,c,s){var _=$<0?1:0;if(_&&($=-$),$===0)it(1/$>0?0:2147483648,c,s);else if(isNaN($))it(2143289344,c,s);else if($>34028234663852886e22)it((_<<31|2139095040)>>>0,c,s);else if($<11754943508222875e-54)it((_<<31|Math.round($/1401298464324817e-60))>>>0,c,s);else{var b=Math.floor(Math.log($)/Math.LN2);it((_<<31|b+127<<23|8388607&Math.round($*Math.pow(2,-b)*8388608))>>>0,c,s)}}function ot(it,$,c){var s=it($,c),_=2*(s>>31)+1,b=s>>>23&255,st=8388607&s;return b===255?st?NaN:_*(1/0):b===0?1401298464324817e-60*_*st:_*Math.pow(2,b-150)*(st+8388608)}h.writeFloatLE=et.bind(null,o),h.writeFloatBE=et.bind(null,a),h.readFloatLE=ot.bind(null,d),h.readFloatBE=ot.bind(null,g)}(),typeof Float64Array<"u"?function(){var et=new Float64Array([-0]),ot=new Uint8Array(et.buffer),it=ot[7]===128;function $(b,st,dt){et[0]=b,st[dt]=ot[0],st[dt+1]=ot[1],st[dt+2]=ot[2],st[dt+3]=ot[3],st[dt+4]=ot[4],st[dt+5]=ot[5],st[dt+6]=ot[6],st[dt+7]=ot[7]}function c(b,st,dt){et[0]=b,st[dt]=ot[7],st[dt+1]=ot[6],st[dt+2]=ot[5],st[dt+3]=ot[4],st[dt+4]=ot[3],st[dt+5]=ot[2],st[dt+6]=ot[1],st[dt+7]=ot[0]}function s(b,st){return ot[0]=b[st],ot[1]=b[st+1],ot[2]=b[st+2],ot[3]=b[st+3],ot[4]=b[st+4],ot[5]=b[st+5],ot[6]=b[st+6],ot[7]=b[st+7],et[0]}function _(b,st){return ot[7]=b[st],ot[6]=b[st+1],ot[5]=b[st+2],ot[4]=b[st+3],ot[3]=b[st+4],ot[2]=b[st+5],ot[1]=b[st+6],ot[0]=b[st+7],et[0]}h.writeDoubleLE=it?$:c,h.writeDoubleBE=it?c:$,h.readDoubleLE=it?s:_,h.readDoubleBE=it?_:s}():function(){function et(it,$,c,s,_,b){var st=s<0?1:0;if(st&&(s=-s),s===0)it(0,_,b+$),it(1/s>0?0:2147483648,_,b+c);else if(isNaN(s))it(0,_,b+$),it(2146959360,_,b+c);else if(s>17976931348623157e292)it(0,_,b+$),it((st<<31|2146435072)>>>0,_,b+c);else{var dt;if(s<22250738585072014e-324)it((dt=s/5e-324)>>>0,_,b+$),it((st<<31|dt/4294967296)>>>0,_,b+c);else{var ct=Math.floor(Math.log(s)/Math.LN2);ct===1024&&(ct=1023),it(4503599627370496*(dt=s*Math.pow(2,-ct))>>>0,_,b+$),it((st<<31|ct+1023<<20|1048576*dt&1048575)>>>0,_,b+c)}}}function ot(it,$,c,s,_){var b=it(s,_+$),st=it(s,_+c),dt=2*(st>>31)+1,ct=st>>>20&2047,pt=4294967296*(1048575&st)+b;return ct===2047?pt?NaN:dt*(1/0):ct===0?5e-324*dt*pt:dt*Math.pow(2,ct-1075)*(pt+4503599627370496)}h.writeDoubleLE=et.bind(null,o,0,4),h.writeDoubleBE=et.bind(null,a,4,0),h.readDoubleLE=ot.bind(null,d,0,4),h.readDoubleBE=ot.bind(null,g,4,0)}(),h}function o(h,et,ot){et[ot]=255&h,et[ot+1]=h>>>8&255,et[ot+2]=h>>>16&255,et[ot+3]=h>>>24}function a(h,et,ot){et[ot]=h>>>24,et[ot+1]=h>>>16&255,et[ot+2]=h>>>8&255,et[ot+3]=255&h}function d(h,et){return(h[et]|h[et+1]<<8|h[et+2]<<16|h[et+3]<<24)>>>0}function g(h,et){return(h[et]<<24|h[et+1]<<16|h[et+2]<<8|h[et+3])>>>0}i.exports=e(e)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(i){}return null}module.exports=inquire},6662:i=>{i.exports=function(e,o,a){var d=a||8192,g=d>>>1,h=null,et=d;return function(ot){if(ot<1||ot>g)return e(ot);et+ot>d&&(h=e(d),et=0);var it=o.call(h,et,et+=ot);return 7&et&&(et=1+(7|et)),it}}},4997:(i,e)=>{var o=e;o.length=function(a){for(var d=0,g=0,h=0;h<a.length;++h)(g=a.charCodeAt(h))<128?d+=1:g<2048?d+=2:(64512&g)==55296&&(64512&a.charCodeAt(h+1))==56320?(++h,d+=4):d+=3;return d},o.read=function(a,d,g){if(g-d<1)return"";for(var h,et=null,ot=[],it=0;d<g;)(h=a[d++])<128?ot[it++]=h:h>191&&h<224?ot[it++]=(31&h)<<6|63&a[d++]:h>239&&h<365?(h=((7&h)<<18|(63&a[d++])<<12|(63&a[d++])<<6|63&a[d++])-65536,ot[it++]=55296+(h>>10),ot[it++]=56320+(1023&h)):ot[it++]=(15&h)<<12|(63&a[d++])<<6|63&a[d++],it>8191&&((et||(et=[])).push(String.fromCharCode.apply(String,ot)),it=0);return et?(it&&et.push(String.fromCharCode.apply(String,ot.slice(0,it))),et.join("")):String.fromCharCode.apply(String,ot.slice(0,it))},o.write=function(a,d,g){for(var h,et,ot=g,it=0;it<a.length;++it)(h=a.charCodeAt(it))<128?d[g++]=h:h<2048?(d[g++]=h>>6|192,d[g++]=63&h|128):(64512&h)==55296&&(64512&(et=a.charCodeAt(it+1)))==56320?(h=65536+((1023&h)<<10)+(1023&et),++it,d[g++]=h>>18|240,d[g++]=h>>12&63|128,d[g++]=h>>6&63|128,d[g++]=63&h|128):(d[g++]=h>>12|224,d[g++]=h>>6&63|128,d[g++]=63&h|128);return g-ot}},3442:(i,e)=>{e.__esModule=!0;var o=function(){function a(d){if(!d)throw new TypeError("Invalid argument; `value` has no value.");this.value=a.EMPTY,d&&a.isGuid(d)&&(this.value=d)}return a.isGuid=function(d){var g=d.toString();return d&&(d instanceof a||a.validator.test(g))},a.create=function(){return new a([a.gen(2),a.gen(1),a.gen(1),a.gen(1),a.gen(3)].join("-"))},a.createEmpty=function(){return new a("emptyguid")},a.parse=function(d){return new a(d)},a.raw=function(){return[a.gen(2),a.gen(1),a.gen(1),a.gen(1),a.gen(3)].join("-")},a.gen=function(d){for(var g="",h=0;h<d;h++)g+=(65536*(1+Math.random())|0).toString(16).substring(1);return g},a.prototype.equals=function(d){return a.isGuid(d)&&this.value===d.toString()},a.prototype.isEmpty=function(){return this.value===a.EMPTY},a.prototype.toString=function(){return this.value},a.prototype.toJSON=function(){return{value:this.value}},a.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),a.EMPTY="00000000-0000-0000-0000-000000000000",a}();e.Guid=o},3720:i=>{i.exports=o;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function o(Tt,jt,dn){this.low=0|Tt,this.high=0|jt,this.unsigned=!!dn}function a(Tt){return(Tt&&Tt.__isLong__)===!0}o.prototype.__isLong__,Object.defineProperty(o.prototype,"__isLong__",{value:!0}),o.isLong=a;var d={},g={};function h(Tt,jt){var dn,yn,mn;return jt?(mn=0<=(Tt>>>=0)&&Tt<256)&&(yn=g[Tt])?yn:(dn=ot(Tt,(0|Tt)<0?-1:0,!0),mn&&(g[Tt]=dn),dn):(mn=-128<=(Tt|=0)&&Tt<128)&&(yn=d[Tt])?yn:(dn=ot(Tt,Tt<0?-1:0,!1),mn&&(d[Tt]=dn),dn)}function et(Tt,jt){if(isNaN(Tt))return jt?ct:dt;if(jt){if(Tt<0)return ct;if(Tt>=_)return $t}else{if(Tt<=-b)return Ct;if(Tt+1>=b)return bt}return Tt<0?et(-Tt,jt).neg():ot(Tt%s|0,Tt/s|0,jt)}function ot(Tt,jt,dn){return new o(Tt,jt,dn)}o.fromInt=h,o.fromNumber=et,o.fromBits=ot;var it=Math.pow;function $(Tt,jt,dn){if(Tt.length===0)throw Error("empty string");if(Tt==="NaN"||Tt==="Infinity"||Tt==="+Infinity"||Tt==="-Infinity")return dt;if(typeof jt=="number"?(dn=jt,jt=!1):jt=!!jt,(dn=dn||10)<2||36<dn)throw RangeError("radix");var yn;if((yn=Tt.indexOf("-"))>0)throw Error("interior hyphen");if(yn===0)return $(Tt.substring(1),jt,dn).neg();for(var mn=et(it(dn,8)),fn=dt,un=0;un<Tt.length;un+=8){var Wt=Math.min(8,Tt.length-un),Jt=parseInt(Tt.substring(un,un+Wt),dn);if(Wt<8){var _n=et(it(dn,Wt));fn=fn.mul(_n).add(et(Jt))}else fn=(fn=fn.mul(mn)).add(et(Jt))}return fn.unsigned=jt,fn}function c(Tt,jt){return typeof Tt=="number"?et(Tt,jt):typeof Tt=="string"?$(Tt,jt):ot(Tt.low,Tt.high,typeof jt=="boolean"?jt:Tt.unsigned)}o.fromString=$,o.fromValue=c;var s=4294967296,_=s*s,b=_/2,st=h(1<<24),dt=h(0);o.ZERO=dt;var ct=h(0,!0);o.UZERO=ct;var pt=h(1);o.ONE=pt;var ft=h(1,!0);o.UONE=ft;var mt=h(-1);o.NEG_ONE=mt;var bt=ot(-1,2147483647,!1);o.MAX_VALUE=bt;var $t=ot(-1,-1,!0);o.MAX_UNSIGNED_VALUE=$t;var Ct=ot(0,-2147483648,!1);o.MIN_VALUE=Ct;var It=o.prototype;It.toInt=function(){return this.unsigned?this.low>>>0:this.low},It.toNumber=function(){return this.unsigned?(this.high>>>0)*s+(this.low>>>0):this.high*s+(this.low>>>0)},It.toString=function(Tt){if((Tt=Tt||10)<2||36<Tt)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Ct)){var jt=et(Tt),dn=this.div(jt),yn=dn.mul(jt).sub(this);return dn.toString(Tt)+yn.toInt().toString(Tt)}return"-"+this.neg().toString(Tt)}for(var mn=et(it(Tt,6),this.unsigned),fn=this,un="";;){var Wt=fn.div(mn),Jt=(fn.sub(Wt.mul(mn)).toInt()>>>0).toString(Tt);if((fn=Wt).isZero())return Jt+un;for(;Jt.length<6;)Jt="0"+Jt;un=""+Jt+un}},It.getHighBits=function(){return this.high},It.getHighBitsUnsigned=function(){return this.high>>>0},It.getLowBits=function(){return this.low},It.getLowBitsUnsigned=function(){return this.low>>>0},It.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ct)?64:this.neg().getNumBitsAbs();for(var Tt=this.high!=0?this.high:this.low,jt=31;jt>0&&!(Tt&1<<jt);jt--);return this.high!=0?jt+33:jt+1},It.isZero=function(){return this.high===0&&this.low===0},It.eqz=It.isZero,It.isNegative=function(){return!this.unsigned&&this.high<0},It.isPositive=function(){return this.unsigned||this.high>=0},It.isOdd=function(){return(1&this.low)==1},It.isEven=function(){return(1&this.low)==0},It.equals=function(Tt){return a(Tt)||(Tt=c(Tt)),(this.unsigned===Tt.unsigned||this.high>>>31!=1||Tt.high>>>31!=1)&&this.high===Tt.high&&this.low===Tt.low},It.eq=It.equals,It.notEquals=function(Tt){return!this.eq(Tt)},It.neq=It.notEquals,It.ne=It.notEquals,It.lessThan=function(Tt){return this.comp(Tt)<0},It.lt=It.lessThan,It.lessThanOrEqual=function(Tt){return this.comp(Tt)<=0},It.lte=It.lessThanOrEqual,It.le=It.lessThanOrEqual,It.greaterThan=function(Tt){return this.comp(Tt)>0},It.gt=It.greaterThan,It.greaterThanOrEqual=function(Tt){return this.comp(Tt)>=0},It.gte=It.greaterThanOrEqual,It.ge=It.greaterThanOrEqual,It.compare=function(Tt){if(a(Tt)||(Tt=c(Tt)),this.eq(Tt))return 0;var jt=this.isNegative(),dn=Tt.isNegative();return jt&&!dn?-1:!jt&&dn?1:this.unsigned?Tt.high>>>0>this.high>>>0||Tt.high===this.high&&Tt.low>>>0>this.low>>>0?-1:1:this.sub(Tt).isNegative()?-1:1},It.comp=It.compare,It.negate=function(){return!this.unsigned&&this.eq(Ct)?Ct:this.not().add(pt)},It.neg=It.negate,It.add=function(Tt){a(Tt)||(Tt=c(Tt));var jt=this.high>>>16,dn=65535&this.high,yn=this.low>>>16,mn=65535&this.low,fn=Tt.high>>>16,un=65535&Tt.high,Wt=Tt.low>>>16,Jt=0,_n=0,vn=0,Sn=0;return vn+=(Sn+=mn+(65535&Tt.low))>>>16,_n+=(vn+=yn+Wt)>>>16,Jt+=(_n+=dn+un)>>>16,Jt+=jt+fn,ot((vn&=65535)<<16|(Sn&=65535),(Jt&=65535)<<16|(_n&=65535),this.unsigned)},It.subtract=function(Tt){return a(Tt)||(Tt=c(Tt)),this.add(Tt.neg())},It.sub=It.subtract,It.multiply=function(Tt){if(this.isZero())return dt;if(a(Tt)||(Tt=c(Tt)),e)return ot(e.mul(this.low,this.high,Tt.low,Tt.high),e.get_high(),this.unsigned);if(Tt.isZero())return dt;if(this.eq(Ct))return Tt.isOdd()?Ct:dt;if(Tt.eq(Ct))return this.isOdd()?Ct:dt;if(this.isNegative())return Tt.isNegative()?this.neg().mul(Tt.neg()):this.neg().mul(Tt).neg();if(Tt.isNegative())return this.mul(Tt.neg()).neg();if(this.lt(st)&&Tt.lt(st))return et(this.toNumber()*Tt.toNumber(),this.unsigned);var jt=this.high>>>16,dn=65535&this.high,yn=this.low>>>16,mn=65535&this.low,fn=Tt.high>>>16,un=65535&Tt.high,Wt=Tt.low>>>16,Jt=65535&Tt.low,_n=0,vn=0,Sn=0,hn=0;return Sn+=(hn+=mn*Jt)>>>16,vn+=(Sn+=yn*Jt)>>>16,Sn&=65535,vn+=(Sn+=mn*Wt)>>>16,_n+=(vn+=dn*Jt)>>>16,vn&=65535,_n+=(vn+=yn*Wt)>>>16,vn&=65535,_n+=(vn+=mn*un)>>>16,_n+=jt*Jt+dn*Wt+yn*un+mn*fn,ot((Sn&=65535)<<16|(hn&=65535),(_n&=65535)<<16|(vn&=65535),this.unsigned)},It.mul=It.multiply,It.divide=function(Tt){if(a(Tt)||(Tt=c(Tt)),Tt.isZero())throw Error("division by zero");var jt,dn,yn;if(e)return this.unsigned||this.high!==-2147483648||Tt.low!==-1||Tt.high!==-1?ot((this.unsigned?e.div_u:e.div_s)(this.low,this.high,Tt.low,Tt.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?ct:dt;if(this.unsigned){if(Tt.unsigned||(Tt=Tt.toUnsigned()),Tt.gt(this))return ct;if(Tt.gt(this.shru(1)))return ft;yn=ct}else{if(this.eq(Ct))return Tt.eq(pt)||Tt.eq(mt)?Ct:Tt.eq(Ct)?pt:(jt=this.shr(1).div(Tt).shl(1)).eq(dt)?Tt.isNegative()?pt:mt:(dn=this.sub(Tt.mul(jt)),yn=jt.add(dn.div(Tt)));if(Tt.eq(Ct))return this.unsigned?ct:dt;if(this.isNegative())return Tt.isNegative()?this.neg().div(Tt.neg()):this.neg().div(Tt).neg();if(Tt.isNegative())return this.div(Tt.neg()).neg();yn=dt}for(dn=this;dn.gte(Tt);){jt=Math.max(1,Math.floor(dn.toNumber()/Tt.toNumber()));for(var mn=Math.ceil(Math.log(jt)/Math.LN2),fn=mn<=48?1:it(2,mn-48),un=et(jt),Wt=un.mul(Tt);Wt.isNegative()||Wt.gt(dn);)Wt=(un=et(jt-=fn,this.unsigned)).mul(Tt);un.isZero()&&(un=pt),yn=yn.add(un),dn=dn.sub(Wt)}return yn},It.div=It.divide,It.modulo=function(Tt){return a(Tt)||(Tt=c(Tt)),e?ot((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,Tt.low,Tt.high),e.get_high(),this.unsigned):this.sub(this.div(Tt).mul(Tt))},It.mod=It.modulo,It.rem=It.modulo,It.not=function(){return ot(~this.low,~this.high,this.unsigned)},It.and=function(Tt){return a(Tt)||(Tt=c(Tt)),ot(this.low&Tt.low,this.high&Tt.high,this.unsigned)},It.or=function(Tt){return a(Tt)||(Tt=c(Tt)),ot(this.low|Tt.low,this.high|Tt.high,this.unsigned)},It.xor=function(Tt){return a(Tt)||(Tt=c(Tt)),ot(this.low^Tt.low,this.high^Tt.high,this.unsigned)},It.shiftLeft=function(Tt){return a(Tt)&&(Tt=Tt.toInt()),(Tt&=63)==0?this:Tt<32?ot(this.low<<Tt,this.high<<Tt|this.low>>>32-Tt,this.unsigned):ot(0,this.low<<Tt-32,this.unsigned)},It.shl=It.shiftLeft,It.shiftRight=function(Tt){return a(Tt)&&(Tt=Tt.toInt()),(Tt&=63)==0?this:Tt<32?ot(this.low>>>Tt|this.high<<32-Tt,this.high>>Tt,this.unsigned):ot(this.high>>Tt-32,this.high>=0?0:-1,this.unsigned)},It.shr=It.shiftRight,It.shiftRightUnsigned=function(Tt){if(a(Tt)&&(Tt=Tt.toInt()),(Tt&=63)==0)return this;var jt=this.high;return Tt<32?ot(this.low>>>Tt|jt<<32-Tt,jt>>>Tt,this.unsigned):ot(Tt===32?jt:jt>>>Tt-32,0,this.unsigned)},It.shru=It.shiftRightUnsigned,It.shr_u=It.shiftRightUnsigned,It.toSigned=function(){return this.unsigned?ot(this.low,this.high,!1):this},It.toUnsigned=function(){return this.unsigned?this:ot(this.low,this.high,!0)},It.toBytes=function(Tt){return Tt?this.toBytesLE():this.toBytesBE()},It.toBytesLE=function(){var Tt=this.high,jt=this.low;return[255&jt,jt>>>8&255,jt>>>16&255,jt>>>24,255&Tt,Tt>>>8&255,Tt>>>16&255,Tt>>>24]},It.toBytesBE=function(){var Tt=this.high,jt=this.low;return[Tt>>>24,Tt>>>16&255,Tt>>>8&255,255&Tt,jt>>>24,jt>>>16&255,jt>>>8&255,255&jt]},o.fromBytes=function(Tt,jt,dn){return dn?o.fromBytesLE(Tt,jt):o.fromBytesBE(Tt,jt)},o.fromBytesLE=function(Tt,jt){return new o(Tt[0]|Tt[1]<<8|Tt[2]<<16|Tt[3]<<24,Tt[4]|Tt[5]<<8|Tt[6]<<16|Tt[7]<<24,jt)},o.fromBytesBE=function(Tt,jt){return new o(Tt[4]<<24|Tt[5]<<16|Tt[6]<<8|Tt[7],Tt[0]<<24|Tt[1]<<16|Tt[2]<<8|Tt[3],jt)}},1446:(i,e,o)=>{var a,d,g,h=o(2100),et=h.Reader,ot=h.Writer,it=h.util,$=h.roots.default||(h.roots.default={});$.onnx=((g={}).Version=(a={},(d=Object.create(a))[a[0]="_START_VERSION"]=0,d[a[1]="IR_VERSION_2017_10_10"]=1,d[a[2]="IR_VERSION_2017_10_30"]=2,d[a[3]="IR_VERSION_2017_11_3"]=3,d[a[4]="IR_VERSION_2019_1_22"]=4,d[a[5]="IR_VERSION"]=5,d),g.AttributeProto=function(){function c(s){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],s)for(var _=Object.keys(s),b=0;b<_.length;++b)s[_[b]]!=null&&(this[_[b]]=s[_[b]])}return c.prototype.name="",c.prototype.refAttrName="",c.prototype.docString="",c.prototype.type=0,c.prototype.f=0,c.prototype.i=it.Long?it.Long.fromBits(0,0,!1):0,c.prototype.s=it.newBuffer([]),c.prototype.t=null,c.prototype.g=null,c.prototype.floats=it.emptyArray,c.prototype.ints=it.emptyArray,c.prototype.strings=it.emptyArray,c.prototype.tensors=it.emptyArray,c.prototype.graphs=it.emptyArray,c.create=function(s){return new c(s)},c.encode=function(s,_){if(_||(_=ot.create()),s.name!=null&&s.hasOwnProperty("name")&&_.uint32(10).string(s.name),s.f!=null&&s.hasOwnProperty("f")&&_.uint32(21).float(s.f),s.i!=null&&s.hasOwnProperty("i")&&_.uint32(24).int64(s.i),s.s!=null&&s.hasOwnProperty("s")&&_.uint32(34).bytes(s.s),s.t!=null&&s.hasOwnProperty("t")&&$.onnx.TensorProto.encode(s.t,_.uint32(42).fork()).ldelim(),s.g!=null&&s.hasOwnProperty("g")&&$.onnx.GraphProto.encode(s.g,_.uint32(50).fork()).ldelim(),s.floats!=null&&s.floats.length){_.uint32(58).fork();for(var b=0;b<s.floats.length;++b)_.float(s.floats[b]);_.ldelim()}if(s.ints!=null&&s.ints.length){for(_.uint32(66).fork(),b=0;b<s.ints.length;++b)_.int64(s.ints[b]);_.ldelim()}if(s.strings!=null&&s.strings.length)for(b=0;b<s.strings.length;++b)_.uint32(74).bytes(s.strings[b]);if(s.tensors!=null&&s.tensors.length)for(b=0;b<s.tensors.length;++b)$.onnx.TensorProto.encode(s.tensors[b],_.uint32(82).fork()).ldelim();if(s.graphs!=null&&s.graphs.length)for(b=0;b<s.graphs.length;++b)$.onnx.GraphProto.encode(s.graphs[b],_.uint32(90).fork()).ldelim();return s.docString!=null&&s.hasOwnProperty("docString")&&_.uint32(106).string(s.docString),s.type!=null&&s.hasOwnProperty("type")&&_.uint32(160).int32(s.type),s.refAttrName!=null&&s.hasOwnProperty("refAttrName")&&_.uint32(170).string(s.refAttrName),_},c.encodeDelimited=function(s,_){return this.encode(s,_).ldelim()},c.decode=function(s,_){s instanceof et||(s=et.create(s));for(var b=_===void 0?s.len:s.pos+_,st=new $.onnx.AttributeProto;s.pos<b;){var dt=s.uint32();switch(dt>>>3){case 1:st.name=s.string();break;case 21:st.refAttrName=s.string();break;case 13:st.docString=s.string();break;case 20:st.type=s.int32();break;case 2:st.f=s.float();break;case 3:st.i=s.int64();break;case 4:st.s=s.bytes();break;case 5:st.t=$.onnx.TensorProto.decode(s,s.uint32());break;case 6:st.g=$.onnx.GraphProto.decode(s,s.uint32());break;case 7:if(st.floats&&st.floats.length||(st.floats=[]),(7&dt)==2)for(var ct=s.uint32()+s.pos;s.pos<ct;)st.floats.push(s.float());else st.floats.push(s.float());break;case 8:if(st.ints&&st.ints.length||(st.ints=[]),(7&dt)==2)for(ct=s.uint32()+s.pos;s.pos<ct;)st.ints.push(s.int64());else st.ints.push(s.int64());break;case 9:st.strings&&st.strings.length||(st.strings=[]),st.strings.push(s.bytes());break;case 10:st.tensors&&st.tensors.length||(st.tensors=[]),st.tensors.push($.onnx.TensorProto.decode(s,s.uint32()));break;case 11:st.graphs&&st.graphs.length||(st.graphs=[]),st.graphs.push($.onnx.GraphProto.decode(s,s.uint32()));break;default:s.skipType(7&dt)}}return st},c.decodeDelimited=function(s){return s instanceof et||(s=new et(s)),this.decode(s,s.uint32())},c.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.name!=null&&s.hasOwnProperty("name")&&!it.isString(s.name))return"name: string expected";if(s.refAttrName!=null&&s.hasOwnProperty("refAttrName")&&!it.isString(s.refAttrName))return"refAttrName: string expected";if(s.docString!=null&&s.hasOwnProperty("docString")&&!it.isString(s.docString))return"docString: string expected";if(s.type!=null&&s.hasOwnProperty("type"))switch(s.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(s.f!=null&&s.hasOwnProperty("f")&&typeof s.f!="number")return"f: number expected";if(s.i!=null&&s.hasOwnProperty("i")&&!(it.isInteger(s.i)||s.i&&it.isInteger(s.i.low)&&it.isInteger(s.i.high)))return"i: integer|Long expected";if(s.s!=null&&s.hasOwnProperty("s")&&!(s.s&&typeof s.s.length=="number"||it.isString(s.s)))return"s: buffer expected";if(s.t!=null&&s.hasOwnProperty("t")&&(b=$.onnx.TensorProto.verify(s.t)))return"t."+b;if(s.g!=null&&s.hasOwnProperty("g")&&(b=$.onnx.GraphProto.verify(s.g)))return"g."+b;if(s.floats!=null&&s.hasOwnProperty("floats")){if(!Array.isArray(s.floats))return"floats: array expected";for(var _=0;_<s.floats.length;++_)if(typeof s.floats[_]!="number")return"floats: number[] expected"}if(s.ints!=null&&s.hasOwnProperty("ints")){if(!Array.isArray(s.ints))return"ints: array expected";for(_=0;_<s.ints.length;++_)if(!(it.isInteger(s.ints[_])||s.ints[_]&&it.isInteger(s.ints[_].low)&&it.isInteger(s.ints[_].high)))return"ints: integer|Long[] expected"}if(s.strings!=null&&s.hasOwnProperty("strings")){if(!Array.isArray(s.strings))return"strings: array expected";for(_=0;_<s.strings.length;++_)if(!(s.strings[_]&&typeof s.strings[_].length=="number"||it.isString(s.strings[_])))return"strings: buffer[] expected"}if(s.tensors!=null&&s.hasOwnProperty("tensors")){if(!Array.isArray(s.tensors))return"tensors: array expected";for(_=0;_<s.tensors.length;++_)if(b=$.onnx.TensorProto.verify(s.tensors[_]))return"tensors."+b}if(s.graphs!=null&&s.hasOwnProperty("graphs")){if(!Array.isArray(s.graphs))return"graphs: array expected";for(_=0;_<s.graphs.length;++_){var b;if(b=$.onnx.GraphProto.verify(s.graphs[_]))return"graphs."+b}}return null},c.fromObject=function(s){if(s instanceof $.onnx.AttributeProto)return s;var _=new $.onnx.AttributeProto;switch(s.name!=null&&(_.name=String(s.name)),s.refAttrName!=null&&(_.refAttrName=String(s.refAttrName)),s.docString!=null&&(_.docString=String(s.docString)),s.type){case"UNDEFINED":case 0:_.type=0;break;case"FLOAT":case 1:_.type=1;break;case"INT":case 2:_.type=2;break;case"STRING":case 3:_.type=3;break;case"TENSOR":case 4:_.type=4;break;case"GRAPH":case 5:_.type=5;break;case"FLOATS":case 6:_.type=6;break;case"INTS":case 7:_.type=7;break;case"STRINGS":case 8:_.type=8;break;case"TENSORS":case 9:_.type=9;break;case"GRAPHS":case 10:_.type=10}if(s.f!=null&&(_.f=Number(s.f)),s.i!=null&&(it.Long?(_.i=it.Long.fromValue(s.i)).unsigned=!1:typeof s.i=="string"?_.i=parseInt(s.i,10):typeof s.i=="number"?_.i=s.i:typeof s.i=="object"&&(_.i=new it.LongBits(s.i.low>>>0,s.i.high>>>0).toNumber())),s.s!=null&&(typeof s.s=="string"?it.base64.decode(s.s,_.s=it.newBuffer(it.base64.length(s.s)),0):s.s.length&&(_.s=s.s)),s.t!=null){if(typeof s.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");_.t=$.onnx.TensorProto.fromObject(s.t)}if(s.g!=null){if(typeof s.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");_.g=$.onnx.GraphProto.fromObject(s.g)}if(s.floats){if(!Array.isArray(s.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");_.floats=[];for(var b=0;b<s.floats.length;++b)_.floats[b]=Number(s.floats[b])}if(s.ints){if(!Array.isArray(s.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(_.ints=[],b=0;b<s.ints.length;++b)it.Long?(_.ints[b]=it.Long.fromValue(s.ints[b])).unsigned=!1:typeof s.ints[b]=="string"?_.ints[b]=parseInt(s.ints[b],10):typeof s.ints[b]=="number"?_.ints[b]=s.ints[b]:typeof s.ints[b]=="object"&&(_.ints[b]=new it.LongBits(s.ints[b].low>>>0,s.ints[b].high>>>0).toNumber())}if(s.strings){if(!Array.isArray(s.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(_.strings=[],b=0;b<s.strings.length;++b)typeof s.strings[b]=="string"?it.base64.decode(s.strings[b],_.strings[b]=it.newBuffer(it.base64.length(s.strings[b])),0):s.strings[b].length&&(_.strings[b]=s.strings[b])}if(s.tensors){if(!Array.isArray(s.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(_.tensors=[],b=0;b<s.tensors.length;++b){if(typeof s.tensors[b]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");_.tensors[b]=$.onnx.TensorProto.fromObject(s.tensors[b])}}if(s.graphs){if(!Array.isArray(s.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(_.graphs=[],b=0;b<s.graphs.length;++b){if(typeof s.graphs[b]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");_.graphs[b]=$.onnx.GraphProto.fromObject(s.graphs[b])}}return _},c.toObject=function(s,_){_||(_={});var b={};if((_.arrays||_.defaults)&&(b.floats=[],b.ints=[],b.strings=[],b.tensors=[],b.graphs=[]),_.defaults){if(b.name="",b.f=0,it.Long){var st=new it.Long(0,0,!1);b.i=_.longs===String?st.toString():_.longs===Number?st.toNumber():st}else b.i=_.longs===String?"0":0;_.bytes===String?b.s="":(b.s=[],_.bytes!==Array&&(b.s=it.newBuffer(b.s))),b.t=null,b.g=null,b.docString="",b.type=_.enums===String?"UNDEFINED":0,b.refAttrName=""}if(s.name!=null&&s.hasOwnProperty("name")&&(b.name=s.name),s.f!=null&&s.hasOwnProperty("f")&&(b.f=_.json&&!isFinite(s.f)?String(s.f):s.f),s.i!=null&&s.hasOwnProperty("i")&&(typeof s.i=="number"?b.i=_.longs===String?String(s.i):s.i:b.i=_.longs===String?it.Long.prototype.toString.call(s.i):_.longs===Number?new it.LongBits(s.i.low>>>0,s.i.high>>>0).toNumber():s.i),s.s!=null&&s.hasOwnProperty("s")&&(b.s=_.bytes===String?it.base64.encode(s.s,0,s.s.length):_.bytes===Array?Array.prototype.slice.call(s.s):s.s),s.t!=null&&s.hasOwnProperty("t")&&(b.t=$.onnx.TensorProto.toObject(s.t,_)),s.g!=null&&s.hasOwnProperty("g")&&(b.g=$.onnx.GraphProto.toObject(s.g,_)),s.floats&&s.floats.length){b.floats=[];for(var dt=0;dt<s.floats.length;++dt)b.floats[dt]=_.json&&!isFinite(s.floats[dt])?String(s.floats[dt]):s.floats[dt]}if(s.ints&&s.ints.length)for(b.ints=[],dt=0;dt<s.ints.length;++dt)typeof s.ints[dt]=="number"?b.ints[dt]=_.longs===String?String(s.ints[dt]):s.ints[dt]:b.ints[dt]=_.longs===String?it.Long.prototype.toString.call(s.ints[dt]):_.longs===Number?new it.LongBits(s.ints[dt].low>>>0,s.ints[dt].high>>>0).toNumber():s.ints[dt];if(s.strings&&s.strings.length)for(b.strings=[],dt=0;dt<s.strings.length;++dt)b.strings[dt]=_.bytes===String?it.base64.encode(s.strings[dt],0,s.strings[dt].length):_.bytes===Array?Array.prototype.slice.call(s.strings[dt]):s.strings[dt];if(s.tensors&&s.tensors.length)for(b.tensors=[],dt=0;dt<s.tensors.length;++dt)b.tensors[dt]=$.onnx.TensorProto.toObject(s.tensors[dt],_);if(s.graphs&&s.graphs.length)for(b.graphs=[],dt=0;dt<s.graphs.length;++dt)b.graphs[dt]=$.onnx.GraphProto.toObject(s.graphs[dt],_);return s.docString!=null&&s.hasOwnProperty("docString")&&(b.docString=s.docString),s.type!=null&&s.hasOwnProperty("type")&&(b.type=_.enums===String?$.onnx.AttributeProto.AttributeType[s.type]:s.type),s.refAttrName!=null&&s.hasOwnProperty("refAttrName")&&(b.refAttrName=s.refAttrName),b},c.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},c.AttributeType=function(){var s={},_=Object.create(s);return _[s[0]="UNDEFINED"]=0,_[s[1]="FLOAT"]=1,_[s[2]="INT"]=2,_[s[3]="STRING"]=3,_[s[4]="TENSOR"]=4,_[s[5]="GRAPH"]=5,_[s[6]="FLOATS"]=6,_[s[7]="INTS"]=7,_[s[8]="STRINGS"]=8,_[s[9]="TENSORS"]=9,_[s[10]="GRAPHS"]=10,_}(),c}(),g.ValueInfoProto=function(){function c(s){if(s)for(var _=Object.keys(s),b=0;b<_.length;++b)s[_[b]]!=null&&(this[_[b]]=s[_[b]])}return c.prototype.name="",c.prototype.type=null,c.prototype.docString="",c.create=function(s){return new c(s)},c.encode=function(s,_){return _||(_=ot.create()),s.name!=null&&s.hasOwnProperty("name")&&_.uint32(10).string(s.name),s.type!=null&&s.hasOwnProperty("type")&&$.onnx.TypeProto.encode(s.type,_.uint32(18).fork()).ldelim(),s.docString!=null&&s.hasOwnProperty("docString")&&_.uint32(26).string(s.docString),_},c.encodeDelimited=function(s,_){return this.encode(s,_).ldelim()},c.decode=function(s,_){s instanceof et||(s=et.create(s));for(var b=_===void 0?s.len:s.pos+_,st=new $.onnx.ValueInfoProto;s.pos<b;){var dt=s.uint32();switch(dt>>>3){case 1:st.name=s.string();break;case 2:st.type=$.onnx.TypeProto.decode(s,s.uint32());break;case 3:st.docString=s.string();break;default:s.skipType(7&dt)}}return st},c.decodeDelimited=function(s){return s instanceof et||(s=new et(s)),this.decode(s,s.uint32())},c.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.name!=null&&s.hasOwnProperty("name")&&!it.isString(s.name))return"name: string expected";if(s.type!=null&&s.hasOwnProperty("type")){var _=$.onnx.TypeProto.verify(s.type);if(_)return"type."+_}return s.docString!=null&&s.hasOwnProperty("docString")&&!it.isString(s.docString)?"docString: string expected":null},c.fromObject=function(s){if(s instanceof $.onnx.ValueInfoProto)return s;var _=new $.onnx.ValueInfoProto;if(s.name!=null&&(_.name=String(s.name)),s.type!=null){if(typeof s.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");_.type=$.onnx.TypeProto.fromObject(s.type)}return s.docString!=null&&(_.docString=String(s.docString)),_},c.toObject=function(s,_){_||(_={});var b={};return _.defaults&&(b.name="",b.type=null,b.docString=""),s.name!=null&&s.hasOwnProperty("name")&&(b.name=s.name),s.type!=null&&s.hasOwnProperty("type")&&(b.type=$.onnx.TypeProto.toObject(s.type,_)),s.docString!=null&&s.hasOwnProperty("docString")&&(b.docString=s.docString),b},c.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},c}(),g.NodeProto=function(){function c(s){if(this.input=[],this.output=[],this.attribute=[],s)for(var _=Object.keys(s),b=0;b<_.length;++b)s[_[b]]!=null&&(this[_[b]]=s[_[b]])}return c.prototype.input=it.emptyArray,c.prototype.output=it.emptyArray,c.prototype.name="",c.prototype.opType="",c.prototype.domain="",c.prototype.attribute=it.emptyArray,c.prototype.docString="",c.create=function(s){return new c(s)},c.encode=function(s,_){if(_||(_=ot.create()),s.input!=null&&s.input.length)for(var b=0;b<s.input.length;++b)_.uint32(10).string(s.input[b]);if(s.output!=null&&s.output.length)for(b=0;b<s.output.length;++b)_.uint32(18).string(s.output[b]);if(s.name!=null&&s.hasOwnProperty("name")&&_.uint32(26).string(s.name),s.opType!=null&&s.hasOwnProperty("opType")&&_.uint32(34).string(s.opType),s.attribute!=null&&s.attribute.length)for(b=0;b<s.attribute.length;++b)$.onnx.AttributeProto.encode(s.attribute[b],_.uint32(42).fork()).ldelim();return s.docString!=null&&s.hasOwnProperty("docString")&&_.uint32(50).string(s.docString),s.domain!=null&&s.hasOwnProperty("domain")&&_.uint32(58).string(s.domain),_},c.encodeDelimited=function(s,_){return this.encode(s,_).ldelim()},c.decode=function(s,_){s instanceof et||(s=et.create(s));for(var b=_===void 0?s.len:s.pos+_,st=new $.onnx.NodeProto;s.pos<b;){var dt=s.uint32();switch(dt>>>3){case 1:st.input&&st.input.length||(st.input=[]),st.input.push(s.string());break;case 2:st.output&&st.output.length||(st.output=[]),st.output.push(s.string());break;case 3:st.name=s.string();break;case 4:st.opType=s.string();break;case 7:st.domain=s.string();break;case 5:st.attribute&&st.attribute.length||(st.attribute=[]),st.attribute.push($.onnx.AttributeProto.decode(s,s.uint32()));break;case 6:st.docString=s.string();break;default:s.skipType(7&dt)}}return st},c.decodeDelimited=function(s){return s instanceof et||(s=new et(s)),this.decode(s,s.uint32())},c.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.input!=null&&s.hasOwnProperty("input")){if(!Array.isArray(s.input))return"input: array expected";for(var _=0;_<s.input.length;++_)if(!it.isString(s.input[_]))return"input: string[] expected"}if(s.output!=null&&s.hasOwnProperty("output")){if(!Array.isArray(s.output))return"output: array expected";for(_=0;_<s.output.length;++_)if(!it.isString(s.output[_]))return"output: string[] expected"}if(s.name!=null&&s.hasOwnProperty("name")&&!it.isString(s.name))return"name: string expected";if(s.opType!=null&&s.hasOwnProperty("opType")&&!it.isString(s.opType))return"opType: string expected";if(s.domain!=null&&s.hasOwnProperty("domain")&&!it.isString(s.domain))return"domain: string expected";if(s.attribute!=null&&s.hasOwnProperty("attribute")){if(!Array.isArray(s.attribute))return"attribute: array expected";for(_=0;_<s.attribute.length;++_){var b=$.onnx.AttributeProto.verify(s.attribute[_]);if(b)return"attribute."+b}}return s.docString!=null&&s.hasOwnProperty("docString")&&!it.isString(s.docString)?"docString: string expected":null},c.fromObject=function(s){if(s instanceof $.onnx.NodeProto)return s;var _=new $.onnx.NodeProto;if(s.input){if(!Array.isArray(s.input))throw TypeError(".onnx.NodeProto.input: array expected");_.input=[];for(var b=0;b<s.input.length;++b)_.input[b]=String(s.input[b])}if(s.output){if(!Array.isArray(s.output))throw TypeError(".onnx.NodeProto.output: array expected");for(_.output=[],b=0;b<s.output.length;++b)_.output[b]=String(s.output[b])}if(s.name!=null&&(_.name=String(s.name)),s.opType!=null&&(_.opType=String(s.opType)),s.domain!=null&&(_.domain=String(s.domain)),s.attribute){if(!Array.isArray(s.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(_.attribute=[],b=0;b<s.attribute.length;++b){if(typeof s.attribute[b]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");_.attribute[b]=$.onnx.AttributeProto.fromObject(s.attribute[b])}}return s.docString!=null&&(_.docString=String(s.docString)),_},c.toObject=function(s,_){_||(_={});var b={};if((_.arrays||_.defaults)&&(b.input=[],b.output=[],b.attribute=[]),_.defaults&&(b.name="",b.opType="",b.docString="",b.domain=""),s.input&&s.input.length){b.input=[];for(var st=0;st<s.input.length;++st)b.input[st]=s.input[st]}if(s.output&&s.output.length)for(b.output=[],st=0;st<s.output.length;++st)b.output[st]=s.output[st];if(s.name!=null&&s.hasOwnProperty("name")&&(b.name=s.name),s.opType!=null&&s.hasOwnProperty("opType")&&(b.opType=s.opType),s.attribute&&s.attribute.length)for(b.attribute=[],st=0;st<s.attribute.length;++st)b.attribute[st]=$.onnx.AttributeProto.toObject(s.attribute[st],_);return s.docString!=null&&s.hasOwnProperty("docString")&&(b.docString=s.docString),s.domain!=null&&s.hasOwnProperty("domain")&&(b.domain=s.domain),b},c.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},c}(),g.ModelProto=function(){function c(s){if(this.opsetImport=[],this.metadataProps=[],s)for(var _=Object.keys(s),b=0;b<_.length;++b)s[_[b]]!=null&&(this[_[b]]=s[_[b]])}return c.prototype.irVersion=it.Long?it.Long.fromBits(0,0,!1):0,c.prototype.opsetImport=it.emptyArray,c.prototype.producerName="",c.prototype.producerVersion="",c.prototype.domain="",c.prototype.modelVersion=it.Long?it.Long.fromBits(0,0,!1):0,c.prototype.docString="",c.prototype.graph=null,c.prototype.metadataProps=it.emptyArray,c.create=function(s){return new c(s)},c.encode=function(s,_){if(_||(_=ot.create()),s.irVersion!=null&&s.hasOwnProperty("irVersion")&&_.uint32(8).int64(s.irVersion),s.producerName!=null&&s.hasOwnProperty("producerName")&&_.uint32(18).string(s.producerName),s.producerVersion!=null&&s.hasOwnProperty("producerVersion")&&_.uint32(26).string(s.producerVersion),s.domain!=null&&s.hasOwnProperty("domain")&&_.uint32(34).string(s.domain),s.modelVersion!=null&&s.hasOwnProperty("modelVersion")&&_.uint32(40).int64(s.modelVersion),s.docString!=null&&s.hasOwnProperty("docString")&&_.uint32(50).string(s.docString),s.graph!=null&&s.hasOwnProperty("graph")&&$.onnx.GraphProto.encode(s.graph,_.uint32(58).fork()).ldelim(),s.opsetImport!=null&&s.opsetImport.length)for(var b=0;b<s.opsetImport.length;++b)$.onnx.OperatorSetIdProto.encode(s.opsetImport[b],_.uint32(66).fork()).ldelim();if(s.metadataProps!=null&&s.metadataProps.length)for(b=0;b<s.metadataProps.length;++b)$.onnx.StringStringEntryProto.encode(s.metadataProps[b],_.uint32(114).fork()).ldelim();return _},c.encodeDelimited=function(s,_){return this.encode(s,_).ldelim()},c.decode=function(s,_){s instanceof et||(s=et.create(s));for(var b=_===void 0?s.len:s.pos+_,st=new $.onnx.ModelProto;s.pos<b;){var dt=s.uint32();switch(dt>>>3){case 1:st.irVersion=s.int64();break;case 8:st.opsetImport&&st.opsetImport.length||(st.opsetImport=[]),st.opsetImport.push($.onnx.OperatorSetIdProto.decode(s,s.uint32()));break;case 2:st.producerName=s.string();break;case 3:st.producerVersion=s.string();break;case 4:st.domain=s.string();break;case 5:st.modelVersion=s.int64();break;case 6:st.docString=s.string();break;case 7:st.graph=$.onnx.GraphProto.decode(s,s.uint32());break;case 14:st.metadataProps&&st.metadataProps.length||(st.metadataProps=[]),st.metadataProps.push($.onnx.StringStringEntryProto.decode(s,s.uint32()));break;default:s.skipType(7&dt)}}return st},c.decodeDelimited=function(s){return s instanceof et||(s=new et(s)),this.decode(s,s.uint32())},c.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.irVersion!=null&&s.hasOwnProperty("irVersion")&&!(it.isInteger(s.irVersion)||s.irVersion&&it.isInteger(s.irVersion.low)&&it.isInteger(s.irVersion.high)))return"irVersion: integer|Long expected";if(s.opsetImport!=null&&s.hasOwnProperty("opsetImport")){if(!Array.isArray(s.opsetImport))return"opsetImport: array expected";for(var _=0;_<s.opsetImport.length;++_)if(b=$.onnx.OperatorSetIdProto.verify(s.opsetImport[_]))return"opsetImport."+b}if(s.producerName!=null&&s.hasOwnProperty("producerName")&&!it.isString(s.producerName))return"producerName: string expected";if(s.producerVersion!=null&&s.hasOwnProperty("producerVersion")&&!it.isString(s.producerVersion))return"producerVersion: string expected";if(s.domain!=null&&s.hasOwnProperty("domain")&&!it.isString(s.domain))return"domain: string expected";if(s.modelVersion!=null&&s.hasOwnProperty("modelVersion")&&!(it.isInteger(s.modelVersion)||s.modelVersion&&it.isInteger(s.modelVersion.low)&&it.isInteger(s.modelVersion.high)))return"modelVersion: integer|Long expected";if(s.docString!=null&&s.hasOwnProperty("docString")&&!it.isString(s.docString))return"docString: string expected";if(s.graph!=null&&s.hasOwnProperty("graph")&&(b=$.onnx.GraphProto.verify(s.graph)))return"graph."+b;if(s.metadataProps!=null&&s.hasOwnProperty("metadataProps")){if(!Array.isArray(s.metadataProps))return"metadataProps: array expected";for(_=0;_<s.metadataProps.length;++_){var b;if(b=$.onnx.StringStringEntryProto.verify(s.metadataProps[_]))return"metadataProps."+b}}return null},c.fromObject=function(s){if(s instanceof $.onnx.ModelProto)return s;var _=new $.onnx.ModelProto;if(s.irVersion!=null&&(it.Long?(_.irVersion=it.Long.fromValue(s.irVersion)).unsigned=!1:typeof s.irVersion=="string"?_.irVersion=parseInt(s.irVersion,10):typeof s.irVersion=="number"?_.irVersion=s.irVersion:typeof s.irVersion=="object"&&(_.irVersion=new it.LongBits(s.irVersion.low>>>0,s.irVersion.high>>>0).toNumber())),s.opsetImport){if(!Array.isArray(s.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");_.opsetImport=[];for(var b=0;b<s.opsetImport.length;++b){if(typeof s.opsetImport[b]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");_.opsetImport[b]=$.onnx.OperatorSetIdProto.fromObject(s.opsetImport[b])}}if(s.producerName!=null&&(_.producerName=String(s.producerName)),s.producerVersion!=null&&(_.producerVersion=String(s.producerVersion)),s.domain!=null&&(_.domain=String(s.domain)),s.modelVersion!=null&&(it.Long?(_.modelVersion=it.Long.fromValue(s.modelVersion)).unsigned=!1:typeof s.modelVersion=="string"?_.modelVersion=parseInt(s.modelVersion,10):typeof s.modelVersion=="number"?_.modelVersion=s.modelVersion:typeof s.modelVersion=="object"&&(_.modelVersion=new it.LongBits(s.modelVersion.low>>>0,s.modelVersion.high>>>0).toNumber())),s.docString!=null&&(_.docString=String(s.docString)),s.graph!=null){if(typeof s.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");_.graph=$.onnx.GraphProto.fromObject(s.graph)}if(s.metadataProps){if(!Array.isArray(s.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(_.metadataProps=[],b=0;b<s.metadataProps.length;++b){if(typeof s.metadataProps[b]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");_.metadataProps[b]=$.onnx.StringStringEntryProto.fromObject(s.metadataProps[b])}}return _},c.toObject=function(s,_){_||(_={});var b={};if((_.arrays||_.defaults)&&(b.opsetImport=[],b.metadataProps=[]),_.defaults){if(it.Long){var st=new it.Long(0,0,!1);b.irVersion=_.longs===String?st.toString():_.longs===Number?st.toNumber():st}else b.irVersion=_.longs===String?"0":0;b.producerName="",b.producerVersion="",b.domain="",it.Long?(st=new it.Long(0,0,!1),b.modelVersion=_.longs===String?st.toString():_.longs===Number?st.toNumber():st):b.modelVersion=_.longs===String?"0":0,b.docString="",b.graph=null}if(s.irVersion!=null&&s.hasOwnProperty("irVersion")&&(typeof s.irVersion=="number"?b.irVersion=_.longs===String?String(s.irVersion):s.irVersion:b.irVersion=_.longs===String?it.Long.prototype.toString.call(s.irVersion):_.longs===Number?new it.LongBits(s.irVersion.low>>>0,s.irVersion.high>>>0).toNumber():s.irVersion),s.producerName!=null&&s.hasOwnProperty("producerName")&&(b.producerName=s.producerName),s.producerVersion!=null&&s.hasOwnProperty("producerVersion")&&(b.producerVersion=s.producerVersion),s.domain!=null&&s.hasOwnProperty("domain")&&(b.domain=s.domain),s.modelVersion!=null&&s.hasOwnProperty("modelVersion")&&(typeof s.modelVersion=="number"?b.modelVersion=_.longs===String?String(s.modelVersion):s.modelVersion:b.modelVersion=_.longs===String?it.Long.prototype.toString.call(s.modelVersion):_.longs===Number?new it.LongBits(s.modelVersion.low>>>0,s.modelVersion.high>>>0).toNumber():s.modelVersion),s.docString!=null&&s.hasOwnProperty("docString")&&(b.docString=s.docString),s.graph!=null&&s.hasOwnProperty("graph")&&(b.graph=$.onnx.GraphProto.toObject(s.graph,_)),s.opsetImport&&s.opsetImport.length){b.opsetImport=[];for(var dt=0;dt<s.opsetImport.length;++dt)b.opsetImport[dt]=$.onnx.OperatorSetIdProto.toObject(s.opsetImport[dt],_)}if(s.metadataProps&&s.metadataProps.length)for(b.metadataProps=[],dt=0;dt<s.metadataProps.length;++dt)b.metadataProps[dt]=$.onnx.StringStringEntryProto.toObject(s.metadataProps[dt],_);return b},c.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},c}(),g.StringStringEntryProto=function(){function c(s){if(s)for(var _=Object.keys(s),b=0;b<_.length;++b)s[_[b]]!=null&&(this[_[b]]=s[_[b]])}return c.prototype.key="",c.prototype.value="",c.create=function(s){return new c(s)},c.encode=function(s,_){return _||(_=ot.create()),s.key!=null&&s.hasOwnProperty("key")&&_.uint32(10).string(s.key),s.value!=null&&s.hasOwnProperty("value")&&_.uint32(18).string(s.value),_},c.encodeDelimited=function(s,_){return this.encode(s,_).ldelim()},c.decode=function(s,_){s instanceof et||(s=et.create(s));for(var b=_===void 0?s.len:s.pos+_,st=new $.onnx.StringStringEntryProto;s.pos<b;){var dt=s.uint32();switch(dt>>>3){case 1:st.key=s.string();break;case 2:st.value=s.string();break;default:s.skipType(7&dt)}}return st},c.decodeDelimited=function(s){return s instanceof et||(s=new et(s)),this.decode(s,s.uint32())},c.verify=function(s){return typeof s!="object"||s===null?"object expected":s.key!=null&&s.hasOwnProperty("key")&&!it.isString(s.key)?"key: string expected":s.value!=null&&s.hasOwnProperty("value")&&!it.isString(s.value)?"value: string expected":null},c.fromObject=function(s){if(s instanceof $.onnx.StringStringEntryProto)return s;var _=new $.onnx.StringStringEntryProto;return s.key!=null&&(_.key=String(s.key)),s.value!=null&&(_.value=String(s.value)),_},c.toObject=function(s,_){_||(_={});var b={};return _.defaults&&(b.key="",b.value=""),s.key!=null&&s.hasOwnProperty("key")&&(b.key=s.key),s.value!=null&&s.hasOwnProperty("value")&&(b.value=s.value),b},c.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},c}(),g.TensorAnnotation=function(){function c(s){if(this.quantParameterTensorNames=[],s)for(var _=Object.keys(s),b=0;b<_.length;++b)s[_[b]]!=null&&(this[_[b]]=s[_[b]])}return c.prototype.tensorName="",c.prototype.quantParameterTensorNames=it.emptyArray,c.create=function(s){return new c(s)},c.encode=function(s,_){if(_||(_=ot.create()),s.tensorName!=null&&s.hasOwnProperty("tensorName")&&_.uint32(10).string(s.tensorName),s.quantParameterTensorNames!=null&&s.quantParameterTensorNames.length)for(var b=0;b<s.quantParameterTensorNames.length;++b)$.onnx.StringStringEntryProto.encode(s.quantParameterTensorNames[b],_.uint32(18).fork()).ldelim();return _},c.encodeDelimited=function(s,_){return this.encode(s,_).ldelim()},c.decode=function(s,_){s instanceof et||(s=et.create(s));for(var b=_===void 0?s.len:s.pos+_,st=new $.onnx.TensorAnnotation;s.pos<b;){var dt=s.uint32();switch(dt>>>3){case 1:st.tensorName=s.string();break;case 2:st.quantParameterTensorNames&&st.quantParameterTensorNames.length||(st.quantParameterTensorNames=[]),st.quantParameterTensorNames.push($.onnx.StringStringEntryProto.decode(s,s.uint32()));break;default:s.skipType(7&dt)}}return st},c.decodeDelimited=function(s){return s instanceof et||(s=new et(s)),this.decode(s,s.uint32())},c.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.tensorName!=null&&s.hasOwnProperty("tensorName")&&!it.isString(s.tensorName))return"tensorName: string expected";if(s.quantParameterTensorNames!=null&&s.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(s.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var _=0;_<s.quantParameterTensorNames.length;++_){var b=$.onnx.StringStringEntryProto.verify(s.quantParameterTensorNames[_]);if(b)return"quantParameterTensorNames."+b}}return null},c.fromObject=function(s){if(s instanceof $.onnx.TensorAnnotation)return s;var _=new $.onnx.TensorAnnotation;if(s.tensorName!=null&&(_.tensorName=String(s.tensorName)),s.quantParameterTensorNames){if(!Array.isArray(s.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");_.quantParameterTensorNames=[];for(var b=0;b<s.quantParameterTensorNames.length;++b){if(typeof s.quantParameterTensorNames[b]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");_.quantParameterTensorNames[b]=$.onnx.StringStringEntryProto.fromObject(s.quantParameterTensorNames[b])}}return _},c.toObject=function(s,_){_||(_={});var b={};if((_.arrays||_.defaults)&&(b.quantParameterTensorNames=[]),_.defaults&&(b.tensorName=""),s.tensorName!=null&&s.hasOwnProperty("tensorName")&&(b.tensorName=s.tensorName),s.quantParameterTensorNames&&s.quantParameterTensorNames.length){b.quantParameterTensorNames=[];for(var st=0;st<s.quantParameterTensorNames.length;++st)b.quantParameterTensorNames[st]=$.onnx.StringStringEntryProto.toObject(s.quantParameterTensorNames[st],_)}return b},c.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},c}(),g.GraphProto=function(){function c(s){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],s)for(var _=Object.keys(s),b=0;b<_.length;++b)s[_[b]]!=null&&(this[_[b]]=s[_[b]])}return c.prototype.node=it.emptyArray,c.prototype.name="",c.prototype.initializer=it.emptyArray,c.prototype.docString="",c.prototype.input=it.emptyArray,c.prototype.output=it.emptyArray,c.prototype.valueInfo=it.emptyArray,c.prototype.quantizationAnnotation=it.emptyArray,c.create=function(s){return new c(s)},c.encode=function(s,_){if(_||(_=ot.create()),s.node!=null&&s.node.length)for(var b=0;b<s.node.length;++b)$.onnx.NodeProto.encode(s.node[b],_.uint32(10).fork()).ldelim();if(s.name!=null&&s.hasOwnProperty("name")&&_.uint32(18).string(s.name),s.initializer!=null&&s.initializer.length)for(b=0;b<s.initializer.length;++b)$.onnx.TensorProto.encode(s.initializer[b],_.uint32(42).fork()).ldelim();if(s.docString!=null&&s.hasOwnProperty("docString")&&_.uint32(82).string(s.docString),s.input!=null&&s.input.length)for(b=0;b<s.input.length;++b)$.onnx.ValueInfoProto.encode(s.input[b],_.uint32(90).fork()).ldelim();if(s.output!=null&&s.output.length)for(b=0;b<s.output.length;++b)$.onnx.ValueInfoProto.encode(s.output[b],_.uint32(98).fork()).ldelim();if(s.valueInfo!=null&&s.valueInfo.length)for(b=0;b<s.valueInfo.length;++b)$.onnx.ValueInfoProto.encode(s.valueInfo[b],_.uint32(106).fork()).ldelim();if(s.quantizationAnnotation!=null&&s.quantizationAnnotation.length)for(b=0;b<s.quantizationAnnotation.length;++b)$.onnx.TensorAnnotation.encode(s.quantizationAnnotation[b],_.uint32(114).fork()).ldelim();return _},c.encodeDelimited=function(s,_){return this.encode(s,_).ldelim()},c.decode=function(s,_){s instanceof et||(s=et.create(s));for(var b=_===void 0?s.len:s.pos+_,st=new $.onnx.GraphProto;s.pos<b;){var dt=s.uint32();switch(dt>>>3){case 1:st.node&&st.node.length||(st.node=[]),st.node.push($.onnx.NodeProto.decode(s,s.uint32()));break;case 2:st.name=s.string();break;case 5:st.initializer&&st.initializer.length||(st.initializer=[]),st.initializer.push($.onnx.TensorProto.decode(s,s.uint32()));break;case 10:st.docString=s.string();break;case 11:st.input&&st.input.length||(st.input=[]),st.input.push($.onnx.ValueInfoProto.decode(s,s.uint32()));break;case 12:st.output&&st.output.length||(st.output=[]),st.output.push($.onnx.ValueInfoProto.decode(s,s.uint32()));break;case 13:st.valueInfo&&st.valueInfo.length||(st.valueInfo=[]),st.valueInfo.push($.onnx.ValueInfoProto.decode(s,s.uint32()));break;case 14:st.quantizationAnnotation&&st.quantizationAnnotation.length||(st.quantizationAnnotation=[]),st.quantizationAnnotation.push($.onnx.TensorAnnotation.decode(s,s.uint32()));break;default:s.skipType(7&dt)}}return st},c.decodeDelimited=function(s){return s instanceof et||(s=new et(s)),this.decode(s,s.uint32())},c.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.node!=null&&s.hasOwnProperty("node")){if(!Array.isArray(s.node))return"node: array expected";for(var _=0;_<s.node.length;++_)if(b=$.onnx.NodeProto.verify(s.node[_]))return"node."+b}if(s.name!=null&&s.hasOwnProperty("name")&&!it.isString(s.name))return"name: string expected";if(s.initializer!=null&&s.hasOwnProperty("initializer")){if(!Array.isArray(s.initializer))return"initializer: array expected";for(_=0;_<s.initializer.length;++_)if(b=$.onnx.TensorProto.verify(s.initializer[_]))return"initializer."+b}if(s.docString!=null&&s.hasOwnProperty("docString")&&!it.isString(s.docString))return"docString: string expected";if(s.input!=null&&s.hasOwnProperty("input")){if(!Array.isArray(s.input))return"input: array expected";for(_=0;_<s.input.length;++_)if(b=$.onnx.ValueInfoProto.verify(s.input[_]))return"input."+b}if(s.output!=null&&s.hasOwnProperty("output")){if(!Array.isArray(s.output))return"output: array expected";for(_=0;_<s.output.length;++_)if(b=$.onnx.ValueInfoProto.verify(s.output[_]))return"output."+b}if(s.valueInfo!=null&&s.hasOwnProperty("valueInfo")){if(!Array.isArray(s.valueInfo))return"valueInfo: array expected";for(_=0;_<s.valueInfo.length;++_)if(b=$.onnx.ValueInfoProto.verify(s.valueInfo[_]))return"valueInfo."+b}if(s.quantizationAnnotation!=null&&s.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(s.quantizationAnnotation))return"quantizationAnnotation: array expected";for(_=0;_<s.quantizationAnnotation.length;++_){var b;if(b=$.onnx.TensorAnnotation.verify(s.quantizationAnnotation[_]))return"quantizationAnnotation."+b}}return null},c.fromObject=function(s){if(s instanceof $.onnx.GraphProto)return s;var _=new $.onnx.GraphProto;if(s.node){if(!Array.isArray(s.node))throw TypeError(".onnx.GraphProto.node: array expected");_.node=[];for(var b=0;b<s.node.length;++b){if(typeof s.node[b]!="object")throw TypeError(".onnx.GraphProto.node: object expected");_.node[b]=$.onnx.NodeProto.fromObject(s.node[b])}}if(s.name!=null&&(_.name=String(s.name)),s.initializer){if(!Array.isArray(s.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(_.initializer=[],b=0;b<s.initializer.length;++b){if(typeof s.initializer[b]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");_.initializer[b]=$.onnx.TensorProto.fromObject(s.initializer[b])}}if(s.docString!=null&&(_.docString=String(s.docString)),s.input){if(!Array.isArray(s.input))throw TypeError(".onnx.GraphProto.input: array expected");for(_.input=[],b=0;b<s.input.length;++b){if(typeof s.input[b]!="object")throw TypeError(".onnx.GraphProto.input: object expected");_.input[b]=$.onnx.ValueInfoProto.fromObject(s.input[b])}}if(s.output){if(!Array.isArray(s.output))throw TypeError(".onnx.GraphProto.output: array expected");for(_.output=[],b=0;b<s.output.length;++b){if(typeof s.output[b]!="object")throw TypeError(".onnx.GraphProto.output: object expected");_.output[b]=$.onnx.ValueInfoProto.fromObject(s.output[b])}}if(s.valueInfo){if(!Array.isArray(s.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(_.valueInfo=[],b=0;b<s.valueInfo.length;++b){if(typeof s.valueInfo[b]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");_.valueInfo[b]=$.onnx.ValueInfoProto.fromObject(s.valueInfo[b])}}if(s.quantizationAnnotation){if(!Array.isArray(s.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(_.quantizationAnnotation=[],b=0;b<s.quantizationAnnotation.length;++b){if(typeof s.quantizationAnnotation[b]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");_.quantizationAnnotation[b]=$.onnx.TensorAnnotation.fromObject(s.quantizationAnnotation[b])}}return _},c.toObject=function(s,_){_||(_={});var b={};if((_.arrays||_.defaults)&&(b.node=[],b.initializer=[],b.input=[],b.output=[],b.valueInfo=[],b.quantizationAnnotation=[]),_.defaults&&(b.name="",b.docString=""),s.node&&s.node.length){b.node=[];for(var st=0;st<s.node.length;++st)b.node[st]=$.onnx.NodeProto.toObject(s.node[st],_)}if(s.name!=null&&s.hasOwnProperty("name")&&(b.name=s.name),s.initializer&&s.initializer.length)for(b.initializer=[],st=0;st<s.initializer.length;++st)b.initializer[st]=$.onnx.TensorProto.toObject(s.initializer[st],_);if(s.docString!=null&&s.hasOwnProperty("docString")&&(b.docString=s.docString),s.input&&s.input.length)for(b.input=[],st=0;st<s.input.length;++st)b.input[st]=$.onnx.ValueInfoProto.toObject(s.input[st],_);if(s.output&&s.output.length)for(b.output=[],st=0;st<s.output.length;++st)b.output[st]=$.onnx.ValueInfoProto.toObject(s.output[st],_);if(s.valueInfo&&s.valueInfo.length)for(b.valueInfo=[],st=0;st<s.valueInfo.length;++st)b.valueInfo[st]=$.onnx.ValueInfoProto.toObject(s.valueInfo[st],_);if(s.quantizationAnnotation&&s.quantizationAnnotation.length)for(b.quantizationAnnotation=[],st=0;st<s.quantizationAnnotation.length;++st)b.quantizationAnnotation[st]=$.onnx.TensorAnnotation.toObject(s.quantizationAnnotation[st],_);return b},c.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},c}(),g.TensorProto=function(){function c(s){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],s)for(var _=Object.keys(s),b=0;b<_.length;++b)s[_[b]]!=null&&(this[_[b]]=s[_[b]])}return c.prototype.dims=it.emptyArray,c.prototype.dataType=0,c.prototype.segment=null,c.prototype.floatData=it.emptyArray,c.prototype.int32Data=it.emptyArray,c.prototype.stringData=it.emptyArray,c.prototype.int64Data=it.emptyArray,c.prototype.name="",c.prototype.docString="",c.prototype.rawData=it.newBuffer([]),c.prototype.externalData=it.emptyArray,c.prototype.dataLocation=0,c.prototype.doubleData=it.emptyArray,c.prototype.uint64Data=it.emptyArray,c.create=function(s){return new c(s)},c.encode=function(s,_){if(_||(_=ot.create()),s.dims!=null&&s.dims.length){_.uint32(10).fork();for(var b=0;b<s.dims.length;++b)_.int64(s.dims[b]);_.ldelim()}if(s.dataType!=null&&s.hasOwnProperty("dataType")&&_.uint32(16).int32(s.dataType),s.segment!=null&&s.hasOwnProperty("segment")&&$.onnx.TensorProto.Segment.encode(s.segment,_.uint32(26).fork()).ldelim(),s.floatData!=null&&s.floatData.length){for(_.uint32(34).fork(),b=0;b<s.floatData.length;++b)_.float(s.floatData[b]);_.ldelim()}if(s.int32Data!=null&&s.int32Data.length){for(_.uint32(42).fork(),b=0;b<s.int32Data.length;++b)_.int32(s.int32Data[b]);_.ldelim()}if(s.stringData!=null&&s.stringData.length)for(b=0;b<s.stringData.length;++b)_.uint32(50).bytes(s.stringData[b]);if(s.int64Data!=null&&s.int64Data.length){for(_.uint32(58).fork(),b=0;b<s.int64Data.length;++b)_.int64(s.int64Data[b]);_.ldelim()}if(s.name!=null&&s.hasOwnProperty("name")&&_.uint32(66).string(s.name),s.rawData!=null&&s.hasOwnProperty("rawData")&&_.uint32(74).bytes(s.rawData),s.doubleData!=null&&s.doubleData.length){for(_.uint32(82).fork(),b=0;b<s.doubleData.length;++b)_.double(s.doubleData[b]);_.ldelim()}if(s.uint64Data!=null&&s.uint64Data.length){for(_.uint32(90).fork(),b=0;b<s.uint64Data.length;++b)_.uint64(s.uint64Data[b]);_.ldelim()}if(s.docString!=null&&s.hasOwnProperty("docString")&&_.uint32(98).string(s.docString),s.externalData!=null&&s.externalData.length)for(b=0;b<s.externalData.length;++b)$.onnx.StringStringEntryProto.encode(s.externalData[b],_.uint32(106).fork()).ldelim();return s.dataLocation!=null&&s.hasOwnProperty("dataLocation")&&_.uint32(112).int32(s.dataLocation),_},c.encodeDelimited=function(s,_){return this.encode(s,_).ldelim()},c.decode=function(s,_){s instanceof et||(s=et.create(s));for(var b=_===void 0?s.len:s.pos+_,st=new $.onnx.TensorProto;s.pos<b;){var dt=s.uint32();switch(dt>>>3){case 1:if(st.dims&&st.dims.length||(st.dims=[]),(7&dt)==2)for(var ct=s.uint32()+s.pos;s.pos<ct;)st.dims.push(s.int64());else st.dims.push(s.int64());break;case 2:st.dataType=s.int32();break;case 3:st.segment=$.onnx.TensorProto.Segment.decode(s,s.uint32());break;case 4:if(st.floatData&&st.floatData.length||(st.floatData=[]),(7&dt)==2)for(ct=s.uint32()+s.pos;s.pos<ct;)st.floatData.push(s.float());else st.floatData.push(s.float());break;case 5:if(st.int32Data&&st.int32Data.length||(st.int32Data=[]),(7&dt)==2)for(ct=s.uint32()+s.pos;s.pos<ct;)st.int32Data.push(s.int32());else st.int32Data.push(s.int32());break;case 6:st.stringData&&st.stringData.length||(st.stringData=[]),st.stringData.push(s.bytes());break;case 7:if(st.int64Data&&st.int64Data.length||(st.int64Data=[]),(7&dt)==2)for(ct=s.uint32()+s.pos;s.pos<ct;)st.int64Data.push(s.int64());else st.int64Data.push(s.int64());break;case 8:st.name=s.string();break;case 12:st.docString=s.string();break;case 9:st.rawData=s.bytes();break;case 13:st.externalData&&st.externalData.length||(st.externalData=[]),st.externalData.push($.onnx.StringStringEntryProto.decode(s,s.uint32()));break;case 14:st.dataLocation=s.int32();break;case 10:if(st.doubleData&&st.doubleData.length||(st.doubleData=[]),(7&dt)==2)for(ct=s.uint32()+s.pos;s.pos<ct;)st.doubleData.push(s.double());else st.doubleData.push(s.double());break;case 11:if(st.uint64Data&&st.uint64Data.length||(st.uint64Data=[]),(7&dt)==2)for(ct=s.uint32()+s.pos;s.pos<ct;)st.uint64Data.push(s.uint64());else st.uint64Data.push(s.uint64());break;default:s.skipType(7&dt)}}return st},c.decodeDelimited=function(s){return s instanceof et||(s=new et(s)),this.decode(s,s.uint32())},c.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.dims!=null&&s.hasOwnProperty("dims")){if(!Array.isArray(s.dims))return"dims: array expected";for(var _=0;_<s.dims.length;++_)if(!(it.isInteger(s.dims[_])||s.dims[_]&&it.isInteger(s.dims[_].low)&&it.isInteger(s.dims[_].high)))return"dims: integer|Long[] expected"}if(s.dataType!=null&&s.hasOwnProperty("dataType")&&!it.isInteger(s.dataType))return"dataType: integer expected";if(s.segment!=null&&s.hasOwnProperty("segment")&&(b=$.onnx.TensorProto.Segment.verify(s.segment)))return"segment."+b;if(s.floatData!=null&&s.hasOwnProperty("floatData")){if(!Array.isArray(s.floatData))return"floatData: array expected";for(_=0;_<s.floatData.length;++_)if(typeof s.floatData[_]!="number")return"floatData: number[] expected"}if(s.int32Data!=null&&s.hasOwnProperty("int32Data")){if(!Array.isArray(s.int32Data))return"int32Data: array expected";for(_=0;_<s.int32Data.length;++_)if(!it.isInteger(s.int32Data[_]))return"int32Data: integer[] expected"}if(s.stringData!=null&&s.hasOwnProperty("stringData")){if(!Array.isArray(s.stringData))return"stringData: array expected";for(_=0;_<s.stringData.length;++_)if(!(s.stringData[_]&&typeof s.stringData[_].length=="number"||it.isString(s.stringData[_])))return"stringData: buffer[] expected"}if(s.int64Data!=null&&s.hasOwnProperty("int64Data")){if(!Array.isArray(s.int64Data))return"int64Data: array expected";for(_=0;_<s.int64Data.length;++_)if(!(it.isInteger(s.int64Data[_])||s.int64Data[_]&&it.isInteger(s.int64Data[_].low)&&it.isInteger(s.int64Data[_].high)))return"int64Data: integer|Long[] expected"}if(s.name!=null&&s.hasOwnProperty("name")&&!it.isString(s.name))return"name: string expected";if(s.docString!=null&&s.hasOwnProperty("docString")&&!it.isString(s.docString))return"docString: string expected";if(s.rawData!=null&&s.hasOwnProperty("rawData")&&!(s.rawData&&typeof s.rawData.length=="number"||it.isString(s.rawData)))return"rawData: buffer expected";if(s.externalData!=null&&s.hasOwnProperty("externalData")){if(!Array.isArray(s.externalData))return"externalData: array expected";for(_=0;_<s.externalData.length;++_){var b;if(b=$.onnx.StringStringEntryProto.verify(s.externalData[_]))return"externalData."+b}}if(s.dataLocation!=null&&s.hasOwnProperty("dataLocation"))switch(s.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(s.doubleData!=null&&s.hasOwnProperty("doubleData")){if(!Array.isArray(s.doubleData))return"doubleData: array expected";for(_=0;_<s.doubleData.length;++_)if(typeof s.doubleData[_]!="number")return"doubleData: number[] expected"}if(s.uint64Data!=null&&s.hasOwnProperty("uint64Data")){if(!Array.isArray(s.uint64Data))return"uint64Data: array expected";for(_=0;_<s.uint64Data.length;++_)if(!(it.isInteger(s.uint64Data[_])||s.uint64Data[_]&&it.isInteger(s.uint64Data[_].low)&&it.isInteger(s.uint64Data[_].high)))return"uint64Data: integer|Long[] expected"}return null},c.fromObject=function(s){if(s instanceof $.onnx.TensorProto)return s;var _=new $.onnx.TensorProto;if(s.dims){if(!Array.isArray(s.dims))throw TypeError(".onnx.TensorProto.dims: array expected");_.dims=[];for(var b=0;b<s.dims.length;++b)it.Long?(_.dims[b]=it.Long.fromValue(s.dims[b])).unsigned=!1:typeof s.dims[b]=="string"?_.dims[b]=parseInt(s.dims[b],10):typeof s.dims[b]=="number"?_.dims[b]=s.dims[b]:typeof s.dims[b]=="object"&&(_.dims[b]=new it.LongBits(s.dims[b].low>>>0,s.dims[b].high>>>0).toNumber())}if(s.dataType!=null&&(_.dataType=0|s.dataType),s.segment!=null){if(typeof s.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");_.segment=$.onnx.TensorProto.Segment.fromObject(s.segment)}if(s.floatData){if(!Array.isArray(s.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(_.floatData=[],b=0;b<s.floatData.length;++b)_.floatData[b]=Number(s.floatData[b])}if(s.int32Data){if(!Array.isArray(s.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(_.int32Data=[],b=0;b<s.int32Data.length;++b)_.int32Data[b]=0|s.int32Data[b]}if(s.stringData){if(!Array.isArray(s.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(_.stringData=[],b=0;b<s.stringData.length;++b)typeof s.stringData[b]=="string"?it.base64.decode(s.stringData[b],_.stringData[b]=it.newBuffer(it.base64.length(s.stringData[b])),0):s.stringData[b].length&&(_.stringData[b]=s.stringData[b])}if(s.int64Data){if(!Array.isArray(s.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(_.int64Data=[],b=0;b<s.int64Data.length;++b)it.Long?(_.int64Data[b]=it.Long.fromValue(s.int64Data[b])).unsigned=!1:typeof s.int64Data[b]=="string"?_.int64Data[b]=parseInt(s.int64Data[b],10):typeof s.int64Data[b]=="number"?_.int64Data[b]=s.int64Data[b]:typeof s.int64Data[b]=="object"&&(_.int64Data[b]=new it.LongBits(s.int64Data[b].low>>>0,s.int64Data[b].high>>>0).toNumber())}if(s.name!=null&&(_.name=String(s.name)),s.docString!=null&&(_.docString=String(s.docString)),s.rawData!=null&&(typeof s.rawData=="string"?it.base64.decode(s.rawData,_.rawData=it.newBuffer(it.base64.length(s.rawData)),0):s.rawData.length&&(_.rawData=s.rawData)),s.externalData){if(!Array.isArray(s.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(_.externalData=[],b=0;b<s.externalData.length;++b){if(typeof s.externalData[b]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");_.externalData[b]=$.onnx.StringStringEntryProto.fromObject(s.externalData[b])}}switch(s.dataLocation){case"DEFAULT":case 0:_.dataLocation=0;break;case"EXTERNAL":case 1:_.dataLocation=1}if(s.doubleData){if(!Array.isArray(s.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(_.doubleData=[],b=0;b<s.doubleData.length;++b)_.doubleData[b]=Number(s.doubleData[b])}if(s.uint64Data){if(!Array.isArray(s.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(_.uint64Data=[],b=0;b<s.uint64Data.length;++b)it.Long?(_.uint64Data[b]=it.Long.fromValue(s.uint64Data[b])).unsigned=!0:typeof s.uint64Data[b]=="string"?_.uint64Data[b]=parseInt(s.uint64Data[b],10):typeof s.uint64Data[b]=="number"?_.uint64Data[b]=s.uint64Data[b]:typeof s.uint64Data[b]=="object"&&(_.uint64Data[b]=new it.LongBits(s.uint64Data[b].low>>>0,s.uint64Data[b].high>>>0).toNumber(!0))}return _},c.toObject=function(s,_){_||(_={});var b={};if((_.arrays||_.defaults)&&(b.dims=[],b.floatData=[],b.int32Data=[],b.stringData=[],b.int64Data=[],b.doubleData=[],b.uint64Data=[],b.externalData=[]),_.defaults&&(b.dataType=0,b.segment=null,b.name="",_.bytes===String?b.rawData="":(b.rawData=[],_.bytes!==Array&&(b.rawData=it.newBuffer(b.rawData))),b.docString="",b.dataLocation=_.enums===String?"DEFAULT":0),s.dims&&s.dims.length){b.dims=[];for(var st=0;st<s.dims.length;++st)typeof s.dims[st]=="number"?b.dims[st]=_.longs===String?String(s.dims[st]):s.dims[st]:b.dims[st]=_.longs===String?it.Long.prototype.toString.call(s.dims[st]):_.longs===Number?new it.LongBits(s.dims[st].low>>>0,s.dims[st].high>>>0).toNumber():s.dims[st]}if(s.dataType!=null&&s.hasOwnProperty("dataType")&&(b.dataType=s.dataType),s.segment!=null&&s.hasOwnProperty("segment")&&(b.segment=$.onnx.TensorProto.Segment.toObject(s.segment,_)),s.floatData&&s.floatData.length)for(b.floatData=[],st=0;st<s.floatData.length;++st)b.floatData[st]=_.json&&!isFinite(s.floatData[st])?String(s.floatData[st]):s.floatData[st];if(s.int32Data&&s.int32Data.length)for(b.int32Data=[],st=0;st<s.int32Data.length;++st)b.int32Data[st]=s.int32Data[st];if(s.stringData&&s.stringData.length)for(b.stringData=[],st=0;st<s.stringData.length;++st)b.stringData[st]=_.bytes===String?it.base64.encode(s.stringData[st],0,s.stringData[st].length):_.bytes===Array?Array.prototype.slice.call(s.stringData[st]):s.stringData[st];if(s.int64Data&&s.int64Data.length)for(b.int64Data=[],st=0;st<s.int64Data.length;++st)typeof s.int64Data[st]=="number"?b.int64Data[st]=_.longs===String?String(s.int64Data[st]):s.int64Data[st]:b.int64Data[st]=_.longs===String?it.Long.prototype.toString.call(s.int64Data[st]):_.longs===Number?new it.LongBits(s.int64Data[st].low>>>0,s.int64Data[st].high>>>0).toNumber():s.int64Data[st];if(s.name!=null&&s.hasOwnProperty("name")&&(b.name=s.name),s.rawData!=null&&s.hasOwnProperty("rawData")&&(b.rawData=_.bytes===String?it.base64.encode(s.rawData,0,s.rawData.length):_.bytes===Array?Array.prototype.slice.call(s.rawData):s.rawData),s.doubleData&&s.doubleData.length)for(b.doubleData=[],st=0;st<s.doubleData.length;++st)b.doubleData[st]=_.json&&!isFinite(s.doubleData[st])?String(s.doubleData[st]):s.doubleData[st];if(s.uint64Data&&s.uint64Data.length)for(b.uint64Data=[],st=0;st<s.uint64Data.length;++st)typeof s.uint64Data[st]=="number"?b.uint64Data[st]=_.longs===String?String(s.uint64Data[st]):s.uint64Data[st]:b.uint64Data[st]=_.longs===String?it.Long.prototype.toString.call(s.uint64Data[st]):_.longs===Number?new it.LongBits(s.uint64Data[st].low>>>0,s.uint64Data[st].high>>>0).toNumber(!0):s.uint64Data[st];if(s.docString!=null&&s.hasOwnProperty("docString")&&(b.docString=s.docString),s.externalData&&s.externalData.length)for(b.externalData=[],st=0;st<s.externalData.length;++st)b.externalData[st]=$.onnx.StringStringEntryProto.toObject(s.externalData[st],_);return s.dataLocation!=null&&s.hasOwnProperty("dataLocation")&&(b.dataLocation=_.enums===String?$.onnx.TensorProto.DataLocation[s.dataLocation]:s.dataLocation),b},c.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},c.DataType=function(){var s={},_=Object.create(s);return _[s[0]="UNDEFINED"]=0,_[s[1]="FLOAT"]=1,_[s[2]="UINT8"]=2,_[s[3]="INT8"]=3,_[s[4]="UINT16"]=4,_[s[5]="INT16"]=5,_[s[6]="INT32"]=6,_[s[7]="INT64"]=7,_[s[8]="STRING"]=8,_[s[9]="BOOL"]=9,_[s[10]="FLOAT16"]=10,_[s[11]="DOUBLE"]=11,_[s[12]="UINT32"]=12,_[s[13]="UINT64"]=13,_[s[14]="COMPLEX64"]=14,_[s[15]="COMPLEX128"]=15,_[s[16]="BFLOAT16"]=16,_}(),c.Segment=function(){function s(_){if(_)for(var b=Object.keys(_),st=0;st<b.length;++st)_[b[st]]!=null&&(this[b[st]]=_[b[st]])}return s.prototype.begin=it.Long?it.Long.fromBits(0,0,!1):0,s.prototype.end=it.Long?it.Long.fromBits(0,0,!1):0,s.create=function(_){return new s(_)},s.encode=function(_,b){return b||(b=ot.create()),_.begin!=null&&_.hasOwnProperty("begin")&&b.uint32(8).int64(_.begin),_.end!=null&&_.hasOwnProperty("end")&&b.uint32(16).int64(_.end),b},s.encodeDelimited=function(_,b){return this.encode(_,b).ldelim()},s.decode=function(_,b){_ instanceof et||(_=et.create(_));for(var st=b===void 0?_.len:_.pos+b,dt=new $.onnx.TensorProto.Segment;_.pos<st;){var ct=_.uint32();switch(ct>>>3){case 1:dt.begin=_.int64();break;case 2:dt.end=_.int64();break;default:_.skipType(7&ct)}}return dt},s.decodeDelimited=function(_){return _ instanceof et||(_=new et(_)),this.decode(_,_.uint32())},s.verify=function(_){return typeof _!="object"||_===null?"object expected":_.begin!=null&&_.hasOwnProperty("begin")&&!(it.isInteger(_.begin)||_.begin&&it.isInteger(_.begin.low)&&it.isInteger(_.begin.high))?"begin: integer|Long expected":_.end!=null&&_.hasOwnProperty("end")&&!(it.isInteger(_.end)||_.end&&it.isInteger(_.end.low)&&it.isInteger(_.end.high))?"end: integer|Long expected":null},s.fromObject=function(_){if(_ instanceof $.onnx.TensorProto.Segment)return _;var b=new $.onnx.TensorProto.Segment;return _.begin!=null&&(it.Long?(b.begin=it.Long.fromValue(_.begin)).unsigned=!1:typeof _.begin=="string"?b.begin=parseInt(_.begin,10):typeof _.begin=="number"?b.begin=_.begin:typeof _.begin=="object"&&(b.begin=new it.LongBits(_.begin.low>>>0,_.begin.high>>>0).toNumber())),_.end!=null&&(it.Long?(b.end=it.Long.fromValue(_.end)).unsigned=!1:typeof _.end=="string"?b.end=parseInt(_.end,10):typeof _.end=="number"?b.end=_.end:typeof _.end=="object"&&(b.end=new it.LongBits(_.end.low>>>0,_.end.high>>>0).toNumber())),b},s.toObject=function(_,b){b||(b={});var st={};if(b.defaults){if(it.Long){var dt=new it.Long(0,0,!1);st.begin=b.longs===String?dt.toString():b.longs===Number?dt.toNumber():dt}else st.begin=b.longs===String?"0":0;it.Long?(dt=new it.Long(0,0,!1),st.end=b.longs===String?dt.toString():b.longs===Number?dt.toNumber():dt):st.end=b.longs===String?"0":0}return _.begin!=null&&_.hasOwnProperty("begin")&&(typeof _.begin=="number"?st.begin=b.longs===String?String(_.begin):_.begin:st.begin=b.longs===String?it.Long.prototype.toString.call(_.begin):b.longs===Number?new it.LongBits(_.begin.low>>>0,_.begin.high>>>0).toNumber():_.begin),_.end!=null&&_.hasOwnProperty("end")&&(typeof _.end=="number"?st.end=b.longs===String?String(_.end):_.end:st.end=b.longs===String?it.Long.prototype.toString.call(_.end):b.longs===Number?new it.LongBits(_.end.low>>>0,_.end.high>>>0).toNumber():_.end),st},s.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},s}(),c.DataLocation=function(){var s={},_=Object.create(s);return _[s[0]="DEFAULT"]=0,_[s[1]="EXTERNAL"]=1,_}(),c}(),g.TensorShapeProto=function(){function c(s){if(this.dim=[],s)for(var _=Object.keys(s),b=0;b<_.length;++b)s[_[b]]!=null&&(this[_[b]]=s[_[b]])}return c.prototype.dim=it.emptyArray,c.create=function(s){return new c(s)},c.encode=function(s,_){if(_||(_=ot.create()),s.dim!=null&&s.dim.length)for(var b=0;b<s.dim.length;++b)$.onnx.TensorShapeProto.Dimension.encode(s.dim[b],_.uint32(10).fork()).ldelim();return _},c.encodeDelimited=function(s,_){return this.encode(s,_).ldelim()},c.decode=function(s,_){s instanceof et||(s=et.create(s));for(var b=_===void 0?s.len:s.pos+_,st=new $.onnx.TensorShapeProto;s.pos<b;){var dt=s.uint32();dt>>>3==1?(st.dim&&st.dim.length||(st.dim=[]),st.dim.push($.onnx.TensorShapeProto.Dimension.decode(s,s.uint32()))):s.skipType(7&dt)}return st},c.decodeDelimited=function(s){return s instanceof et||(s=new et(s)),this.decode(s,s.uint32())},c.verify=function(s){if(typeof s!="object"||s===null)return"object expected";if(s.dim!=null&&s.hasOwnProperty("dim")){if(!Array.isArray(s.dim))return"dim: array expected";for(var _=0;_<s.dim.length;++_){var b=$.onnx.TensorShapeProto.Dimension.verify(s.dim[_]);if(b)return"dim."+b}}return null},c.fromObject=function(s){if(s instanceof $.onnx.TensorShapeProto)return s;var _=new $.onnx.TensorShapeProto;if(s.dim){if(!Array.isArray(s.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");_.dim=[];for(var b=0;b<s.dim.length;++b){if(typeof s.dim[b]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");_.dim[b]=$.onnx.TensorShapeProto.Dimension.fromObject(s.dim[b])}}return _},c.toObject=function(s,_){_||(_={});var b={};if((_.arrays||_.defaults)&&(b.dim=[]),s.dim&&s.dim.length){b.dim=[];for(var st=0;st<s.dim.length;++st)b.dim[st]=$.onnx.TensorShapeProto.Dimension.toObject(s.dim[st],_)}return b},c.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},c.Dimension=function(){function s(b){if(b)for(var st=Object.keys(b),dt=0;dt<st.length;++dt)b[st[dt]]!=null&&(this[st[dt]]=b[st[dt]])}var _;return s.prototype.dimValue=it.Long?it.Long.fromBits(0,0,!1):0,s.prototype.dimParam="",s.prototype.denotation="",Object.defineProperty(s.prototype,"value",{get:it.oneOfGetter(_=["dimValue","dimParam"]),set:it.oneOfSetter(_)}),s.create=function(b){return new s(b)},s.encode=function(b,st){return st||(st=ot.create()),b.dimValue!=null&&b.hasOwnProperty("dimValue")&&st.uint32(8).int64(b.dimValue),b.dimParam!=null&&b.hasOwnProperty("dimParam")&&st.uint32(18).string(b.dimParam),b.denotation!=null&&b.hasOwnProperty("denotation")&&st.uint32(26).string(b.denotation),st},s.encodeDelimited=function(b,st){return this.encode(b,st).ldelim()},s.decode=function(b,st){b instanceof et||(b=et.create(b));for(var dt=st===void 0?b.len:b.pos+st,ct=new $.onnx.TensorShapeProto.Dimension;b.pos<dt;){var pt=b.uint32();switch(pt>>>3){case 1:ct.dimValue=b.int64();break;case 2:ct.dimParam=b.string();break;case 3:ct.denotation=b.string();break;default:b.skipType(7&pt)}}return ct},s.decodeDelimited=function(b){return b instanceof et||(b=new et(b)),this.decode(b,b.uint32())},s.verify=function(b){if(typeof b!="object"||b===null)return"object expected";var st={};if(b.dimValue!=null&&b.hasOwnProperty("dimValue")&&(st.value=1,!(it.isInteger(b.dimValue)||b.dimValue&&it.isInteger(b.dimValue.low)&&it.isInteger(b.dimValue.high))))return"dimValue: integer|Long expected";if(b.dimParam!=null&&b.hasOwnProperty("dimParam")){if(st.value===1)return"value: multiple values";if(st.value=1,!it.isString(b.dimParam))return"dimParam: string expected"}return b.denotation!=null&&b.hasOwnProperty("denotation")&&!it.isString(b.denotation)?"denotation: string expected":null},s.fromObject=function(b){if(b instanceof $.onnx.TensorShapeProto.Dimension)return b;var st=new $.onnx.TensorShapeProto.Dimension;return b.dimValue!=null&&(it.Long?(st.dimValue=it.Long.fromValue(b.dimValue)).unsigned=!1:typeof b.dimValue=="string"?st.dimValue=parseInt(b.dimValue,10):typeof b.dimValue=="number"?st.dimValue=b.dimValue:typeof b.dimValue=="object"&&(st.dimValue=new it.LongBits(b.dimValue.low>>>0,b.dimValue.high>>>0).toNumber())),b.dimParam!=null&&(st.dimParam=String(b.dimParam)),b.denotation!=null&&(st.denotation=String(b.denotation)),st},s.toObject=function(b,st){st||(st={});var dt={};return st.defaults&&(dt.denotation=""),b.dimValue!=null&&b.hasOwnProperty("dimValue")&&(typeof b.dimValue=="number"?dt.dimValue=st.longs===String?String(b.dimValue):b.dimValue:dt.dimValue=st.longs===String?it.Long.prototype.toString.call(b.dimValue):st.longs===Number?new it.LongBits(b.dimValue.low>>>0,b.dimValue.high>>>0).toNumber():b.dimValue,st.oneofs&&(dt.value="dimValue")),b.dimParam!=null&&b.hasOwnProperty("dimParam")&&(dt.dimParam=b.dimParam,st.oneofs&&(dt.value="dimParam")),b.denotation!=null&&b.hasOwnProperty("denotation")&&(dt.denotation=b.denotation),dt},s.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},s}(),c}(),g.TypeProto=function(){function c(_){if(_)for(var b=Object.keys(_),st=0;st<b.length;++st)_[b[st]]!=null&&(this[b[st]]=_[b[st]])}var s;return c.prototype.tensorType=null,c.prototype.denotation="",Object.defineProperty(c.prototype,"value",{get:it.oneOfGetter(s=["tensorType"]),set:it.oneOfSetter(s)}),c.create=function(_){return new c(_)},c.encode=function(_,b){return b||(b=ot.create()),_.tensorType!=null&&_.hasOwnProperty("tensorType")&&$.onnx.TypeProto.Tensor.encode(_.tensorType,b.uint32(10).fork()).ldelim(),_.denotation!=null&&_.hasOwnProperty("denotation")&&b.uint32(50).string(_.denotation),b},c.encodeDelimited=function(_,b){return this.encode(_,b).ldelim()},c.decode=function(_,b){_ instanceof et||(_=et.create(_));for(var st=b===void 0?_.len:_.pos+b,dt=new $.onnx.TypeProto;_.pos<st;){var ct=_.uint32();switch(ct>>>3){case 1:dt.tensorType=$.onnx.TypeProto.Tensor.decode(_,_.uint32());break;case 6:dt.denotation=_.string();break;default:_.skipType(7&ct)}}return dt},c.decodeDelimited=function(_){return _ instanceof et||(_=new et(_)),this.decode(_,_.uint32())},c.verify=function(_){if(typeof _!="object"||_===null)return"object expected";if(_.tensorType!=null&&_.hasOwnProperty("tensorType")){var b=$.onnx.TypeProto.Tensor.verify(_.tensorType);if(b)return"tensorType."+b}return _.denotation!=null&&_.hasOwnProperty("denotation")&&!it.isString(_.denotation)?"denotation: string expected":null},c.fromObject=function(_){if(_ instanceof $.onnx.TypeProto)return _;var b=new $.onnx.TypeProto;if(_.tensorType!=null){if(typeof _.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");b.tensorType=$.onnx.TypeProto.Tensor.fromObject(_.tensorType)}return _.denotation!=null&&(b.denotation=String(_.denotation)),b},c.toObject=function(_,b){b||(b={});var st={};return b.defaults&&(st.denotation=""),_.tensorType!=null&&_.hasOwnProperty("tensorType")&&(st.tensorType=$.onnx.TypeProto.Tensor.toObject(_.tensorType,b),b.oneofs&&(st.value="tensorType")),_.denotation!=null&&_.hasOwnProperty("denotation")&&(st.denotation=_.denotation),st},c.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},c.Tensor=function(){function _(b){if(b)for(var st=Object.keys(b),dt=0;dt<st.length;++dt)b[st[dt]]!=null&&(this[st[dt]]=b[st[dt]])}return _.prototype.elemType=0,_.prototype.shape=null,_.create=function(b){return new _(b)},_.encode=function(b,st){return st||(st=ot.create()),b.elemType!=null&&b.hasOwnProperty("elemType")&&st.uint32(8).int32(b.elemType),b.shape!=null&&b.hasOwnProperty("shape")&&$.onnx.TensorShapeProto.encode(b.shape,st.uint32(18).fork()).ldelim(),st},_.encodeDelimited=function(b,st){return this.encode(b,st).ldelim()},_.decode=function(b,st){b instanceof et||(b=et.create(b));for(var dt=st===void 0?b.len:b.pos+st,ct=new $.onnx.TypeProto.Tensor;b.pos<dt;){var pt=b.uint32();switch(pt>>>3){case 1:ct.elemType=b.int32();break;case 2:ct.shape=$.onnx.TensorShapeProto.decode(b,b.uint32());break;default:b.skipType(7&pt)}}return ct},_.decodeDelimited=function(b){return b instanceof et||(b=new et(b)),this.decode(b,b.uint32())},_.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.elemType!=null&&b.hasOwnProperty("elemType")&&!it.isInteger(b.elemType))return"elemType: integer expected";if(b.shape!=null&&b.hasOwnProperty("shape")){var st=$.onnx.TensorShapeProto.verify(b.shape);if(st)return"shape."+st}return null},_.fromObject=function(b){if(b instanceof $.onnx.TypeProto.Tensor)return b;var st=new $.onnx.TypeProto.Tensor;if(b.elemType!=null&&(st.elemType=0|b.elemType),b.shape!=null){if(typeof b.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");st.shape=$.onnx.TensorShapeProto.fromObject(b.shape)}return st},_.toObject=function(b,st){st||(st={});var dt={};return st.defaults&&(dt.elemType=0,dt.shape=null),b.elemType!=null&&b.hasOwnProperty("elemType")&&(dt.elemType=b.elemType),b.shape!=null&&b.hasOwnProperty("shape")&&(dt.shape=$.onnx.TensorShapeProto.toObject(b.shape,st)),dt},_.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},_}(),c}(),g.OperatorSetIdProto=function(){function c(s){if(s)for(var _=Object.keys(s),b=0;b<_.length;++b)s[_[b]]!=null&&(this[_[b]]=s[_[b]])}return c.prototype.domain="",c.prototype.version=it.Long?it.Long.fromBits(0,0,!1):0,c.create=function(s){return new c(s)},c.encode=function(s,_){return _||(_=ot.create()),s.domain!=null&&s.hasOwnProperty("domain")&&_.uint32(10).string(s.domain),s.version!=null&&s.hasOwnProperty("version")&&_.uint32(16).int64(s.version),_},c.encodeDelimited=function(s,_){return this.encode(s,_).ldelim()},c.decode=function(s,_){s instanceof et||(s=et.create(s));for(var b=_===void 0?s.len:s.pos+_,st=new $.onnx.OperatorSetIdProto;s.pos<b;){var dt=s.uint32();switch(dt>>>3){case 1:st.domain=s.string();break;case 2:st.version=s.int64();break;default:s.skipType(7&dt)}}return st},c.decodeDelimited=function(s){return s instanceof et||(s=new et(s)),this.decode(s,s.uint32())},c.verify=function(s){return typeof s!="object"||s===null?"object expected":s.domain!=null&&s.hasOwnProperty("domain")&&!it.isString(s.domain)?"domain: string expected":s.version!=null&&s.hasOwnProperty("version")&&!(it.isInteger(s.version)||s.version&&it.isInteger(s.version.low)&&it.isInteger(s.version.high))?"version: integer|Long expected":null},c.fromObject=function(s){if(s instanceof $.onnx.OperatorSetIdProto)return s;var _=new $.onnx.OperatorSetIdProto;return s.domain!=null&&(_.domain=String(s.domain)),s.version!=null&&(it.Long?(_.version=it.Long.fromValue(s.version)).unsigned=!1:typeof s.version=="string"?_.version=parseInt(s.version,10):typeof s.version=="number"?_.version=s.version:typeof s.version=="object"&&(_.version=new it.LongBits(s.version.low>>>0,s.version.high>>>0).toNumber())),_},c.toObject=function(s,_){_||(_={});var b={};if(_.defaults)if(b.domain="",it.Long){var st=new it.Long(0,0,!1);b.version=_.longs===String?st.toString():_.longs===Number?st.toNumber():st}else b.version=_.longs===String?"0":0;return s.domain!=null&&s.hasOwnProperty("domain")&&(b.domain=s.domain),s.version!=null&&s.hasOwnProperty("version")&&(typeof s.version=="number"?b.version=_.longs===String?String(s.version):s.version:b.version=_.longs===String?it.Long.prototype.toString.call(s.version):_.longs===Number?new it.LongBits(s.version.low>>>0,s.version.high>>>0).toNumber():s.version),b},c.prototype.toJSON=function(){return this.constructor.toObject(this,h.util.toJSONOptions)},c}(),g),i.exports=$},2100:(i,e,o)=>{i.exports=o(9482)},9482:(i,e,o)=>{var a=e;function d(){a.util._configure(),a.Writer._configure(a.BufferWriter),a.Reader._configure(a.BufferReader)}a.build="minimal",a.Writer=o(1173),a.BufferWriter=o(3155),a.Reader=o(1408),a.BufferReader=o(593),a.util=o(9693),a.rpc=o(5994),a.roots=o(5054),a.configure=d,d()},1408:(i,e,o)=>{i.exports=ot;var a,d=o(9693),g=d.LongBits,h=d.utf8;function et(st,dt){return RangeError("index out of range: "+st.pos+" + "+(dt||1)+" > "+st.len)}function ot(st){this.buf=st,this.pos=0,this.len=st.length}var it,$=typeof Uint8Array<"u"?function(st){if(st instanceof Uint8Array||Array.isArray(st))return new ot(st);throw Error("illegal buffer")}:function(st){if(Array.isArray(st))return new ot(st);throw Error("illegal buffer")},c=function(){return d.Buffer?function(st){return(ot.create=function(dt){return d.Buffer.isBuffer(dt)?new a(dt):$(dt)})(st)}:$};function s(){var st=new g(0,0),dt=0;if(!(this.len-this.pos>4)){for(;dt<3;++dt){if(this.pos>=this.len)throw et(this);if(st.lo=(st.lo|(127&this.buf[this.pos])<<7*dt)>>>0,this.buf[this.pos++]<128)return st}return st.lo=(st.lo|(127&this.buf[this.pos++])<<7*dt)>>>0,st}for(;dt<4;++dt)if(st.lo=(st.lo|(127&this.buf[this.pos])<<7*dt)>>>0,this.buf[this.pos++]<128)return st;if(st.lo=(st.lo|(127&this.buf[this.pos])<<28)>>>0,st.hi=(st.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return st;if(dt=0,this.len-this.pos>4){for(;dt<5;++dt)if(st.hi=(st.hi|(127&this.buf[this.pos])<<7*dt+3)>>>0,this.buf[this.pos++]<128)return st}else for(;dt<5;++dt){if(this.pos>=this.len)throw et(this);if(st.hi=(st.hi|(127&this.buf[this.pos])<<7*dt+3)>>>0,this.buf[this.pos++]<128)return st}throw Error("invalid varint encoding")}function _(st,dt){return(st[dt-4]|st[dt-3]<<8|st[dt-2]<<16|st[dt-1]<<24)>>>0}function b(){if(this.pos+8>this.len)throw et(this,8);return new g(_(this.buf,this.pos+=4),_(this.buf,this.pos+=4))}ot.create=c(),ot.prototype._slice=d.Array.prototype.subarray||d.Array.prototype.slice,ot.prototype.uint32=(it=4294967295,function(){if(it=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(it=(it|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(it=(it|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(it=(it|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(it=(it|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return it;if((this.pos+=5)>this.len)throw this.pos=this.len,et(this,10);return it}),ot.prototype.int32=function(){return 0|this.uint32()},ot.prototype.sint32=function(){var st=this.uint32();return st>>>1^-(1&st)|0},ot.prototype.bool=function(){return this.uint32()!==0},ot.prototype.fixed32=function(){if(this.pos+4>this.len)throw et(this,4);return _(this.buf,this.pos+=4)},ot.prototype.sfixed32=function(){if(this.pos+4>this.len)throw et(this,4);return 0|_(this.buf,this.pos+=4)},ot.prototype.float=function(){if(this.pos+4>this.len)throw et(this,4);var st=d.float.readFloatLE(this.buf,this.pos);return this.pos+=4,st},ot.prototype.double=function(){if(this.pos+8>this.len)throw et(this,4);var st=d.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,st},ot.prototype.bytes=function(){var st=this.uint32(),dt=this.pos,ct=this.pos+st;if(ct>this.len)throw et(this,st);return this.pos+=st,Array.isArray(this.buf)?this.buf.slice(dt,ct):dt===ct?new this.buf.constructor(0):this._slice.call(this.buf,dt,ct)},ot.prototype.string=function(){var st=this.bytes();return h.read(st,0,st.length)},ot.prototype.skip=function(st){if(typeof st=="number"){if(this.pos+st>this.len)throw et(this,st);this.pos+=st}else do if(this.pos>=this.len)throw et(this);while(128&this.buf[this.pos++]);return this},ot.prototype.skipType=function(st){switch(st){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(st=7&this.uint32())!=4;)this.skipType(st);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+st+" at offset "+this.pos)}return this},ot._configure=function(st){a=st,ot.create=c(),a._configure();var dt=d.Long?"toLong":"toNumber";d.merge(ot.prototype,{int64:function(){return s.call(this)[dt](!1)},uint64:function(){return s.call(this)[dt](!0)},sint64:function(){return s.call(this).zzDecode()[dt](!1)},fixed64:function(){return b.call(this)[dt](!0)},sfixed64:function(){return b.call(this)[dt](!1)}})}},593:(i,e,o)=>{i.exports=g;var a=o(1408);(g.prototype=Object.create(a.prototype)).constructor=g;var d=o(9693);function g(h){a.call(this,h)}g._configure=function(){d.Buffer&&(g.prototype._slice=d.Buffer.prototype.slice)},g.prototype.string=function(){var h=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+h,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+h,this.len))},g._configure()},5054:i=>{i.exports={}},5994:(i,e,o)=>{e.Service=o(7948)},7948:(i,e,o)=>{i.exports=d;var a=o(9693);function d(g,h,et){if(typeof g!="function")throw TypeError("rpcImpl must be a function");a.EventEmitter.call(this),this.rpcImpl=g,this.requestDelimited=!!h,this.responseDelimited=!!et}(d.prototype=Object.create(a.EventEmitter.prototype)).constructor=d,d.prototype.rpcCall=function g(h,et,ot,it,$){if(!it)throw TypeError("request must be specified");var c=this;if(!$)return a.asPromise(g,c,h,et,ot,it);if(c.rpcImpl)try{return c.rpcImpl(h,et[c.requestDelimited?"encodeDelimited":"encode"](it).finish(),function(s,_){if(s)return c.emit("error",s,h),$(s);if(_!==null){if(!(_ instanceof ot))try{_=ot[c.responseDelimited?"decodeDelimited":"decode"](_)}catch(b){return c.emit("error",b,h),$(b)}return c.emit("data",_,h),$(null,_)}c.end(!0)})}catch(s){return c.emit("error",s,h),void setTimeout(function(){$(s)},0)}else setTimeout(function(){$(Error("already ended"))},0)},d.prototype.end=function(g){return this.rpcImpl&&(g||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(i,e,o)=>{i.exports=d;var a=o(9693);function d(ot,it){this.lo=ot>>>0,this.hi=it>>>0}var g=d.zero=new d(0,0);g.toNumber=function(){return 0},g.zzEncode=g.zzDecode=function(){return this},g.length=function(){return 1};var h=d.zeroHash="\0\0\0\0\0\0\0\0";d.fromNumber=function(ot){if(ot===0)return g;var it=ot<0;it&&(ot=-ot);var $=ot>>>0,c=(ot-$)/4294967296>>>0;return it&&(c=~c>>>0,$=~$>>>0,++$>4294967295&&($=0,++c>4294967295&&(c=0))),new d($,c)},d.from=function(ot){if(typeof ot=="number")return d.fromNumber(ot);if(a.isString(ot)){if(!a.Long)return d.fromNumber(parseInt(ot,10));ot=a.Long.fromString(ot)}return ot.low||ot.high?new d(ot.low>>>0,ot.high>>>0):g},d.prototype.toNumber=function(ot){if(!ot&&this.hi>>>31){var it=1+~this.lo>>>0,$=~this.hi>>>0;return it||($=$+1>>>0),-(it+4294967296*$)}return this.lo+4294967296*this.hi},d.prototype.toLong=function(ot){return a.Long?new a.Long(0|this.lo,0|this.hi,!!ot):{low:0|this.lo,high:0|this.hi,unsigned:!!ot}};var et=String.prototype.charCodeAt;d.fromHash=function(ot){return ot===h?g:new d((et.call(ot,0)|et.call(ot,1)<<8|et.call(ot,2)<<16|et.call(ot,3)<<24)>>>0,(et.call(ot,4)|et.call(ot,5)<<8|et.call(ot,6)<<16|et.call(ot,7)<<24)>>>0)},d.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},d.prototype.zzEncode=function(){var ot=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^ot)>>>0,this.lo=(this.lo<<1^ot)>>>0,this},d.prototype.zzDecode=function(){var ot=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^ot)>>>0,this.hi=(this.hi>>>1^ot)>>>0,this},d.prototype.length=function(){var ot=this.lo,it=(this.lo>>>28|this.hi<<4)>>>0,$=this.hi>>>24;return $===0?it===0?ot<16384?ot<128?1:2:ot<2097152?3:4:it<16384?it<128?5:6:it<2097152?7:8:$<128?9:10}},9693:function(i,e,o){var a=e;function d(h,et,ot){for(var it=Object.keys(et),$=0;$<it.length;++$)h[it[$]]!==void 0&&ot||(h[it[$]]=et[it[$]]);return h}function g(h){function et(ot,it){if(!(this instanceof et))return new et(ot,it);Object.defineProperty(this,"message",{get:function(){return ot}}),Error.captureStackTrace?Error.captureStackTrace(this,et):Object.defineProperty(this,"stack",{value:new Error().stack||""}),it&&d(this,it)}return(et.prototype=Object.create(Error.prototype)).constructor=et,Object.defineProperty(et.prototype,"name",{get:function(){return h}}),et.prototype.toString=function(){return this.name+": "+this.message},et}a.asPromise=o(4537),a.base64=o(7419),a.EventEmitter=o(9211),a.float=o(945),a.inquire=o(7199),a.utf8=o(4997),a.pool=o(6662),a.LongBits=o(1945),a.isNode=!!(o.g!==void 0&&o.g&&o.g.process&&o.g.process.versions&&o.g.process.versions.node),a.global=a.isNode&&o.g||typeof window<"u"&&window||typeof self<"u"&&self||this,a.emptyArray=Object.freeze?Object.freeze([]):[],a.emptyObject=Object.freeze?Object.freeze({}):{},a.isInteger=Number.isInteger||function(h){return typeof h=="number"&&isFinite(h)&&Math.floor(h)===h},a.isString=function(h){return typeof h=="string"||h instanceof String},a.isObject=function(h){return h&&typeof h=="object"},a.isset=a.isSet=function(h,et){var ot=h[et];return!(ot==null||!h.hasOwnProperty(et))&&(typeof ot!="object"||(Array.isArray(ot)?ot.length:Object.keys(ot).length)>0)},a.Buffer=function(){try{var h=a.inquire("buffer").Buffer;return h.prototype.utf8Write?h:null}catch{return null}}(),a._Buffer_from=null,a._Buffer_allocUnsafe=null,a.newBuffer=function(h){return typeof h=="number"?a.Buffer?a._Buffer_allocUnsafe(h):new a.Array(h):a.Buffer?a._Buffer_from(h):typeof Uint8Array>"u"?h:new Uint8Array(h)},a.Array=typeof Uint8Array<"u"?Uint8Array:Array,a.Long=a.global.dcodeIO&&a.global.dcodeIO.Long||a.global.Long||a.inquire("long"),a.key2Re=/^true|false|0|1$/,a.key32Re=/^-?(?:0|[1-9][0-9]*)$/,a.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,a.longToHash=function(h){return h?a.LongBits.from(h).toHash():a.LongBits.zeroHash},a.longFromHash=function(h,et){var ot=a.LongBits.fromHash(h);return a.Long?a.Long.fromBits(ot.lo,ot.hi,et):ot.toNumber(!!et)},a.merge=d,a.lcFirst=function(h){return h.charAt(0).toLowerCase()+h.substring(1)},a.newError=g,a.ProtocolError=g("ProtocolError"),a.oneOfGetter=function(h){for(var et={},ot=0;ot<h.length;++ot)et[h[ot]]=1;return function(){for(var it=Object.keys(this),$=it.length-1;$>-1;--$)if(et[it[$]]===1&&this[it[$]]!==void 0&&this[it[$]]!==null)return it[$]}},a.oneOfSetter=function(h){return function(et){for(var ot=0;ot<h.length;++ot)h[ot]!==et&&delete this[h[ot]]}},a.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},a._configure=function(){var h=a.Buffer;h?(a._Buffer_from=h.from!==Uint8Array.from&&h.from||function(et,ot){return new h(et,ot)},a._Buffer_allocUnsafe=h.allocUnsafe||function(et){return new h(et)}):a._Buffer_from=a._Buffer_allocUnsafe=null}},1173:(i,e,o)=>{i.exports=c;var a,d=o(9693),g=d.LongBits,h=d.base64,et=d.utf8;function ot(pt,ft,mt){this.fn=pt,this.len=ft,this.next=void 0,this.val=mt}function it(){}function $(pt){this.head=pt.head,this.tail=pt.tail,this.len=pt.len,this.next=pt.states}function c(){this.len=0,this.head=new ot(it,0,0),this.tail=this.head,this.states=null}var s=function(){return d.Buffer?function(){return(c.create=function(){return new a})()}:function(){return new c}};function _(pt,ft,mt){ft[mt]=255&pt}function b(pt,ft){this.len=pt,this.next=void 0,this.val=ft}function st(pt,ft,mt){for(;pt.hi;)ft[mt++]=127&pt.lo|128,pt.lo=(pt.lo>>>7|pt.hi<<25)>>>0,pt.hi>>>=7;for(;pt.lo>127;)ft[mt++]=127&pt.lo|128,pt.lo=pt.lo>>>7;ft[mt++]=pt.lo}function dt(pt,ft,mt){ft[mt]=255&pt,ft[mt+1]=pt>>>8&255,ft[mt+2]=pt>>>16&255,ft[mt+3]=pt>>>24}c.create=s(),c.alloc=function(pt){return new d.Array(pt)},d.Array!==Array&&(c.alloc=d.pool(c.alloc,d.Array.prototype.subarray)),c.prototype._push=function(pt,ft,mt){return this.tail=this.tail.next=new ot(pt,ft,mt),this.len+=ft,this},b.prototype=Object.create(ot.prototype),b.prototype.fn=function(pt,ft,mt){for(;pt>127;)ft[mt++]=127&pt|128,pt>>>=7;ft[mt]=pt},c.prototype.uint32=function(pt){return this.len+=(this.tail=this.tail.next=new b((pt>>>=0)<128?1:pt<16384?2:pt<2097152?3:pt<268435456?4:5,pt)).len,this},c.prototype.int32=function(pt){return pt<0?this._push(st,10,g.fromNumber(pt)):this.uint32(pt)},c.prototype.sint32=function(pt){return this.uint32((pt<<1^pt>>31)>>>0)},c.prototype.uint64=function(pt){var ft=g.from(pt);return this._push(st,ft.length(),ft)},c.prototype.int64=c.prototype.uint64,c.prototype.sint64=function(pt){var ft=g.from(pt).zzEncode();return this._push(st,ft.length(),ft)},c.prototype.bool=function(pt){return this._push(_,1,pt?1:0)},c.prototype.fixed32=function(pt){return this._push(dt,4,pt>>>0)},c.prototype.sfixed32=c.prototype.fixed32,c.prototype.fixed64=function(pt){var ft=g.from(pt);return this._push(dt,4,ft.lo)._push(dt,4,ft.hi)},c.prototype.sfixed64=c.prototype.fixed64,c.prototype.float=function(pt){return this._push(d.float.writeFloatLE,4,pt)},c.prototype.double=function(pt){return this._push(d.float.writeDoubleLE,8,pt)};var ct=d.Array.prototype.set?function(pt,ft,mt){ft.set(pt,mt)}:function(pt,ft,mt){for(var bt=0;bt<pt.length;++bt)ft[mt+bt]=pt[bt]};c.prototype.bytes=function(pt){var ft=pt.length>>>0;if(!ft)return this._push(_,1,0);if(d.isString(pt)){var mt=c.alloc(ft=h.length(pt));h.decode(pt,mt,0),pt=mt}return this.uint32(ft)._push(ct,ft,pt)},c.prototype.string=function(pt){var ft=et.length(pt);return ft?this.uint32(ft)._push(et.write,ft,pt):this._push(_,1,0)},c.prototype.fork=function(){return this.states=new $(this),this.head=this.tail=new ot(it,0,0),this.len=0,this},c.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ot(it,0,0),this.len=0),this},c.prototype.ldelim=function(){var pt=this.head,ft=this.tail,mt=this.len;return this.reset().uint32(mt),mt&&(this.tail.next=pt.next,this.tail=ft,this.len+=mt),this},c.prototype.finish=function(){for(var pt=this.head.next,ft=this.constructor.alloc(this.len),mt=0;pt;)pt.fn(pt.val,ft,mt),mt+=pt.len,pt=pt.next;return ft},c._configure=function(pt){a=pt,c.create=s(),a._configure()}},3155:(i,e,o)=>{i.exports=g;var a=o(1173);(g.prototype=Object.create(a.prototype)).constructor=g;var d=o(9693);function g(){a.call(this)}function h(et,ot,it){et.length<40?d.utf8.write(et,ot,it):ot.utf8Write?ot.utf8Write(et,it):ot.write(et,it)}g._configure=function(){g.alloc=d._Buffer_allocUnsafe,g.writeBytesBuffer=d.Buffer&&d.Buffer.prototype instanceof Uint8Array&&d.Buffer.prototype.set.name==="set"?function(et,ot,it){ot.set(et,it)}:function(et,ot,it){if(et.copy)et.copy(ot,it,0,et.length);else for(var $=0;$<et.length;)ot[it++]=et[$++]}},g.prototype.bytes=function(et){d.isString(et)&&(et=d._Buffer_from(et,"base64"));var ot=et.length>>>0;return this.uint32(ot),ot&&this._push(g.writeBytesBuffer,ot,et),this},g.prototype.string=function(et){var ot=d.Buffer.byteLength(et);return this.uint32(ot),ot&&this._push(h,ot,et),this},g._configure()},7714:(i,e,o)=>{e.R=void 0;const a=o(6919),d=o(7448);e.R=new class{async init(){}async createSessionHandler(g,h){const et=new a.Session(h);return await et.loadModel(g),new d.OnnxjsSessionHandler(et)}}},4200:(i,e,o)=>{e.c8=e.rX=void 0;const a=o(1670),d=o(5381),g=o(2157),h=o(2306);e.rX=()=>{if((typeof a.env.wasm.initTimeout!="number"||a.env.wasm.initTimeout<0)&&(a.env.wasm.initTimeout=0),typeof a.env.wasm.simd!="boolean"&&(a.env.wasm.simd=!0),typeof a.env.wasm.proxy!="boolean"&&(a.env.wasm.proxy=!1),typeof a.env.wasm.numThreads!="number"||!Number.isInteger(a.env.wasm.numThreads)||a.env.wasm.numThreads<=0){const et=typeof navigator>"u"?(0,d.cpus)().length:navigator.hardwareConcurrency;a.env.wasm.numThreads=Math.min(4,Math.ceil((et||1)/2))}},e.c8=new class{async init(){(0,e.rX)(),await(0,g.initWasm)()}async createSessionHandler(et,ot){const it=new h.OnnxruntimeWebAssemblySessionHandler;return await it.loadModel(et,ot),Promise.resolve(it)}}},6018:function(i,e,o){var a=this&&this.__createBinding||(Object.create?function(h,et,ot,it){it===void 0&&(it=ot);var $=Object.getOwnPropertyDescriptor(et,ot);$&&!("get"in $?!et.__esModule:$.writable||$.configurable)||($={enumerable:!0,get:function(){return et[ot]}}),Object.defineProperty(h,it,$)}:function(h,et,ot,it){it===void 0&&(it=ot),h[it]=et[ot]}),d=this&&this.__exportStar||function(h,et){for(var ot in h)ot==="default"||Object.prototype.hasOwnProperty.call(et,ot)||a(et,h,ot)};Object.defineProperty(e,"__esModule",{value:!0}),d(o(1670),e);const g=o(1670);{const h=o(7714).R;(0,g.registerBackend)("webgl",h,-10)}{const h=o(4200).c8;(0,g.registerBackend)("cpu",h,10),(0,g.registerBackend)("wasm",h,10),(0,g.registerBackend)("xnnpack",h,9)}},246:(i,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createAttributeWithCacheKey=void 0;class o{constructor(d){Object.assign(this,d)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(d=>`${this[d]}`).join(";")),this._cacheKey}}e.createAttributeWithCacheKey=a=>new o(a)},7778:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Attribute=void 0;const a=o(1446),d=o(9395),g=o(9162),h=o(2517);var et=d.onnxruntime.experimental.fbs;class ot{constructor($){if(this._attributes=new Map,$!=null){for(const c of $)c instanceof a.onnx.AttributeProto?this._attributes.set(c.name,[ot.getValue(c),ot.getType(c)]):c instanceof et.Attribute&&this._attributes.set(c.name(),[ot.getValue(c),ot.getType(c)]);if(this._attributes.size<$.length)throw new Error("duplicated attribute names")}}set($,c,s){this._attributes.set($,[s,c])}delete($){this._attributes.delete($)}getFloat($,c){return this.get($,"float",c)}getInt($,c){return this.get($,"int",c)}getString($,c){return this.get($,"string",c)}getTensor($,c){return this.get($,"tensor",c)}getFloats($,c){return this.get($,"floats",c)}getInts($,c){return this.get($,"ints",c)}getStrings($,c){return this.get($,"strings",c)}getTensors($,c){return this.get($,"tensors",c)}get($,c,s){const _=this._attributes.get($);if(_===void 0){if(s!==void 0)return s;throw new Error(`required attribute not found: ${$}`)}if(_[1]!==c)throw new Error(`type mismatch: expected ${c} but got ${_[1]}`);return _[0]}static getType($){const c=$ instanceof a.onnx.AttributeProto?$.type:$.type();switch(c){case a.onnx.AttributeProto.AttributeType.FLOAT:return"float";case a.onnx.AttributeProto.AttributeType.INT:return"int";case a.onnx.AttributeProto.AttributeType.STRING:return"string";case a.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case a.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case a.onnx.AttributeProto.AttributeType.INTS:return"ints";case a.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case a.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${a.onnx.AttributeProto.AttributeType[c]}`)}}static getValue($){const c=$ instanceof a.onnx.AttributeProto?$.type:$.type();if(c===a.onnx.AttributeProto.AttributeType.GRAPH||c===a.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const s=this.getValueNoCheck($);if(c===a.onnx.AttributeProto.AttributeType.INT&&h.LongUtil.isLong(s))return h.LongUtil.longToNumber(s);if(c===a.onnx.AttributeProto.AttributeType.INTS){const _=s,b=new Array(_.length);for(let st=0;st<_.length;st++){const dt=_[st];b[st]=h.LongUtil.longToNumber(dt)}return b}if(c===a.onnx.AttributeProto.AttributeType.TENSOR)return $ instanceof a.onnx.AttributeProto?g.Tensor.fromProto(s):g.Tensor.fromOrtTensor(s);if(c===a.onnx.AttributeProto.AttributeType.TENSORS){if($ instanceof a.onnx.AttributeProto)return s.map(_=>g.Tensor.fromProto(_));if($ instanceof et.Attribute)return s.map(_=>g.Tensor.fromOrtTensor(_))}if(c===a.onnx.AttributeProto.AttributeType.STRING&&$ instanceof a.onnx.AttributeProto){const _=s;return(0,h.decodeUtf8String)(_)}return c===a.onnx.AttributeProto.AttributeType.STRINGS&&$ instanceof a.onnx.AttributeProto?s.map(h.decodeUtf8String):s}static getValueNoCheck($){return $ instanceof a.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat($):this.getValueNoCheckFromOrtFormat($)}static getValueNoCheckFromOnnxFormat($){switch($.type){case a.onnx.AttributeProto.AttributeType.FLOAT:return $.f;case a.onnx.AttributeProto.AttributeType.INT:return $.i;case a.onnx.AttributeProto.AttributeType.STRING:return $.s;case a.onnx.AttributeProto.AttributeType.TENSOR:return $.t;case a.onnx.AttributeProto.AttributeType.GRAPH:return $.g;case a.onnx.AttributeProto.AttributeType.FLOATS:return $.floats;case a.onnx.AttributeProto.AttributeType.INTS:return $.ints;case a.onnx.AttributeProto.AttributeType.STRINGS:return $.strings;case a.onnx.AttributeProto.AttributeType.TENSORS:return $.tensors;case a.onnx.AttributeProto.AttributeType.GRAPHS:return $.graphs;default:throw new Error(`unsupported attribute type: ${a.onnx.AttributeProto.AttributeType[$.type]}`)}}static getValueNoCheckFromOrtFormat($){switch($.type()){case et.AttributeType.FLOAT:return $.f();case et.AttributeType.INT:return $.i();case et.AttributeType.STRING:return $.s();case et.AttributeType.TENSOR:return $.t();case et.AttributeType.GRAPH:return $.g();case et.AttributeType.FLOATS:return $.floatsArray();case et.AttributeType.INTS:{const c=[];for(let s=0;s<$.intsLength();s++)c.push($.ints(s));return c}case et.AttributeType.STRINGS:{const c=[];for(let s=0;s<$.stringsLength();s++)c.push($.strings(s));return c}case et.AttributeType.TENSORS:{const c=[];for(let s=0;s<$.tensorsLength();s++)c.push($.tensors(s));return c}default:throw new Error(`unsupported attribute type: ${et.AttributeType[$.type()]}`)}}}e.Attribute=ot},7091:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.resolveBackend=e.backend=void 0;const a=o(5038),d=new Map;async function g(h){const et=e.backend;if(et[h]!==void 0&&function(ot){const it=ot;return"initialize"in it&&typeof it.initialize=="function"&&"createSessionHandler"in it&&typeof it.createSessionHandler=="function"&&"dispose"in it&&typeof it.dispose=="function"}(et[h])){const ot=et[h];let it=ot.initialize();if(typeof it=="object"&&"then"in it&&(it=await it),it)return d.set(h,ot),ot}}e.backend={webgl:new a.WebGLBackend},e.resolveBackend=async function h(et){if(!et)return h(["webgl"]);{const ot=typeof et=="string"?[et]:et;for(const it of ot){const $=d.get(it);if($)return $;const c=await g(it);if(c)return c}}throw new Error("no available backend to use")}},5038:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLBackend=void 0;const a=o(1670),d=o(6231),g=o(6416),h=o(7305);e.WebGLBackend=class{get contextId(){return a.env.webgl.contextId}set contextId(et){a.env.webgl.contextId=et}get matmulMaxBatchSize(){return a.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(et){a.env.webgl.matmulMaxBatchSize=et}get textureCacheMode(){return a.env.webgl.textureCacheMode}set textureCacheMode(et){a.env.webgl.textureCacheMode=et}get pack(){return a.env.webgl.pack}set pack(et){a.env.webgl.pack=et}get async(){return a.env.webgl.async}set async(et){a.env.webgl.async=et}initialize(){try{return this.glContext=(0,h.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),d.Logger.setWithEnv(a.env),d.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(et){return d.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${et}`),!1}}createSessionHandler(et){return new g.WebGLSessionHandler(this,et)}dispose(){this.glContext.dispose()}}},5107:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.CoordsGlslLib=void 0;const a=o(2517),d=o(8520),g=o(5060),h=o(7859),et=o(9390);class ot extends d.GlslLib{constructor($){super($)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new d.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new d.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const $=this.context.outputTextureLayout;return $.isPacked?this.getPackedOutputSamplingSnippet($):this.getUnpackedOutputSamplingSnippet($)}getPackedOutputSamplingSnippet($){const c=$.unpackedShape,s=[$.width,$.height],_={},b="getOutputCoords";switch(c.length){case 0:_[b]=this.getOutputScalarCoords();break;case 1:_[b]=this.getOutputPacked1DCoords(c,s);break;case 2:_[b]=this.getOutputPacked2DCoords(c,s);break;case 3:_[b]=this.getOutputPacked3DCoords(c,s);break;default:_[b]=this.getOutputPackedNDCoords(c,s)}const st=`
      void setOutput(vec4 val) {
        ${(0,g.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return _.floatTextureSetRGBA=new d.GlslLibRoutine(st),_}getUnpackedOutputSamplingSnippet($){const c=$.unpackedShape,s=[$.width,$.height],_={},b="getOutputCoords";switch(c.length){case 0:_[b]=this.getOutputScalarCoords();break;case 1:_[b]=this.getOutputUnpacked1DCoords(c,s);break;case 2:_[b]=this.getOutputUnpacked2DCoords(c,s);break;case 3:_[b]=this.getOutputUnpacked3DCoords(c,s);break;case 4:_[b]=this.getOutputUnpacked4DCoords(c,s);break;case 5:_[b]=this.getOutputUnpacked5DCoords(c,s);break;case 6:_[b]=this.getOutputUnpacked6DCoords(c,s);break;default:throw new Error(`Unsupported output dimensionality: ${c.length}`)}const st=`
        void setOutput(float val) {
          ${(0,g.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return _.floatTextureSetR=new d.GlslLibRoutine(st),_}getOutputScalarCoords(){return new d.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords($,c){const s=c;let _="";return s[0]===1?(_=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${s[1]}.0);
          }
        `,new d.GlslLibRoutine(_)):s[1]===1?(_=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${s[0]}.0);
          }
        `,new d.GlslLibRoutine(_)):(_=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${s[0]}, ${s[1]}));
          return 2 * (resTexRC.y * ${s[0]} + resTexRC.x);
        }
      `,new d.GlslLibRoutine(_))}getOutputPacked2DCoords($,c){let s="";if(a.ArrayUtil.arraysEqual($,c))return s=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${c[0]}, ${c[1]}));
        }
      `,new d.GlslLibRoutine(s);const _=c,b=Math.ceil($[1]/2);return s=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${_[0]}, ${_[1]}));

          int index = resTexRC.y * ${_[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${b}) * 2;
          int c = 2 * (index / ${b});

          return ivec2(r, c);
        }
      `,new d.GlslLibRoutine(s)}getOutputPacked3DCoords($,c){const s=[c[0],c[1]],_=Math.ceil($[2]/2),b=_*Math.ceil($[1]/2),st=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${s[0]}, ${s[1]}));
          int index = resTexRC.y * ${s[0]} + resTexRC.x;

          int b = index / ${b};
          index -= b * ${b};

          // reverse r and c order for packed texture
          int r = imod(index, ${_}) * 2;
          int c = 2 * (index / ${_});

          return ivec3(b, r, c);
        }
      `;return new d.GlslLibRoutine(st)}getOutputPackedNDCoords($,c){const s=[c[0],c[1]],_=Math.ceil($[$.length-1]/2),b=_*Math.ceil($[$.length-2]/2);let st=b,dt="",ct="b, r, c";for(let ft=2;ft<$.length-1;ft++)st*=$[$.length-ft-1],dt=`
      int b${ft} = index / ${st};
      index -= b${ft} * ${st};
    `+dt,ct=`b${ft}, `+ct;const pt=`
      ivec${$.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${s[0]}, ${s[1]}));
        int index = resTexRC.y * ${s[0]} + resTexRC.x;

        ${dt}

        int b = index / ${b};
        index -= b * ${b};

        // reverse r and c order for packed texture
        int r = imod(index, ${_}) * 2;
        int c = 2 * (index / ${_});

        return ivec${$.length}(${ct});
      }
    `;return new d.GlslLibRoutine(pt)}getOutputUnpacked1DCoords($,c){const s=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${c[0]}, ${c[1]}));
          return resTexRC.y * ${c[0]} + resTexRC.x;
        }
      `;return new d.GlslLibRoutine(s)}getOutputUnpacked2DCoords($,c){const s=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${c[0]}, ${c[1]}));
          int index = resTexRC.y * ${c[0]} + resTexRC.x;
          int r = index / ${$[1]};
          int c = index - r * ${$[1]};
          return ivec2(r, c);
        }
      `;return new d.GlslLibRoutine(s)}getOutputUnpacked3DCoords($,c){let s="";const _=$.length;let b=null;_<2&&(b=[]),b=new Array(_-1),b[_-2]=$[_-1];for(let ct=_-3;ct>=0;--ct)b[ct]=b[ct+1]*$[ct+1];const st=["r","c","d"],dt=b.map((ct,pt)=>`int ${st[pt]} = index / ${ct}; ${pt===b.length-1?`int ${st[pt+1]} = index - ${st[pt]} * ${ct}`:`index -= ${st[pt]} * ${ct}`};`).join("");return s=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${c[0]}, ${c[1]}));
          int index = resTexRC.y * ${c[0]} + resTexRC.x;
          ${dt}
          return ivec3(r, c, d);
        }
      `,new d.GlslLibRoutine(s)}getOutputUnpacked4DCoords($,c){let s="";const _=$.length;let b=null;_<2&&(b=[]),b=new Array(_-1),b[_-2]=$[_-1];for(let ct=_-3;ct>=0;--ct)b[ct]=b[ct+1]*$[ct+1];const st=["r","c","d","d2"],dt=b.map((ct,pt)=>`int ${st[pt]} = index / ${ct}; ${pt===b.length-1?`int ${st[pt+1]} = index - ${st[pt]} * ${ct}`:`index -= ${st[pt]} * ${ct}`};`).join("");return s=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${c[0]}, ${c[1]}));
          int index = resTexRC.y * ${c[0]} + resTexRC.x;
          ${dt}
          return ivec4(r, c, d, d2);
        }
      `,new d.GlslLibRoutine(s)}getOutputUnpacked5DCoords($,c){let s="";const _=$.length;let b=null;_<2&&(b=[]),b=new Array(_-1),b[_-2]=$[_-1];for(let ct=_-3;ct>=0;--ct)b[ct]=b[ct+1]*$[ct+1];const st=["r","c","d","d2","d3"],dt=b.map((ct,pt)=>`int ${st[pt]} = index / ${ct}; ${pt===b.length-1?`int ${st[pt+1]} = index - ${st[pt]} * ${ct}`:`index -= ${st[pt]} * ${ct}`};`).join("");return s=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${c[0]}, ${c[1]}));
          int index = resTexRC.y * ${c[0]} + resTexRC.x;
          ${dt}
          return ivec5(r, c, d, d2, d3);
        }
      `,new d.GlslLibRoutine(s)}getOutputUnpacked6DCoords($,c){let s="";const _=$.length;let b=null;_<2&&(b=[]),b=new Array(_-1),b[_-2]=$[_-1];for(let ct=_-3;ct>=0;--ct)b[ct]=b[ct+1]*$[ct+1];const st=["r","c","d","d2","d3","d4"],dt=b.map((ct,pt)=>`int ${st[pt]} = index / ${ct}; ${pt===b.length-1?`int ${st[pt+1]} = index - ${st[pt]} * ${ct}`:`index -= ${st[pt]} * ${ct}`};`).join("");return s=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${c[0]}, ${c[1]}));
         int index = resTexRC.y * ${c[0]} + resTexRC.x;
         ${dt}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new d.GlslLibRoutine(s)}getCommonUtilFuncs(){const $={};let c="uvFromFlat";$[c]=new d.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),c="packedUVfrom1D",$[c]=new d.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),c="packedUVfrom2D",$[c]=new d.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),c="packedUVfrom3D",$[c]=new d.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),c="sampleTexture";const s=(0,g.getGlsl)(this.context.glContext.version);return $[c]=new d.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${s.texture2D}(textureSampler, uv).r;
        }`),$}getInputsSamplingSnippets(){const $={},c=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((s,_)=>{const b=this.context.inputTextureLayouts[_],st=(0,et.generateShaderFuncNameFromInputSamplerName)(s);b.isPacked?$[st]=this.getPackedSamplerFromInput(st,s,b):$[st]=this.getUnpackedSamplerFromInput(st,s,b);const dt=(0,et.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(s);b.unpackedShape.length<=c.unpackedShape.length&&(b.isPacked?$[dt]=this.getPackedSamplerAtOutputCoords(dt,b,c,s):$[dt]=this.getUnpackedSamplerAtOutputCoords(dt,b,c,s))}),$}getPackedSamplerAtOutputCoords($,c,s,_){const b=c.unpackedShape,st=s.unpackedShape,dt=_,ct=(0,et.generateShaderFuncNameFromInputSamplerName)(dt),pt=b.length,ft=st.length,mt=a.BroadcastUtil.getBroadcastDims(b,st),bt=(0,et.getCoordsDataType)(ft),$t=ft-pt;let Ct;const It=(0,et.getGlChannels)();Ct=pt===0?"":ft<2&&mt.length>=1?"coords = 0;":mt.map(fn=>`coords.${It[fn+$t]} = 0;`).join(`
`);let Tt="";Tt=ft<2&&pt>0?"coords":b.map((fn,un)=>`coords.${It[un+$t]}`).join(", ");let jt="return outputValue;";const dn=a.ShapeUtil.size(b)===1,yn=a.ShapeUtil.size(st)===1;if(pt!==1||dn||yn){if(dn&&!yn)jt=ft===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(mt.length){const fn=pt-2,un=pt-1;mt.indexOf(fn)>-1&&mt.indexOf(un)>-1?jt="return vec4(outputValue.x);":mt.indexOf(fn)>-1?jt="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":mt.indexOf(un)>-1&&(jt="return vec4(outputValue.xx, outputValue.zz);")}}else jt=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const mn=`
      vec4 ${$}() {
        ${bt} coords = getOutputCoords();
        
        int lastDim = coords.${It[ft-1]};
        coords.${It[ft-1]} = coords.${It[ft-2]};
        coords.${It[ft-2]} = lastDim;
      
        ${Ct}
        vec4 outputValue = ${ct}(${Tt});
        ${jt}
      }
    `;return new d.GlslLibRoutine(mn,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords($,c,s,_){const b=[s.width,s.height],st=[c.width,c.height],dt=c.unpackedShape.length,ct=s.unpackedShape.length,pt=c.unpackedShape,ft=s.unpackedShape,mt=(0,et.generateShaderFuncNameFromInputSamplerName)(_);if(dt===ct&&a.ArrayUtil.arraysEqual(st,b)){const yn=`
          float ${$}() {
            return sampleTexture(${_}, TexCoords);
          }
        `;return new d.GlslLibRoutine(yn,["coordinates.sampleTexture"])}const bt=(0,et.getCoordsDataType)(ct),$t=a.BroadcastUtil.getBroadcastDims(pt,ft),Ct=ct-dt;let It;const Tt=(0,et.getGlChannels)();It=dt===0?"":ct<2&&$t.length>=1?"coords = 0;":$t.map(yn=>`coords.${Tt[yn+Ct]} = 0;`).join(`
`);let jt="";jt=ct<2&&dt>0?"coords":c.unpackedShape.map((yn,mn)=>`coords.${Tt[mn+Ct]}`).join(", ");const dn=`
        float ${$}() {
          ${bt} coords = getOutputCoords();
          ${It}
          return ${mt}(${jt});
        }
      `;return new d.GlslLibRoutine(dn,["coordinates.getOutputCoords"])}getPackedSamplerFromInput($,c,s){switch(s.unpackedShape.length){case 0:return this.getPackedSamplerScalar($,c);case 1:return this.getPackedSampler1D($,c,s);case 2:return this.getPackedSampler2D($,c,s);case 3:return this.getPackedSampler3D($,c,s);default:return this.getPackedSamplerND($,c,s)}}getUnpackedSamplerFromInput($,c,s){const _=s.unpackedShape;switch(_.length){case 0:return this.getUnpackedSamplerScalar($,c,s);case 1:return this.getUnpackedSampler1D($,c,s);case 2:return this.getUnpackedSampler2D($,c,s);case 3:return this.getUnpackedSampler3D($,c,s);case 4:return this.getUnpackedSampler4D($,c,s);case 5:return this.getUnpackedSampler5D($,c,s);case 6:return this.getUnpackedSampler6D($,c,s);default:throw new Error(`Unsupported dimension ${_.length}-D`)}}getPackedSamplerScalar($,c){const s=`
          vec4 ${$}() {
            return ${(0,g.getGlsl)(this.context.glContext.version).texture2D}(${c}, halfCR);
          }
        `;return new d.GlslLibRoutine(s)}getPackedSampler1D($,c,s){const _=[s.width,s.height],b=[_[1],_[0]],st=(0,g.getGlsl)(this.context.glContext.version),dt=`vec4 ${$}(int index) {
      vec2 uv = packedUVfrom1D(
      ${b[0]}, ${b[1]}, index);
      return ${st.texture2D}(${c}, uv);
    }`;return new d.GlslLibRoutine(dt,["coordinates.packedUVfrom1D"])}getPackedSampler2D($,c,s){const _=s.unpackedShape,b=[s.width,s.height],st=(0,g.getGlsl)(this.context.glContext.version),dt=b[0],ct=b[1];if(b!=null&&a.ArrayUtil.arraysEqual(_,b)){const bt=`vec4 ${$}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${ct}.0, ${dt}.0);
        return ${st.texture2D}(${c}, uv);
      }`;return new d.GlslLibRoutine(bt)}const pt=b,ft=Math.ceil(_[1]/2),mt=`vec4 ${$}(int row, int col) {
      vec2 uv = packedUVfrom2D(${pt[1]}, ${pt[0]}, ${ft}, row, col);
      return ${st.texture2D}(${c}, uv);
    }`;return new d.GlslLibRoutine(mt,["coordinates.packedUVfrom2D"])}getPackedSampler3D($,c,s){const _=s.unpackedShape,b=[s.width,s.height],st=[b[0],b[1]],dt=(0,g.getGlsl)(this.context.glContext.version);if(_[0]===1){const bt=_.slice(1),$t=[1,2],Ct=(0,et.squeezeInputShape)(_,bt),It=["b","row","col"],Tt=JSON.parse(JSON.stringify(s));Tt.unpackedShape=Ct;const jt=this.getPackedSamplerFromInput($,c,Tt),dn=`${jt.routineBody}
      vec4 ${$}(int b, int row, int col) {
        return ${$}(${(0,et.getSqueezedParams)(It,$t)});
      } `;return new d.GlslLibRoutine(dn,jt.dependencies)}const ct=st[0],pt=st[1],ft=Math.ceil(_[2]/2),mt=`vec4 ${$}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${pt}, ${ct}, ${ft*Math.ceil(_[1]/2)}, ${ft}, b, row, col);
      return ${dt.texture2D}(${c}, uv);}`;return new d.GlslLibRoutine(mt,["coordinates.packedUVfrom3D"])}getPackedSamplerND($,c,s){const _=s.unpackedShape,b=_.length,st=[s.width,s.height],dt=(0,g.getGlsl)(this.context.glContext.version),ct=[st[0],st[1]],pt=ct[1],ft=ct[0],mt=Math.ceil(_[b-1]/2);let bt=mt*Math.ceil(_[b-2]/2),$t="int b, int row, int col",Ct=`b * ${bt} + (row / 2) * ${mt} + (col / 2)`;for(let Tt=2;Tt<b-1;Tt++)$t=`int b${Tt}, `+$t,bt*=_[b-Tt-1],Ct=`b${Tt} * ${bt} + `+Ct;const It=`vec4 ${$}(${$t}) {
      int index = ${Ct};
      int texR = index / ${ft};
      int texC = index - texR * ${ft};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${ft}, ${pt});
      return ${dt.texture2D}(${c}, uv);
    }`;return new d.GlslLibRoutine(It)}getUnpackedSamplerScalar($,c,s){const[_,b]=[s.width,s.height];if(_===1&&b===1){const dt=`
          float ${$}() {
            return sampleTexture(${c}, halfCR);
          }
        `;return new d.GlslLibRoutine(dt,["coordinates.sampleTexture"])}const st=`
        float ${$}() {
          int offset_${c} = coordsToOffset(TexCoords, ${_}, ${b});
          vec2 uv = uvFromFlat(${_}, ${b}, offset_${c});
          return sampleTexture(${c}, uv);
        }
      `;return new d.GlslLibRoutine(st,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D($,c,s){const _=s.width,b=s.height;if(b===1&&_===1){const dt=`
        float ${$}(int index) {
          return sampleTexture(${c}, halfCR);
        }
      `;return new d.GlslLibRoutine(dt,["coordinates.sampleTexture"])}if(b===1){const dt=`
          float ${$}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${_}.0, 0.5);
            return sampleTexture(${c}, uv);
          }
        `;return new d.GlslLibRoutine(dt,["coordinates.sampleTexture"])}if(_===1){const dt=`
          float ${$}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${b}.0);
            return sampleTexture(${c}, uv);
          }
        `;return new d.GlslLibRoutine(dt,["coordinates.sampleTexture"])}const st=`
        float ${$}(int index) {
          vec2 uv = uvFromFlat(${_}, ${b}, index);
          return sampleTexture(${c}, uv);
        }
      `;return new d.GlslLibRoutine(st,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D($,c,s){const _=s.unpackedShape,b=[s.height,s.width];if(b!=null&&a.ArrayUtil.arraysEqual(_,b)){const bt=`
          float ${$}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${b[1]}.0, ${b[0]}.0);
            return sampleTexture(${c}, uv);
          }
        `;return new d.GlslLibRoutine(bt,["coordinates.sampleTexture"])}const{newShape:st,keptDims:dt}=(0,h.squeezeShape)(_),ct=st;if(ct.length<_.length){const bt=(0,et.squeezeInputShape)(_,ct),$t=JSON.parse(JSON.stringify(s));$t.unpackedShape=bt;const Ct=["col","row"],It=`
          ${this.getUnpackedSamplerFromInput($,c,$t).routineBody}
          float ${$}(int row, int col) {
            return ${$}(${(0,et.getSqueezedParams)(Ct,dt)});
          }
        `;return new d.GlslLibRoutine(It,["coordinates.sampleTexture"])}const pt=b[1],ft=b[0];if(ft===1){const bt=`
          float ${$}(int row, int col) {
            int offset_${c} = coordsToOffset(TexCoords, ${pt}, ${ft});
            float index = dot(vec3(row, col, offset_${c}), vec3(${_[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${pt}.0);
            return sampleTexture(${c}, uv);
          }
        `;return new d.GlslLibRoutine(bt,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(pt===1){const bt=`
          float ${$}(int row, int col) {
            int offset_${c} = coordsToOffset(TexCoords, ${pt}, ${ft});
            float index = dot(vec3(row, col, offset_${c}), vec3(${_[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${ft}.0, 0.5);
            return sampleTexture(${c}, uv);
          }
        `;return new d.GlslLibRoutine(bt,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const mt=`
        float ${$}(int row, int col) {
          int index = col * ${_[1]} + row;
          vec2 uv = uvFromFlat(${pt}, ${ft}, index);
          return sampleTexture(${c}, uv);
        }
      `;return new d.GlslLibRoutine(mt,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D($,c,s){const _=s.unpackedShape,b=_[1]*_[2],st=_[2],{newShape:dt,keptDims:ct}=(0,h.squeezeShape)(_),pt=dt;if(pt.length<_.length){const mt=(0,et.squeezeInputShape)(_,pt),bt=["batch","col","row"],$t=JSON.parse(JSON.stringify(s));$t.unpackedShape=mt;const Ct=this.getUnpackedSamplerFromInput($,c,$t),It=ct.reverse(),Tt=`
          ${Ct.routineBody}
          float ${$}(int batch, int row, int col) {
            return ${$}(${(0,et.getSqueezedParams)(bt,It)});
          }
        `;return new d.GlslLibRoutine(Tt,Ct.dependencies)}const ft=`
          float ${$}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${b} + col * ${st} + row;
            vec2 uv = uvFromFlat(${s.width}, ${s.height}, index);
            return sampleTexture(${c}, uv);
          }
      `;return new d.GlslLibRoutine(ft,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D($,c,s){const _=s.unpackedShape,b=_[3],st=_[2]*b,dt=`
        float ${$}(int row, int col, int depth, int depth2) {
          int index = row * ${_[1]*st} + col * ${st} +
              depth2 * ${b} + depth;
          vec2 uv = uvFromFlat(${s.width}, ${s.height}, index);
          return sampleTexture(${c}, uv);
        }
      `;return new d.GlslLibRoutine(dt,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D($,c,s){const _=s.unpackedShape,b=_[4],st=_[3]*b,dt=_[2]*st,ct=_[1]*dt,{newShape:pt,keptDims:ft}=(0,h.squeezeShape)(_);if(pt.length<_.length){const bt=(0,et.squeezeInputShape)(_,pt),$t=["row","col","depth","depth2","depth3"],Ct=JSON.parse(JSON.stringify(s));Ct.unpackedShape=bt;const It=`
          ${this.getUnpackedSamplerFromInput($,c,Ct).routineBody}
          float ${$}(int row, int col, int depth, int depth2, int depth3) {
            return ${$}(${(0,et.getSqueezedParams)($t,ft)});
          }
        `;return new d.GlslLibRoutine(It,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const mt=`
        float ${$}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${ct} + col * ${dt} + depth * ${st} +
          depth3 * ${b} + depth2;
          vec2 uv = uvFromFlat(${s.width}, ${s.height}, index);
          return sampleTexture(${c}, uv);
        }
      `;return new d.GlslLibRoutine(mt,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D($,c,s){const _=s.unpackedShape,b=_[5],st=_[4]*b,dt=_[3]*st,ct=_[2]*dt,pt=_[1]*ct,{newShape:ft,keptDims:mt}=(0,h.squeezeShape)(_);if(ft.length<_.length){const $t=(0,et.squeezeInputShape)(_,ft),Ct=["row","col","depth","depth2","depth3","depth4"],It=JSON.parse(JSON.stringify(s));It.unpackedShape=$t;const Tt=`
            ${this.getUnpackedSamplerFromInput($,c,It).routineBody}
            float ${$}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${$}(${(0,et.getSqueezedParams)(Ct,mt)});
            }
          `;return new d.GlslLibRoutine(Tt,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const bt=`
          float ${$}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${pt} + col * ${ct} + depth * ${dt} +
            depth2 * ${st} + depth3 * ${b} + depth4;
            vec2 uv = uvFromFlat(${s.width}, ${s.height}, index);
            return sampleTexture(${c}, uv);
          }
        `;return new d.GlslLibRoutine(bt,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const $=this.context.outputTextureLayout,c=$.shape.length,s=$.strides,_=$.width,b=$.height,st=[];for(let ct=0;ct<c-1;++ct)st.push(`
        c[${ct}] = offset / ${s[ct]};`),st.push(`
        offset -= c[${ct}] * ${s[ct]};`);st.push(`
        c[${c-1}] = offset;`);const dt=`
      void toVec(vec2 texCoords, out int c[${c}]) {
        int offset = coordsToOffset(texCoords, ${_}, ${b});
        ${st.join("")}
      }
      void toVec(int offset, out int c[${c}]) {
        ${st.join("")}
      }
    `;return{toVec:new d.GlslLibRoutine(dt,["coordinates.coordsToOffset"])}}valueFrom(){const $={};return this.context.programInfo.inputNames.forEach((c,s)=>{const _=this.context.inputTextureLayouts[s],b=(_.unpackedShape.length>0?_.unpackedShape:_.shape).length;let st=`_${c}`;$[st]=new d.GlslLibRoutine(this.getValueFromSingle(c,b,_.width,_.height,!1),[`shapeUtils.indicesToOffset${st}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),st+="_T",$[st]=new d.GlslLibRoutine(this.getValueFromSingle(c,b,_.width,_.height,!0),[`shapeUtils.indicesToOffset${st}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),$}getValueFromSingle($,c,s,_,b){let st=`_${$}`;return b&&(st+="_T"),`
        float ${st}(int m[${c}]) {
          int offset = indicesToOffset${st}(m);
          vec2 coords = offsetToCoords(offset, ${s}, ${_});
          float value = getColorAsFloat(${(0,g.getGlsl)(this.context.glContext.version).texture2D}(${$}, coords));
          return value;
        }
        `}getPackedValueFrom($,c,s,_,b){let st=`_${$}_Pack`;return b&&(st+="_T"),`
        vec4 ${st}(int m[${c}]) {
          int offset = indicesToOffset_${$}(m);
          vec2 coords = offsetToCoords(offset, ${s}, ${_});
          return ${(0,g.getGlsl)(this.context.glContext.version).texture2D}(${$}, coords);
        }
        `}}e.CoordsGlslLib=ot},8520:(i,e)=>{var o;Object.defineProperty(e,"__esModule",{value:!0}),e.TopologicalSortGlslRoutines=e.GlslLibRoutineNode=e.GlslLibRoutine=e.GlslLib=e.GlslContext=e.FunctionType=void 0,(o=e.FunctionType||(e.FunctionType={}))[o.ValueBased=0]="ValueBased",o[o.Positional=1]="Positional",e.GlslContext=class{constructor(a,d,g,h){this.glContext=a,this.programInfo=d,this.inputTextureLayouts=g,this.outputTextureLayout=h}},e.GlslLib=class{constructor(a){this.context=a}},e.GlslLibRoutine=class{constructor(a,d){this.routineBody=a,this.dependencies=d}},e.GlslLibRoutineNode=class{constructor(a,d,g){this.name=a,this.dependencies=g||[],d&&(this.routineBody=d)}addDependency(a){a&&this.dependencies.push(a)}},e.TopologicalSortGlslRoutines=class{static returnOrderedNodes(a){if(!a||a.length===0)return[];if(a.length===1)return a;const d=new Set,g=new Set,h=new Array;return this.createOrderedNodes(a,d,g,h),h}static createOrderedNodes(a,d,g,h){for(let et=0;et<a.length;++et)this.dfsTraverse(a[et],d,g,h)}static dfsTraverse(a,d,g,h){if(!a||g.has(a.name))return;if(d.has(a.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");d.add(a.name);const et=a.dependencies;if(et&&et.length>0)for(let ot=0;ot<et.length;++ot)this.dfsTraverse(et[ot],d,g,h);h.push(a),g.add(a.name),d.delete(a.name)}}},7341:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.EncodingGlslLib=void 0;const a=o(8520);class d extends a.GlslLib{constructor(h){super(h)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new a.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new a.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const h=d.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new a.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${h}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const h=d.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new a.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${h}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const h=new ArrayBuffer(4),et=new Uint32Array(h),ot=new Uint8Array(h);if(et[0]=3735928559,ot[0]===239)return!0;if(ot[0]===222)return!1;throw new Error("unknown endianness")}}e.EncodingGlslLib=d},9894:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.FragColorGlslLib=void 0;const a=o(8520),d=o(5060);class g extends a.GlslLib{constructor(et){super(et)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const et=(0,d.getGlsl)(this.context.glContext.version);return{setFragColor:new a.GlslLibRoutine(`
        void setFragColor(float value) {
            ${et.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new a.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}e.FragColorGlslLib=g},2848:(i,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.replaceInlines=void 0;const o=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;e.replaceInlines=function(a){const d={};let g;for(;(g=o.exec(a))!==null;){const h=g[3].split(",").map(et=>{const ot=et.trim().split(" ");return ot&&ot.length===2?{type:ot[0],name:ot[1]}:null}).filter(et=>et!==null);d[g[2]]={params:h,body:g[4]}}for(const h in d){const et="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",h),ot=new RegExp(et,"gm");for(;(g=ot.exec(a))!==null;){const it=g[1],$=g[2],c=g[3].split(","),s=it?`${it} ${$};`:"";let _=d[h].body,b="";d[h].params.forEach((dt,ct)=>{dt&&(b+=`${dt.type} ${dt.name} = ${c[ct]};
`)}),_=`${b}
 ${_}`,_=_.replace("return",`${$} = `);const st=`
      ${s}
      {
        ${_}
      }
      `;a=a.replace(g[0],st)}}return a.replace(o,"")}},8879:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.GlslPreprocessor=void 0;const a=o(8520),d=o(2848),g=o(5483),h=o(5060);e.GlslPreprocessor=class{constructor(et,ot,it,$){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new a.GlslContext(et,ot,it,$),Object.keys(g.glslRegistry).forEach(s=>{const _=new g.glslRegistry[s](this.context);this.libs[s]=_});const c=this.glslLibRoutineDependencyGraph;for(const s in this.libs){const _=this.libs[s].getFunctions();for(const b in _){const st=s+"."+b;let dt;c[st]?(dt=c[st],dt.routineBody=_[b].routineBody):(dt=new a.GlslLibRoutineNode(st,_[b].routineBody),c[st]=dt);const ct=_[b].dependencies;if(ct)for(let pt=0;pt<ct.length;++pt)if(c[ct[pt]])dt.addDependency(c[ct[pt]]);else{const ft=new a.GlslLibRoutineNode(ct[pt]);c[ct[pt]]=ft,dt.addDependency(ft)}}}}preprocess(){const et=this.context.programInfo;let ot=et.shaderSource;return this.context.programInfo.hasMain||(ot=`${ot}
      ${(0,h.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),ot=(0,d.replaceInlines)(ot),`${(0,h.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(et.inputNames,et.variables)}
    ${this.getImports(ot)}
    ${ot}`}getImports(et){const ot=this.selectGlslLibRoutinesToBeIncluded(et);if(ot.length===0)return"";let it="";for(let $=0;$<ot.length;++$){if(!ot[$].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${ot[$].name}`);it+=ot[$].routineBody+`
`}return it}selectGlslLibRoutinesToBeIncluded(et){const ot=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(it=>{const $=it.split(".")[1];et.indexOf($)!==-1&&ot.push(this.glslLibRoutineDependencyGraph[it])}),a.TopologicalSortGlslRoutines.returnOrderedNodes(ot)}getUniforms(et,ot){const it=[];if(et)for(const $ of et)it.push(`uniform sampler2D ${$};`);if(ot)for(const $ of ot)it.push(`uniform ${$.type} ${$.name}${$.arrayLength?`[${$.arrayLength}]`:""};`);return it.join(`
`)}}},5483:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.glslRegistry=void 0;const a=o(5107),d=o(7341),g=o(9894),h=o(2655),et=o(3891);e.glslRegistry={encoding:d.EncodingGlslLib,fragcolor:g.FragColorGlslLib,vec:et.VecGlslLib,shapeUtils:h.ShapeUtilsGlslLib,coordinates:a.CoordsGlslLib}},2655:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ShapeUtilsGlslLib=void 0;const a=o(8520);class d extends a.GlslLib{constructor(h){super(h)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const h=this.context.outputTextureLayout.shape.length,et={};return this.context.programInfo.inputNames.forEach((ot,it)=>{const $=this.context.inputTextureLayouts[it].unpackedShape;if($.length<=h){const c=$.length,s=h-c,_=`bcastIndices_${ot}`;let b="";for(let dt=0;dt<c;++dt)b+=`
          realIndices[${dt}] = int( mod(float(bcastedIndices[${s+dt}]), ${$[dt]}.0) );
          `;const st=`
        void ${_} (int bcastedIndices[${h}], out int realIndices[${c}]) {
          ${b}
        }
        `;et[_]=new a.GlslLibRoutine(st)}}),et}bcastMatmulIndex(){const h=this.context.outputTextureLayout.shape.length,et={};return this.context.programInfo.inputNames.forEach((ot,it)=>{const $=this.context.inputTextureLayouts[it].shape;if(!($.length<2||$.length>h)){const c=$.length,s=h-c,_=`bcastMatmulIndices_${ot}`;let b="";for(let dt=0;dt<c-2;++dt)b+=`
          realIndices[${dt}] = int( mod(float(bcastedIndices[${s+dt}]), ${$[dt]}.0) );
          `;const st=`
        void ${_}(int bcastedIndices[${h}], out int realIndices[${c}]) {
          ${b}
          realIndices[${c-1}] = bcastedIndices[${h-1}];
          realIndices[${c-2}] = bcastedIndices[${h-2}];
        }
        `;et[_]=new a.GlslLibRoutine(st)}}),et}indicesToOffset(){const h={};return this.context.programInfo.inputNames.forEach((et,ot)=>{const it=this.context.inputTextureLayouts[ot].shape,$=this.context.inputTextureLayouts[ot].strides,c=it.length;let s=`indicesToOffset_${et}`;h[s]=new a.GlslLibRoutine(d.indexToOffsetSingle(s,c,$)),s=`indicesToOffset_${et}_T`,h[s]=new a.GlslLibRoutine(d.indexToOffsetSingle(s,c,$.slice().reverse()))}),h}static indexToOffsetSingle(h,et,ot){let it="";for(let $=et-1;$>=0;--$)it+=`
        offset += indices[${$}] * ${ot[$]};
        `;return`
      int ${h}(int indices[${et}]) {
        int offset = 0;
        ${it}
        return offset;
      }
      `}offsetToIndices(){const h={};return this.context.programInfo.inputNames.forEach((et,ot)=>{const it=this.context.inputTextureLayouts[ot].shape,$=this.context.inputTextureLayouts[ot].strides,c=it.length;let s=`offsetToIndices_${et}`;h[s]=new a.GlslLibRoutine(d.offsetToIndicesSingle(s,c,$)),s=`offsetToIndices_${et}_T`,h[s]=new a.GlslLibRoutine(d.offsetToIndicesSingle(s,c,$.slice().reverse()))}),h}static offsetToIndicesSingle(h,et,ot){const it=[];for(let $=0;$<et-1;++$)it.push(`
      indices[${$}] = offset / ${ot[$]};`),it.push(`
        offset -= indices[${$}] * ${ot[$]};`);return it.push(`
      indices[${et-1}] = offset;`),`
      void ${h}(int offset, out int indices[${et}]) {
        ${it.join("")}
      }
      `}incrementIndices(){const h={};return this.context.programInfo.inputNames.forEach((et,ot)=>{const it=this.context.inputTextureLayouts[ot].shape,$=it.length,c=`incrementIndices_${et}`;let s="";for(let b=0;b<$;++b)s+=`
        shape[${b}] = ${it[b]};`;const _=`
        void ${c}(int axis, out int indices[${$}]) {
          int shape[${$}];
          ${s};
          for(int i = ${$} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;h[c]=new a.GlslLibRoutine(_)}),h}}e.ShapeUtilsGlslLib=d},5060:(i,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getDefaultFragShaderMain=e.getFragShaderPreamble=e.getVertexShaderSource=e.getGlsl=void 0;const o={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},a={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function d(g){return g===1?o:a}e.getGlsl=d,e.getVertexShaderSource=function(g){const h=d(g);return`${h.version}
      precision highp float;
      ${h.attribute} vec3 position;
      ${h.attribute} vec2 textureCoord;

      ${h.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},e.getFragShaderPreamble=function(g){const h=d(g);return`${h.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${h.varyingFrag} vec2 TexCoords;
    ${h.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},e.getDefaultFragShaderMain=function(g,h){return`
  void main() {
    int indices[${h}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${d(g).output} = result;
  }
  `}},3891:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.VecGlslLib=void 0;const a=o(8520);class d extends a.GlslLib{constructor(h){super(h)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const h=this.context.outputTextureLayout.shape.length,et={add:"+=",sub:"-=",mul:"*=",div:"/="},ot={};for(const it in et){const $=`${it}Vec`;let c="";for(let _=0;_<h;++_)c+=`
          dest[${_}] ${et[it]} src[${_}];
          `;const s=`
        void ${$}(int src[${h}], out int dest[${h}]) {
          ${c}
        }
        `;ot[$]=new a.GlslLibRoutine(s)}return ot}copyVec(){const h=this.context.outputTextureLayout.shape.length;let et="";for(let it=0;it<h;++it)et+=`
        dest[${it}] = src[${it}];
        `;const ot=`
      void copyVec(int src[${h}], out int dest[${h}]) {
        ${et}
      }
      `;return{copyVec:new a.GlslLibRoutine(ot)}}setVecItem(){const h=this.context.outputTextureLayout.shape.length;let et=`
        if(index < 0)
            index =${h} + index;
        if (index == 0)
            m[0] = value;
        `;for(let it=1;it<h-1;++it)et+=`
        else if (index == ${it})
            m[${it}] = value;
            `;et+=`
        else
            m[${h-1}] = value;
        `;const ot=`
      void setVecItem(out int m[${h}], int index, int value) {
        ${et}
      }
        `;return{setVecItem:new a.GlslLibRoutine(ot)}}getVecItem(){const h=this.context.outputTextureLayout.shape.length;let et=`
        if(index < 0)
            index = ${h} + index;
        if (index == 0)
            return m[0];
      `;for(let it=1;it<h-1;++it)et+=`
        else if (index == ${it})
            return m[${it}];
      `;et+=`
        else
            return m[${h-1}];
        `;const ot=`
      int getVecItem(int m[${h}], int index) {
        ${et}
      }
    `;return{getVecItem:new a.GlslLibRoutine(ot)}}}e.VecGlslLib=d},8316:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLInferenceHandler=void 0;const a=o(6231),d=o(9162),g=o(2517),h=o(2403),et=o(7019),ot=o(8710),it=o(5611),$=o(4057),c=o(2039);e.WebGLInferenceHandler=class{constructor(s){this.session=s,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(s,_){return(0,$.calculateTextureWidthAndHeight)(this.session.layoutStrategy,s,_)}executeProgram(s,_){if(_.length<s.inputNames.length)throw new Error(`Input size mustn't be less than ${s.inputNames.length}.`);if(s.inputNames.length!==s.inputTypes.length)throw new Error("input names size does not match input types");const b=[];for(let mt=0;mt<s.inputNames.length;++mt)b[mt]=this.getOrCreateTextureData(_[mt],s.inputTypes[mt]);const st=((mt,bt)=>{const $t=bt.map(It=>`${It.unpackedShape.join(",")};${It.width}x${It.height}`).join("_");let Ct=mt.name;return mt.cacheHint&&(Ct+="["+mt.cacheHint+"]"),Ct+=":"+$t,Ct})(s,b);let dt=this.session.programManager.getArtifact(st);const ct=dt?dt.programInfo:typeof s.get=="function"?s.get():s,pt=(0,$.createTextureLayoutFromTextureType)(this.session.layoutStrategy,ct.output.dims,ct.output.textureType),ft=this.createTextureData(pt,ct.output.type);return dt||(dt=this.session.programManager.build(ct,b,ft),this.session.programManager.setArtifact(st,dt)),this.runProgram(dt,b,ft),ft}run(s,_){return this.executeProgram(s,_).tensor}runProgram(s,_,b){for(let st=0;st<_.length;++st)if(!!_[st].isPacked!=(s.programInfo.inputTypes[st]===c.TextureType.packed))throw new Error(`input[${st}] property packed inconsistent`);if(!!b.isPacked!=(s.programInfo.output.textureType===c.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(s,_,b)}getOrCreateTextureData(s,_){let b=this.getTextureData(s.dataId,_===c.TextureType.packed);if(!b&&(b=this.getTextureData(s.dataId,_!==c.TextureType.packed),b))return _===c.TextureType.packed?this.pack(b):this.unpack(b);if(!b){const st=(0,$.createTextureLayoutFromTextureType)(this.session.layoutStrategy,s.dims,_);if(_===c.TextureType.packedLastDimension){const pt=s.dims;if(pt.length===4){const ft=[pt[0],Math.ceil(pt[1]*pt[2]*pt[3]/4)],mt=(0,$.createTextureLayoutFromTextureType)(this.session.layoutStrategy,ft,_);let bt=s.numberData;if(pt[1]*pt[2]*pt[3]%4!=0){const $t=pt[0],Ct=pt[1]*pt[2]*pt[3],It=Math.ceil(Ct*1/4)*4;bt=new Float32Array($t*It);for(let Tt=0;Tt<$t;++Tt){const jt=Tt*Ct,dn=Tt*It+Tt%1*Ct;bt.set(s.numberData.subarray(jt,jt+Ct),dn)}}return this.createTextureData(mt,s.type,bt,s,1)}}if(_===c.TextureType.packed){const dt=(0,$.createTextureLayoutFromShape)(this.session.layoutStrategy,s.dims,1,[],{reverseWH:!0}),ct=this.createTextureData(dt,s.type,s.numberData,s,1);b=this.pack(ct)}else b=this.createTextureData(st,s.type,s.numberData,s,1)}return b}createTextureDataFromLayoutBindTensor(s,_,b,st){return this.createTextureData(s,_,b,st,1)}createTextureData(s,_,b,st,dt){a.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(s)}]`);const ct=this.session.textureManager.createTextureFromLayout(_,s,b,dt);return this.createTextureDataFromTexture(s,_,ct,st)}reshapeUnpacked(s,_){const b=this.getOrCreateTextureData(s,c.TextureType.unpacked),st={channels:b.channels,height:b.height,width:b.width,shape:_.length!==0?_:[1],strides:g.ShapeUtil.computeStrides(_),unpackedShape:_};return this.createTextureDataFromTexture(st,s.type,b.texture).tensor}reshapePacked(s,_){const b=this.getOrCreateTextureData(s,c.TextureType.packed);if((0,et.isReshapeCheap)(s.dims,_)){const ft={channels:b.channels,height:b.height,width:b.width,shape:_.length!==0?_:[1],strides:g.ShapeUtil.computeStrides(_),unpackedShape:_,isPacked:!0};return this.createTextureDataFromTexture(ft,s.type,b.texture).tensor}const st=(0,et.processDims3D)(s.dims),dt=(0,et.processDims3D)(_),ct=this.reshapePacked(s,st),pt=this.run((0,et.createPackedReshape3DProgramInfoLoader)(this,ct,dt),[ct]);return this.reshapePacked(pt,_)}cast(s,_){const b=this.getOrCreateTextureData(s,c.TextureType.unpacked);return this.createTextureDataFromTexture(b,_,b.texture).tensor}createTextureDataFromTexture(s,_,b,st,dt){const ct=Object.assign(Object.assign({},s),{tensor:st||new d.Tensor(s.unpackedShape,_,pt=>this.readTexture(ct),async pt=>this.readTextureAsync(ct),void 0,dt),texture:b});return this.setTextureData(ct.tensor.dataId,ct,s.isPacked),ct}getTextureData(s,_=!1){return this.session.isInitializer(s)?this.session.getTextureData(s,_):_?this.packedTextureDataCache.get(s):this.unpackedTextureDataCache.get(s)}setTextureData(s,_,b=!1){this.session.isInitializer(s)?this.session.setTextureData(s,_,b):(b?this.packedTextureDataCache:this.unpackedTextureDataCache).set(s,_)}isTextureLayoutCached(s,_=!1){return!!this.getTextureData(s.dataId,_)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(s=>this.session.textureManager.releaseTexture(s)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(s=>this.session.textureManager.releaseTexture(s)),this.unpackedTextureDataCache=new Map}readTexture(s){return s.isPacked?this.readTexture(this.unpack(s)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(s,s.tensor.type,s.channels):this.session.textureManager.readUint8TextureAsFloat((0,ot.encodeAsUint8)(this,s))}async readTextureAsync(s){return s.isPacked?this.readTextureAsync(this.unpack(s)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(s,s.tensor.type,s.channels):this.session.textureManager.readUint8TextureAsFloat((0,ot.encodeAsUint8)(this,s))}pack(s){return this.executeProgram((0,h.createPackProgramInfoLoader)(this,s.tensor),[s.tensor])}unpack(s){return this.executeProgram((0,it.createUnpackProgramInfoLoader)(this,s.tensor),[s.tensor])}}},1640:function(i,e,o){var a=this&&this.__createBinding||(Object.create?function(vn,Sn,hn,rr){rr===void 0&&(rr=hn);var vr=Object.getOwnPropertyDescriptor(Sn,hn);vr&&!("get"in vr?!Sn.__esModule:vr.writable||vr.configurable)||(vr={enumerable:!0,get:function(){return Sn[hn]}}),Object.defineProperty(vn,rr,vr)}:function(vn,Sn,hn,rr){rr===void 0&&(rr=hn),vn[rr]=Sn[hn]}),d=this&&this.__setModuleDefault||(Object.create?function(vn,Sn){Object.defineProperty(vn,"default",{enumerable:!0,value:Sn})}:function(vn,Sn){vn.default=Sn}),g=this&&this.__importStar||function(vn){if(vn&&vn.__esModule)return vn;var Sn={};if(vn!=null)for(var hn in vn)hn!=="default"&&Object.prototype.hasOwnProperty.call(vn,hn)&&a(Sn,vn,hn);return d(Sn,vn),Sn};Object.defineProperty(e,"__esModule",{value:!0}),e.WEBGL_OP_RESOLVE_RULES=void 0;const h=o(2898),et=g(o(7839)),ot=o(4196),it=o(2069),$=o(8138),c=o(9663),s=o(5193),_=o(7992),b=o(1253),st=o(4776),dt=o(6572),ct=o(3346),pt=o(5623),ft=o(2870),mt=o(2143),bt=o(4939),$t=o(718),Ct=o(2268),It=o(8117),Tt=o(2278),jt=o(5524),dn=o(5975),yn=o(3933),mn=o(6558),fn=o(5723),un=o(3738),Wt=g(o(4909)),Jt=o(8428),_n=o(9793);e.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",Wt.abs],["Acos","","7+",Wt.acos],["Add","","7+",et.add],["And","","7+",et.and],["Asin","","7+",Wt.asin],["Atan","","7+",Wt.atan],["AveragePool","","7+",mt.averagePool,mt.parseAveragePoolAttributes],["BatchNormalization","","7+",h.batchNormalization,h.parseBatchNormalizationAttributes],["Cast","","6+",ot.cast,ot.parseCastAttributes],["Ceil","","6+",Wt.ceil],["Clip","","6-10",Wt.clip,Wt.parseClipAttributes],["Clip","","11+",Wt.clipV11],["Concat","","4+",it.concat,it.parseConcatAttributes],["Conv","","1+",$.conv,$.parseConvAttributes],["ConvTranspose","","1+",c.convTranspose,c.parseConvTransposeAttributes],["Cos","","7+",Wt.cos],["Div","","7+",et.div],["Dropout","","7+",Wt.identity],["DepthToSpace","","1+",s.depthToSpace,s.parseDepthToSpaceAttributes],["Equal","","7+",et.equal],["Elu","","6+",Wt.elu,Wt.parseEluAttributes],["Exp","","6+",Wt.exp],["Flatten","","1+",_.flatten,_.parseFlattenAttributes],["Floor","","6+",Wt.floor],["FusedConv","com.microsoft","1+",$.conv,$.parseConvAttributes],["Gather","","1+",b.gather,b.parseGatherAttributes],["Gemm","","7-10",st.gemm,st.parseGemmAttributesV7],["Gemm","","11+",st.gemm,st.parseGemmAttributesV11],["GlobalAveragePool","","1+",mt.globalAveragePool,mt.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",mt.globalMaxPool],["Greater","","7+",et.greater],["Identity","","1+",Wt.identity],["ImageScaler","","1+",dt.imageScaler,dt.parseImageScalerAttributes],["InstanceNormalization","","6+",ct.instanceNormalization,ct.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",Wt.leakyRelu,Wt.parseLeakyReluAttributes],["Less","","7+",et.less],["Log","","6+",Wt.log],["MatMul","","1+",pt.matMul,pt.parseMatMulAttributes],["MaxPool","","1+",mt.maxPool,mt.parseMaxPoolAttributes],["Mul","","7+",et.mul],["Neg","","6+",Wt.neg],["Not","","1+",Wt.not],["Or","","7+",et.or],["Pad","","2-10",ft.padV2,ft.parsePadAttributesV2],["Pad","","11+",ft.padV11,ft.parsePadAttributesV11],["Pow","","7+",et.pow],["PRelu","","7+",et.pRelu],["ReduceLogSum","","1+",bt.reduceLogSum,bt.parseReduceAttributes],["ReduceMax","","1+",bt.reduceMax,bt.parseReduceAttributes],["ReduceMean","","1+",bt.reduceMean,bt.parseReduceAttributes],["ReduceMin","","1+",bt.reduceMin,bt.parseReduceAttributes],["ReduceProd","","1+",bt.reduceProd,bt.parseReduceAttributes],["ReduceSum","","1-12",bt.reduceSum,bt.parseReduceAttributes],["ReduceSumSquare","","1+",bt.reduceLogSumSquare,bt.parseReduceAttributes],["Relu","","6+",Wt.relu],["Reshape","","5+",$t.reshape],["Resize","","10",Ct.resize,Ct.parseResizeAttributesV10],["Resize","","11+",Ct.resize,Ct.parseResizeAttributesV11],["Shape","","1+",It.shape],["Sigmoid","","6+",Wt.sigmoid],["Sin","","7+",Wt.sin],["Slice","","10+",Tt.sliceV10],["Slice","","1-9",Tt.slice,Tt.parseSliceAttributes],["Softmax","","1-12",jt.softmax,jt.parseSoftmaxAttributes],["Softmax","","13+",jt.softmaxV13,jt.parseSoftmaxAttributesV13],["Split","","2-12",dn.split,dn.parseSplitAttributes],["Sqrt","","6+",Wt.sqrt],["Squeeze","","1-12",yn.squeeze,yn.parseSqueezeAttributes],["Squeeze","","13+",yn.squeezeV13],["Sub","","7+",et.sub],["Sum","","6+",mn.sum],["Tan","","7+",Wt.tan],["Tanh","","6+",Wt.tanh],["Tile","","6+",fn.tile],["Transpose","","1+",un.transpose,un.parseTransposeAttributes],["Upsample","","7-8",_n.upsample,_n.parseUpsampleAttributesV7],["Upsample","","9",_n.upsample,_n.parseUpsampleAttributesV9],["Unsqueeze","","1-12",Jt.unsqueeze,Jt.parseUnsqueezeAttributes],["Unsqueeze","","13+",Jt.unsqueezeV13],["Xor","","7+",et.xor]]},2898:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseBatchNormalizationAttributes=e.batchNormalization=void 0;const a=o(246),d=o(5060),g=o(2039),h={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[g.TextureType.unpacked,g.TextureType.unpacked,g.TextureType.unpacked,g.TextureType.unpacked,g.TextureType.unpacked]};e.batchNormalization=(it,$,c)=>(ot($),[it.run(Object.assign(Object.assign({},h),{cacheHint:c.cacheKey,get:()=>et(it,$,c)}),$)]),e.parseBatchNormalizationAttributes=it=>{const $=it.attributes.getFloat("epsilon",1e-5),c=it.attributes.getFloat("momentum",.9),s=it.attributes.getInt("spatial",1);return(0,a.createAttributeWithCacheKey)({epsilon:$,momentum:c,spatial:s})};const et=(it,$,c)=>{const s=(0,d.getGlsl)(it.session.backend.glContext.version),_=$[0].dims.length,[b,st]=it.calculateTextureWidthAndHeight($[1].dims,g.TextureType.unpacked),dt=`
  float process(int[${_}] indices) {
    vec2 position = offsetToCoords(indices[1], ${b}, ${st});
    float scale = getColorAsFloat(${s.texture2D}(Scale, position));
    float mean = getColorAsFloat(${s.texture2D}(Mean, position));
    float variance = getColorAsFloat(${s.texture2D}(Variance, position));
    float b = getColorAsFloat(${s.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${c.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},h),{output:{dims:$[0].dims,type:$[0].type,textureType:g.TextureType.unpacked},shaderSource:dt})},ot=it=>{if(!it||it.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const $=it[0],c=it[1],s=it[2],_=it[3],b=it[4];if($.dims.length<3||c.dims.length!==1||s.dims.length!==1||_.dims.length!==1||b.dims.length!==1)throw new Error("invalid input shape.");if(c.dims[0]!==$.dims[1]||s.dims[0]!==$.dims[1]||_.dims[0]!==$.dims[1]||b.dims[0]!==$.dims[1])throw new Error("invalid input shape.");if($.type!=="float32"&&$.type!=="float64"||c.type!=="float32"&&c.type!=="float64"||s.type!=="float32"&&s.type!=="float64"||_.type!=="float32"&&_.type!=="float64"||b.type!=="float32"&&b.type!=="float64")throw new Error("invalid input tensor types.")}},7839:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.xor=e.sub=e.pRelu=e.pow=e.or=e.mul=e.less=e.greater=e.equal=e.div=e.and=e.add=e.glslPRelu=e.glslPow=e.glslXor=e.glslOr=e.glslAnd=e.glslLess=e.glslGreater=e.glslEqual=e.glslSub=e.glslMul=e.glslDiv=e.glslAdd=void 0;const a=o(2517),d=o(8520),g=o(5060),h=o(2039);function et(){const bt="add_";return{body:`
  float ${bt}(float a, float b) {
    return a + b;
  }
  vec4 ${bt}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:bt,type:d.FunctionType.ValueBased}}function ot(){const bt="div_";return{body:`
  float ${bt}(float a, float b) {
    return a / b;
  }
  vec4 ${bt}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:bt,type:d.FunctionType.ValueBased}}function it(){const bt="mul_";return{body:`
  float ${bt}(float a, float b) {
    return a * b;
  }
  vec4 ${bt}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:bt,type:d.FunctionType.ValueBased}}function $(){const bt="sub_";return{body:`
  float ${bt}(float a, float b) {
    return a - b;
  }
  vec4 ${bt}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:bt,type:d.FunctionType.ValueBased}}function c(){const bt="equal_";return{body:`
  float ${bt}(float a, float b) {
    return float(a == b);
  }
  vec4 ${bt}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:bt,type:d.FunctionType.ValueBased}}function s(){const bt="greater_";return{body:`
  float ${bt}(float a, float b) {
    return float(a > b);
  }
  vec4 ${bt}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:bt,type:d.FunctionType.ValueBased}}function _(){const bt="less_";return{body:`
  float ${bt}(float a, float b) {
    return float(a < b);
  }
  vec4 ${bt}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:bt,type:d.FunctionType.ValueBased}}function b(){const bt="and_";return{body:`
  float ${bt}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${bt}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:bt,type:d.FunctionType.ValueBased}}function st(){const bt="or_";return{body:`
  float ${bt}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${bt}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:bt,type:d.FunctionType.ValueBased}}function dt(){const bt="xor_";return{body:`
  float ${bt}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${bt}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:bt,type:d.FunctionType.ValueBased}}function ct(){return function(bt){const $t=`${bt}_`;return{body:`
  float ${$t}(float a, float b) {
    return ${bt}(a, b);
  }
  vec4 ${$t}(vec4 v1, vec4 v2) {
    return ${bt}(v1, v2);
  }
  `,name:$t,type:d.FunctionType.ValueBased}}("pow")}function pt(){const bt="prelu_";return{body:`
  float ${bt}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${bt}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:bt,type:d.FunctionType.ValueBased}}e.glslAdd=et,e.glslDiv=ot,e.glslMul=it,e.glslSub=$,e.glslEqual=c,e.glslGreater=s,e.glslLess=_,e.glslAnd=b,e.glslOr=st,e.glslXor=dt,e.glslPow=ct,e.glslPRelu=pt;const ft=(bt,$t,Ct,It=$t[0].type,Tt)=>{const jt=bt.session.pack?h.TextureType.packed:h.TextureType.unpacked;return{name:Ct.name,inputNames:["A","B"],inputTypes:[jt,jt],cacheHint:Tt,get:()=>mt(bt,$t,Ct,It)}},mt=(bt,$t,Ct,It=$t[0].type)=>{const Tt=bt.session.pack?h.TextureType.packed:h.TextureType.unpacked,jt=!a.ShapeUtil.areEqual($t[0].dims,$t[1].dims);let dn=$t[0].dims;const yn=bt.session.pack;if(jt){const un=a.BroadcastUtil.calcShape($t[0].dims,$t[1].dims,!1);if(!un)throw new Error("Can't perform binary op on the given tensors");dn=un;const Wt=dn.length,Jt=$t[0].dims.length!==0?$t[0].dims.length:1,_n=$t[1].dims.length!==0?$t[1].dims.length:1,vn=$t[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",Sn=$t[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",hn=(0,g.getGlsl)(bt.session.backend.glContext.version),rr=yn?`
      ${Ct.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${Ct.name}(a, b);
        ${hn.output} = result;
      }`:`
      ${Ct.body}
      float process(int indices[${Wt}]) {
        int aindices[${Jt}];
        int bindices[${_n}];
        ${vn}
        ${Sn}
        return ${Ct.name}(_A(aindices), _B(bindices));
      }`;return{name:Ct.name,inputNames:["A","B"],inputTypes:[Tt,Tt],output:{dims:dn,type:It,textureType:Tt},shaderSource:rr,hasMain:yn}}const mn=(0,g.getGlsl)(bt.session.backend.glContext.version),fn=`
    ${Ct.body}
    void main() {
      vec4 v1 = ${mn.texture2D}(A, TexCoords);
      vec4 v2 = ${mn.texture2D}(B, TexCoords);
      vec4 result = ${Ct.name}(v1, v2);
      ${mn.output} = result;
    }
    `;return{name:Ct.name,inputNames:["A","B"],inputTypes:[Tt,Tt],output:{dims:$t[0].dims,type:It,textureType:Tt},shaderSource:fn,hasMain:!0}};e.add=(bt,$t)=>[bt.run(ft(bt,$t,et()),$t)],e.and=(bt,$t)=>[bt.run(ft(bt,$t,b(),"bool"),$t)],e.div=(bt,$t)=>[bt.run(ft(bt,$t,ot()),$t)],e.equal=(bt,$t)=>[bt.run(ft(bt,$t,c(),"bool"),$t)],e.greater=(bt,$t)=>[bt.run(ft(bt,$t,s(),"bool"),$t)],e.less=(bt,$t)=>[bt.run(ft(bt,$t,_(),"bool"),$t)],e.mul=(bt,$t)=>[bt.run(ft(bt,$t,it()),$t)],e.or=(bt,$t)=>[bt.run(ft(bt,$t,st(),"bool"),$t)],e.pow=(bt,$t)=>[bt.run(ft(bt,$t,ct()),$t)],e.pRelu=(bt,$t)=>[bt.run(ft(bt,$t,pt()),$t)],e.sub=(bt,$t)=>[bt.run(ft(bt,$t,$()),$t)],e.xor=(bt,$t)=>[bt.run(ft(bt,$t,dt(),"bool"),$t)]},4196:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseCastAttributes=e.cast=void 0;const a=o(2517);e.cast=(g,h,et)=>(d(h),[g.cast(h[0],et)]),e.parseCastAttributes=g=>a.ProtoUtil.tensorDataTypeFromProto(g.attributes.getInt("to"));const d=g=>{if(!g||g.length!==1)throw new Error("Cast requires 1 input.");if(g[0].type==="string")throw new Error("Invalid input type.")}},1163:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedConcatProgramInfoLoader=void 0;const a=o(5060),d=o(2039),g=o(9390),h=o(2827);e.createPackedConcatProgramInfoLoader=(ot,it,$)=>{const c=(s=it.length,_=$.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:s},(b,st)=>`X${st}`),inputTypes:Array(s).fill(d.TextureType.packed),cacheHint:_});var s,_;return Object.assign(Object.assign({},c),{get:()=>((b,st,dt,ct)=>{const pt=dt[0].dims.slice();if(ct>=pt.length||ct<-1*pt.length)throw new Error("axis specified for concat doesn't match input dimensionality");ct<0&&(ct=pt.length+ct);const ft=pt.slice(0);for(let vn=1;vn<dt.length;vn++){const Sn=dt[vn].dims.slice();for(let hn=0;hn<pt.length;hn++)if(hn===ct)ft[ct]+=Sn[hn];else if(pt[hn]!==Sn[hn])throw new Error("non concat dimensions must match")}const mt=ft.length,bt=(0,h.getChannels)("coords",mt),$t=(0,g.getCoordsDataType)(mt),Ct=(0,h.unpackFromChannel)(),It=dt.map(vn=>vn.dims),Tt=(0,g.getGlChannels)(mt),jt=new Array(It.length-1);jt[0]=It[0][ct];for(let vn=1;vn<jt.length;vn++)jt[vn]=jt[vn-1]+It[vn][ct];const dn=Tt[ct],yn=Tt.slice(-2),mn=Tt.join();let fn=`if (${dn} < ${jt[0]}) {
        return getChannel(
            getX0(${mn}), vec2(${yn.join()}));
        }`;for(let vn=1;vn<jt.length;vn++){const Sn=jt[vn-1];fn+=`
            if (${dn} < ${jt[vn]}  && ${dn} >= ${jt[vn-1]}) {
              return getChannel(
                getX${vn}(${et(Tt,dn,Sn)}),
                vec2(${et(yn,dn,Sn)}));
            }`}const un=jt.length,Wt=jt[jt.length-1];fn+=`
            return getChannel(
              getX${un}(${et(Tt,dn,Wt)}),
              vec2(${et(yn,dn,Wt)}));`;const Jt=(0,a.getGlsl)(b.session.backend.glContext.version),_n=`
          ${Ct}
          float getValue(${Tt.map(vn=>"int "+vn)}) {
            ${fn}
          }

          void main() {
            ${$t} coords = getOutputCoords();
            int lastDim = coords.${Tt[mt-1]};
            coords.${Tt[mt-1]} = coords.${Tt[mt-2]};
            coords.${Tt[mt-2]} = lastDim;

            vec4 result = vec4(getValue(${bt}), 0., 0., 0.);

            ${bt[mt-1]} = ${bt[mt-1]} + 1;
            if (${bt[mt-1]} < ${ft[mt-1]}) {
              result.g = getValue(${bt});
            }

            ${bt[mt-2]} = ${bt[mt-2]} + 1;
            if (${bt[mt-2]} < ${ft[mt-2]}) {
              result.a = getValue(${bt});
            }

            ${bt[mt-1]} = ${bt[mt-1]} - 1;
            if (${bt[mt-2]} < ${ft[mt-2]} &&
                ${bt[mt-1]} < ${ft[mt-1]}) {
              result.b = getValue(${bt});
            }
            ${Jt.output} = result;
          }
        `;return Object.assign(Object.assign({},st),{output:{dims:ft,type:dt[0].type,textureType:d.TextureType.packed},shaderSource:_n,hasMain:!0})})(ot,c,it,$.axis)})};const et=(ot,it,$)=>{const c=ot.indexOf(it);return ot.map((s,_)=>_===c?`${s} - ${$}`:s).join()}},2069:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseConcatAttributes=e.concat=void 0;const a=o(246),d=o(2039),g=o(1163);e.concat=(s,_,b)=>(c(_),s.session.pack&&_[0].dims.length>1?[s.run((0,g.createPackedConcatProgramInfoLoader)(s,_,b),_)]:[s.run(h(s,_,b),_)]);const h=(s,_,b)=>{const st=(dt=_.length,ct=b.cacheKey,{name:"Concat",inputNames:Array.from({length:dt},(pt,ft)=>`X${ft}`),inputTypes:Array(dt).fill(d.TextureType.unpacked),cacheHint:ct});var dt,ct;return Object.assign(Object.assign({},st),{get:()=>((pt,ft,mt,bt)=>{const $t=mt[0].dims.slice();if(bt>=$t.length||bt<-1*$t.length)throw new Error("axis specified for concat doesn't match input dimensionality");bt<0&&(bt=$t.length+bt);const Ct=$t.slice(0);for(let mn=1;mn<mt.length;mn++){const fn=mt[mn].dims.slice();for(let un=0;un<$t.length;un++)if(un===bt)Ct[bt]+=fn[un];else if($t[un]!==fn[un])throw new Error("non concat dimensions must match")}const It=Ct.length,Tt=new Array(mt.length);let jt=0;for(let mn=0;mn<Tt.length;++mn)jt+=mt[mn].dims[bt],Tt[mn]=jt;let dn="";dn=mt.length<5?et(Tt):ot(Tt);const yn=`
        ${it(mt.length,It)}
        ${$(Tt)}
        ${dn}
        float process(int indices[${It}]) {
          int textureIndex = getTextureWhereDataResides (indices[${bt}]);

          if(textureIndex != 0) {
            indices[${bt}] = indices[${bt}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},ft),{output:{dims:Ct,type:mt[0].type,textureType:d.TextureType.unpacked},shaderSource:yn})})(0,st,_,b.axis)})},et=s=>`int getTextureWhereDataResides(int index) {
      ${s.map((_,b)=>`if(index<${_}) {return ${b};}
`).join("")}
    }`,ot=s=>et(s),it=(s,_)=>{const b=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${_}]) {`];for(let st=0;st<s;++st)st===0?b.push(`	if (textureIndex == ${st}) { return _X${st}(indices); }`):st===s-1?b.push(`	else { return _X${st}(indices); }`):b.push(`	else if (textureIndex == ${st}) { return _X${st}(indices); }`);return b.push("	}"),b.join(`
`)},$=s=>{const _=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let b=0;b<s.length;++b)b===0?_.push(`	if (index == ${b}) { return ${s[b]}; }`):b===s.length-1?_.push(`	else { return ${s[b]}; }`):_.push(`	else if (index == ${b}) { return ${s[b]}; }`);return _.push("	}"),_.join(`
`)};e.parseConcatAttributes=s=>(0,a.createAttributeWithCacheKey)({axis:s.attributes.getInt("axis")});const c=s=>{if(!s||s.length<1)throw new Error("too few inputs");const _=s[0].type,b=s[0].dims.length;if(_==="string")throw new Error("string tensor is not supported yet");for(const st of s){if(st.type!==_)throw new Error("input tensors should be one type");if(st.dims.length!==b)throw new Error("input tensors should have the same shape")}}},4770:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createUnpackedGroupedConvProgramInfoLoader=void 0;const a=o(6231),d=o(5060),g=o(2039),h=o(8138),et=o(2823);e.createUnpackedGroupedConvProgramInfoLoader=(ot,it,$)=>{const c=(s=it.length>2,_=$.cacheKey,{name:"GroupedConv",inputNames:s?["X","W","Bias"]:["X","W"],inputTypes:s?[g.TextureType.unpacked,g.TextureType.unpacked,g.TextureType.unpacked]:[g.TextureType.unpacked,g.TextureType.unpacked],cacheHint:_});var s,_;return Object.assign(Object.assign({},c),{get:()=>((b,st,dt,ct)=>{const pt=st.length>2?"value += getBias(output_channel);":"",ft=st[0].dims.slice(),mt=st[1].dims.slice(),bt=mt[0]/ct.group;a.Logger.verbose("GroupedConv",`autpPad:${ct.autoPad}, dilations:${ct.dilations}, group:${ct.group}, kernelShape:${ct.kernelShape}, pads:${ct.pads}, strides:${ct.strides}`);const $t=(0,h.calculateOutputShape)(ft,mt,ct.dilations,ct.pads,ct.strides),Ct=(0,d.getGlsl)(b.session.backend.glContext.version),{activationFunction:It,applyActivation:Tt}=(0,et.getActivationSnippet)(ct),jt=`
  const ivec2 strides = ivec2(${ct.strides[0]}, ${ct.strides[1]});
  const ivec2 pads = ivec2(${ct.pads[0]}, ${ct.pads[1]});
  ${It}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${bt};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${mt[1]}; wInChannel++) {
      int input_channel = group_id * ${mt[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${mt[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${ct.dilations[0]};

        if (xHeight < 0 || xHeight >= ${ft[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${mt[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${ct.dilations[1]};
          if (xWidth < 0 || xWidth >= ${ft[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${pt}
    ${Tt}
    ${Ct.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},dt),{output:{dims:$t,type:st[0].type,textureType:g.TextureType.unpacked},shaderSource:jt,hasMain:!0})})(ot,it,c,$)})}},1386:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.conv2DPacked=e.conv2DPackedPointwise=void 0;const a=o(8138),d=o(8555),g=o(708);e.conv2DPackedPointwise=(h,et,ot)=>{const it=et[0].dims,$=et[1].dims,c=(0,a.calculateOutputShape)(it,$,ot.dilations,ot.pads,ot.strides),s=h.reshapePacked(et[0],[it[1],it[2]*it[3]]),_=h.reshapePacked(et[1],[$[0],$[1]]),b=et.length>2?[_,s,et[2]]:[_,s],st=h.run((0,g.createPackedMatmulProgramInfoLoader)(h,b,ot),b);return h.reshapePacked(st,c)},e.conv2DPacked=(h,et,ot)=>{const it=et[0].dims,$=et[1].dims,c=(0,a.calculateOutputShape)(it,$,ot.dilations,ot.pads,ot.strides),s=h.run((0,d.createPackedIm2ColProgramInfoLoader)(h,et[0],et[1],c,ot),[et[0]]),_=h.reshapePacked(et[1],[$[0],$[1]*$[2]*$[3]]),b=et.length===3?[_,s,et[2]]:[_,s],st=h.run((0,g.createPackedMatmulProgramInfoLoader)(h,b,ot),b);return h.reshapePacked(st,c)}},9663:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseConvTransposeAttributes=e.convTranspose=void 0;const a=o(246),d=o(5060),g=o(2039),h=o(2823),et=(_,b,st,dt,ct,pt)=>(_-1)*b+st+(dt-1)*ct+1-pt,ot=(_,b,st,dt,ct)=>{const pt=Math.floor(_/2);b==="SAME_UPPER"?(st[dt]=pt,st[ct]=_-pt):b==="SAME_LOWER"&&(st[dt]=_-pt,st[ct]=pt)};e.convTranspose=(_,b,st)=>(s(b,st),it(_,b,st));const it=(_,b,st)=>{const dt=c(st,b);return[$(_,b,dt)]},$=(_,b,st)=>_.run(((dt,ct,pt)=>{const ft=(mt=ct.length>2,bt=pt.cacheKey,{name:"ConvTranspose",inputNames:mt?["X","W","B"]:["X","W"],inputTypes:mt?[g.TextureType.unpacked,g.TextureType.unpacked,g.TextureType.unpacked]:[g.TextureType.unpacked,g.TextureType.unpacked],cacheHint:bt});var mt,bt;return Object.assign(Object.assign({},ft),{get:()=>(($t,Ct,It,Tt)=>{const jt=Ct.length>2?"getB(output_channel)":"0.0",dn=Ct[0].dims,yn=Ct[1].dims,mn=yn[1],fn=yn[0]/Tt.group,un=[Ct[0].dims[0],Ct[1].dims[1]*Tt.group,...Tt.outputShape],Wt=(0,d.getGlsl)($t.session.backend.glContext.version),{activationFunction:Jt,applyActivation:_n}=(0,h.getActivationSnippet)(Tt),vn=`
  const ivec2 strides = ivec2(${Tt.strides[0]}, ${Tt.strides[1]});
  const ivec2 pads = ivec2(${Tt.pads[0]}, ${Tt.pads[1]});
  ${Jt}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${mn};
    int wOutChannel = output_channel - group_id * ${mn};

    float value = ${jt};
    for (int inChannelOffset = 0; inChannelOffset < ${fn}; inChannelOffset++) {
      int input_channel = group_id * ${fn} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${yn[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${yn[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${Tt.dilations[0]}, wHOff * ${Tt.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${dn[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${dn[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${_n}
    ${Wt.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},It),{output:{dims:un,type:Ct[0].type,textureType:g.TextureType.unpacked},shaderSource:vn,hasMain:!0})})(dt,ct,ft,pt)})})(_,b,st),b),c=(_,b)=>{const st=_.kernelShape.slice();if(_.kernelShape.length===0)for(let ft=2;ft<b[1].dims.length;++ft)st.push(b[1].dims[ft]);const dt=_.pads.slice(),ct=_.outputShape.slice();((ft,mt,bt,$t,Ct,It,Tt,jt)=>{const dn=ft.length-2,yn=jt.length===0;for(let mn=0;mn<dn;++mn){const fn=yn?ft[mn+2]*It[mn]:jt[mn],un=et(ft[mn+2],It[mn],Ct[mn],mt[mn],bt[mn],fn);ot(un,$t,Ct,mn,mn+dn),yn&&jt.push(It[mn]*(ft[mn+2]-1)+Tt[mn]+(mt[mn]-1)*bt[mn]+1-Ct[mn]-Ct[mn+dn])}})(b[0].dims,st,_.dilations,_.autoPad,dt,_.strides,_.outputPadding,ct);const pt=Object.assign({},_);return Object.assign(pt,{kernelShape:st,pads:dt,outputShape:ct,cacheKey:_.cacheKey}),pt};e.parseConvTransposeAttributes=_=>{const b=_.attributes,st=(0,h.parseInternalActivationAttributes)(b),dt=b.getString("auto_pad","NOTSET"),ct=b.getInts("dilations",[1,1]),pt=b.getInt("group",1),ft=b.getInts("kernel_shape",[]),mt=b.getInts("output_padding",[0,0]),bt=b.getInts("output_shape",[]),$t=b.getInts("pads",[0,0,0,0]),Ct=b.getInts("strides",[1,1]);return(0,a.createAttributeWithCacheKey)(Object.assign({autoPad:dt,dilations:ct,group:pt,kernelShape:ft,outputPadding:mt,outputShape:bt,pads:$t,strides:Ct},st))};const s=(_,b)=>{if(!_||_.length!==2&&_.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(_[0].dims.length!==4||_[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(_[0].dims[1]!==_[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const st=_[1].dims[1]*b.group;if(_.length===3&&(_[2].dims.length!==1||_[2].dims[0]!==st))throw new Error("invalid bias");const dt=_[0].dims.length-2;if(b.dilations.length!==dt)throw new Error(`dilations should be ${dt}D`);if(b.strides.length!==dt)throw new Error(`strides should be ${dt}D`);if(b.pads.length!==2*dt)throw new Error(`pads should be ${2*dt}D`);if(b.outputPadding.length!==dt)throw new Error(`output_padding should be ${dt}D`);if(b.kernelShape.length!==0&&b.kernelShape.length!==_[1].dims.length-2)throw new Error("invalid kernel shape");if(b.outputShape.length!==0&&b.outputShape.length!==_[0].dims.length-2)throw new Error("invalid output shape");if(_[0].type!=="float32"||_[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(_.length===3&&_[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},8138:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseConvAttributes=e.conv=e.calculateOutputShape=void 0;const a=o(246),d=o(2517),g=o(4770),h=o(1386),et=o(9828),ot=o(2823),it=o(3248),$=o(5623);e.calculateOutputShape=(dt,ct,pt,ft,mt)=>{const bt=dt[0],$t=dt.slice(2),Ct=$t.length,It=ct[0],Tt=ct.slice(2).map((dn,yn)=>dn+(dn-1)*(pt[yn]-1)),jt=$t.map((dn,yn)=>dn+ft[yn]+ft[yn+Ct]).map((dn,yn)=>Math.floor((dn-Tt[yn]+mt[yn])/mt[yn]));return[bt,It].concat(...jt)},e.conv=(dt,ct,pt)=>(st(ct,pt),c(dt,ct,pt));const c=(dt,ct,pt)=>{const ft=b(pt,ct),mt=dt.session.pack,bt=ft.kernelShape[0]===1&&ft.kernelShape[1]===1;return ft.group>1?[dt.run((0,g.createUnpackedGroupedConvProgramInfoLoader)(dt,ct,ft),ct)]:bt&&mt?[s(dt,ct,ft)]:mt&&ct[0].dims.length===4&&ct[0].dims[0]===1&&!bt?[(0,h.conv2DPacked)(dt,ct,ft)]:[_(dt,ct,ft)]},s=(dt,ct,pt)=>{const ft=ct[0].dims,mt=ct[1].dims,bt=(0,e.calculateOutputShape)(ft,mt,pt.dilations,pt.pads,pt.strides),$t=dt.reshapeUnpacked(ct[0],[ft[1],ft[2]*ft[3]]),Ct=dt.reshapeUnpacked(ct[1],[mt[0],mt[1]]),It=ct.length>2?[Ct,$t,ct[2]]:[Ct,$t],Tt=dt.run((0,$.createMatmulProgramInfoLoader)(It,pt),It);return dt.reshapeUnpacked(Tt,bt)},_=(dt,ct,pt)=>{const ft=ct[0].dims,mt=ct[1].dims,bt=(0,e.calculateOutputShape)(ft,mt,pt.dilations,pt.pads,pt.strides),$t=dt.run((0,it.createIm2ColProgramInfoLoader)(dt,ct[0],ct[1],bt,pt),[ct[0]]),Ct=ct.length===3?[$t,ct[1],ct[2]]:[$t,ct[1]];return dt.run((0,et.createDotProductProgramInfoLoader)(dt,ct,bt,pt),Ct)},b=(dt,ct)=>{const pt=dt.kernelShape.slice();if(dt.kernelShape.length===0)for(let bt=2;bt<ct[1].dims.length;++bt)pt.push(ct[1].dims[bt]);const ft=dt.pads.slice();d.PoolConvUtil.adjustPadsBasedOnAutoPad(ct[0].dims,dt.strides,dt.dilations,pt,ft,dt.autoPad);const mt=Object.assign({},dt);return Object.assign(mt,{kernelShape:pt,pads:ft,cacheKey:dt.cacheKey}),mt};e.parseConvAttributes=dt=>{const ct=dt.attributes,pt=(0,ot.parseInternalActivationAttributes)(ct),ft=ct.getString("auto_pad","NOTSET"),mt=ct.getInts("dilations",[1,1]),bt=ct.getInt("group",1),$t=ct.getInts("kernel_shape",[]),Ct=ct.getInts("pads",[0,0,0,0]),It=ct.getInts("strides",[1,1]);return(0,a.createAttributeWithCacheKey)(Object.assign({autoPad:ft,dilations:mt,group:bt,kernelShape:$t,pads:Ct,strides:It},pt))};const st=(dt,ct)=>{if(!dt||dt.length!==2&&dt.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(dt[0].dims.length!==4||dt[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(dt[0].dims[1]!==dt[1].dims[1]*ct.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(dt.length===3&&(dt[2].dims.length!==1||dt[1].dims[0]!==dt[2].dims[0]))throw new Error("invalid bias");const pt=dt[0].dims.length-2;if(ct.dilations.length!==pt)throw new Error(`dilations should be ${pt}D`);if(ct.strides.length!==pt)throw new Error(`strides should be ${pt}D`);if(ct.pads.length!==2*pt)throw new Error(`pads should be ${2*pt}D`);if(ct.kernelShape.length!==0&&ct.kernelShape.length!==dt[1].dims.length-2)throw new Error("invalid kernel shape");if(dt[0].type!=="float32"||dt[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(dt.length===3&&dt[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},5193:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseDepthToSpaceAttributes=e.depthToSpace=void 0;const a=o(3738);e.depthToSpace=(g,h,et)=>{d(h);const ot=et.blocksize,it=ot*ot,$=et.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],c=et.mode==="DCR"?[h[0].dims[0],ot,ot,h[0].dims[1]/it,h[0].dims[2],h[0].dims[3]]:[h[0].dims[0],h[0].dims[1]/it,ot,ot,h[0].dims[2],h[0].dims[3]],s=g.reshapeUnpacked(h[0],c),_={perm:$,cacheKey:`${$}`},[b]=(0,a.transpose)(g,[s],_),st=[h[0].dims[0],h[0].dims[1]/it,h[0].dims[2]*ot,h[0].dims[3]*ot];return[g.reshapeUnpacked(b,st)]},e.parseDepthToSpaceAttributes=g=>{const h=g.attributes.getInt("blocksize");if(h<1)throw new Error(`blocksize must be >= 1, but got : ${h} for DepthToSpace`);const et=g.attributes.getString("mode","DCR");if(et!=="DCR"&&et!=="CRD")throw new Error(`unrecognized mode: ${et} for DepthToSpace`);return{mode:et,blocksize:h}};const d=g=>{if(g.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${g.length}`);if(g[0].type==="string"||g[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createDotProductProgramInfoLoader=void 0;const a=o(2517),d=o(5060),g=o(2039),h=o(2823),et=o(3248);e.createDotProductProgramInfoLoader=(ot,it,$,c)=>{const s=((_,b)=>({name:"ConvDotProduct",inputNames:_?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:_?[g.TextureType.unpacked,g.TextureType.packedLastDimension,g.TextureType.unpacked]:[g.TextureType.unpacked,g.TextureType.packedLastDimension],cacheKey:b.activationCacheKey}))(it.length>2,c);return Object.assign(Object.assign({},s),{get:()=>((_,b,st,dt,ct)=>{const pt=st[0].dims,ft=st[1].dims,mt=[ft[0],Math.ceil(pt[1]*ft[2]*ft[3]/4)],bt=(0,et.calculateIm2ColDims)(pt,ft,dt),[$t,Ct]=_.calculateTextureWidthAndHeight(mt,g.TextureType.packedLastDimension),It=a.ShapeUtil.computeStrides(bt),[Tt,jt]=_.calculateTextureWidthAndHeight(bt,g.TextureType.packedLastDimension),dn=dt.length,yn=st.length<3?"0.0":"_B(b)",mn=Math.ceil(pt[1]*ft[2]*ft[3]/4),{activationFunction:fn,applyActivation:un}=(0,h.getActivationSnippet)(ct),Wt=(0,d.getGlsl)(_.session.backend.glContext.version),Jt=`
${fn}
float process(int indices[${dn}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${It[0]} + im2col[1] * ${It[1]} + im2col[2] * ${It[2]};
  int kernelOffset = indices[1] * ${mt[1]};
  float value = ${yn};
  for (int i = 0; i < ${mn}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${Tt}, ${jt});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${$t}, ${Ct});
    value += dot(${Wt.texture2D}(Im2Col, im2colCoords), ${Wt.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${un}
  return value;
}`;return Object.assign(Object.assign({},b),{output:{dims:dt,type:st[0].type,textureType:g.TextureType.unpacked},shaderSource:Jt})})(ot,s,it,$,c)})}},7992:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseFlattenAttributes=e.flatten=void 0;const a=o(2517);e.flatten=(g,h,et)=>{d(h,et);const ot=a.ShapeUtil.flattenShape(h[0].dims,et);return[g.reshapeUnpacked(h[0],ot)]},e.parseFlattenAttributes=g=>g.attributes.getInt("axis",1);const d=(g,h)=>{if(!g||g.length!==1)throw new Error("Flatten requires 1 input.");const et=g[0].dims.length;if(et===0)throw new Error("scalar tensor is not supported.");if(h<-et||h>et)throw new Error("Invalid axis");if(g[0].type==="string")throw new Error("string tensor is not supported.")}},2823:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseInternalActivationAttributes=e.getActivationSnippet=void 0;const a=o(2517),d=o(4909);e.getActivationSnippet=function(g){let h;switch(g.activation){case"Relu":h=(0,d.glslRelu)();break;case"Sigmoid":h=(0,d.glslSigmoid)();break;case"Clip":h=(0,d.glslClip)(g.clipMin,g.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const et=h.name;return{activationFunction:h.body,applyActivation:`value = ${et}_(value);`}},e.parseInternalActivationAttributes=g=>{const h=g.getString("activation","");if(h==="Clip"){const[et,ot]=g.getFloats("activation_params",[a.MIN_CLIP,a.MAX_CLIP]);return{activation:h,clipMax:ot,clipMin:et,activationCacheKey:`${h}:${et},${ot}`}}return{activation:h,activationCacheKey:h}}},1253:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseGatherAttributes=e.gather=void 0;const a=o(246),d=o(782),g=o(2517),h=o(2039);e.gather=($,c,s)=>(it(c,s.axis),[$.run(ot($,c,s),c)]),e.parseGatherAttributes=$=>(0,a.createAttributeWithCacheKey)({axis:$.attributes.getInt("axis",0)});const et={name:"Gather",inputNames:["A","B"],inputTypes:[h.TextureType.unpacked,h.TextureType.unpacked]},ot=($,c,s)=>{const _=Object.assign(Object.assign({},et),{cacheHint:s.cacheKey});return Object.assign(Object.assign({},_),{get:()=>((b,st,dt,ct)=>{const pt=dt[0].dims.slice(),ft=dt[1].dims.slice(),mt=new Array(pt.length+ft.length-1);ct=g.ShapeUtil.normalizeAxis(ct,pt.length);const bt=[];for(let Ct=0;Ct<mt.length;Ct++)Ct<ct?(mt[Ct]=pt[Ct],bt.push(`inputIdx[${Ct}] = outputIdx[${Ct}];`)):Ct<ct+ft.length?(mt[Ct]=ft[Ct-ct],bt.push(`indexDataIdx[${Ct-ct}] = outputIdx[${Ct}];`)):(mt[Ct]=pt[Ct-ft.length+1],bt.push(`inputIdx[${Ct-ft.length+1}] = outputIdx[${Ct}];`));const $t=`
      float process(int outputIdx[${mt.length||1}]) {
        int inputIdx[${pt.length}];
        int indexDataIdx[${ft.length||1}];
        indexDataIdx[0] = 0;
        ${bt.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${ct}] = idx < 0 ? idx + ${pt[ct]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},st),{output:{dims:mt,type:dt[0].type,textureType:h.TextureType.unpacked},shaderSource:$t})})(0,_,c,s.axis)})},it=($,c)=>{if(!$||$.length!==2)throw new Error("Gather requires 2 inputs.");const s=$[0].dims.length;if(s<1)throw new Error("Invalid input shape.");if(c<-s||c>s-1)throw new Error("Invalid axis.");if(d.NUMBER_TYPES.indexOf($[0].type)===-1)throw new Error("Invaid input type.");if($[1].type!=="int32"&&$[1].type!=="int16")throw new Error("Invaid input type.")}},4776:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseGemmAttributesV11=e.parseGemmAttributesV7=e.gemm=void 0;const a=o(246),d=o(2517),g=o(2039);e.gemm=($,c,s)=>(it(c,s),[$.run(et(c,s),c)]);const h=($,c)=>{const s=$.attributes.getInt("transA",0)!==0,_=$.attributes.getInt("transB",0)!==0,b=$.attributes.getFloat("alpha",1),st=$.attributes.getFloat("beta",1);return(0,a.createAttributeWithCacheKey)({transA:s,transB:_,alpha:b,beta:st,isOptionalC:c})};e.parseGemmAttributesV7=$=>h($,!1),e.parseGemmAttributesV11=$=>h($,!0);const et=($,c)=>{const s={name:"Gemm",inputNames:$.length===3?["A","B","C"]:["A","B"],inputTypes:$.length===3?[g.TextureType.unpacked,g.TextureType.unpacked,g.TextureType.unpacked]:[g.TextureType.unpacked,g.TextureType.unpacked],key:c.cacheKey};return Object.assign(Object.assign({},s),{get:()=>ot(s,$,c)})},ot=($,c,s)=>{const _=c[0].dims.slice(),b=c[1].dims.slice(),[st,dt]=d.GemmUtil.getShapeOfGemmResult(_,s.transA,b,s.transB,c.length===3?c[2].dims:void 0),ct=[st,dt];if(!ct)throw new Error("Can't use gemm on the given tensors");let pt=_[_.length-1],ft="";s.transA&&(pt=_[0]),s.transA&&s.transB?ft="value += _A_T(a) * _B_T(b);":s.transA&&!s.transB?ft="value += _A_T(a) * _B(b);":!s.transA&&s.transB?ft="value += _A(a) * _B_T(b);":s.transA||s.transB||(ft="value += _A(a) * _B(b);");const mt=ct.length,bt=`
      float process(int indices[${mt}]) {
          int a[${mt}];
          int b[${mt}];
          ${c.length===3?`int c[${c[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${c.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${pt}; ++k) {
              a[${mt-1}] = k;
              b[${mt-2}] = k;
              ${ft}
          }

          value = value * alpha;
          ${c.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},$),{output:{dims:ct,type:c[0].type,textureType:g.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:s.alpha},{name:"beta",type:"float",data:s.beta}],shaderSource:bt})},it=($,c)=>{if(!$)throw new Error("Input is missing");if(c.isOptionalC&&($.length<2||$.length>3))throw new Error("Invaid input shape.");if(!c.isOptionalC&&$.length!==3)throw new Error("Gemm requires 3 inputs");if($.length===3&&$[2].dims.length!==1&&$[2].dims.length!==2)throw new Error("Invalid input shape of C");if($[0].type!=="float32"&&$[0].type!=="float64"||$[1].type!=="float32"&&$[1].type!=="float64"||$.length===3&&$[2].type!=="float32"&&$[2].type!=="float64")throw new Error("Invalid input type.");if($[0].type!==$[1].type||$.length===3&&$[0].type!==$[2].type)throw new Error("Input types are mismatched")}},8555:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedIm2ColProgramInfoLoader=void 0;const a=o(5060),d=o(2039),g=o(2827);e.createPackedIm2ColProgramInfoLoader=(h,et,ot,it,$)=>{const c=(s=$.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[d.TextureType.packed],cacheHint:s});var s;return Object.assign(Object.assign({},c),{get:()=>((_,b,st,dt,ct,pt)=>{const ft=st.dims,mt=dt.dims,bt=ct.length,$t=[mt[1]*mt[2]*mt[3],ct[2]*ct[3]],Ct=mt[2]*mt[3],It=(0,g.unpackFromChannel)(),Tt=(0,a.getGlsl)(_.session.backend.glContext.version);let jt="";for(let yn=0;yn<=1;yn++)for(let mn=0;mn<=1;mn++)jt+=`
            blockIndex = rc.x + ${mn};
            pos = rc.y + ${yn};

            if(blockIndex < ${$t[1]} && pos < ${$t[0]}) {
              offsetY = int(blockIndex / (${ct[bt-1]})) * ${pt.strides[0]} -
                ${pt.pads[0]};
              d0 = offsetY + ${pt.dilations[0]} * (imod(pos, ${Ct}) / ${mt[2]});

              if(d0 < ${ft[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${ct[bt-1]}) * ${pt.strides[1]} -
                  ${pt.pads[1]};
                d1 = offsetX + ${pt.dilations[1]} * imod(imod(pos, ${Ct}), ${mt[2]});

                if(d1 < ${ft[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${Ct}.);
                    innerDims = vec2(d0, d1);
                    result[${2*yn+mn}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const dn=`
      ${It}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${jt}
          ${Tt.output} = result;
      }
            `;return Object.assign(Object.assign({},b),{output:{dims:$t,type:st.type,textureType:d.TextureType.packed},shaderSource:dn,hasMain:!0})})(h,c,et,ot,it,$)})}},3248:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.calculateIm2ColDims=e.createIm2ColProgramInfoLoader=void 0;const a=o(2039);e.createIm2ColProgramInfoLoader=(d,g,h,et,ot)=>{const it=($=ot.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[a.TextureType.unpacked],cacheHint:$});var $;return Object.assign(Object.assign({},it),{get:()=>((c,s,_,b,st,dt)=>{const ct=_.dims,pt=b.dims,ft=st.length,mt=(0,e.calculateIm2ColDims)(ct,pt,st,4),bt=`
        const int XC = ${ct[1]};
        const int XH = ${ct[2]};
        const int XW = ${ct[3]};
        const int KH = ${dt.kernelShape[0]};
        const int KW = ${dt.kernelShape[1]};
        const int dilationH = ${dt.dilations[0]};
        const int dilationW = ${dt.dilations[1]};
        const int strideH = ${dt.strides[0]};
        const int strideW = ${dt.strides[1]};
        const int padH = ${dt.pads[0]};
        const int padW = ${dt.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${ft}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${ct.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},s),{output:{dims:mt,type:_.type,textureType:a.TextureType.packedLastDimension},shaderSource:bt})})(0,it,g,h,et,ot)})},e.calculateIm2ColDims=(d,g,h,et=4)=>[h[0],h[2],h[3],Math.ceil(d[1]*g[2]*g[3]/et)]},6572:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseImageScalerAttributes=e.imageScaler=void 0;const a=o(246),d=o(2039);e.imageScaler=(it,$,c)=>(ot($),[it.run(h(it,$,c),$)]),e.parseImageScalerAttributes=it=>{const $=it.attributes.getFloat("scale"),c=it.attributes.getFloats("bias");return(0,a.createAttributeWithCacheKey)({scale:$,bias:c})};const g={name:"ImageScaler",inputNames:["X"],inputTypes:[d.TextureType.unpacked]},h=(it,$,c)=>{const s=Object.assign(Object.assign({},g),{cacheHint:c.cacheKey});return Object.assign(Object.assign({},s),{get:()=>((_,b,st,dt)=>{const ct=st[0].dims.slice(),pt=ct.length,ft=`
      ${et(dt.bias.length)}
      float process(int indices[${pt}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},b),{output:{dims:ct,type:st[0].type,textureType:d.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:dt.bias.length,data:dt.bias},{name:"scale",type:"float",data:dt.scale}],shaderSource:ft})})(0,s,$,c)})},et=it=>{const $=[`float getBias(float bias[${it}], int channel) {`];for(let c=0;c<it;++c)c===0?$.push(`	if (channel == ${c}) { return bias[${c}]; }`):c===it-1?$.push(`	else { return bias[${c}]; }`):$.push(`	else if (channel == ${c}) { return bias[${c}]; }`);return $.push("	}"),$.join(`
`)},ot=it=>{if(!it||it.length!==1)throw new Error("ImageScaler requires 1 input.");if(it[0].dims.length!==4)throw new Error("Invalid input shape.");if(it[0].type!=="float32"&&it[0].type!=="float64")throw new Error("Invalid input type.")}},3346:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseInstanceNormalizationAttributes=e.instanceNormalization=void 0;const a=o(5060),d=o(2039);e.instanceNormalization=($,c,s)=>{it(c);const _=$.run(h(c[0]),c);return[$.run(ot($,c[0],s,_.dims),[c[0],_,c[1],c[2]])]},e.parseInstanceNormalizationAttributes=$=>$.attributes.getFloat("epsilon",1e-5);const g={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[d.TextureType.unpacked]},h=$=>Object.assign(Object.assign({},g),{get:()=>((c,s)=>{const _=s.dims.slice(),b=_[1],st=_[2]*_[3],dt=[_[0],b],ct=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${_[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${_[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${st});
        temp = 0.0;
        for(int a2=0; a2<${_[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${_[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${st});

        return v;
      }`;return Object.assign(Object.assign({},c),{output:{dims:dt,type:s.type,textureType:d.TextureType.packedLastDimension},shaderSource:ct})})(g,$)}),et={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[d.TextureType.unpacked,d.TextureType.packedLastDimension,d.TextureType.unpacked,d.TextureType.unpacked]},ot=($,c,s,_)=>{const b=Object.assign(Object.assign({},et),{cacheHint:`${s}`});return Object.assign(Object.assign({},b),{get:()=>((st,dt,ct,pt,ft)=>{const mt=(0,a.getGlsl)(st.session.backend.glContext.version),[bt,$t]=st.calculateTextureWidthAndHeight(ft,d.TextureType.packedLastDimension),[Ct,It]=[bt/4,$t],Tt=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${Ct}, ${It});
        return ${mt.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},dt),{output:{dims:ct.dims,type:ct.type,textureType:d.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:pt}],shaderSource:Tt})})($,b,c,s,_)})},it=$=>{if(!$||$.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const c=$[0],s=$[1],_=$[2];if(c.dims.length<3||s.dims.length!==1||_.dims.length!==1)throw new Error("Invalid input shape.");if(s.dims[0]!==c.dims[1]||_.dims[0]!==c.dims[1])throw new Error("Input shapes are mismatched.");if(c.type!=="float32"&&c.type!=="float64"||s.type!=="float32"&&s.type!=="float64"||_.type!=="float32"&&_.type!=="float64")throw new Error("Invalid input type.");if($[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},708:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedMatmulProgramInfoLoader=void 0;const a=o(2517),d=o(5060),g=o(2039),h=o(9390),et=o(2823),ot=o(5623);e.createPackedMatmulProgramInfoLoader=(it,$,c)=>{const s=(_=$.length>2,b=c.activationCacheKey,{name:"MatMul (packed)",inputNames:_?["A","B","Bias"]:["A","B"],inputTypes:_?[g.TextureType.packed,g.TextureType.packed,g.TextureType.packed]:[g.TextureType.packed,g.TextureType.packed],cacheHint:b});var _,b;return Object.assign(Object.assign({},s),{get:()=>((st,dt,ct,pt)=>{const ft=ct.length>2,mt=ft?"value += getBiasForMatmul();":"",bt=ct[0].dims,$t=ct[1].dims,Ct=a.BroadcastUtil.calcShape(bt,$t,!0),It=!a.ShapeUtil.areEqual(ct[0].dims,ct[1].dims);if(!Ct)throw new Error("Can't use matmul on the given tensors");const Tt=bt[bt.length-1],jt=Math.ceil(Tt/2),dn=bt.length,yn=$t.length,mn=(0,d.getGlsl)(st.session.backend.glContext.version),fn=(0,h.getCoordsDataType)(Ct.length),un=Ct.length,Wt=(0,h.getGlChannels)(),{activationFunction:Jt,applyActivation:_n}=(0,et.getActivationSnippet)(pt),vn=ft?`${(0,ot.getBiasForMatmul)(fn,Wt,ct[2].dims,Ct,!0)}`:"",Sn=It?`${function(Ir,$r,Ur,Yr){let r0=[],b0=[];const t0=Ur[0].dims,l0=Ur[1].dims,_i=t0.length,Po=l0.length,vm=Yr.length,s0=vm-_i,k0=vm-Po;r0=t0.map((a0,e0)=>`coords.${$r[e0+s0]}`),r0[_i-1]="i*2",r0.join(", "),b0=l0.map((a0,e0)=>`coords.${$r[e0+k0]}`),b0[Po-2]="i*2",b0.join(", ");const E0=a.BroadcastUtil.getBroadcastDims(t0,Yr),O0=a.BroadcastUtil.getBroadcastDims(l0,Yr),U0=E0.map(a0=>`coords.${$r[a0+s0]} = 0;`).join(`
`),w0=O0.map(a0=>`coords.${$r[a0+k0]} = 0;`).join(`
`),v0=`int lastDim = coords.${$r[vm-1]};
  coords.${$r[vm-1]} = coords.${$r[vm-2]};
  coords.${$r[vm-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${Ir} coords = getOutputCoords();
  ${v0}
  ${U0}
  vec4 outputValue = getA(${r0});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${Ir} coords = getOutputCoords();
  ${v0}
  ${w0}
  vec4 outputValue = getB(${b0});
  return outputValue;
}`}(fn,Wt,ct,Ct)}`:"",hn=It?"getAAtOutCoordsMatmul(i)":`getA(${function(Ir,$r){let Ur="";for(let Yr=0;Yr<$r-2;Yr++)Ur+=`rc.${Ir[Yr]}, `;return Ur+=`rc.${Ir[$r-2]}, i*2`,Ur}(Wt,dn)})`,rr=It?"getBAtOutCoordsMatmul(i)":`getB(${function(Ir,$r){let Ur="";for(let Yr=0;Yr<$r-2;Yr++)Ur+=`rc.${Ir[Yr]}, `;return Ur+=`i*2, rc.${Ir[$r-1]}`,Ur}(Wt,yn)})`,vr=`
            ${Sn}
            ${vn}
            ${Jt}
            void main() {
              ${It?"":`${fn} rc =
          getOutputCoords(); int lastDim = rc.${Wt[un-1]}; rc.${Wt[un-1]} =
          rc.${Wt[un-2]}; rc.${Wt[un-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${jt}; i++) {
                vec4 a = ${hn};
                vec4 b = ${rr};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${mt}
              ${_n}
              ${mn.output} = value;
            }`;return Object.assign(Object.assign({},dt),{output:{dims:Ct,type:ct[0].type,textureType:g.TextureType.packed},shaderSource:vr,hasMain:!0})})(it,s,$,c)})}},5623:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getBiasForMatmul=e.createMatmulProgramInfoLoader=e.parseMatMulAttributes=e.matMul=void 0;const a=o(2517),d=o(2039),g=o(9390),h=o(2823),et=o(708);function ot(c,s){const _=(b=c.length>2,st=s.activationCacheKey,{name:"MatMul",inputNames:b?["A","B","Bias"]:["A","B"],inputTypes:b?[d.TextureType.unpacked,d.TextureType.unpacked,d.TextureType.unpacked]:[d.TextureType.unpacked,d.TextureType.unpacked],cacheHint:st});var b,st;return Object.assign(Object.assign({},_),{get:()=>function(dt,ct,pt){const ft=ct[0].dims,mt=ct[1].dims,bt=a.BroadcastUtil.calcShape(ft,mt,!0);if(!bt)throw new Error("Can't use matmul on the given tensors");const $t=(0,g.getCoordsDataType)(bt.length),Ct=(0,g.getGlChannels)(),{activationFunction:It,applyActivation:Tt}=(0,h.getActivationSnippet)(pt),jt=ct.length>2,dn=jt?"value += getBiasForMatmul();":"",yn=jt?`${$($t,Ct,ct[2].dims,bt,!1)}`:"",mn=bt.length,fn=ft.length,un=mt.length,Wt=`
    ${It}
    ${yn}
    float process(int indices[${mn}]) {
        int a[${fn}];
        int b[${un}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${ft[ft.length-1]}; ++k) {
            a[${fn-1}] = k;
            b[${un-2}] = k;
            value += _A(a) * _B(b);
        }
        ${dn}
        ${Tt}
        return value;
    }`;return Object.assign(Object.assign({},dt),{output:{dims:bt,type:ct[0].type,textureType:d.TextureType.unpacked},shaderSource:Wt})}(_,c,s)})}e.matMul=(c,s,_)=>(it(s),c.session.pack?[c.run((0,et.createPackedMatmulProgramInfoLoader)(c,s,_),s)]:[c.run(ot(s,_),s)]),e.parseMatMulAttributes=c=>(0,h.parseInternalActivationAttributes)(c.attributes),e.createMatmulProgramInfoLoader=ot;const it=c=>{if(!c||c.length!==2)throw new Error("MatMul requires 2 inputs.");if(c[0].dims[c[0].dims.length-1]!==c[1].dims[c[1].dims.length-2])throw new Error("shared dimension does not match.");if(c[0].type!=="float32"&&c[0].type!=="float64"||c[1].type!=="float32"&&c[1].type!=="float64")throw new Error("inputs should be float type");if(c[0].type!==c[1].type)throw new Error("inputs types should match")};function $(c,s,_,b,st){let dt="";const ct=_.length,pt=b.length,ft=pt-ct;dt=pt<2&&ct>0?"coords":_.map(($t,Ct)=>`coords.${s[Ct+ft]}`).join(", ");const mt=a.BroadcastUtil.getBroadcastDims(_,b).map($t=>`coords.${s[$t+ft]} = 0;`).join(`
`);let bt="vec4(outputValue.xx, outputValue.yy)";return a.ShapeUtil.size(_)===1&&(bt="vec4(outputValue.x)"),st?`
vec4 getBiasForMatmul() {
  ${c} coords = getOutputCoords();
  ${mt}
  vec4 outputValue = getBias(${dt});
  return ${bt};
}`:`
float getBiasForMatmul() {
  ${c} coords = getOutputCoords();
  ${mt}
  return getBias(coords.x);
}`}e.getBiasForMatmul=$},2403:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createPackProgramInfoLoader=void 0;const a=o(5060),d=o(2039),g=o(9390),h=o(2827),et={name:"pack",inputNames:["A"],inputTypes:[d.TextureType.unpackedReversed]};e.createPackProgramInfoLoader=(ot,it)=>Object.assign(Object.assign({},et),{get:()=>(($,c)=>{const s=(0,a.getGlsl)($.session.backend.glContext.version),_=c.dims,b=_.length,st=c.dims.length,dt=(0,g.getCoordsDataType)(st),ct=(0,h.getChannels)("rc",st),pt=(ft=st,mt=ct,bt=_[_.length-2],$t=_[_.length-1],ft===0||ft===1?"":`
    int r = ${mt[ft-2]};
    int c = ${mt[ft-1]};
    int rp1 = ${mt[ft-2]} + 1;
    int cp1 = ${mt[ft-1]} + 1;
    bool rEdge = rp1 >= ${$t};
    bool cEdge = cp1 >= ${bt};
    `);var ft,mt,bt,$t;let Ct;Ct=b===0?[1,1]:b===1?[_[0],1]:[_[st-1],_[st-2]];const It=function(dn,yn,mn){if(dn===0)return"false";if(dn===1)return`rc > ${yn[0]}`;let fn="";for(let un=dn-2;un<dn;un++)fn+=`${mn[un]} >= ${yn[un-dn+2]}`,un<dn-1&&(fn+="||");return fn}(st,Ct,ct),Tt=function(dn,yn){const mn=dn.length;if(mn===0)return"getA(), 0, 0, 0";if(mn===1)return`getA(rc),
            rc + 1 >= ${dn[0]} ? 0. : getA(rc + 1),
            0, 0`;let fn="";if(mn>2)for(let un=0;un<mn-2;++un)fn+=`${yn[un]},`;return`getA(${fn}r, c),
          rEdge ? 0. : getA(${fn}rp1, c),
          cEdge ? 0. : getA(${fn}r, cp1),
          rEdge || cEdge ? 0. : getA(${fn}rp1, cp1)`}(_,ct),jt=`
        void main() {
          ${dt} rc = getOutputCoords();

          if(${It}) {
            ${s.output} = vec4(0);
          } else {
            ${pt}

            ${s.output} = vec4(${Tt});
          }
        }
      `;return Object.assign(Object.assign({},et),{hasMain:!0,output:{dims:c.dims,type:c.type,textureType:d.TextureType.packed},shaderSource:jt})})(ot,it)})},2827:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.unpackFromChannel=e.getChannels=e.getVecChannels=void 0;const a=o(9390);function d(g,h){return(0,a.getGlChannels)(h).map(et=>`${g}.${et}`)}e.getVecChannels=d,e.getChannels=function(g,h){return h===1?[g]:d(g,h)},e.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},2870:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parsePadAttributesV11=e.padV11=e.parsePadAttributesV2=e.padV2=void 0;const a=o(246),d=o(2517),g=o(5060),h=o(2039),et={name:"Pad",inputNames:["A"],inputTypes:[h.TextureType.unpacked]};e.padV2=(dt,ct,pt)=>($(ct),[dt.run(Object.assign(Object.assign({},et),{cacheHint:pt.cacheKey,get:()=>it(dt,ct[0],pt)}),ct)]),e.parsePadAttributesV2=dt=>{const ct=dt.attributes.getString("mode","constant"),pt=dt.attributes.getFloat("value",0),ft=dt.attributes.getInts("pads");return(0,a.createAttributeWithCacheKey)({mode:ct,value:pt,pads:ft})},e.padV11=(dt,ct,pt)=>{c(ct);const ft=ot(dt,ct,pt);return(0,e.padV2)(dt,[ct[0]],ft)},e.parsePadAttributesV11=dt=>dt.attributes.getString("mode","constant");const ot=(dt,ct,pt)=>{if(!dt.session.isInitializer(ct[1].dataId)||ct.length>=3&&!dt.session.isInitializer(ct[2].dataId))throw new Error("dynamic pad attributes are not allowed");const ft=Array.from(ct[1].integerData),mt=ct.length>=3?ct[2].floatData[0]:0;return(0,a.createAttributeWithCacheKey)({mode:pt,pads:ft,value:mt})},it=(dt,ct,pt)=>{const ft=d.ShapeUtil.padShape(ct.dims.slice(),pt.pads),mt=ft.length,bt=`
      ${s(dt,ct,pt)}
      float process(int[${mt}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[h.TextureType.unpacked],output:{dims:ft,type:ct.type,textureType:h.TextureType.unpacked},shaderSource:bt}},$=dt=>{if(!dt||dt.length!==1)throw new Error("Pad requires 1 input");if(dt[0].type!=="float32"&&dt[0].type!=="float64")throw new Error("Invalid input type.")},c=dt=>{if(!dt||dt.length!==2&&dt.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(dt[1].type!=="int32")throw new Error("Invalid input type.");if(dt.length>=3&&dt[2].type==="string")throw new Error("Invalid input type.")},s=(dt,ct,pt)=>{const ft=(0,g.getGlsl)(dt.session.backend.glContext.version),[mt,bt]=dt.calculateTextureWidthAndHeight(ct.dims,h.TextureType.unpacked),$t=d.ShapeUtil.computeStrides(ct.dims);switch(pt.mode){case"constant":return _(ft,ct.dims,$t,mt,bt,pt.pads,pt.value);case"reflect":return b(ft,ct.dims,$t,mt,bt,pt.pads);case"edge":return st(ft,ct.dims,$t,mt,bt,pt.pads);default:throw new Error("Invalid mode")}},_=(dt,ct,pt,ft,mt,bt,$t)=>{const Ct=ct.length;let It="";for(let Tt=Ct-1;Tt>=0;--Tt)It+=`
        k = m[${Tt}] - ${bt[Tt]};
        if (k < 0)  return constant;
        if (k >= ${ct[Tt]}) return constant;
        offset += k * ${pt[Tt]};
        `;return`
      float padA(int m[${Ct}]) {
        const float constant = float(${$t});
        int offset = 0;
        int k = 0;
        ${It}
        vec2 coords = offsetToCoords(offset, ${ft}, ${mt});
        float value = getColorAsFloat(${dt.texture2D}(A, coords));
        return value;
      }
      `},b=(dt,ct,pt,ft,mt,bt)=>{const $t=ct.length;let Ct="";for(let It=$t-1;It>=0;--It)Ct+=`
        k = m[${It}] - ${bt[It]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(ct[It]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${ct[It]}) { k = _2n_1 - k; }
        }
        offset += k * ${pt[It]};
        `;return`
      float padA(int m[${$t}]) {
        int offset = 0;
        int k = 0;
        ${Ct}
        vec2 coords = offsetToCoords(offset, ${ft}, ${mt});
        float value = getColorAsFloat(${dt.texture2D}(A, coords));
        return value;
      }
      `},st=(dt,ct,pt,ft,mt,bt)=>{const $t=ct.length;let Ct="";for(let It=$t-1;It>=0;--It)Ct+=`
        k = m[${It}] - ${bt[It]};
        if (k < 0)  k = 0;
        if (k >= ${ct[It]}) k = ${ct[It]-1};
        offset += k * ${pt[It]};
      `;return`
      float padA(int m[${$t}]) {
        int offset = 0;
        int k = 0;
        ${Ct}
        vec2 coords = offsetToCoords(offset, ${ft}, ${mt});
        float value = getColorAsFloat(${dt.texture2D}(A, coords));
        return value;
      }
      `}},2143:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.globalMaxPool=e.parseMaxPoolAttributes=e.maxPool=e.parseGlobalAveragePoolAttributes=e.globalAveragePool=e.parseAveragePoolAttributes=e.averagePool=void 0;const a=o(246),d=o(2517),g=o(2039);e.averagePool=(st,dt,ct)=>{c(dt);const pt={name:"AveragePool",inputNames:["X"],inputTypes:[g.TextureType.unpacked],cacheHint:ct.cacheKey};return[st.run(Object.assign(Object.assign({},pt),{get:()=>h(dt,pt,!1,ct)}),dt)]},e.parseAveragePoolAttributes=st=>{const dt=st.attributes.getString("auto_pad","NOTSET"),ct=st.attributes.getInt("ceil_mode",0),pt=st.attributes.getInt("count_include_pad",0)!==0,ft=st.attributes.getInts("kernel_shape"),mt=st.attributes.getInts("strides",[]),bt=st.attributes.getInts("pads",[]);if(ct!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,a.createAttributeWithCacheKey)({autoPad:dt,ceilMode:ct,countIncludePad:pt,kernelShape:ft,strides:mt,pads:bt})};const h=(st,dt,ct,pt)=>{const[ft,mt]=ot(st,pt,ct),bt=d.ShapeUtil.size(ft.kernelShape);let $t="";ft.countIncludePad?$t+=`value /= float(${bt});`:$t+=`value /= float(${bt} - pad);`;const Ct=`
        ${s(st[0].dims,ft,"value += _X(x);",$t,"0.0")}
      `;return Object.assign(Object.assign({},dt),{output:{dims:mt,type:st[0].type,textureType:g.TextureType.unpacked},shaderSource:Ct})};e.globalAveragePool=(st,dt,ct)=>{c(dt);const pt={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[g.TextureType.unpacked],cacheHint:`${ct.countIncludePad}`};return[st.run(Object.assign(Object.assign({},pt),{get:()=>h(dt,pt,!0,ct)}),dt)]},e.parseGlobalAveragePoolAttributes=st=>{const dt=st.attributes.getInt("count_include_pad",0)!==0;return(0,a.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:dt,kernelShape:[],strides:[],pads:[]})},e.maxPool=(st,dt,ct)=>{c(dt);const pt={name:"MaxPool",inputNames:["X"],inputTypes:[g.TextureType.unpacked],cacheHint:ct.cacheKey};return[st.run(Object.assign(Object.assign({},pt),{get:()=>et(dt,pt,!1,ct)}),dt)]},e.parseMaxPoolAttributes=st=>{const dt=st.attributes.getString("auto_pad","NOTSET"),ct=st.attributes.getInt("ceil_mode",0),pt=st.attributes.getInts("kernel_shape"),ft=st.attributes.getInts("strides",[]),mt=st.attributes.getInts("pads",[]),bt=st.attributes.getInt("storage_order",0),$t=st.attributes.getInts("dilations",[]);if(bt!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(ct!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,a.createAttributeWithCacheKey)({autoPad:dt,ceilMode:ct,countIncludePad:!1,kernelShape:pt,strides:ft,pads:mt,storageOrder:bt,dilations:$t})};const et=(st,dt,ct,pt)=>{const[ft,mt]=ot(st,pt,ct),bt=`
      ${s(st[0].dims,ft,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},dt),{output:{dims:mt,type:st[0].type,textureType:g.TextureType.unpacked},shaderSource:bt})},ot=(st,dt,ct)=>{const pt=st[0].dims.slice(),ft=Object.hasOwnProperty.call(dt,"dilations"),mt=dt.kernelShape.slice(),bt=dt.strides.slice(),$t=ft?dt.dilations.slice():[],Ct=dt.pads.slice();d.PoolConvUtil.adjustPoolAttributes(ct,pt,mt,bt,$t,Ct);const It=d.PoolConvUtil.computePoolOutputShape(ct,pt,bt,$t,mt,Ct,dt.autoPad),Tt=Object.assign({},dt);return ft?Object.assign(Tt,{kernelShape:mt,strides:bt,pads:Ct,dilations:$t,cacheKey:dt.cacheKey}):Object.assign(Tt,{kernelShape:mt,strides:bt,pads:Ct,cacheKey:dt.cacheKey}),[Tt,It]},it={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},$={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[g.TextureType.unpacked]};e.globalMaxPool=(st,dt)=>(c(dt),[st.run(Object.assign(Object.assign({},$),{get:()=>et(dt,$,!0,it)}),dt)]);const c=st=>{if(!st||st.length!==1)throw new Error("Pool ops requires 1 input.");if(st[0].type!=="float32"&&st[0].type!=="float64")throw new Error("Invalid input type.")},s=(st,dt,ct,pt,ft)=>{const mt=st.length;if(dt.kernelShape.length<=2){const bt=dt.kernelShape[dt.kernelShape.length-1],$t=dt.strides[dt.strides.length-1],Ct=dt.pads[dt.pads.length/2-1],It=dt.pads[dt.pads.length-1],Tt=st[mt-1];let jt="",dn="",yn="";if(jt=Ct+It!==0?`
          for (int i = 0; i < ${bt}; i++) {
            x[${mt} - 1] = indices[${mt} - 1] * ${$t} - ${Ct} + i;
            if (x[${mt} - 1] < 0 || x[${mt} - 1] >= ${Tt}) {
              pad++;
              continue;
            }
            ${ct}
          }`:`
          for (int i = 0; i < ${bt}; i++) {
            x[${mt} - 1] = indices[${mt} - 1] * ${$t} - ${Ct} + i;
            ${ct}
          }`,dt.kernelShape.length===2){const mn=dt.kernelShape[dt.kernelShape.length-2],fn=dt.strides[dt.strides.length-2],un=dt.pads[dt.pads.length/2-2],Wt=dt.pads[dt.pads.length-2],Jt=st[mt-2];dn=un+Wt!==0?`
            for (int j = 0; j < ${mn}; j++) {
              x[${mt} - 2] = indices[${mt} - 2] * ${fn} - ${un} + j;
              if (x[${mt} - 2] < 0 || x[${mt} - 2] >= ${Jt}) {
                pad+= ${bt};
                continue;
              }
          `:`
            for (int j = 0; j < ${mn}; j++) {
              x[${mt} - 2] = indices[${mt} - 2] * ${fn} - ${un} + j;
            `,yn=`
          }
        `}return`
        float process(int indices[${mt}]) {
          int x[${mt}];
          copyVec(indices, x);

          float value = ${ft};
          int pad = 0;
          ${dn}
          ${jt}
          ${yn}
          ${pt}
          return value;
        }
      `}{const bt=d.ShapeUtil.size(dt.kernelShape),$t=d.ShapeUtil.computeStrides(dt.kernelShape),Ct=$t.length,It=dt.pads.length,Tt=b(Ct),jt=_(st,"inputDims"),dn=_(dt.pads,"pads"),yn=_($t,"kernelStrides"),mn=_(dt.strides,"strides");let fn="";return fn=dt.pads.reduce((un,Wt)=>un+Wt)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${ct}
          }`:`
          }
          ${ct}
        `,`
        ${Tt}
        float process(int indices[${mt}]) {
          int x[${mt}];
          copyVec(indices, x);
          int offset[${Ct}];
          int pads[${It}];
          int inputDims[${mt}];
          int kernelStrides[${Ct}];
          int strides[${Ct}];
          ${dn}
          ${jt}
          ${mn}
          ${yn}

          float value = ${ft};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${bt}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${mt} - ${Ct}; j < ${mt}; j++) {
              x[j] = indices[j] * strides[j - ${mt} + ${Ct}]
                + offset[j - ${mt} + ${Ct}] - pads[j - 2];
              ${fn}
          }
          ${pt}

          return value;
        }
      `}},_=(st,dt)=>{let ct="";for(let pt=0;pt<st.length;pt++)ct+=`
      ${dt}[${pt}] = ${st[pt]};
    `;return ct},b=st=>`
  void offsetToIndices(int offset, int[${st}] strides, out int[${st}] indices) {
    if (${st} == 0) {
      return;
    }
    for (int i = 0; i < ${st} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${st} - 1] = offset;
  }`},4939:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.reduceLogSumSquare=e.reduceLogSum=e.reduceProd=e.reduceMin=e.reduceMax=e.reduceMean=e.reduceSum=e.parseReduceAttributes=void 0;const a=o(246),d=o(782),g=o(2517),h=o(2039),et=($,c,s,_,b)=>{it(c);const st={name:_,inputNames:["A"],inputTypes:[h.TextureType.unpacked]};return[$.run(Object.assign(Object.assign({},st),{cacheHint:s.cacheKey,get:()=>ot($,c,s,_,b,st)}),c)]};e.parseReduceAttributes=$=>{const c=$.attributes.getInts("axes",[]),s=$.attributes.getInt("keepdims",1)===1;return(0,a.createAttributeWithCacheKey)({axes:c,keepDims:s})};const ot=($,c,s,_,b,st)=>{const dt=[],ct=c[0].dims.length||1,pt=[],ft=g.ShapeUtil.normalizeAxes(s.axes,c[0].dims.length),mt=b(c,ft);let bt=mt[1];for(let Ct=0;Ct<c[0].dims.length;Ct++)ft.indexOf(Ct)>=0||ft.length===0?(s.keepDims&&dt.push(1),bt=`
          for(int j${Ct} = 0; j${Ct} < ${c[0].dims[Ct]}; j${Ct}++) {
            inputIdx[${Ct}] = j${Ct};
            ${bt}
          }`):(pt.push(`inputIdx[${Ct}] = outputIdx[${dt.length}];`),dt.push(c[0].dims[Ct]));const $t=`
      float process(int outputIdx[${dt.length||1}]) {
        float value;                 // final result
        int inputIdx[${ct}];      // addressing input data
        ${pt.join(`
`)}
        ${mt[0]}       // init ops for reduce max/min
        ${bt}
        ${mt[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},st),{output:{dims:dt,type:c[0].type,textureType:h.TextureType.unpacked},shaderSource:$t})},it=$=>{if(!$||$.length!==1)throw new Error("Reduce op requires 1 input.");if(d.NUMBER_TYPES.indexOf($[0].type)===-1)throw new Error("Invalid input type.")};e.reduceSum=($,c,s)=>et($,c,s,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),e.reduceMean=($,c,s)=>et($,c,s,"ReduceMean",(_,b)=>{let st=1;for(let dt=0;dt<_[0].dims.length;dt++)(b.indexOf(dt)>=0||b.length===0)&&(st*=_[0].dims[dt]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${st}.;`]}),e.reduceMax=($,c,s)=>et($,c,s,"ReduceMax",(_,b)=>{const st=[];for(let dt=0;dt<_[0].dims.length;dt++)(b.indexOf(dt)>=0||b.length===0)&&st.push(`inputIdx[${dt}] = 0;`);return[`${st.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),e.reduceMin=($,c,s)=>et($,c,s,"ReduceMin",(_,b)=>{const st=[];for(let dt=0;dt<_[0].dims.length;dt++)(b.indexOf(dt)>=0||b.length===0)&&st.push(`inputIdx[${dt}] = 0;`);return[`${st.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),e.reduceProd=($,c,s)=>et($,c,s,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),e.reduceLogSum=($,c,s)=>et($,c,s,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),e.reduceLogSumSquare=($,c,s)=>et($,c,s,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7019:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.isReshapeCheap=e.processDims3D=e.createPackedReshape3DProgramInfoLoader=void 0;const a=o(2517),d=o(5060),g=o(2039),h=o(2827);e.createPackedReshape3DProgramInfoLoader=(et,ot,it)=>{const $=(c=>({name:"Reshape (packed)",inputTypes:[g.TextureType.packed],inputNames:["A"],cacheHint:`${c}`}))(it);return Object.assign(Object.assign({},$),{get:()=>((c,s,_,b)=>{const st=s.dims,dt=b;let ct="";for(let mt=0;mt<4;mt++){let bt="";switch(mt){case 0:bt="outputCoords = rc;";break;case 1:bt="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:bt="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:bt="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}ct+=`
        ${bt}
        ${mt>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${mt}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${mt>0?"}":""}
      `}const pt=(0,d.getGlsl)(c.session.backend.glContext.version),ft=`
      ${function(mt){const bt=a.ShapeUtil.computeStrides(mt),$t=["b","r","c"],Ct="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${bt.map((It,Tt)=>`int ${$t[Tt]} = ${Ct} / ${It}; ${Tt===bt.length-1?`int ${$t[Tt+1]} = ${Ct} - ${$t[Tt]} * ${It}`:`index -= ${$t[Tt]} * ${It}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(st)}
      ${function(mt){const bt=a.ShapeUtil.computeStrides(mt);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${bt[0]} + coords.z * ${bt[1]} + coords.y;
  }
`}(dt)}
      ${(0,h.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${dt[2]};
        int cols = ${dt[1]};

        ${ct}
        ${pt.output} = result;
      }
    `;return Object.assign(Object.assign({},_),{output:{dims:dt,type:s.type,textureType:g.TextureType.packed},shaderSource:ft,hasMain:!0})})(et,ot,$,it)})},e.processDims3D=function(et){if(et.length===0)return[1,1,1];let ot=1;for(let it=0;it<et.length-2;++it)ot*=et[it];return[ot,et.length>1?et[et.length-2]:1,et[et.length-1]]},e.isReshapeCheap=function(et,ot){let it=!1;return it=et.length===0||ot.length===0||(et.length<2||ot.length<2?et[et.length-1]===ot[ot.length-1]:et[et.length-1]===ot[ot.length-1]&&et[et.length-2]===ot[ot.length-2]),it}},718:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.reshape=void 0;const a=o(2517);e.reshape=(d,g)=>{const h=a.ShapeUtil.calculateReshapedDims(g[0].dims,g[1].integerData);return d.session.pack?[d.reshapePacked(g[0],h)]:[d.reshapeUnpacked(g[0],h)]}},2268:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseResizeAttributesV11=e.parseResizeAttributesV10=e.resize=void 0;const a=o(5060),d=o(2039),g=o(9390),h=o(2827),et=o(9793),ot={name:"Resize",inputNames:["A"],inputTypes:[d.TextureType.packed]};e.resize=(_,b,st)=>((0,et.validateInputs)(b,st),[_.run(Object.assign(Object.assign({},ot),{cacheHint:st.cacheKey,get:()=>it(_,b,st)}),b)]),e.parseResizeAttributesV10=_=>(0,et.parseUpsampleAttributes)(_,10),e.parseResizeAttributesV11=_=>(0,et.parseUpsampleAttributes)(_,11);const it=(_,b,st)=>{const dt=(0,a.getGlsl)(_.session.backend.glContext.version),[ct,pt]=$(b,st);if(ct.every(fn=>fn===1)&&st.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},ot),{output:{dims:pt,type:b[0].type,textureType:d.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${dt.texture2D}(X, TexCoords);
                    ${dt.output} = v;
                }`});const ft=pt.length;if(ft<2)throw new Error(`output dimension should be at least 2, but got ${ft}`);const mt=pt[ft-2],bt=pt[ft-1],$t=b[0].dims;if(ft!==$t.length)throw new Error(`output dimension should match input ${$t.length}, but got ${ft}`);const Ct=$t[ft-2],It=$t[ft-1],Tt=ct[ft-2],jt=ct[ft-1];let dn="";if(st.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${st.mode}'`);switch(st.coordinateTransformMode){case"asymmetric":dn=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":dn=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":dn=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${bt}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${mt}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${bt}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${mt}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":dn=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${bt}.0 - 1.0, ${mt}.0 - 1.0, ${bt}.0 - 1.0,
                            ${mt}.0 - 1.0);
                        vec4 original = vec4(${It}.0 - 1.0, ${Ct}.0 - 1.0, ${It}.0 - 1.0,
                            ${Ct}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${st.coordinateTransformMode}'`)}const yn=(0,g.getCoordsDataType)(ft),mn=`
            const vec2 inputWH = vec2(${Ct}.0, ${It}.0);
            const vec4 scaleWHWH = vec4(float(${Tt}), float(${jt}), float(${Tt}), float(${jt}));
            ${(0,h.unpackFromChannel)()}
            ${dn}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${yn} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${mt-1};
                bool hasNextCol = rc.z < ${bt-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${dt.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},ot),{output:{dims:pt,type:b[0].type,textureType:d.TextureType.packed},hasMain:!0,shaderSource:mn})},$=(_,b)=>{const st=_[0].dims;let dt,ct=b.scales;if(ct.length===0){const ft=_[b.scalesInputIdx];if(ft&&ft.size!==0){if(_[b.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");ct=c(ft,b.mode,b.isResize)}else{const mt=_[b.sizesInputIdx];if(!mt||mt.size===0)throw new Error("Either scales or sizes MUST be provided as input.");dt=Array.from(mt.integerData),ct=s(dt,st,b.mode,b.isResize)}}else if(_[b.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const pt=dt||st.map((ft,mt)=>Math.floor(ft*ct[mt]));return[ct,pt]},c=(_,b,st)=>{const dt=Array.from(_.floatData);return(0,et.scalesValidation)(dt,b,st),dt},s=(_,b,st,dt)=>{const ct=b.length,pt=new Array(ct);for(let ft=0,mt=ct;ft<mt;ft++)if(b[ft]===0){if(_[ft]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");pt[ft]=1}else pt[ft]=_[ft]/b[ft];return(0,et.scalesValidation)(pt,st,dt),pt}},8117:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.shape=void 0;const a=o(9162);e.shape=(g,h)=>(d(h),[new a.Tensor([h[0].dims.length],"int32",void 0,void 0,new Int32Array(h[0].dims))]);const d=g=>{if(!g||g.length!==1)throw new Error("Shape requires 1 input.")}},2278:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.sliceV10=e.parseSliceAttributes=e.slice=void 0;const a=o(246),d=o(782),g=o(2517),h=o(2039),et={name:"Slice",inputNames:["A"],inputTypes:[h.TextureType.unpacked]};e.slice=(s,_,b)=>(it(_),[s.run(Object.assign(Object.assign({},et),{cacheHint:b.cacheKey,get:()=>ot(s,_[0],b)}),_)]),e.parseSliceAttributes=s=>{const _=s.attributes.getInts("starts"),b=s.attributes.getInts("ends"),st=s.attributes.getInts("axes",[]);return(0,a.createAttributeWithCacheKey)({starts:_,ends:b,axes:st})};const ot=(s,_,b)=>{const st=b.axes.length===0?_.dims.slice(0).map(($t,Ct)=>Ct):b.axes,dt=g.ShapeUtil.normalizeAxes(st,_.dims.length),ct=b.starts.map(($t,Ct)=>$t>_.dims[dt[Ct]]-1?_.dims[dt[Ct]]:g.ShapeUtil.normalizeAxis($t,_.dims[dt[Ct]])),pt=b.ends.map(($t,Ct)=>$t>_.dims[dt[Ct]]-1?_.dims[dt[Ct]]:g.ShapeUtil.normalizeAxis($t,_.dims[dt[Ct]])),ft=_.dims.slice(),mt=[];for(let $t=0;$t<dt.length;$t++)ft[dt[$t]]=pt[$t]-ct[$t],ct[$t]>0&&mt.push(`outputIdx[${dt[$t]}] += ${ct[$t]};`);const bt=`
      float process(int outputIdx[${ft.length}]) {
        ${mt.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},et),{output:{dims:ft,type:_.type,textureType:h.TextureType.unpacked},shaderSource:bt})},it=s=>{if(!s||s.length!==1)throw new Error("Slice requires 1 input.");if(d.NUMBER_TYPES.indexOf(s[0].type)===-1)throw new Error("Invalid input type.")};e.sliceV10=(s,_)=>{c(_);const b=$(s,_);return[s.run(Object.assign(Object.assign({},et),{cacheHint:b.cacheKey,get:()=>ot(s,_[0],b)}),[_[0]])]};const $=(s,_)=>{if(!s.session.isInitializer(_[1].dataId)||!s.session.isInitializer(_[2].dataId)||_.length>=4&&!s.session.isInitializer(_[3].dataId)||_.length>=5&&!s.session.isInitializer(_[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(_.length>=5&&_[4].integerData.some(ct=>ct!==1))throw new Error("currently non-1 steps is not supported for Slice");const b=Array.from(_[1].integerData),st=Array.from(_[2].integerData),dt=_.length>=4?Array.from(_[3].integerData):[];return{starts:b,ends:st,axes:dt,cacheKey:`${dt};${b};${st}`}},c=s=>{if(!s||s.length<3||s.length>5)throw new Error("Invalid input number.");if(s[1].type!=="int32"||s[1].dims.length!==1)throw new Error("Invalid input type.");if(s[2].type!=="int32"||s[2].dims.length!==1)throw new Error("Invalid input type.");if(s.length>=4&&(s[3].type!=="int32"||s[3].dims.length!==1))throw new Error("Invalid input type.");if(s.length>=5&&(s[4].type!=="int32"||s[4].dims.length!==1))throw new Error("Invalid input type.")}},5524:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.softmaxV13=e.parseSoftmaxAttributesV13=e.parseSoftmaxAttributes=e.softmax=void 0;const a=o(246),d=o(2517),g=o(5060),h=o(2039),et=o(3738),ot={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[h.TextureType.unpacked]},it={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[h.TextureType.unpacked,h.TextureType.unpacked]},$={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]};e.softmax=(dt,ct,pt)=>{st(ct);const ft=ct[0].dims.slice(),mt=d.ShapeUtil.normalizeAxis(pt.axis,ft.length),bt=d.ShapeUtil.sizeToDimension(ft,mt),$t=d.ShapeUtil.sizeFromDimension(ft,mt);return c(dt,ct,pt,bt,$t)},e.parseSoftmaxAttributes=dt=>(0,a.createAttributeWithCacheKey)({axis:dt.attributes.getInt("axis",1)}),e.parseSoftmaxAttributesV13=dt=>(0,a.createAttributeWithCacheKey)({axis:dt.attributes.getInt("axis",-1)}),e.softmaxV13=(dt,ct,pt)=>{st(ct);const ft=ct[0].dims.slice(),mt=d.ShapeUtil.normalizeAxis(pt.axis,ft.length),bt=ft.length,$t=mt!==bt-1,Ct=[];let It,Tt=[],jt=[];$t&&(Tt=Array.from({length:bt}).map((fn,un)=>un),Tt[mt]=bt-1,Tt[bt-1]=mt,Tt.map(fn=>Ct.push(ft[fn])),It=(0,a.createAttributeWithCacheKey)({perm:Tt}),jt=(0,et.transpose)(dt,ct,It));const dn=$t?d.ShapeUtil.sizeToDimension(Ct,bt-1):d.ShapeUtil.sizeToDimension(ft,bt-1),yn=$t?d.ShapeUtil.sizeFromDimension(Ct,bt-1):d.ShapeUtil.sizeFromDimension(ft,bt-1),mn=c(dt,$t?jt:ct,pt,dn,yn);return $t?(0,et.transpose)(dt,mn,It):mn};const c=(dt,ct,pt,ft,mt)=>{const bt=s(dt,ct[0],ft,mt,[ft]),$t=dt.run(Object.assign(Object.assign({},ot),{cacheHint:pt.cacheKey,get:()=>bt}),ct),Ct=_(dt,ct[0],ft,mt,bt.output.dims,[ft]),It=dt.run(Object.assign(Object.assign({},it),{cacheHint:pt.cacheKey,get:()=>Ct}),[ct[0],$t]),Tt=b(dt,ct[0],ft,mt,bt.output.dims,Ct.output.dims);return[dt.run(Object.assign(Object.assign({},$),{cacheHint:pt.cacheKey,get:()=>Tt}),[ct[0],$t,It])]},s=(dt,ct,pt,ft,mt)=>{const[bt,$t]=dt.calculateTextureWidthAndHeight(ct.dims,h.TextureType.unpacked),Ct=mt.length;if(pt<1||ft<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(mt.length!==1)throw new Error("Dimensionality of the output should be 1");if(mt[0]!==pt)throw new Error("Shape of the output should be equal to logical row count");const It=(0,g.getGlsl)(dt.session.backend.glContext.version),Tt=`
      float process(int[${Ct}] indices) {
        int logical_row_start_offset = indices[0] * ${ft};

        float max = getColorAsFloat(${It.texture2D}(A, offsetToCoords(logical_row_start_offset, ${bt},
        ${$t} )));
        for(int i=1; i<${ft}; ++i)
        {
          float current = getColorAsFloat(${It.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${bt}, ${$t})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},ot),{output:{dims:mt,type:ct.type,textureType:h.TextureType.unpacked},shaderSource:Tt})},_=(dt,ct,pt,ft,mt,bt)=>{const[$t,Ct]=dt.calculateTextureWidthAndHeight(ct.dims,h.TextureType.unpacked),It=bt.length;if(pt<1||ft<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(bt.length!==1)throw new Error("Dimensionality of the output should be 1");if(bt[0]!==pt)throw new Error("Shape of the output should be equal to logical row count");if(mt.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(mt[0]!==pt)throw new Error("Shape of the intermediate results should be equal to logical row count");const Tt=`
      float process(int[${It}] indices) {
        int logical_row_start_offset = indices[0] * ${ft};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${ft}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,g.getGlsl)(dt.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${$t}, ${Ct}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},it),{output:{dims:bt,type:ct.type,textureType:h.TextureType.unpacked},shaderSource:Tt})},b=(dt,ct,pt,ft,mt,bt)=>{const[$t,Ct]=dt.calculateTextureWidthAndHeight(ct.dims,h.TextureType.unpacked),It=ct.dims.length;if(pt<1||ft<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(mt.length!==1||bt.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(mt[0]!==pt||bt[0]!==pt)throw new Error("Shape of the intermediate results should be equal to logical row count");const Tt=`
      float process(int[${It}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${$t}, ${Ct});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${ft};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},$),{output:{dims:ct.dims,type:ct.type,textureType:h.TextureType.unpacked},shaderSource:Tt})},st=dt=>{if(!dt||dt.length!==1)throw new Error("Softmax requires 1 input.");if(dt[0].type!=="float32"&&dt[0].type!=="float64")throw new Error("Invalid input type")}},5975:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseSplitAttributes=e.split=void 0;const a=o(246),d=o(2517),g=o(2039),h={name:"Split",inputNames:["A"],inputTypes:[g.TextureType.unpacked]};e.split=($,c,s)=>{it(c);const _=d.ShapeUtil.normalizeAxis(s.axis,c[0].dims.length),b=et($,c,_,s),st=[];for(let dt=0;dt<b;++dt)st.push($.run(Object.assign(Object.assign({},h),{cacheHint:`${s.cacheKey};${dt}`,get:()=>ot($,c[0],s,_,dt)}),c));return st},e.parseSplitAttributes=$=>{const c=$.attributes.getInt("axis",0),s=$.attributes.getInts("split",[]),_=$.outputs.length;return(0,a.createAttributeWithCacheKey)({axis:c,split:s,numOutputs:_})};const et=($,c,s,_)=>{const[,b]=d.SplitUtil.splitShape(c[0].dims,s,_.split,_.numOutputs);return b.length},ot=($,c,s,_,b)=>{const[st,dt]=d.SplitUtil.splitShape(c.dims,_,s.split,s.numOutputs),ct=dt[b],pt=st[b],ft=`
      float process(int indices[${pt.length}]) {
        indices[${_}] += ${ct};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},h),{cacheHint:`${s.cacheKey}:${b}`,output:{dims:pt,type:c.type,textureType:g.TextureType.unpacked},shaderSource:ft})},it=$=>{if(!$||$.length!==1)throw new Error("Split requires one input.");if($[0].type!=="int8"&&$[0].type!=="uint8"&&$[0].type!=="int16"&&$[0].type!=="uint16"&&$[0].type!=="int32"&&$[0].type!=="uint32"&&$[0].type!=="float32"&&$[0].type!=="float64"&&$[0].type!=="bool")throw new Error("Invalid input type.")}},3933:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseSqueezeAttributes=e.squeezeV13=e.squeeze=void 0;const a=o(2517);e.squeeze=(h,et,ot)=>{d(et);const it=a.ShapeUtil.squeezeShape(et[0].dims,ot);return[h.reshapeUnpacked(et[0],it)]},e.squeezeV13=(h,et)=>(g(et),(0,e.squeeze)(h,[et[0]],Array.from(et[1].integerData))),e.parseSqueezeAttributes=h=>h.attributes.getInts("axes");const d=h=>{if(!h||h.length!==1)throw new Error("Squeeze requires 1 input.");if(h[0].type==="string")throw new Error("invalid input tensor types.")},g=h=>{if(!h||h.length!==2)throw new Error("Squeeze requires 2 inputs.");if(h[1].type!=="int32")throw new Error("Invalid input type.")}},6558:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.sum=void 0;const a=o(5060),d=o(2039);e.sum=(et,ot)=>{h(ot);const it={name:"Sum",inputNames:ot.map(($,c)=>`X${c}`),inputTypes:new Array(ot.length).fill(d.TextureType.unpacked)};return[et.run(Object.assign(Object.assign({},it),{get:()=>g(et,ot,it)}),ot)]};const g=(et,ot,it)=>{const $=(0,a.getGlsl)(et.session.backend.glContext.version),c=ot[0].dims.slice(),s=`
      void main() {
        vec4 result = ${ot.map((_,b)=>`${$.texture2D}(X${b},TexCoords)`).join(" + ")};
        ${$.output} = result;
      }
    `;return Object.assign(Object.assign({},it),{output:{dims:c,type:ot[0].type,textureType:d.TextureType.unpacked},hasMain:!0,shaderSource:s})},h=et=>{if(!et||et.length===0)throw new Error("Sum requires inputs.");const ot=et[0].dims.length;for(let it=1;it<et.length;it++){if(ot!==et[it].dims.length)throw new Error("Input shapes are mismatched.");for(let $=0;$<ot;$++)if(et[0].dims[$]!==et[it].dims[$])throw new Error("Input shapes are not matched.")}if(et[0].type!=="float32"&&et[0].type!=="float64")throw new Error("Invalid input type.");for(let it=1;it<et.length;it++)if(et[0].type!==et[it].type)throw new Error("Input types are not matched.")}},5723:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.tile=void 0;const a=o(782),d=o(2039);e.tile=(et,ot)=>{h(ot);const it={name:"Tile",inputNames:["A"],inputTypes:[d.TextureType.unpacked]};return[et.run(Object.assign(Object.assign({},it),{get:()=>g(et,ot,it)}),ot)]};const g=(et,ot,it)=>{const $=ot[0].dims.slice(),c=new Array($.length),s=[];for(let st=0;st<$.length;st++)c[st]=$[st]*ot[1].numberData[st],s.push(`inputIdx[${st}] = int(mod(float(outputIdx[${st}]), ${$[st]}.));`);const _=c.length,b=`
      float process(int outputIdx[${_}]) {
        int inputIdx[${_}];
        ${s.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},it),{output:{dims:c,type:ot[0].type,textureType:d.TextureType.unpacked},shaderSource:b})},h=et=>{if(!et||et.length!==2)throw new Error("Tile requires 2 input.");if(et[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(et[1].dims[0]!==et[0].dims.length)throw new Error("Invalid input shape.");if(a.NUMBER_TYPES.indexOf(et[0].type)===-1)throw new Error("Invalid input type.");if(et[1].type!=="int32"&&et[1].type!=="int16")throw new Error("Invalid repeat type.")}},3738:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseTransposeAttributes=e.transpose=void 0;const a=o(246),d=o(2517),g=o(2039),h={name:"Transpose",inputNames:["A"],inputTypes:[g.TextureType.unpacked]};e.transpose=(s,_,b)=>(c(_),[s.run(Object.assign(Object.assign({},h),{cacheHint:b.cacheKey,get:()=>et(s,_[0],b.perm)}),_)]),e.parseTransposeAttributes=s=>(0,a.createAttributeWithCacheKey)({perm:s.attributes.getInts("perm",[])});const et=(s,_,b)=>{const st=_.dims;b=ot(st,b);const dt=it(st,b),ct=st.length,pt=`
      ${$("perm",b,ct)}
      float process(int indices[${ct}]) {
        int a[${ct}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},h),{output:{dims:dt,type:_.type,textureType:g.TextureType.unpacked},shaderSource:pt})},ot=(s,_)=>(_&&_.length!==s.length&&(_=[...s.keys()].reverse()),_),it=(s,_)=>(_=ot(s,_),d.ShapeUtil.sortBasedOnPerm(s,_)),$=(s,_,b)=>{const st=[];st.push(`void ${s}(out int a[${b}], int src[${b}]) {`);for(let dt=0;dt<b;++dt)st.push(`	a[${_[dt]}]=src[${dt}];`);return st.push("	}"),st.join(`
`)},c=s=>{if(!s||s.length!==1)throw new Error("Transpose requires 1 input.");if(s[0].type!=="float32"&&s[0].type!=="float64")throw new Error("input should be float tensor")}},8710:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.encodeAsUint8=void 0;const a=o(5060),d=o(2039);e.encodeAsUint8=(g,h)=>{const et=h.shape,ot=(0,a.getGlsl)(g.session.backend.glContext.version),it=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${ot.texture2D}(X,TexCoords).r;
      ${ot.output} = encodeAsUint8(value);
    }`,$={name:"Uint8Encode",inputTypes:[d.TextureType.unpacked],inputNames:["X"],output:{dims:et,type:h.tensor.type,textureType:d.TextureType.downloadUint8AsFloat},shaderSource:it,hasMain:!0};return g.executeProgram($,[h.tensor])}},4909:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.tanh=e.tan=e.sqrt=e.sin=e.sigmoid=e.relu=e.not=e.neg=e.log=e.parseLeakyReluAttributes=e.leakyRelu=e.identity=e.floor=e.exp=e.parseEluAttributes=e.elu=e.cos=e.ceil=e.clipV11=e.parseClipAttributes=e.clip=e.atan=e.asin=e.acos=e.abs=e.glslTanh=e.glslTan=e.glslSqrt=e.glslSigmoid=e.glslRelu=e.glslSin=e.glslNot=e.glslNeg=e.glslLog=e.glslLeakyRelu=e.glslIdentity=e.glslClip=e.glslFloor=e.glslExp=e.glslElu=e.glslCos=e.glslCeil=e.glslAtan=e.glslAsin=e.glslAcos=e.glslAbs=void 0;const a=o(246),d=o(2517),g=o(8520),h=o(5060),et=o(2039);function ot(){return mn("abs")}function it(){return mn("acos")}function $(){return mn("asin")}function c(){return mn("atan")}function s(){return mn("ceil")}function _(){return mn("cos")}function b(Wt){const Jt="elu";return{body:`
  const float alpha = float(${Wt});

  float ${Jt}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${Jt}_(vec4 v) {
    return vec4(${Jt}_(v.x), ${Jt}_(v.y), ${Jt}_(v.z), ${Jt}_(v.w));
  }
  `,name:Jt,type:g.FunctionType.ValueBased}}function st(){return mn("exp")}function dt(){return mn("floor")}function ct(Wt,Jt){const _n="clip";return{body:`
  const float min = float(${Wt});
  const float max = float(${Jt});

  float ${_n}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${_n}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:_n,type:g.FunctionType.ValueBased}}function pt(){const Wt="indentity";return{body:`
  float ${Wt}_(float a) {
    return a;
  }
  vec4 ${Wt}_(vec4 v) {
    return v;
  }
  `,name:Wt,type:g.FunctionType.ValueBased}}function ft(Wt){const Jt="leakyRelu";return{body:`
  const float alpha = float(${Wt});

  float ${Jt}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${Jt}_(vec4 v) {
    return vec4(${Jt}_(v.x), ${Jt}_(v.y), ${Jt}_(v.z), ${Jt}_(v.w));
  }
  `,name:Jt,type:g.FunctionType.ValueBased}}function mt(){return mn("log")}function bt(){const Wt="neg";return{body:`
  float ${Wt}_(float a) {
    return -a;
  }
  vec4 ${Wt}_(vec4 v) {
    return -v;
  }
  `,name:Wt,type:g.FunctionType.ValueBased}}function $t(){const Wt="not";return{body:`
  float ${Wt}_(float a) {
    return float( ! bool(a) );
  }
  bool ${Wt}_(bool a) {
    return !a;
  }
  vec4 ${Wt}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${Wt}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:Wt,type:g.FunctionType.ValueBased}}function Ct(){return mn("sin")}function It(){const Wt="relu";return{body:`
  float ${Wt}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${Wt}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:Wt,type:g.FunctionType.ValueBased}}function Tt(){const Wt="sigmoid";return{body:`
  float ${Wt}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${Wt}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:Wt,type:g.FunctionType.ValueBased}}function jt(){return mn("sqrt")}function dn(){return mn("tan")}function yn(){const Wt="tanh";return{body:`
  float ${Wt}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${Wt}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:Wt,type:g.FunctionType.ValueBased}}function mn(Wt){return{body:`
  float ${Wt}_(float a) {
    return ${Wt}(a);
  }
  vec4 ${Wt}_(vec4 v) {
    return ${Wt}(v);
  }
  `,name:Wt,type:g.FunctionType.ValueBased}}e.glslAbs=ot,e.glslAcos=it,e.glslAsin=$,e.glslAtan=c,e.glslCeil=s,e.glslCos=_,e.glslElu=b,e.glslExp=st,e.glslFloor=dt,e.glslClip=ct,e.glslIdentity=pt,e.glslLeakyRelu=ft,e.glslLog=mt,e.glslNeg=bt,e.glslNot=$t,e.glslSin=Ct,e.glslRelu=It,e.glslSigmoid=Tt,e.glslSqrt=jt,e.glslTan=dn,e.glslTanh=yn;const fn=(Wt,Jt,_n,vn)=>{const Sn=Wt.session.pack?et.TextureType.packed:et.TextureType.unpacked,hn={name:_n.name,inputTypes:[Sn],inputNames:["A"],cacheHint:vn};return Object.assign(Object.assign({},hn),{get:()=>((rr,vr,Ir,$r)=>{const Ur=rr.session.pack?et.TextureType.packed:et.TextureType.unpacked,Yr=(0,h.getGlsl)(rr.session.backend.glContext.version);return Object.assign(Object.assign({},vr),{output:{dims:Ir.dims,type:Ir.type,textureType:Ur},shaderSource:`
     ${$r.body}
     void main() {
       vec4 v = ${Yr.texture2D}(A, TexCoords);
       v = ${$r.name}_(v);
       ${Yr.output} = v;
     }
     `,hasMain:!0})})(Wt,hn,Jt,_n)})};e.abs=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],ot()),Jt)],e.acos=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],it()),Jt)],e.asin=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],$()),Jt)],e.atan=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],c()),Jt)],e.clip=(Wt,Jt,_n)=>[Wt.run(fn(Wt,Jt[0],ct(_n.min,_n.max),_n.cacheKey),Jt)],e.parseClipAttributes=Wt=>(0,a.createAttributeWithCacheKey)({min:Wt.attributes.getFloat("min",d.MIN_CLIP),max:Wt.attributes.getFloat("max",d.MAX_CLIP)}),e.clipV11=(Wt,Jt)=>{const _n=un(Wt,Jt);return(0,e.clip)(Wt,[Jt[0]],_n)};const un=(Wt,Jt)=>{if(Jt.length>=3&&(!Wt.session.isInitializer(Jt[1].dataId)||!Wt.session.isInitializer(Jt[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const _n=Jt.length>=3?Jt[1].numberData[0]:d.MIN_CLIP,vn=Jt.length>=3?Jt[2].numberData[0]:d.MAX_CLIP;return(0,a.createAttributeWithCacheKey)({min:_n,max:vn})};e.ceil=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],s()),Jt)],e.cos=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],_()),Jt)],e.elu=(Wt,Jt,_n)=>[Wt.run(fn(Wt,Jt[0],b(_n.alpha),_n.cacheKey),Jt)],e.parseEluAttributes=Wt=>(0,a.createAttributeWithCacheKey)({alpha:Wt.attributes.getFloat("alpha",1)}),e.exp=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],st()),Jt)],e.floor=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],dt()),Jt)],e.identity=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],pt()),Jt)],e.leakyRelu=(Wt,Jt,_n)=>[Wt.run(fn(Wt,Jt[0],ft(_n.alpha),_n.cacheKey),Jt)],e.parseLeakyReluAttributes=Wt=>(0,a.createAttributeWithCacheKey)({alpha:Wt.attributes.getFloat("alpha",.01)}),e.log=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],mt()),Jt)],e.neg=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],bt()),Jt)],e.not=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],$t()),Jt)],e.relu=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],It()),Jt)],e.sigmoid=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],Tt()),Jt)],e.sin=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],Ct()),Jt)],e.sqrt=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],jt()),Jt)],e.tan=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],dn()),Jt)],e.tanh=(Wt,Jt)=>[Wt.run(fn(Wt,Jt[0],yn()),Jt)]},5611:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createUnpackProgramInfoLoader=e.createUnpackProgramInfo=void 0;const a=o(5060),d=o(2039),g=o(9390),h=o(2827),et={name:"unpack",inputNames:["A"],inputTypes:[d.TextureType.packed]};e.createUnpackProgramInfo=(ot,it)=>{const $=it.dims.length,c=(0,h.getChannels)("rc",$),s=c.slice(-2),_=(0,g.getCoordsDataType)($),b=(0,h.unpackFromChannel)(),st=it.dims.length===0?"":function(pt,ft){if(pt===1)return"rc";let mt="";for(let bt=0;bt<pt;bt++)mt+=ft[bt],bt<pt-1&&(mt+=",");return mt}($,c),dt=$<=1?"rc":`vec2(${s.join(",")})`,ct=`
    ${b}
    void main() {
      ${_} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${st});

       ${(0,a.getGlsl)(ot.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${dt}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},et),{hasMain:!0,output:{dims:it.dims,type:it.type,textureType:d.TextureType.unpacked},shaderSource:ct})},e.createUnpackProgramInfoLoader=(ot,it)=>Object.assign(Object.assign({},et),{get:()=>(0,e.createUnpackProgramInfo)(ot,it)})},8428:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.parseUnsqueezeAttributes=e.unsqueezeV13=e.unsqueeze=void 0;const a=o(2517);e.unsqueeze=(h,et,ot)=>{d(et);const it=a.ShapeUtil.unsqueezeShape(et[0].dims,ot);return[h.reshapeUnpacked(et[0],it)]},e.unsqueezeV13=(h,et)=>(g(et),(0,e.unsqueeze)(h,[et[0]],Array.from(et[1].integerData))),e.parseUnsqueezeAttributes=h=>h.attributes.getInts("axes");const d=h=>{if(!h||h.length!==1)throw new Error("Unsqueeze requires 1 input.");if(h[0].type==="string")throw new Error("invalid input tensor types.")},g=h=>{if(!h||h.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(h[1].type!=="int32")throw new Error("Invalid input type.")}},9793:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.scalesValidation=e.validateInputs=e.parseUpsampleAttributes=e.parseUpsampleAttributesV9=e.parseUpsampleAttributesV7=e.upsample=void 0;const a=o(246),d=o(5060),g=o(2039),h={name:"Upsample",inputNames:["X"],inputTypes:[g.TextureType.unpacked]};e.upsample=(ot,it,$)=>((0,e.validateInputs)(it,$),[ot.run(Object.assign(Object.assign({},h),{cacheHint:$.cacheKey,get:()=>et(ot,it,$)}),it)]),e.parseUpsampleAttributesV7=ot=>(0,e.parseUpsampleAttributes)(ot,7),e.parseUpsampleAttributesV9=ot=>(0,e.parseUpsampleAttributes)(ot,9),e.parseUpsampleAttributes=(ot,it)=>{const $=it>=10,c=ot.attributes.getString("mode","nearest");if(c!=="nearest"&&c!=="linear"&&(it<11||c!=="cubic"))throw new Error(`unrecognized mode: ${c}`);let s=[];it<9&&(s=ot.attributes.getFloats("scales"),(0,e.scalesValidation)(s,c,$));const _=ot.attributes.getFloat("extrapolation_value",0),b=it>10?ot.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(b)===-1)throw new Error(`coordinate_transform_mode '${b}' is not supported`);const st=b==="tf_crop_and_resize",dt=st,ct=c==="nearest"&&it>=11?ot.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(ct)===-1)throw new Error(`nearest_mode '${ct}' is not supported`);const pt=ot.attributes.getFloat("cubic_coeff_a",-.75),ft=ot.attributes.getInt("exclude_outside",0)!==0;if(ft&&c!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const mt=it<11||c==="nearest"&&b==="asymmetric"&&ct==="floor";let bt=0,$t=0,Ct=0;return it>10?ot.inputs.length>2?(bt=1,$t=2,Ct=3):($t=1,Ct=2):it===9&&($t=1),(0,a.createAttributeWithCacheKey)({opset:it,isResize:$,mode:c,scales:s,extrapolationValue:_,coordinateTransformMode:b,useExtrapolation:dt,needRoiInput:st,nearestMode:ct,cubicCoefficientA:pt,excludeOutside:ft,useNearest2xOptimization:mt,roiInputIdx:bt,scalesInputIdx:$t,sizesInputIdx:Ct})};const et=(ot,it,$)=>{const c=(0,d.getGlsl)(ot.session.backend.glContext.version),[s,_]=ot.calculateTextureWidthAndHeight(it[0].dims,g.TextureType.unpacked),b=it[0].dims.map((Ct,It)=>Math.floor(Ct*$.scales[It])),[st,dt]=ot.calculateTextureWidthAndHeight(b,g.TextureType.unpacked),ct=b.length,pt=new Array(ct),ft=new Array(ct);let mt=`
      int output_pitches[${ct}];
      int input_pitches[${ct}];
      `;for(let Ct=ct-1;Ct>=0;Ct--)pt[Ct]=Ct===ct-1?1:pt[Ct+1]*b[Ct+1],ft[Ct]=Ct===ct-1?1:ft[Ct+1]*it[0].dims[Ct+1],mt+=`
        output_pitches[${Ct}] = ${pt[Ct]};
        input_pitches[${Ct}] = ${ft[Ct]};
        `;const bt=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${s}, ${_});
        float value = getColorAsFloat(${c.texture2D}(X, coords));
        return value;
      }
      `,$t=$.mode==="nearest"?`
    ${bt}
    float process(int indices[${ct}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${st}, ${dt});

      ${mt}

      int d, m;
      for (int dim = 0; dim < ${ct}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:ct===4?`
    ${bt}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${st}, ${dt});

      ${mt}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${it[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${bt}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${st}, ${dt});

      ${mt}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${it[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},h),{output:{dims:b,type:it[0].type,textureType:g.TextureType.unpacked},shaderSource:$t,variables:[{name:"scales",type:"int",arrayLength:$.scales.length,data:$.scales.map(Ct=>Math.ceil(Ct))}]})};e.validateInputs=(ot,it)=>{if(!ot||it.opset<9&&ot.length!==1||it.opset>=9&&it.opset<11&&ot.length!==2||it.opset>=11&&ot.length<2)throw new Error("invalid inputs.");if(it.scales.length>0&&ot[0].dims.length!==it.scales.length)throw new Error("Invalid input shape.");if(ot[0].type==="string")throw new Error("Invalid input tensor types.")},e.scalesValidation=(ot,it,$)=>{if($){for(const c of ot)if(c<=0)throw new Error("Scale value should be greater than 0.")}else for(const c of ot)if(c<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(it!=="linear"&&it!=="cubic"||ot.length===2||ot.length===4&&ot[0]===1&&ot[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${$?"Resize":"Upsample"} opeartor.`)}},1958:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ProgramManager=void 0;const a=o(1670),d=o(6231),g=o(8879),h=o(5060);e.ProgramManager=class{constructor(et,ot,it){this.profiler=et,this.glContext=ot,this.textureLayoutStrategy=it,this.repo=new Map,this.attributesBound=!1}getArtifact(et){return this.repo.get(et)}setArtifact(et,ot){this.repo.set(et,ot)}run(et,ot,it){var $;this.profiler.event("op",`ProgramManager.run ${($=et.programInfo.name)!==null&&$!==void 0?$:"unknown kernel"}`,()=>{var c;const s=this.glContext.gl,_=et.program;s.useProgram(_);try{this.bindOutput(it),this.attributesBound||this.bindAttributes(et.attribLocations),this.bindUniforms(et.uniformLocations,(c=et.programInfo.variables)!==null&&c!==void 0?c:[],ot)}catch(b){throw d.Logger.error("ProgramManager",et.programInfo.shaderSource),b}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(et=>this.glContext.deleteProgram(et.program))}build(et,ot,it){return this.profiler.event("backend","ProgramManager.build",()=>{const $=new g.GlslPreprocessor(this.glContext,et,ot,it),c=$.preprocess(),s=this.compile(c);return{programInfo:et,program:s,uniformLocations:this.getUniformLocations(s,$.context.programInfo.inputNames,$.context.programInfo.variables),attribLocations:this.getAttribLocations(s)}})}compile(et){if(!this.vertexShader){d.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const $=(0,h.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader($,this.glContext.gl.VERTEX_SHADER)}a.env.debug&&d.Logger.verbose("ProrgramManager",`FragShader:
${et}
`);const ot=this.glContext.compileShader(et,this.glContext.gl.FRAGMENT_SHADER),it=this.glContext.createProgram(this.vertexShader,ot);return this.glContext.deleteShader(ot),it}bindOutput(et){const ot=et.width,it=et.height;d.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${ot}/${it}, shape=${et.shape}, type=${et.tensor.type}`),this.glContext.attachFramebuffer(et.texture,ot,it)}bindAttributes(et){const ot=et.position,it=et.textureCoord;this.glContext.setVertexAttributes(ot,it),this.attributesBound=!0}bindUniforms(et,ot,it){var $;const c=this.glContext.gl;let s=0;for(const{name:_,type:b,location:st,arrayLength:dt}of et){const ct=($=ot.find(pt=>pt.name===_))===null||$===void 0?void 0:$.data;if(b!=="sampler2D"&&!ct)throw new Error(`variable '${_}' does not have data defined in program info`);switch(b){case"sampler2D":this.bindTexture(it[s],st,s),s++;break;case"float":dt?c.uniform1fv(st,ct):c.uniform1f(st,ct);break;case"int":dt?c.uniform1iv(st,ct):c.uniform1i(st,ct);break;default:throw new Error(`Uniform not implemented: ${b}`)}}}bindTexture(et,ot,it){this.glContext.bindTextureToUniform(et.texture,it,ot)}getAttribLocations(et){return{position:this.getAttribLocation(et,"position"),textureCoord:this.getAttribLocation(et,"textureCoord")}}getUniformLocations(et,ot,it){const $=[];if(ot)for(const c of ot)$.push({name:c,type:"sampler2D",location:this.getUniformLocation(et,c)});if(it)for(const c of it)$.push(Object.assign(Object.assign({},c),{location:this.getUniformLocation(et,c.name)}));return $}getUniformLocation(et,ot){const it=this.glContext.gl.getUniformLocation(et,ot);if(it===null)throw new Error(`Uniform ${ot} not found.`);return it}getAttribLocation(et,ot){return this.glContext.gl.getAttribLocation(et,ot)}}},6416:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLSessionHandler=void 0;const a=o(6231),d=o(1047),g=o(8316),h=o(1640),et=o(1958),ot=o(7859),it=o(5702);e.WebGLSessionHandler=class{constructor($,c){this.backend=$,this.context=c,this.layoutStrategy=new ot.PreferLogicalStrategy($.glContext.maxTextureSize),this.programManager=new et.ProgramManager(this.context.profiler,$.glContext,this.layoutStrategy),this.textureManager=new it.TextureManager($.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:$.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=$.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new g.WebGLInferenceHandler(this)}onGraphInitialized($){const c=$.getValues().filter(s=>s.from===-1&&s.tensor).map(s=>s.tensor.dataId);this.initializers=new Set(c)}isInitializer($){return!!this.initializers&&this.initializers.has($)}addInitializer($){this.initializers.add($)}getTextureData($,c){return c?this.packedTextureDataCache.get($):this.unpackedTextureDataCache.get($)}setTextureData($,c,s=!1){a.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),s?this.packedTextureDataCache.set($,c):this.unpackedTextureDataCache.set($,c)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach($=>this.textureManager.releaseTexture($,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach($=>this.textureManager.releaseTexture($,!0)),this.unpackedTextureDataCache=new Map}resolve($,c,s){const _=(0,d.resolveOperator)($,c,h.WEBGL_OP_RESOLVE_RULES);return{impl:_.opImpl,context:_.opInit?_.opInit($,s):$}}}},7769:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Uint8DataEncoder=e.RGBAFloatDataEncoder=e.RedFloat32DataEncoder=void 0;const a=o(6231);e.RedFloat32DataEncoder=class{constructor(d,g=1){if(g===1)this.internalFormat=d.R32F,this.format=d.RED,this.textureType=d.FLOAT,this.channelSize=g;else{if(g!==4)throw new Error(`Invalid number of channels: ${g}`);this.internalFormat=d.RGBA32F,this.format=d.RGBA,this.textureType=d.FLOAT,this.channelSize=g}}encode(d,g){let h,et;return d.constructor!==Float32Array&&(a.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),et=new Float32Array(d)),g*this.channelSize>d.length?(a.Logger.warning("Encoder","Source data too small. Allocating larger array"),et=d,h=this.allocate(g*this.channelSize),et.forEach((ot,it)=>h[it]=ot)):(et=d,h=et),h}allocate(d){return new Float32Array(4*d)}decode(d,g){return this.channelSize===1?d.filter((h,et)=>et%4==0).subarray(0,g):d.subarray(0,g)}},e.RGBAFloatDataEncoder=class{constructor(d,g=1,h){if(g!==1&&g!==4)throw new Error(`Invalid number of channels: ${g}`);this.internalFormat=d.RGBA,this.format=d.RGBA,this.channelSize=g,this.textureType=h||d.FLOAT}encode(d,g){let h=d;return this.channelSize===1&&(a.Logger.verbose("Encoder","Exploding into a larger array"),h=this.allocate(g),d.forEach((et,ot)=>h[4*ot]=et)),h}allocate(d){return new Float32Array(4*d)}decode(d,g){return this.channelSize===1?d.filter((h,et)=>et%4==0).subarray(0,g):d.subarray(0,g)}},e.Uint8DataEncoder=class{constructor(d,g=1){if(this.channelSize=4,g===1)this.internalFormat=d.ALPHA,this.format=d.ALPHA,this.textureType=d.UNSIGNED_BYTE,this.channelSize=g;else{if(g!==4)throw new Error(`Invalid number of channels: ${g}`);this.internalFormat=d.RGBA,this.format=d.RGBA,this.textureType=d.UNSIGNED_BYTE,this.channelSize=g}}encode(d,g){return new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}allocate(d){return new Uint8Array(d*this.channelSize)}decode(d,g){if(d instanceof Uint8Array)return d.subarray(0,g);throw new Error(`Invalid array type: ${d.constructor}`)}}},7859:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getBatchDim=e.sizeToSquarishShape=e.getRowsCols=e.sizeFromShape=e.isInt=e.parseAxisParam=e.squeezeShape=e.PreferLogicalStrategy=e.AlwaysKeepOriginalSizeStrategy=void 0;const a=o(6231),d=o(2517);function g($,c){const s=[],_=[],b=c!=null&&Array.isArray(c)&&c.length===0,st=c==null||b?null:h(c,$).sort();let dt=0;for(let ct=0;ct<$.length;++ct){if(st!=null){if(st[dt]===ct&&$[ct]!==1)throw new Error(`Can't squeeze axis ${ct} since its dim '${$[ct]}' is not 1`);(st[dt]==null||st[dt]>ct)&&$[ct]===1&&(s.push($[ct]),_.push(ct)),st[dt]<=ct&&dt++}$[ct]!==1&&(s.push($[ct]),_.push(ct))}return{newShape:s,keptDims:_}}function h($,c){const s=c.length;return $=$==null?c.map((_,b)=>b):[].concat($),(0,d.assert)($.every(_=>_>=-s&&_<s),()=>`All values in axis param must be in range [-${s}, ${s}) but got axis ${$}`),(0,d.assert)($.every(et),()=>`All values in axis param must be integers but got axis ${$}`),$.map(_=>_<0?s+_:_)}function et($){return $%1==0}function ot($){if($.length===0)return 1;let c=$[0];for(let s=1;s<$.length;s++)c*=$[s];return c}function it($){const c=Math.ceil(Math.sqrt($));return[c,Math.ceil($/c)]}e.AlwaysKeepOriginalSizeStrategy=class{constructor($){this.maxTextureSize=$}computeTextureWH($,c){if($.length===0)return[1,1];const s=this.maxTextureSize;if(c&&c.breakAxis!==void 0){const st=c.breakAxis>=$.length?1:$.slice(c.breakAxis).reduce((ct,pt)=>ct*pt),dt=c.breakAxis<=0?1:$.slice(0,c.breakAxis).reduce((ct,pt)=>ct*pt);if(!(st>s||dt>s))return[st,dt];a.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${$}, breakAxis:${c.breakAxis}`)}const _=$.reduce((st,dt)=>st*dt);let b=Math.floor(Math.sqrt(_));for(;b<s&&b<_&&_%b!=0;b++);if(b>=s||_%b!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${$}`);return[b,_/b]}},e.PreferLogicalStrategy=class{constructor($){this.maxTextureSize=$}computeTextureWH($,c){const s=this.computeTexture($,c);return c&&c.isPacked&&(s[0]/=2,s[1]/=2),c&&c.reverseWH?[s[1],s[0]]:s}computeTexture($,c){const s=c&&c.isPacked;if($.length===0)return s?[2,2]:[1,1];let _=this.maxTextureSize;if(c&&c.breakAxis!==void 0){const dt=c.breakAxis>=$.length?1:$.slice(c.breakAxis).reduce((pt,ft)=>pt*ft),ct=c.breakAxis<=0?1:$.slice(0,c.breakAxis).reduce((pt,ft)=>pt*ft);if(!(dt>_||ct>_))return[dt,ct];a.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${$}, breakAxis:${c.breakAxis}`)}let b=$.slice(0);s&&(_*=2,b=b.map((dt,ct)=>ct>=b.length-2?b[ct]%2==0?b[ct]:b[ct]+1:b[ct]),b.length===1&&(b=[2,b[0]])),b.length!==2&&(b=g(b).newShape);const st=ot(b);return b.length<=1&&st<=_?[1,st]:b.length===2&&b[0]<=_&&b[1]<=_?b:b.length===3&&b[0]*b[1]<=_&&b[2]<=_?[b[0]*b[1],b[2]]:b.length===3&&b[0]<=_&&b[1]*b[2]<=_?[b[0],b[1]*b[2]]:b.length===4&&b[0]*b[1]*b[2]<=_&&b[3]<=_?[b[0]*b[1]*b[2],b[3]]:b.length===4&&b[0]<=_&&b[1]*b[2]*b[3]<=_?[b[0],b[1]*b[2]*b[3]]:s?it(st/4).map(dt=>2*dt):it(st)}},e.squeezeShape=g,e.parseAxisParam=h,e.isInt=et,e.sizeFromShape=ot,e.getRowsCols=function($){if($.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[$.length>1?$[$.length-2]:1,$[$.length-1]]},e.sizeToSquarishShape=it,e.getBatchDim=function($,c=2){return ot($.slice(0,$.length-c))}},4057:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createTextureLayoutFromShape=e.calculateTextureWidthAndHeight=e.createTextureLayoutFromTextureType=void 0;const a=o(2517),d=o(2039);e.createTextureLayoutFromTextureType=(g,h,et)=>{const ot=et===d.TextureType.unpacked||et===d.TextureType.unpackedReversed?1:4,it=et===d.TextureType.packed,$=et===d.TextureType.unpackedReversed||et===d.TextureType.packed,c=et===d.TextureType.packedLastDimension?h.length-1:void 0,s=et===d.TextureType.packedLastDimension?h.map((_,b)=>b===h.length-1?4*_:_):void 0;return(0,e.createTextureLayoutFromShape)(g,h,ot,s,{isPacked:it,reverseWH:$,breakAxis:c})},e.calculateTextureWidthAndHeight=(g,h,et)=>{const ot=(0,e.createTextureLayoutFromTextureType)(g,h,et);return[ot.width,ot.height]},e.createTextureLayoutFromShape=(g,h,et=1,ot,it)=>{const $=!(!it||!it.isPacked),[c,s]=g.computeTextureWH($&&ot||h,it),_=h.length;let b=h.slice(0);if(_===0&&(b=[1]),et===1)ot=h;else if($){if(et!==4)throw new Error("a packed texture must be 4-channel");ot=h,_>0&&(b[_-1]=Math.ceil(b[_-1]/2)),_>1&&(b[_-2]=Math.ceil(b[_-2]/2))}else if(!ot)throw new Error("Unpacked shape is needed when using channels > 1");return{width:c,height:s,channels:et,isPacked:$,shape:b,strides:a.ShapeUtil.computeStrides(b),unpackedShape:ot,reversedWH:it&&it.reverseWH}}},5702:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.TextureManager=void 0;const a=o(6231);e.TextureManager=class{constructor(d,g,h,et){this.glContext=d,this.layoutStrategy=g,this.profiler=h,this.config=et,this.pendingRead=new Map,et.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(d,g,h,et){const ot=this.toEncoderType(d),it=this.glContext.getEncoder(ot,g.channels||1,et);if(g.isPacked&&et===1)throw new Error("not implemented");const $=g.width,c=g.height;let s,_;if(this.config.reuseTextures){s=`${$}x${c}_${it.format}_${it.internalFormat}_${it.textureType}`,_=this.inUseTextures.get(s),_||(_=[],this.inUseTextures.set(s,_));const st=this.idleTextures.get(s);if(st&&st.length>0){const dt=st.pop();return _.push(dt),et===1&&this.glContext.updateTexture(dt,$,c,it,this.toTextureData(d,h)),dt}}a.Logger.verbose("TextureManager",`Creating new texture of size ${g.width}x${g.height}`);const b=this.glContext.allocateTexture($,c,it,this.toTextureData(d,h));return this.config.reuseTextures&&(_.push(b),this.textureLookup.set(b,s)),b}readTexture(d,g,h){return h||(h=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const et=d.shape.reduce((it,$)=>it*$)*h,ot=this.glContext.readTexture(d.texture,d.width,d.height,et,this.toEncoderType(g),h);return this.toTensorData(g,ot)})}async readTextureAsync(d,g,h){const et=d.tensor.dataId;if(h||(h=1),this.pendingRead.has(et)){const ot=this.pendingRead.get(et);return new Promise(it=>ot==null?void 0:ot.push(it))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(et,[]);const ot=d.shape.reduce((s,_)=>s*_)*h;await this.glContext.createAndWaitForFence();const it=this.glContext.readTexture(d.texture,d.width,d.height,ot,this.toEncoderType(g),h),$=this.toTensorData(g,it),c=this.pendingRead.get(et);return this.pendingRead.delete(et),c==null||c.forEach(s=>s($)),$})}readUint8TextureAsFloat(d){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const g=d.shape.reduce((et,ot)=>et*ot),h=this.glContext.readTexture(d.texture,d.width,d.height,4*g,"byte",4);return new Float32Array(h.buffer,h.byteOffset,g)})}releaseTexture(d,g){let h;if(this.config.reuseTextures&&(h=this.textureLookup.get(d.texture),h)){g&&this.textureLookup.delete(h);const et=this.inUseTextures.get(h);if(et){const ot=et.indexOf(d.texture);if(ot!==-1){et.splice(ot,1);let it=this.idleTextures.get(h);it||(it=[],this.idleTextures.set(h,it)),it.push(d.texture)}}}h&&!g||(a.Logger.verbose("TextureManager",`Deleting texture of size ${d.width}x${d.height}`),this.glContext.deleteTexture(d.texture))}toTensorData(d,g){switch(d){case"int16":return g instanceof Int16Array?g:Int16Array.from(g);case"int32":return g instanceof Int32Array?g:Int32Array.from(g);case"int8":return g instanceof Int8Array?g:Int8Array.from(g);case"uint16":return g instanceof Uint16Array?g:Uint16Array.from(g);case"uint32":return g instanceof Uint32Array?g:Uint32Array.from(g);case"uint8":case"bool":return g instanceof Uint8Array?g:Uint8Array.from(g);case"float32":return g instanceof Float32Array?g:Float32Array.from(g);case"float64":return g instanceof Float64Array?g:Float64Array.from(g);default:throw new Error(`TensorData type ${d} is not supported`)}}toTextureData(d,g){if(g)return g instanceof Float32Array?g:new Float32Array(g)}toEncoderType(d){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(i,e)=>{var o;Object.defineProperty(e,"__esModule",{value:!0}),e.TextureType=void 0,(o=e.TextureType||(e.TextureType={}))[o.unpacked=0]="unpacked",o[o.unpackedReversed=1]="unpackedReversed",o[o.packed=2]="packed",o[o.downloadUint8AsFloat=3]="downloadUint8AsFloat",o[o.packedLastDimension=4]="packedLastDimension"},9390:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.getGlChannels=e.getCoordsDataType=e.getSqueezedParams=e.squeezeInputShape=e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=e.generateShaderFuncNameFromInputSamplerName=e.repeatedTry=e.getPackedShape=void 0;const a=o(2517);e.getPackedShape=function(d){const g=d.length;return d.slice(0,g-1).concat(d[g-1]/4)},e.repeatedTry=async function(d,g=et=>0,h){return new Promise((et,ot)=>{let it=0;const $=()=>{if(d())return void et();it++;const c=g(it);h!=null&&it>=h?ot():setTimeout($,c)};$()})},e.generateShaderFuncNameFromInputSamplerName=function(d){return(0,a.assert)(d!==void 0&&d.length!==0,()=>"empty string found for sampler name"),"get"+d.charAt(0).toUpperCase()+d.slice(1)},e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(d){return(0,a.assert)(d!==void 0&&d.length!==0,()=>"empty string found for sampler name"),"get"+d.charAt(0).toUpperCase()+d.slice(1)+"AtOutCoords"},e.squeezeInputShape=function(d,g){let h=JSON.parse(JSON.stringify(d));return h=g,h},e.getSqueezedParams=function(d,g){return g.map(h=>d[h]).join(", ")},e.getCoordsDataType=function(d){if(d<=1)return"int";if(d===2)return"ivec2";if(d===3)return"ivec3";if(d===4)return"ivec4";if(d===5)return"ivec5";if(d===6)return"ivec6";throw Error(`GPU for rank ${d} is not yet supported`)},e.getGlChannels=function(d=6){return["x","y","z","w","u","v"].slice(0,d)}},7305:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.createNewWebGLContext=e.createWebGLContext=void 0;const a=o(6231),d=o(1713),g={};function h(et){const ot=function(){if(typeof document>"u"){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const c=document.createElement("canvas");return c.width=1,c.height=1,c}();let it;const $={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!et||et==="webgl2")&&(it=ot.getContext("webgl2",$),it))try{return new d.WebGLContext(it,2)}catch(c){a.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${c}`)}if((!et||et==="webgl")&&(it=ot.getContext("webgl",$)||ot.getContext("experimental-webgl",$),it))try{return new d.WebGLContext(it,1)}catch(c){a.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${c}`)}throw new Error("WebGL is not supported")}e.createWebGLContext=function et(ot){let it;ot&&ot!=="webgl2"||!("webgl2"in g)?ot&&ot!=="webgl"||!("webgl"in g)||(it=g.webgl):it=g.webgl2,it=it||h(ot),ot=ot||it.version===1?"webgl":"webgl2";const $=it.gl;return g[ot]=it,$.isContextLost()?(delete g[ot],et(ot)):($.disable($.DEPTH_TEST),$.disable($.STENCIL_TEST),$.disable($.BLEND),$.disable($.DITHER),$.disable($.POLYGON_OFFSET_FILL),$.disable($.SAMPLE_COVERAGE),$.enable($.SCISSOR_TEST),$.enable($.CULL_FACE),$.cullFace($.BACK),it)},e.createNewWebGLContext=h},1713:function(i,e,o){var a=this&&this.__createBinding||(Object.create?function($,c,s,_){_===void 0&&(_=s);var b=Object.getOwnPropertyDescriptor(c,s);b&&!("get"in b?!c.__esModule:b.writable||b.configurable)||(b={enumerable:!0,get:function(){return c[s]}}),Object.defineProperty($,_,b)}:function($,c,s,_){_===void 0&&(_=s),$[_]=c[s]}),d=this&&this.__setModuleDefault||(Object.create?function($,c){Object.defineProperty($,"default",{enumerable:!0,value:c})}:function($,c){$.default=c}),g=this&&this.__importStar||function($){if($&&$.__esModule)return $;var c={};if($!=null)for(var s in $)s!=="default"&&Object.prototype.hasOwnProperty.call($,s)&&a(c,$,s);return d(c,$),c};Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLContext=e.linearSearchLastTrue=void 0;const h=o(1670),et=g(o(7769)),ot=o(9390);function it($){let c=0;for(;c<$.length&&$[c]();++c);return c-1}e.linearSearchLastTrue=it,e.WebGLContext=class{constructor($,c){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=$,this.version=c,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture($,c,s,_){const b=this.gl,st=b.createTexture();b.bindTexture(b.TEXTURE_2D,st),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE),b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);const dt=_?s.encode(_,$*c):null;return b.texImage2D(b.TEXTURE_2D,0,s.internalFormat,$,c,0,s.format,s.textureType,dt),this.checkError(),st}updateTexture($,c,s,_,b){const st=this.gl;st.bindTexture(st.TEXTURE_2D,$);const dt=_.encode(b,c*s);st.texSubImage2D(st.TEXTURE_2D,0,0,0,c,s,_.format,_.textureType,dt),this.checkError()}attachFramebuffer($,c,s){const _=this.gl;_.bindTexture(_.TEXTURE_2D,$),_.bindFramebuffer(_.FRAMEBUFFER,this.framebuffer),_.framebufferTexture2D(_.FRAMEBUFFER,_.COLOR_ATTACHMENT0,_.TEXTURE_2D,$,0),this.checkError(),_.viewport(0,0,c,s),_.scissor(0,0,c,s)}readTexture($,c,s,_,b,st){const dt=this.gl;st||(st=1),this.frameBufferBound||this.attachFramebuffer($,c,s);const ct=this.getEncoder(b,st),pt=ct.allocate(c*s);return dt.bindTexture(dt.TEXTURE_2D,$),dt.framebufferTexture2D(dt.FRAMEBUFFER,dt.COLOR_ATTACHMENT0,dt.TEXTURE_2D,$,0),dt.readPixels(0,0,c,s,dt.RGBA,ct.textureType,pt),this.checkError(),ct.decode(pt,_)}isFramebufferReady(){return!0}getActiveTexture(){const $=this.gl;return"TEXTURE"+($.getParameter(this.gl.ACTIVE_TEXTURE)-$.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes($,c){const s=this.gl;s.vertexAttribPointer($,3,s.FLOAT,!1,20,0),s.enableVertexAttribArray($),c!==-1&&(s.vertexAttribPointer(c,2,s.FLOAT,!1,20,12),s.enableVertexAttribArray(c)),this.checkError()}createProgram($,c){const s=this.gl,_=s.createProgram();return s.attachShader(_,$),s.attachShader(_,c),s.linkProgram(_),_}compileShader($,c){const s=this.gl,_=s.createShader(c);if(!_)throw new Error(`createShader() returned null with type ${c}`);if(s.shaderSource(_,$),s.compileShader(_),s.getShaderParameter(_,s.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${s.getShaderInfoLog(_)}
Shader source:
${$}`);return _}deleteShader($){this.gl.deleteShader($)}bindTextureToUniform($,c,s){const _=this.gl;_.activeTexture(_.TEXTURE0+c),this.checkError(),_.bindTexture(_.TEXTURE_2D,$),this.checkError(),_.uniform1i(s,c),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(h.env.debug){const $=this.gl,c=$.getError();let s="";switch(c){case $.NO_ERROR:return;case $.INVALID_ENUM:s="INVALID_ENUM";break;case $.INVALID_VALUE:s="INVALID_VALUE";break;case $.INVALID_OPERATION:s="INVALID_OPERATION";break;case $.INVALID_FRAMEBUFFER_OPERATION:s="INVALID_FRAMEBUFFER_OPERATION";break;case $.OUT_OF_MEMORY:s="OUT_OF_MEMORY";break;case $.CONTEXT_LOST_WEBGL:s="CONTEXT_LOST_WEBGL";break;default:s=`Unknown WebGL Error: ${c.toString(16)}`}throw new Error(s)}}deleteTexture($){this.gl.deleteTexture($)}deleteProgram($){this.gl.deleteProgram($)}getEncoder($,c,s=0){if(this.version===2)return new et.RedFloat32DataEncoder(this.gl,c);switch($){case"float":return s===1||this.isRenderFloat32Supported?new et.RGBAFloatDataEncoder(this.gl,c):new et.RGBAFloatDataEncoder(this.gl,c,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new et.Uint8DataEncoder(this.gl,c);default:throw new Error(`Invalid dataType: ${$}`)}}clearActiveTextures(){const $=this.gl;for(let c=0;c<this.maxTextureImageUnits;++c)$.activeTexture($.TEXTURE0+c),$.bindTexture($.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const $=this.gl;$.bindFramebuffer($.FRAMEBUFFER,null),$.deleteFramebuffer(this.framebuffer),$.bindBuffer($.ARRAY_BUFFER,null),$.deleteBuffer(this.vertexbuffer),$.bindBuffer($.ELEMENT_ARRAY_BUFFER,null),$.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const $=this.gl,c=$.createBuffer();if(!c)throw new Error("createBuffer() returned null");const s=this.createDefaultGeometry();return $.bindBuffer($.ARRAY_BUFFER,c),$.bufferData($.ARRAY_BUFFER,s,$.STATIC_DRAW),this.checkError(),c}createFramebuffer(){const $=this.gl.createFramebuffer();if(!$)throw new Error("createFramebuffer returned null");return $}queryVitalParameters(){const $=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=$.getParameter($.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=$.getParameter($.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const $=this.gl,c=$.createTexture();$.bindTexture($.TEXTURE_2D,c);const s=this.version===2?$.RGBA32F:$.RGBA;$.texImage2D($.TEXTURE_2D,0,s,1,1,0,$.RGBA,$.FLOAT,null);const _=$.createFramebuffer();$.bindFramebuffer($.FRAMEBUFFER,_),$.framebufferTexture2D($.FRAMEBUFFER,$.COLOR_ATTACHMENT0,$.TEXTURE_2D,c,0);const b=$.checkFramebufferStatus($.FRAMEBUFFER)===$.FRAMEBUFFER_COMPLETE;return $.bindTexture($.TEXTURE_2D,null),$.bindFramebuffer($.FRAMEBUFFER,null),$.deleteTexture(c),$.deleteFramebuffer(_),b}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const $=this.gl;let c,s,_,b,st;try{c=$.createTexture(),s=$.createFramebuffer(),$.bindTexture($.TEXTURE_2D,c);const dt=this.version===2?$.RGBA32F:$.RGBA;return $.texImage2D($.TEXTURE_2D,0,dt,1,1,0,$.RGBA,$.FLOAT,null),$.bindFramebuffer($.FRAMEBUFFER,s),$.framebufferTexture2D($.FRAMEBUFFER,$.COLOR_ATTACHMENT0,$.TEXTURE_2D,c,0),$.enable($.BLEND),_=$.createShader($.VERTEX_SHADER),!!_&&($.shaderSource(_,"void main(){}"),$.compileShader(_),b=$.createShader($.FRAGMENT_SHADER),!!b&&($.shaderSource(b,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),$.compileShader(b),st=$.createProgram(),!!st&&($.attachShader(st,_),$.attachShader(st,b),$.linkProgram(st),$.useProgram(st),$.drawArrays($.POINTS,0,1),$.getError()===$.NO_ERROR)))}finally{$.disable($.BLEND),st&&$.deleteProgram(st),_&&$.deleteShader(_),b&&$.deleteShader(b),s&&($.bindFramebuffer($.FRAMEBUFFER,null),$.deleteFramebuffer(s)),c&&($.bindTexture($.TEXTURE_2D,null),$.deleteTexture(c))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const $=this.gl,c=this.disjointTimerQueryWebgl2Extension,s=$.createQuery();return $.beginQuery(c.TIME_ELAPSED_EXT,s),s}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const $=this.gl,c=this.disjointTimerQueryWebgl2Extension;$.endQuery(c.TIME_ELAPSED_EXT)}}isTimerResultAvailable($){let c=!1,s=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const _=this.gl,b=this.disjointTimerQueryWebgl2Extension;c=_.getQueryParameter($,_.QUERY_RESULT_AVAILABLE),s=_.getParameter(b.GPU_DISJOINT_EXT)}return c&&!s}getTimerResult($){let c=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const s=this.gl;c=s.getQueryParameter($,s.QUERY_RESULT),s.deleteQuery($)}return c/1e6}async waitForQueryAndGetTime($){return await(0,ot.repeatedTry)(()=>this.isTimerResultAvailable($)),this.getTimerResult($)}async createAndWaitForFence(){const $=this.createFence(this.gl);return this.pollFence($)}createFence($){let c;const s=$,_=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);return $.flush(),c=_===null?()=>!0:()=>{const b=s.clientWaitSync(_,0,0);return b===s.ALREADY_SIGNALED||b===s.CONDITION_SATISFIED},{query:_,isFencePassed:c}}async pollFence($){return new Promise(c=>{this.addItemToPoll(()=>$.isFencePassed(),()=>c())})}pollItems(){const $=it(this.itemsToPoll.map(c=>c.isDoneFn));for(let c=0;c<=$;++c){const{resolveFn:s}=this.itemsToPoll[c];s()}this.itemsToPoll=this.itemsToPoll.slice($+1)}async addItemToPoll($,c){this.itemsToPoll.push({isDoneFn:$,resolveFn:c}),this.itemsToPoll.length>1||await(0,ot.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},1036:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ExecutionPlan=void 0;const a=o(6231);class d{constructor(h,et){this.op=h,this.node=et}}e.ExecutionPlan=class{constructor(g,h,et){this.graph=g,this.profiler=et,this.initialize(h)}initialize(g){this.profiler.event("session","ExecutionPlan.initialize",()=>{const h=this.graph.getNodes();if(h.length!==g.length)throw new Error("The size of nodes and OPs do not match.");this._ops=g.map((et,ot)=>new d(et,h[ot])),this.reset(),this._starter=[],this._ops.forEach((et,ot)=>{let it=!0;for(const $ of et.node.inputs)if(!this._values[$]&&this.graph.getInputIndices().indexOf($)===-1){it=!1;break}it&&this._starter.push(ot)})})}reset(){this._values=this.graph.getValues().map(g=>g.tensor)}async execute(g,h){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();const et=g.createInferenceHandler(),ot=this.graph.getInputIndices();if(h.length!==ot.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${h.length} expected: ${ot.length}`);h.forEach((b,st)=>{const dt=ot[st];this._values[dt]=b});const it=this._starter.slice(0),$=this.graph.getValues(),c=this.graph.getNodes();let s=0;for(;s<it.length;){const b=it[s++],st=this._ops[b],dt=st.node.inputs.map(mt=>this._values[mt]);if(dt.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${st.node}`);const ct=dt;a.Logger.verbose("ExecPlan",`Runing op:${st.node.name} (${ct.map((mt,bt)=>`'${st.node.inputs[bt]}': ${mt.type}[${mt.dims.join(",")}]`).join(", ")})`);const pt=await this.profiler.event("node",st.node.name,async()=>st.op.impl(et,ct,st.op.context));if(pt.length!==st.node.outputs.length)throw new Error("the size of output does not match model definition.");pt.forEach((mt,bt)=>{const $t=st.node.outputs[bt];if(this._values[$t])throw new Error(`output [${$t}] already has value: op:${st.node.name}`);this._values[$t]=mt});const ft=new Set;pt.forEach((mt,bt)=>{const $t=st.node.outputs[bt];for(const Ct of $[$t].to){const It=c[Ct];let Tt=!0;for(const jt of It.inputs)if(!this._values[jt]){Tt=!1;break}Tt&&ft.add(Ct)}}),it.push(...ft)}const _=[];for(let b=0;b<this.graph.getOutputIndices().length;b++){const st=this.graph.getOutputIndices()[b],dt=this._values[st];if(dt===void 0)throw new Error(`required output [${st}] does not have value`);st===0?await dt.getData():dt.data,_.push(dt)}return a.Logger.verbose("ExecPlan","disposing of inferenceHandler"),et.dispose(),_})}}},7070:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Graph=void 0;const a=o(1446),d=o(7778),g=o(9395),h=o(9162),et=o(2517);var ot=g.onnxruntime.experimental.fbs;e.Graph={from:(s,_)=>new c(s,_)};class it{constructor(_){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,_&&(this.type=et.ProtoUtil.tensorValueTypeFromProto(_.type.tensorType))}get from(){return this._from}get to(){return this._to}}class ${constructor(_,b){_ instanceof a.onnx.NodeProto?(this.name=_.name,this.opType=_.opType,this.attributes=new d.Attribute(_.attribute)):_ instanceof ot.Node&&(this.name=b??_.name(),this.opType=_.opType(),this.attributes=new d.Attribute(et.ProtoUtil.tensorAttributesFromORTFormat(_))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class c{constructor(_,b){if(!_)throw new TypeError("graph is empty");this.buildGraph(_),this.transformGraph(b),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(_){if(_ instanceof a.onnx.GraphProto)this.buildGraphFromOnnxFormat(_);else{if(!(_ instanceof ot.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(_)}}buildGraphFromOnnxFormat(_){const b=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const st=new Map;if(!_.input)throw new Error("missing information in graph: input");const dt=[];for(const ct of _.input){if(b.has(ct.name))throw new Error(`duplicated input name: ${ct.name}`);const pt=this._allData.push(new it(ct))-1;b.set(ct.name,pt),dt.push(ct.name)}if(!_.initializer)throw new Error("missing information in graph: initializer");for(const ct of _.initializer){let pt=b.get(ct.name);if(pt===void 0){const ft=new it;ft.type={shape:{dims:et.ProtoUtil.tensorDimsFromProto(ct.dims)},tensorType:et.ProtoUtil.tensorDataTypeFromProto(ct.dataType)},pt=this._allData.push(ft)-1,b.set(ct.name,pt)}this._allData[pt]._from=-1,this._allData[pt].tensor=h.Tensor.fromProto(ct)}for(let ct=0;ct<this._allData.length;ct++)this._allData[ct].tensor||(this._allInputIndices.push(ct),this._allInputNames.push(dt[ct]));if(!_.output)throw new Error("missing information in graph: output");for(const ct of _.output){if(b.has(ct.name))throw new Error(`duplicated output name: ${ct.name}`);const pt=this._allData.push(new it(ct))-1;b.set(ct.name,pt),this._allOutputIndices.push(pt),this._allOutputNames.push(ct.name)}if(!_.node)throw new Error("missing information in graph: node");for(const ct of _.node){if(!ct.name)for(let ft=0;;ft++){const mt=`unnamed_${ct.opType}_${ft}`;if(!st.has(mt)){ct.name=mt;break}}if(st.has(ct.name))throw new Error(`duplicated node name: ${ct.name}`);const pt=this._nodes.push(new $(ct))-1;st.set(ct.name,pt)}for(let ct=0;ct<this._nodes.length;ct++){const pt=this._nodes[ct],ft=_.node[ct];if(!ft.output)throw new Error(`missing output for node: ${ft.name}`);for(const mt of ft.output){let bt=b.get(mt);if(bt===void 0&&(bt=this._allData.push(new it)-1,b.set(mt,bt)),pt.outputs.push(bt),this._allData[bt]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${bt}`);if(this._allData[bt]._from=ct,ft.opType==="Constant"){if(!ft.attribute||ft.attribute.length!==1||!ft.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!ft.output||ft.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");pt.outputs.pop(),pt.executeNode=!1,this._allData[bt]._from=-1,this._allData[bt].tensor=h.Tensor.fromProto(ft.attribute[0].t)}}}for(let ct=0;ct<this._nodes.length;ct++){const pt=this._nodes[ct],ft=_.node[ct];if(!ft.input)throw new Error(`missing input for node: ${ft.name}`);for(const mt of ft.input){const bt=b.get(mt);if(bt===void 0){if(mt===""&&ft.input.length===3&&ft.opType==="Resize")continue;throw new Error(`unrecognized input '${mt}' for node: ${ft.name}`)}pt.inputs.push(bt),this._allData[bt]._to.push(ct)}}return!0}buildGraphFromOrtFormat(_){var b,st,dt;const ct=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const pt=new Map,ft=[];for(let mt=0;mt<_.inputsLength();mt++){const bt=_.inputs(mt);if(ct.has(bt))throw new Error(`duplicated input name: ${bt}`);for(let $t=0;$t<_.nodeArgsLength();$t++)if(((b=_.nodeArgs($t))===null||b===void 0?void 0:b.name())===bt){const Ct=new it;if(((dt=(st=_.nodeArgs($t))===null||st===void 0?void 0:st.type())===null||dt===void 0?void 0:dt.valueType())!==ot.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const It=_.nodeArgs($t).type().value(new ot.TensorTypeAndShape),Tt=et.ProtoUtil.tensorDataTypeFromProto(It.elemType()),jt=It.shape(),dn=[];for(let mn=0;mn<jt.dimLength();mn++)dn.push(et.LongUtil.longToNumber(jt.dim(mn).value().dimValue()));Ct.type={shape:{dims:dn},tensorType:Tt};const yn=this._allData.push(Ct)-1;ct.set(bt,yn),ft.push(bt)}}for(let mt=0;mt<_.initializersLength();mt++){const bt=_.initializers(mt);let $t=ct.get(bt.name());if($t===void 0){const Ct=new it,It=et.ProtoUtil.tensorDimsFromORTFormat(bt),Tt=et.ProtoUtil.tensorDataTypeFromProto(bt.dataType());Ct.type={shape:{dims:It},tensorType:Tt},$t=this._allData.push(Ct)-1,ct.set(bt.name(),$t)}this._allData[$t]._from=-1,this._allData[$t].tensor=h.Tensor.fromOrtTensor(bt)}for(let mt=0;mt<this._allData.length;mt++)this._allData[mt].tensor||(this._allInputIndices.push(mt),this._allInputNames.push(ft[mt]));for(let mt=0;mt<_.outputsLength();mt++){const bt=_.outputs(mt);if(ct.has(bt))throw new Error(`duplicated output name: ${bt}`);const $t=this._allData.push(new it)-1;ct.set(bt,$t),this._allOutputIndices.push($t),this._allOutputNames.push(bt)}if(!_.nodes)throw new Error("missing information in graph: node");for(let mt=0;mt<_.nodesLength();mt++){const bt=_.nodes(mt);let $t=bt.name();if(!$t)for(let It=0;$t=`unnamed_${bt.opType()}_${It}`,pt.has($t);It++);if(pt.has($t))throw new Error(`duplicated node name: ${$t}`);const Ct=this._nodes.push(new $(bt,$t))-1;pt.set($t,Ct)}for(let mt=0;mt<this._nodes.length;mt++){const bt=this._nodes[mt],$t=_.nodes(mt);if($t==null)throw new Error(`No node exists at index ${mt}`);if(($t==null?void 0:$t.outputsLength())===0)throw new Error(`missing output for node: ${$t.name}`);for(let Ct=0;Ct<($t==null?void 0:$t.outputsLength());Ct++){const It=$t==null?void 0:$t.outputs(Ct);let Tt=ct.get(It);if(Tt===void 0&&(Tt=this._allData.push(new it)-1,ct.set(It,Tt)),bt.outputs.push(Tt),this._allData[Tt]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${Tt}`);if(this._allData[Tt]._from=mt,$t.opType()==="Constant"){if($t.attributesLength()!==1||!$t.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if($t.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");bt.outputs.pop(),bt.executeNode=!1,this._allData[Tt]._from=-1,this._allData[Tt].tensor=h.Tensor.fromOrtTensor($t.attributes(0).t())}}}for(let mt=0;mt<this._nodes.length;mt++){const bt=this._nodes[mt],$t=_.nodes(mt);if($t.inputsLength()===0)throw new Error(`missing input for node: ${$t.name}`);for(let Ct=0;Ct<$t.inputsLength();Ct++){const It=$t.inputs(Ct),Tt=ct.get(It);if(Tt===void 0)throw new Error(`unrecognized input '${It}' for node: ${$t.name()}`);bt.inputs.push(Tt),this._allData[Tt]._to.push(mt)}}}checkIsAcyclic(){const _=new Set;this._allInputIndices.forEach(dt=>{this._allData[dt]._to.forEach(ct=>{_.add(ct)})});const b=Array.from(_),st=new Array(this._nodes.length).fill("white");for(;b.length>0;){const dt=b.pop();st[dt]==="gray"?st[dt]="black":(b.push(dt),st[dt]="gray",this._nodes[dt].outputs.forEach(ct=>{const pt=this._allData[ct];if(pt.tensor!==void 0)throw new Error("node outputs should not be initialized");if(pt._from!==dt)throw new Error("from property of the Value object doesn't match index of Node being processed");pt._to.forEach(ft=>{if(st[ft]==="gray")throw new Error("model graph is cyclic");st[ft]==="white"&&b.push(ft)})}))}}transformGraph(_){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),_&&_.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let _=0;for(let b=0;b<this._nodes.length;b++)this._nodes[b].executeNode?_>0&&(this._nodes[b].inputs.forEach(st=>{const dt=this._allData[st]._to.indexOf(b+_);dt!==-1&&(this._allData[st]._to[dt]=b)}),this._nodes[b].outputs.forEach(st=>{this._allData[st]._from&&this._allData[st]._from===b+_&&(this._allData[st]._from=b)})):(_++,this._nodes[b].outputs.forEach(st=>{this._allData[st]._from=-2}),this._nodes.splice(b,1),b--);_=0;for(let b=0;b<this._allData.length;b++)if(this._allData[b].from!==-2||this._allOutputIndices.indexOf(b+_)!==-1){if(_>0){let st=-1;this._allData[b].from!==void 0&&this._allData[b].from!==-1?(st=this._nodes[this._allData[b].from].outputs.indexOf(b+_),st!==-1&&(this._nodes[this._allData[b].from].outputs[st]=b)):(st=this._allInputIndices.indexOf(b+_),st!==-1&&(this._allInputIndices[st]=b)),this._allData[b].to.forEach(dt=>{st=this._nodes[dt].inputs.indexOf(b+_),st!==-1&&(this._nodes[dt].inputs[st]=b)}),this._allData[b].to.length===0&&(st=this._allOutputIndices.indexOf(b+_),st!==-1&&(this._allOutputIndices[st]=b))}}else _++,this._allData.splice(b,1),b--}deleteNode(_){const b=this._nodes[_];if(b.outputs.length>1){for(let mt=1;mt<b.outputs.length;mt++)if(this._allData[b.outputs[mt]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}b.executeNode=!1;const st=b.inputs[0],dt=b.outputs[0],ct=this._allData[dt].to,pt=this._allData[st].to.indexOf(_);if(pt===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[st].to.splice(pt,1),this._allData[dt]._to=[];const ft=this._allOutputIndices.indexOf(dt);if(ft!==-1&&(this._allOutputIndices[ft]=st),ct&&ct.length>0)for(const mt of ct){const bt=this._nodes[mt].inputs.indexOf(dt);if(bt===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[mt].inputs[bt]=st,this._allData[st].to.push(mt)}}removeAllDropoutNodes(){let _=0;for(const b of this._nodes){if(b.opType==="Dropout"){if(b.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(b.outputs.length!==1&&b.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(b.outputs.length===2&&this._allData[b.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(_)}_++}}removeAllIdentityNodes(){let _=0;for(const b of this._nodes)b.opType==="Identity"&&this.deleteNode(_),_++}isActivation(_){switch(_.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const _ of this._nodes)if(_.opType==="Conv"){const b=this._allData[_.outputs[0]]._to;if(b.length===1&&this.isActivation(this._nodes[b[0]])){const st=this._nodes[b[0]];if(st.opType==="Clip")if(st.inputs.length===1)try{_.attributes.set("activation_params","floats",[st.attributes.getFloat("min"),st.attributes.getFloat("max")])}catch{_.attributes.set("activation_params","floats",[et.MIN_CLIP,et.MAX_CLIP])}else{if(!(st.inputs.length>=3&&this._allData[st.inputs[1]].tensor!==void 0&&this._allData[st.inputs[2]].tensor!==void 0))continue;_.attributes.set("activation_params","floats",[this._allData[st.inputs[1]].tensor.floatData[0],this._allData[st.inputs[2]].tensor.floatData[0]])}_.attributes.set("activation","string",st.opType),this.deleteNode(b[0])}}}}},6231:(i,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.now=e.Profiler=e.Logger=void 0;const o={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},a={none:new class{log($,c,s){}},console:new class{log($,c,s){console.log(`${this.color($)} ${s?"\x1B[35m"+s+"\x1B[0m ":""}${c}`)}color($){switch($){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${$}`)}}}},d={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let g={"":d};function h($,c,s,_){if(c===void 0)return b=$,{verbose:h.verbose.bind(null,b),info:h.info.bind(null,b),warning:h.warning.bind(null,b),error:h.error.bind(null,b),fatal:h.fatal.bind(null,b)};if(s===void 0)et($,c);else if(typeof s=="number"&&_===void 0)et($,c);else if(typeof s=="string"&&_===void 0)et($,s,0,c);else{if(typeof s!="string"||typeof _!="number")throw new TypeError("input is valid");et($,s,0,c)}var b}function et($,c,s,_){const b=g[_||""]||g[""];o[$]<o[b.minimalSeverity]||(b.logDateTime&&(c=`${new Date().toISOString()}|${c}`),b.logSourceLocation,a[b.provider].log($,c,_))}(function($){function c(_){g={},s("",_||{})}function s(_,b){if(_==="*")c(b);else{const st=g[_]||d;g[_]={provider:b.provider||st.provider,minimalSeverity:b.minimalSeverity||st.minimalSeverity,logDateTime:b.logDateTime===void 0?st.logDateTime:b.logDateTime,logSourceLocation:b.logSourceLocation===void 0?st.logSourceLocation:b.logSourceLocation}}}$.verbose=function(_,b){$("verbose",_,b)},$.info=function(_,b){$("info",_,b)},$.warning=function(_,b){$("warning",_,b)},$.error=function(_,b){$("error",_,b)},$.fatal=function(_,b){$("fatal",_,b)},$.reset=c,$.set=s,$.setWithEnv=function(_){const b={};_.logLevel&&(b.minimalSeverity=_.logLevel),s("",b)}})(h||(h={})),e.Logger=h;class ot{constructor(c,s,_,b,st,dt){this.category=c,this.name=s,this.startTime=_,this.endCallback=b,this.timer=st,this.ctx=dt}end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class it{constructor(c,s,_,b){this.category=c,this.name=s,this.startTime=_,this.endTime=b}}e.Profiler=class{static create($){return $===void 0?new this:new this($.maxNumberEvents,$.flushBatchSize,$.flushIntervalInMilliseconds)}constructor($,c,s){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=$===void 0?1e4:$,this._flushBatchSize=c===void 0?10:c,this._flushIntervalInMilliseconds=s===void 0?5e3:s}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,e.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event($,c,s,_){const b=this._started?this.begin($,c,_):void 0;let st=!1;const dt=s();if(dt&&typeof dt.then=="function")return st=!0,new Promise((ct,pt)=>{dt.then(async ft=>{b&&await b.end(),ct(ft)},async ft=>{b&&await b.end(),pt(ft)})});if(!st&&b){const ct=b.end();if(ct&&typeof ct.then=="function")return new Promise((pt,ft)=>{ct.then(()=>{pt(dt)},mt=>{ft(mt)})})}return dt}begin($,c,s){if(!this._started)throw new Error("profiler is not started yet");if(s===void 0){const _=(0,e.now)();return this.flush(_),new ot($,c,_,b=>this.endSync(b))}{const _=s.beginTimer();return new ot($,c,0,async b=>this.end(b),_,s)}}async end($){const c=await $.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new it($.category,$.name,$.startTime,c)),this.flush(c))}endSync($){const c=(0,e.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new it($.category,$.name,$.startTime,c)),this.flush(c))}logOneEvent($){e.Logger.verbose(`Profiler.${$.category}`,`${($.endTime-$.startTime).toFixed(2)}ms on event '${$.name}' at ${$.endTime.toFixed(2)}`)}flush($){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||$-this._flushTime>=this._flushIntervalInMilliseconds){for(const c=this._flushPointer;this._flushPointer<c+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,e.now)()}}get started(){return this._started}},e.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},2644:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Model=void 0;const a=o(5686),d=o(1446),g=o(7070),h=o(9395),et=o(2517);var ot=h.onnxruntime.experimental.fbs;e.Model=class{constructor(){}load(it,$,c){if(!c)try{return void this.loadFromOnnxFormat(it,$)}catch(s){if(c!==void 0)throw s}this.loadFromOrtFormat(it,$)}loadFromOnnxFormat(it,$){const c=d.onnx.ModelProto.decode(it);if(et.LongUtil.longToNumber(c.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=c.opsetImport.map(s=>({domain:s.domain,version:et.LongUtil.longToNumber(s.version)})),this._graph=g.Graph.from(c.graph,$)}loadFromOrtFormat(it,$){const c=new a.flatbuffers.ByteBuffer(it),s=ot.InferenceSession.getRootAsInferenceSession(c).model();if(et.LongUtil.longToNumber(s.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let _=0;_<s.opsetImportLength();_++){const b=s.opsetImport(_);this._opsets.push({domain:b==null?void 0:b.domain(),version:et.LongUtil.longToNumber(b.version())})}this._graph=g.Graph.from(s.graph(),$)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(i,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.FLOAT_TYPES=e.INT_TYPES=e.NUMBER_TYPES=void 0,e.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],e.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],e.FLOAT_TYPES=["float32","float64"]},1047:(i,e)=>{function o(a,d){if(d.endsWith("+")){const g=Number.parseInt(d.substring(0,d.length-1),10);return!isNaN(g)&&g<=a}if(d.split("-").length===2){const g=d.split("-"),h=Number.parseInt(g[0],10),et=Number.parseInt(g[1],10);return!isNaN(h)&&!isNaN(et)&&h<=a&&a<=et}return Number.parseInt(d,10)===a}Object.defineProperty(e,"__esModule",{value:!0}),e.resolveOperator=void 0,e.resolveOperator=function(a,d,g){for(const h of g){const et=h[0],ot=h[1],it=h[2],$=h[3],c=h[4];if(a.opType===et){for(const s of d)if((s.domain===ot||s.domain==="ai.onnx"&&ot==="")&&o(s.version,it))return{opImpl:$,opInit:c}}}throw new TypeError(`cannot resolve operator '${a.opType}' with opsets: ${d.map(h=>`${h.domain||"ai.onnx"} v${h.version}`).join(", ")}`)}},9395:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.onnxruntime=void 0;const a=o(5686);var d,g;d=e.onnxruntime||(e.onnxruntime={}),function(h){(function(et){et[et.UNDEFINED=0]="UNDEFINED",et[et.FLOAT=1]="FLOAT",et[et.INT=2]="INT",et[et.STRING=3]="STRING",et[et.TENSOR=4]="TENSOR",et[et.GRAPH=5]="GRAPH",et[et.FLOATS=6]="FLOATS",et[et.INTS=7]="INTS",et[et.STRINGS=8]="STRINGS",et[et.TENSORS=9]="TENSORS",et[et.GRAPHS=10]="GRAPHS",et[et.SPARSE_TENSOR=11]="SPARSE_TENSOR",et[et.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(h.AttributeType||(h.AttributeType={}))}((g=d.experimental||(d.experimental={})).fbs||(g.fbs={})),function(h){(function(et){(function(ot){(function(it){it[it.UNKNOWN=0]="UNKNOWN",it[it.VALUE=1]="VALUE",it[it.PARAM=2]="PARAM"})(ot.DimensionValueType||(ot.DimensionValueType={}))})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){(function(it){it[it.UNDEFINED=0]="UNDEFINED",it[it.FLOAT=1]="FLOAT",it[it.UINT8=2]="UINT8",it[it.INT8=3]="INT8",it[it.UINT16=4]="UINT16",it[it.INT16=5]="INT16",it[it.INT32=6]="INT32",it[it.INT64=7]="INT64",it[it.STRING=8]="STRING",it[it.BOOL=9]="BOOL",it[it.FLOAT16=10]="FLOAT16",it[it.DOUBLE=11]="DOUBLE",it[it.UINT32=12]="UINT32",it[it.UINT64=13]="UINT64",it[it.COMPLEX64=14]="COMPLEX64",it[it.COMPLEX128=15]="COMPLEX128",it[it.BFLOAT16=16]="BFLOAT16"})(ot.TensorDataType||(ot.TensorDataType={}))})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){(function(it){it[it.Primitive=0]="Primitive",it[it.Fused=1]="Fused"})(ot.NodeType||(ot.NodeType={}))})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){(function(it){it[it.NONE=0]="NONE",it[it.tensor_type=1]="tensor_type",it[it.sequence_type=2]="sequence_type",it[it.map_type=3]="map_type"})(ot.TypeInfoValue||(ot.TypeInfoValue={}))})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsShape(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsShape(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}dim(c,s){let _=this.bb.__offset(this.bb_pos,4);return _?(s||new h.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*c),this.bb):null}dimLength(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__vector_len(this.bb_pos+c):0}static startShape(c){c.startObject(1)}static addDim(c,s){c.addFieldOffset(0,s,0)}static createDimVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startDimVector(c,s){c.startVector(4,s,4)}static endShape(c){return c.endObject()}static createShape(c,s){return it.startShape(c),it.addDim(c,s),it.endShape(c)}}ot.Shape=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsDimension(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsDimension(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}value(c){let s=this.bb.__offset(this.bb_pos,4);return s?(c||new h.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}denotation(c){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,c):null}static startDimension(c){c.startObject(2)}static addValue(c,s){c.addFieldOffset(0,s,0)}static addDenotation(c,s){c.addFieldOffset(1,s,0)}static endDimension(c){return c.endObject()}static createDimension(c,s,_){return it.startDimension(c),it.addValue(c,s),it.addDenotation(c,_),it.endDimension(c)}}ot.Dimension=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsDimensionValue(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsDimensionValue(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}dimType(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.readInt8(this.bb_pos+c):h.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.readInt64(this.bb_pos+c):this.bb.createLong(0,0)}dimParam(c){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,c):null}static startDimensionValue(c){c.startObject(3)}static addDimType(c,s){c.addFieldInt8(0,s,h.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(c,s){c.addFieldInt64(1,s,c.createLong(0,0))}static addDimParam(c,s){c.addFieldOffset(2,s,0)}static endDimensionValue(c){return c.endObject()}static createDimensionValue(c,s,_,b){return it.startDimensionValue(c),it.addDimType(c,s),it.addDimValue(c,_),it.addDimParam(c,b),it.endDimensionValue(c)}}ot.DimensionValue=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsTensorTypeAndShape(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsTensorTypeAndShape(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}elemType(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.readInt32(this.bb_pos+c):h.experimental.fbs.TensorDataType.UNDEFINED}shape(c){let s=this.bb.__offset(this.bb_pos,6);return s?(c||new h.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startTensorTypeAndShape(c){c.startObject(2)}static addElemType(c,s){c.addFieldInt32(0,s,h.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(c,s){c.addFieldOffset(1,s,0)}static endTensorTypeAndShape(c){return c.endObject()}static createTensorTypeAndShape(c,s,_){return it.startTensorTypeAndShape(c),it.addElemType(c,s),it.addShape(c,_),it.endTensorTypeAndShape(c)}}ot.TensorTypeAndShape=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsMapType(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsMapType(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}keyType(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.readInt32(this.bb_pos+c):h.experimental.fbs.TensorDataType.UNDEFINED}valueType(c){let s=this.bb.__offset(this.bb_pos,6);return s?(c||new h.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startMapType(c){c.startObject(2)}static addKeyType(c,s){c.addFieldInt32(0,s,h.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(c,s){c.addFieldOffset(1,s,0)}static endMapType(c){return c.endObject()}static createMapType(c,s,_){return it.startMapType(c),it.addKeyType(c,s),it.addValueType(c,_),it.endMapType(c)}}ot.MapType=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsSequenceType(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsSequenceType(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}elemType(c){let s=this.bb.__offset(this.bb_pos,4);return s?(c||new h.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startSequenceType(c){c.startObject(1)}static addElemType(c,s){c.addFieldOffset(0,s,0)}static endSequenceType(c){return c.endObject()}static createSequenceType(c,s){return it.startSequenceType(c),it.addElemType(c,s),it.endSequenceType(c)}}ot.SequenceType=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(et.fbs||(et.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(ot,it){return this.bb_pos=ot,this.bb=it,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(ot,it,$,c){return ot.prep(4,12),ot.writeInt32(c),ot.writeInt32($),ot.writeInt32(it),ot.offset()}}})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsNodeEdge(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsNodeEdge(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}nodeIndex(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.readUint32(this.bb_pos+c):0}inputEdges(c,s){let _=this.bb.__offset(this.bb_pos,6);return _?(s||new h.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+_)+12*c,this.bb):null}inputEdgesLength(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__vector_len(this.bb_pos+c):0}outputEdges(c,s){let _=this.bb.__offset(this.bb_pos,8);return _?(s||new h.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+_)+12*c,this.bb):null}outputEdgesLength(){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__vector_len(this.bb_pos+c):0}static startNodeEdge(c){c.startObject(3)}static addNodeIndex(c,s){c.addFieldInt32(0,s,0)}static addInputEdges(c,s){c.addFieldOffset(1,s,0)}static startInputEdgesVector(c,s){c.startVector(12,s,4)}static addOutputEdges(c,s){c.addFieldOffset(2,s,0)}static startOutputEdgesVector(c,s){c.startVector(12,s,4)}static endNodeEdge(c){return c.endObject()}static createNodeEdge(c,s,_,b){return it.startNodeEdge(c),it.addNodeIndex(c,s),it.addInputEdges(c,_),it.addOutputEdges(c,b),it.endNodeEdge(c)}}ot.NodeEdge=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsNode(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsNode(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}name(c){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,c):null}docString(c){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,c):null}domain(c){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,c):null}sinceVersion(){let c=this.bb.__offset(this.bb_pos,10);return c?this.bb.readInt32(this.bb_pos+c):0}index(){let c=this.bb.__offset(this.bb_pos,12);return c?this.bb.readUint32(this.bb_pos+c):0}opType(c){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb_pos+s,c):null}type(){let c=this.bb.__offset(this.bb_pos,16);return c?this.bb.readInt32(this.bb_pos+c):h.experimental.fbs.NodeType.Primitive}executionProviderType(c){let s=this.bb.__offset(this.bb_pos,18);return s?this.bb.__string(this.bb_pos+s,c):null}inputs(c,s){let _=this.bb.__offset(this.bb_pos,20);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*c,s):null}inputsLength(){let c=this.bb.__offset(this.bb_pos,20);return c?this.bb.__vector_len(this.bb_pos+c):0}outputs(c,s){let _=this.bb.__offset(this.bb_pos,22);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*c,s):null}outputsLength(){let c=this.bb.__offset(this.bb_pos,22);return c?this.bb.__vector_len(this.bb_pos+c):0}attributes(c,s){let _=this.bb.__offset(this.bb_pos,24);return _?(s||new h.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*c),this.bb):null}attributesLength(){let c=this.bb.__offset(this.bb_pos,24);return c?this.bb.__vector_len(this.bb_pos+c):0}inputArgCounts(c){let s=this.bb.__offset(this.bb_pos,26);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+4*c):0}inputArgCountsLength(){let c=this.bb.__offset(this.bb_pos,26);return c?this.bb.__vector_len(this.bb_pos+c):0}inputArgCountsArray(){let c=this.bb.__offset(this.bb_pos,26);return c?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+c),this.bb.__vector_len(this.bb_pos+c)):null}implicitInputs(c,s){let _=this.bb.__offset(this.bb_pos,28);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*c,s):null}implicitInputsLength(){let c=this.bb.__offset(this.bb_pos,28);return c?this.bb.__vector_len(this.bb_pos+c):0}static startNode(c){c.startObject(13)}static addName(c,s){c.addFieldOffset(0,s,0)}static addDocString(c,s){c.addFieldOffset(1,s,0)}static addDomain(c,s){c.addFieldOffset(2,s,0)}static addSinceVersion(c,s){c.addFieldInt32(3,s,0)}static addIndex(c,s){c.addFieldInt32(4,s,0)}static addOpType(c,s){c.addFieldOffset(5,s,0)}static addType(c,s){c.addFieldInt32(6,s,h.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(c,s){c.addFieldOffset(7,s,0)}static addInputs(c,s){c.addFieldOffset(8,s,0)}static createInputsVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startInputsVector(c,s){c.startVector(4,s,4)}static addOutputs(c,s){c.addFieldOffset(9,s,0)}static createOutputsVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startOutputsVector(c,s){c.startVector(4,s,4)}static addAttributes(c,s){c.addFieldOffset(10,s,0)}static createAttributesVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startAttributesVector(c,s){c.startVector(4,s,4)}static addInputArgCounts(c,s){c.addFieldOffset(11,s,0)}static createInputArgCountsVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addInt32(s[_]);return c.endVector()}static startInputArgCountsVector(c,s){c.startVector(4,s,4)}static addImplicitInputs(c,s){c.addFieldOffset(12,s,0)}static createImplicitInputsVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startImplicitInputsVector(c,s){c.startVector(4,s,4)}static endNode(c){return c.endObject()}static createNode(c,s,_,b,st,dt,ct,pt,ft,mt,bt,$t,Ct,It){return it.startNode(c),it.addName(c,s),it.addDocString(c,_),it.addDomain(c,b),it.addSinceVersion(c,st),it.addIndex(c,dt),it.addOpType(c,ct),it.addType(c,pt),it.addExecutionProviderType(c,ft),it.addInputs(c,mt),it.addOutputs(c,bt),it.addAttributes(c,$t),it.addInputArgCounts(c,Ct),it.addImplicitInputs(c,It),it.endNode(c)}}ot.Node=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsValueInfo(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsValueInfo(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}name(c){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,c):null}docString(c){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,c):null}type(c){let s=this.bb.__offset(this.bb_pos,8);return s?(c||new h.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startValueInfo(c){c.startObject(3)}static addName(c,s){c.addFieldOffset(0,s,0)}static addDocString(c,s){c.addFieldOffset(1,s,0)}static addType(c,s){c.addFieldOffset(2,s,0)}static endValueInfo(c){return c.endObject()}static createValueInfo(c,s,_,b){return it.startValueInfo(c),it.addName(c,s),it.addDocString(c,_),it.addType(c,b),it.endValueInfo(c)}}ot.ValueInfo=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsTypeInfo(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsTypeInfo(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}denotation(c){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,c):null}valueType(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.readUint8(this.bb_pos+c):h.experimental.fbs.TypeInfoValue.NONE}value(c){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__union(c,this.bb_pos+s):null}static startTypeInfo(c){c.startObject(3)}static addDenotation(c,s){c.addFieldOffset(0,s,0)}static addValueType(c,s){c.addFieldInt8(1,s,h.experimental.fbs.TypeInfoValue.NONE)}static addValue(c,s){c.addFieldOffset(2,s,0)}static endTypeInfo(c){return c.endObject()}static createTypeInfo(c,s,_,b){return it.startTypeInfo(c),it.addDenotation(c,s),it.addValueType(c,_),it.addValue(c,b),it.endTypeInfo(c)}}ot.TypeInfo=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsOperatorSetId(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsOperatorSetId(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}domain(c){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,c):null}version(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.readInt64(this.bb_pos+c):this.bb.createLong(0,0)}static startOperatorSetId(c){c.startObject(2)}static addDomain(c,s){c.addFieldOffset(0,s,0)}static addVersion(c,s){c.addFieldInt64(1,s,c.createLong(0,0))}static endOperatorSetId(c){return c.endObject()}static createOperatorSetId(c,s,_){return it.startOperatorSetId(c),it.addDomain(c,s),it.addVersion(c,_),it.endOperatorSetId(c)}}ot.OperatorSetId=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsTensor(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsTensor(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}name(c){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,c):null}docString(c){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,c):null}dims(c){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+8*c):this.bb.createLong(0,0)}dimsLength(){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__vector_len(this.bb_pos+c):0}dataType(){let c=this.bb.__offset(this.bb_pos,10);return c?this.bb.readInt32(this.bb_pos+c):h.experimental.fbs.TensorDataType.UNDEFINED}rawData(c){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint8(this.bb.__vector(this.bb_pos+s)+c):0}rawDataLength(){let c=this.bb.__offset(this.bb_pos,12);return c?this.bb.__vector_len(this.bb_pos+c):0}rawDataArray(){let c=this.bb.__offset(this.bb_pos,12);return c?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+c),this.bb.__vector_len(this.bb_pos+c)):null}stringData(c,s){let _=this.bb.__offset(this.bb_pos,14);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*c,s):null}stringDataLength(){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.__vector_len(this.bb_pos+c):0}static startTensor(c){c.startObject(6)}static addName(c,s){c.addFieldOffset(0,s,0)}static addDocString(c,s){c.addFieldOffset(1,s,0)}static addDims(c,s){c.addFieldOffset(2,s,0)}static createDimsVector(c,s){c.startVector(8,s.length,8);for(let _=s.length-1;_>=0;_--)c.addInt64(s[_]);return c.endVector()}static startDimsVector(c,s){c.startVector(8,s,8)}static addDataType(c,s){c.addFieldInt32(3,s,h.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(c,s){c.addFieldOffset(4,s,0)}static createRawDataVector(c,s){c.startVector(1,s.length,1);for(let _=s.length-1;_>=0;_--)c.addInt8(s[_]);return c.endVector()}static startRawDataVector(c,s){c.startVector(1,s,1)}static addStringData(c,s){c.addFieldOffset(5,s,0)}static createStringDataVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startStringDataVector(c,s){c.startVector(4,s,4)}static endTensor(c){return c.endObject()}static createTensor(c,s,_,b,st,dt,ct){return it.startTensor(c),it.addName(c,s),it.addDocString(c,_),it.addDims(c,b),it.addDataType(c,st),it.addRawData(c,dt),it.addStringData(c,ct),it.endTensor(c)}}ot.Tensor=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsSparseTensor(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsSparseTensor(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}values(c){let s=this.bb.__offset(this.bb_pos,4);return s?(c||new h.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}indices(c){let s=this.bb.__offset(this.bb_pos,6);return s?(c||new h.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}dims(c){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+8*c):this.bb.createLong(0,0)}dimsLength(){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__vector_len(this.bb_pos+c):0}static startSparseTensor(c){c.startObject(3)}static addValues(c,s){c.addFieldOffset(0,s,0)}static addIndices(c,s){c.addFieldOffset(1,s,0)}static addDims(c,s){c.addFieldOffset(2,s,0)}static createDimsVector(c,s){c.startVector(8,s.length,8);for(let _=s.length-1;_>=0;_--)c.addInt64(s[_]);return c.endVector()}static startDimsVector(c,s){c.startVector(8,s,8)}static endSparseTensor(c){return c.endObject()}static createSparseTensor(c,s,_,b){return it.startSparseTensor(c),it.addValues(c,s),it.addIndices(c,_),it.addDims(c,b),it.endSparseTensor(c)}}ot.SparseTensor=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsAttribute(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsAttribute(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}name(c){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,c):null}docString(c){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,c):null}type(){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.readInt32(this.bb_pos+c):h.experimental.fbs.AttributeType.UNDEFINED}f(){let c=this.bb.__offset(this.bb_pos,10);return c?this.bb.readFloat32(this.bb_pos+c):0}i(){let c=this.bb.__offset(this.bb_pos,12);return c?this.bb.readInt64(this.bb_pos+c):this.bb.createLong(0,0)}s(c){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb_pos+s,c):null}t(c){let s=this.bb.__offset(this.bb_pos,16);return s?(c||new h.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}g(c){let s=this.bb.__offset(this.bb_pos,18);return s?(c||new h.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}floats(c){let s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+4*c):0}floatsLength(){let c=this.bb.__offset(this.bb_pos,20);return c?this.bb.__vector_len(this.bb_pos+c):0}floatsArray(){let c=this.bb.__offset(this.bb_pos,20);return c?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+c),this.bb.__vector_len(this.bb_pos+c)):null}ints(c){let s=this.bb.__offset(this.bb_pos,22);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+8*c):this.bb.createLong(0,0)}intsLength(){let c=this.bb.__offset(this.bb_pos,22);return c?this.bb.__vector_len(this.bb_pos+c):0}strings(c,s){let _=this.bb.__offset(this.bb_pos,24);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*c,s):null}stringsLength(){let c=this.bb.__offset(this.bb_pos,24);return c?this.bb.__vector_len(this.bb_pos+c):0}tensors(c,s){let _=this.bb.__offset(this.bb_pos,26);return _?(s||new h.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*c),this.bb):null}tensorsLength(){let c=this.bb.__offset(this.bb_pos,26);return c?this.bb.__vector_len(this.bb_pos+c):0}graphs(c,s){let _=this.bb.__offset(this.bb_pos,28);return _?(s||new h.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*c),this.bb):null}graphsLength(){let c=this.bb.__offset(this.bb_pos,28);return c?this.bb.__vector_len(this.bb_pos+c):0}static startAttribute(c){c.startObject(13)}static addName(c,s){c.addFieldOffset(0,s,0)}static addDocString(c,s){c.addFieldOffset(1,s,0)}static addType(c,s){c.addFieldInt32(2,s,h.experimental.fbs.AttributeType.UNDEFINED)}static addF(c,s){c.addFieldFloat32(3,s,0)}static addI(c,s){c.addFieldInt64(4,s,c.createLong(0,0))}static addS(c,s){c.addFieldOffset(5,s,0)}static addT(c,s){c.addFieldOffset(6,s,0)}static addG(c,s){c.addFieldOffset(7,s,0)}static addFloats(c,s){c.addFieldOffset(8,s,0)}static createFloatsVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addFloat32(s[_]);return c.endVector()}static startFloatsVector(c,s){c.startVector(4,s,4)}static addInts(c,s){c.addFieldOffset(9,s,0)}static createIntsVector(c,s){c.startVector(8,s.length,8);for(let _=s.length-1;_>=0;_--)c.addInt64(s[_]);return c.endVector()}static startIntsVector(c,s){c.startVector(8,s,8)}static addStrings(c,s){c.addFieldOffset(10,s,0)}static createStringsVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startStringsVector(c,s){c.startVector(4,s,4)}static addTensors(c,s){c.addFieldOffset(11,s,0)}static createTensorsVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startTensorsVector(c,s){c.startVector(4,s,4)}static addGraphs(c,s){c.addFieldOffset(12,s,0)}static createGraphsVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startGraphsVector(c,s){c.startVector(4,s,4)}static endAttribute(c){return c.endObject()}static createAttribute(c,s,_,b,st,dt,ct,pt,ft,mt,bt,$t,Ct,It){return it.startAttribute(c),it.addName(c,s),it.addDocString(c,_),it.addType(c,b),it.addF(c,st),it.addI(c,dt),it.addS(c,ct),it.addT(c,pt),it.addG(c,ft),it.addFloats(c,mt),it.addInts(c,bt),it.addStrings(c,$t),it.addTensors(c,Ct),it.addGraphs(c,It),it.endAttribute(c)}}ot.Attribute=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsGraph(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsGraph(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}initializers(c,s){let _=this.bb.__offset(this.bb_pos,4);return _?(s||new h.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*c),this.bb):null}initializersLength(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__vector_len(this.bb_pos+c):0}nodeArgs(c,s){let _=this.bb.__offset(this.bb_pos,6);return _?(s||new h.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*c),this.bb):null}nodeArgsLength(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__vector_len(this.bb_pos+c):0}nodes(c,s){let _=this.bb.__offset(this.bb_pos,8);return _?(s||new h.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*c),this.bb):null}nodesLength(){let c=this.bb.__offset(this.bb_pos,8);return c?this.bb.__vector_len(this.bb_pos+c):0}maxNodeIndex(){let c=this.bb.__offset(this.bb_pos,10);return c?this.bb.readUint32(this.bb_pos+c):0}nodeEdges(c,s){let _=this.bb.__offset(this.bb_pos,12);return _?(s||new h.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*c),this.bb):null}nodeEdgesLength(){let c=this.bb.__offset(this.bb_pos,12);return c?this.bb.__vector_len(this.bb_pos+c):0}inputs(c,s){let _=this.bb.__offset(this.bb_pos,14);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*c,s):null}inputsLength(){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.__vector_len(this.bb_pos+c):0}outputs(c,s){let _=this.bb.__offset(this.bb_pos,16);return _?this.bb.__string(this.bb.__vector(this.bb_pos+_)+4*c,s):null}outputsLength(){let c=this.bb.__offset(this.bb_pos,16);return c?this.bb.__vector_len(this.bb_pos+c):0}sparseInitializers(c,s){let _=this.bb.__offset(this.bb_pos,18);return _?(s||new h.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*c),this.bb):null}sparseInitializersLength(){let c=this.bb.__offset(this.bb_pos,18);return c?this.bb.__vector_len(this.bb_pos+c):0}static startGraph(c){c.startObject(8)}static addInitializers(c,s){c.addFieldOffset(0,s,0)}static createInitializersVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startInitializersVector(c,s){c.startVector(4,s,4)}static addNodeArgs(c,s){c.addFieldOffset(1,s,0)}static createNodeArgsVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startNodeArgsVector(c,s){c.startVector(4,s,4)}static addNodes(c,s){c.addFieldOffset(2,s,0)}static createNodesVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startNodesVector(c,s){c.startVector(4,s,4)}static addMaxNodeIndex(c,s){c.addFieldInt32(3,s,0)}static addNodeEdges(c,s){c.addFieldOffset(4,s,0)}static createNodeEdgesVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startNodeEdgesVector(c,s){c.startVector(4,s,4)}static addInputs(c,s){c.addFieldOffset(5,s,0)}static createInputsVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startInputsVector(c,s){c.startVector(4,s,4)}static addOutputs(c,s){c.addFieldOffset(6,s,0)}static createOutputsVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startOutputsVector(c,s){c.startVector(4,s,4)}static addSparseInitializers(c,s){c.addFieldOffset(7,s,0)}static createSparseInitializersVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startSparseInitializersVector(c,s){c.startVector(4,s,4)}static endGraph(c){return c.endObject()}static createGraph(c,s,_,b,st,dt,ct,pt,ft){return it.startGraph(c),it.addInitializers(c,s),it.addNodeArgs(c,_),it.addNodes(c,b),it.addMaxNodeIndex(c,st),it.addNodeEdges(c,dt),it.addInputs(c,ct),it.addOutputs(c,pt),it.addSparseInitializers(c,ft),it.endGraph(c)}}ot.Graph=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsModel(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsModel(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}irVersion(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.readInt64(this.bb_pos+c):this.bb.createLong(0,0)}opsetImport(c,s){let _=this.bb.__offset(this.bb_pos,6);return _?(s||new h.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*c),this.bb):null}opsetImportLength(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__vector_len(this.bb_pos+c):0}producerName(c){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,c):null}producerVersion(c){let s=this.bb.__offset(this.bb_pos,10);return s?this.bb.__string(this.bb_pos+s,c):null}domain(c){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.__string(this.bb_pos+s,c):null}modelVersion(){let c=this.bb.__offset(this.bb_pos,14);return c?this.bb.readInt64(this.bb_pos+c):this.bb.createLong(0,0)}docString(c){let s=this.bb.__offset(this.bb_pos,16);return s?this.bb.__string(this.bb_pos+s,c):null}graph(c){let s=this.bb.__offset(this.bb_pos,18);return s?(c||new h.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}graphDocString(c){let s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,c):null}static startModel(c){c.startObject(9)}static addIrVersion(c,s){c.addFieldInt64(0,s,c.createLong(0,0))}static addOpsetImport(c,s){c.addFieldOffset(1,s,0)}static createOpsetImportVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startOpsetImportVector(c,s){c.startVector(4,s,4)}static addProducerName(c,s){c.addFieldOffset(2,s,0)}static addProducerVersion(c,s){c.addFieldOffset(3,s,0)}static addDomain(c,s){c.addFieldOffset(4,s,0)}static addModelVersion(c,s){c.addFieldInt64(5,s,c.createLong(0,0))}static addDocString(c,s){c.addFieldOffset(6,s,0)}static addGraph(c,s){c.addFieldOffset(7,s,0)}static addGraphDocString(c,s){c.addFieldOffset(8,s,0)}static endModel(c){return c.endObject()}static createModel(c,s,_,b,st,dt,ct,pt,ft,mt){return it.startModel(c),it.addIrVersion(c,s),it.addOpsetImport(c,_),it.addProducerName(c,b),it.addProducerVersion(c,st),it.addDomain(c,dt),it.addModelVersion(c,ct),it.addDocString(c,pt),it.addGraph(c,ft),it.addGraphDocString(c,mt),it.endModel(c)}}ot.Model=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsKernelCreateInfos(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsKernelCreateInfos(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}nodeIndices(c){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+4*c):0}nodeIndicesLength(){let c=this.bb.__offset(this.bb_pos,4);return c?this.bb.__vector_len(this.bb_pos+c):0}nodeIndicesArray(){let c=this.bb.__offset(this.bb_pos,4);return c?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+c),this.bb.__vector_len(this.bb_pos+c)):null}kernelDefHashes(c){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readUint64(this.bb.__vector(this.bb_pos+s)+8*c):this.bb.createLong(0,0)}kernelDefHashesLength(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__vector_len(this.bb_pos+c):0}static startKernelCreateInfos(c){c.startObject(2)}static addNodeIndices(c,s){c.addFieldOffset(0,s,0)}static createNodeIndicesVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addInt32(s[_]);return c.endVector()}static startNodeIndicesVector(c,s){c.startVector(4,s,4)}static addKernelDefHashes(c,s){c.addFieldOffset(1,s,0)}static createKernelDefHashesVector(c,s){c.startVector(8,s.length,8);for(let _=s.length-1;_>=0;_--)c.addInt64(s[_]);return c.endVector()}static startKernelDefHashesVector(c,s){c.startVector(8,s,8)}static endKernelCreateInfos(c){return c.endObject()}static createKernelCreateInfos(c,s,_){return it.startKernelCreateInfos(c),it.addNodeIndices(c,s),it.addKernelDefHashes(c,_),it.endKernelCreateInfos(c)}}ot.KernelCreateInfos=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsSubGraphSessionState(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsSubGraphSessionState(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}graphId(c){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,c):null}sessionState(c){let s=this.bb.__offset(this.bb_pos,6);return s?(c||new h.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startSubGraphSessionState(c){c.startObject(2)}static addGraphId(c,s){c.addFieldOffset(0,s,0)}static addSessionState(c,s){c.addFieldOffset(1,s,0)}static endSubGraphSessionState(c){let s=c.endObject();return c.requiredField(s,4),s}static createSubGraphSessionState(c,s,_){return it.startSubGraphSessionState(c),it.addGraphId(c,s),it.addSessionState(c,_),it.endSubGraphSessionState(c)}}ot.SubGraphSessionState=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsSessionState(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsSessionState(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}kernels(c){let s=this.bb.__offset(this.bb_pos,4);return s?(c||new h.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}subGraphSessionStates(c,s){let _=this.bb.__offset(this.bb_pos,6);return _?(s||new h.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+_)+4*c),this.bb):null}subGraphSessionStatesLength(){let c=this.bb.__offset(this.bb_pos,6);return c?this.bb.__vector_len(this.bb_pos+c):0}static startSessionState(c){c.startObject(2)}static addKernels(c,s){c.addFieldOffset(0,s,0)}static addSubGraphSessionStates(c,s){c.addFieldOffset(1,s,0)}static createSubGraphSessionStatesVector(c,s){c.startVector(4,s.length,4);for(let _=s.length-1;_>=0;_--)c.addOffset(s[_]);return c.endVector()}static startSubGraphSessionStatesVector(c,s){c.startVector(4,s,4)}static endSessionState(c){return c.endObject()}static createSessionState(c,s,_){return it.startSessionState(c),it.addKernels(c,s),it.addSubGraphSessionStates(c,_),it.endSessionState(c)}}ot.SessionState=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(h){(function(et){(function(ot){class it{constructor(){this.bb=null,this.bb_pos=0}__init(c,s){return this.bb_pos=c,this.bb=s,this}static getRootAsInferenceSession(c,s){return(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static getSizePrefixedRootAsInferenceSession(c,s){return c.setPosition(c.position()+a.flatbuffers.SIZE_PREFIX_LENGTH),(s||new it).__init(c.readInt32(c.position())+c.position(),c)}static bufferHasIdentifier(c){return c.__has_identifier("ORTM")}ortVersion(c){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,c):null}model(c){let s=this.bb.__offset(this.bb_pos,6);return s?(c||new h.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}sessionState(c){let s=this.bb.__offset(this.bb_pos,8);return s?(c||new h.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startInferenceSession(c){c.startObject(3)}static addOrtVersion(c,s){c.addFieldOffset(0,s,0)}static addModel(c,s){c.addFieldOffset(1,s,0)}static addSessionState(c,s){c.addFieldOffset(2,s,0)}static endInferenceSession(c){return c.endObject()}static finishInferenceSessionBuffer(c,s){c.finish(s,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(c,s){c.finish(s,"ORTM",!0)}static createInferenceSession(c,s,_,b){return it.startInferenceSession(c),it.addOrtVersion(c,s),it.addModel(c,_),it.addSessionState(c,b),it.endInferenceSession(c)}}ot.InferenceSession=it})(et.fbs||(et.fbs={}))})(h.experimental||(h.experimental={}))}(e.onnxruntime||(e.onnxruntime={}))},7448:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.OnnxjsSessionHandler=void 0;const a=o(1670),d=o(9162);e.OnnxjsSessionHandler=class{constructor(g){this.session=g,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(g,h,et){const ot=new Map;for(const c in g)if(Object.hasOwnProperty.call(g,c)){const s=g[c];ot.set(c,new d.Tensor(s.dims,s.type,void 0,void 0,s.data))}const it=await this.session.run(ot),$={};return it.forEach((c,s)=>{$[s]=new a.Tensor(c.type,c.data,c.dims)}),$}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Session=void 0;const a=o(7067),d=o(1296),g=o(7091),h=o(1036),et=o(6231),ot=o(2644);e.Session=class{constructor(it={}){this._initialized=!1,this.backendHint=it.backendHint,this.profiler=et.Profiler.create(it.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(it,$,c){await this.profiler.event("session","Session.loadModel",async()=>{const s=await(0,g.resolveBackend)(this.backendHint);if(this.sessionHandler=s.createSessionHandler(this.context),this._model=new ot.Model,typeof it=="string"){const _=it.endsWith(".ort");if(typeof fetch>"u"){const b=await(0,d.promisify)(a.readFile)(it);this.initialize(b,_)}else{const b=await fetch(it),st=await b.arrayBuffer();this.initialize(new Uint8Array(st),_)}}else if(ArrayBuffer.isView(it))this.initialize(it);else{const _=new Uint8Array(it,$||0,c||it.byteLength);this.initialize(_)}})}initialize(it,$){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{const c=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(it,c,$),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new h.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(it){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{const $=this.normalizeAndValidateInputs(it),c=await this._executionPlan.execute(this.sessionHandler,$);return this.createOutput(c)})}normalizeAndValidateInputs(it){const $=this._model.graph.getInputNames();if(Array.isArray(it)){if(it.length!==$.length)throw new Error(`incorrect input array length: expected ${$.length} but got ${it.length}`)}else{if(it.size!==$.length)throw new Error(`incorrect input map size: expected ${$.length} but got ${it.size}`);const c=new Array(it.size);let s=0;for(let _=0;_<$.length;++_){const b=it.get($[_]);if(!b)throw new Error(`missing input tensor for: '${name}'`);c[s++]=b}it=c}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,it,!1);else{const c=this._model.graph.getInputIndices(),s=this._model.graph.getValues(),_=new Array(c.length);for(let b=0;b<c.length;++b){const st=s[c[b]];_[b]=st.type.shape.dims,this.context.graphInputTypes.push(st.type.tensorType),this.context.graphInputDims.push(it[b].dims)}this.validateInputTensorDims(_,it,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,it),it}validateInputTensorTypes(it,$){for(let c=0;c<$.length;c++){const s=it[c],_=$[c].type;if(s!==_)throw new Error(`input tensor[${c}] check failed: expected type '${s}' but got ${_}`)}}validateInputTensorDims(it,$,c){for(let s=0;s<$.length;s++){const _=it[s],b=$[s].dims;if(!this.compareTensorDims(_,b,c))throw new Error(`input tensor[${s}] check failed: expected shape '[${_.join(",")}]' but got [${b.join(",")}]`)}}compareTensorDims(it,$,c){if(it.length!==$.length)return!1;for(let s=0;s<it.length;++s)if(it[s]!==$[s]&&(!c||it[s]!==0))return!1;return!0}createOutput(it){const $=this._model.graph.getOutputNames();if(it.length!==$.length)throw new Error("expected number of outputs do not match number of generated outputs");const c=new Map;for(let s=0;s<$.length;++s)c.set($[s],it[s]);return c}initializeOps(it){const $=it.getNodes();this._ops=new Array($.length);for(let c=0;c<$.length;c++)this._ops[c]=this.sessionHandler.resolve($[c],this._model.opsets,it)}}},9162:function(i,e,o){var a=this&&this.__importDefault||function(st){return st&&st.__esModule?st:{default:st}};Object.defineProperty(e,"__esModule",{value:!0}),e.Tensor=void 0;const d=o(3442),g=a(o(3720)),h=o(1446),et=o(9395),ot=o(2517);var it=et.onnxruntime.experimental.fbs;class ${get data(){if(this.cache===void 0){const dt=this.dataProvider(this.dataId);if(dt.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=dt}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(dt){return this.data[ot.ShapeUtil.indicesToOffset(dt,this.strides)]}set(dt,ct){this.data[ot.ShapeUtil.indicesToOffset(dt,this.strides)]=ct}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=ot.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(dt,ct,pt,ft,mt,bt=d.Guid.create()){this.dims=dt,this.type=ct,this.dataProvider=pt,this.asyncDataProvider=ft,this.cache=mt,this.dataId=bt,this.size=ot.ShapeUtil.validateDimsAndCalcSize(dt);const $t=this.size,Ct=pt===void 0&&ft===void 0&&mt===void 0;if(mt!==void 0&&mt.length!==$t)throw new RangeError("Input dims doesn't match data length.");if(ct==="string"){if(!(mt===void 0||Array.isArray(mt)&&mt.every(It=>typeof It=="string")))throw new TypeError("cache should be a string array");Ct&&(this.cache=new Array($t))}else{if(mt!==void 0){const It=s(ct);if(!(mt instanceof It))throw new TypeError(`cache should be type ${It.name}`)}if(Ct){const It=new ArrayBuffer($t*function(Tt){switch(Tt){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${Tt}`)}}(ct));this.cache=function(Tt,jt){return new(s(jt))(Tt)}(It,ct)}}}static fromProto(dt){if(!dt)throw new Error("cannot construct Value from an empty tensor");const ct=ot.ProtoUtil.tensorDataTypeFromProto(dt.dataType),pt=ot.ProtoUtil.tensorDimsFromProto(dt.dims),ft=new $(pt,ct);if(ct==="string")dt.stringData.forEach((mt,bt)=>{ft.data[bt]=(0,ot.decodeUtf8String)(mt)});else if(dt.rawData&&typeof dt.rawData.byteLength=="number"&&dt.rawData.byteLength>0){const mt=ft.data,bt=new DataView(dt.rawData.buffer,dt.rawData.byteOffset,dt.rawData.byteLength),$t=c(dt.dataType),Ct=dt.rawData.byteLength/$t;if(dt.rawData.byteLength%$t!=0)throw new Error("invalid buffer length");if(mt.length!==Ct)throw new Error("buffer length mismatch");for(let It=0;It<Ct;It++){const Tt=b(bt,dt.dataType,It*$t);mt[It]=Tt}}else{let mt;switch(dt.dataType){case h.onnx.TensorProto.DataType.FLOAT:mt=dt.floatData;break;case h.onnx.TensorProto.DataType.INT32:case h.onnx.TensorProto.DataType.INT16:case h.onnx.TensorProto.DataType.UINT16:case h.onnx.TensorProto.DataType.INT8:case h.onnx.TensorProto.DataType.UINT8:case h.onnx.TensorProto.DataType.BOOL:mt=dt.int32Data;break;case h.onnx.TensorProto.DataType.INT64:mt=dt.int64Data;break;case h.onnx.TensorProto.DataType.DOUBLE:mt=dt.doubleData;break;case h.onnx.TensorProto.DataType.UINT32:case h.onnx.TensorProto.DataType.UINT64:mt=dt.uint64Data;break;default:throw new Error("unspecific error")}if(mt==null)throw new Error("failed to populate data from a tensorproto value");const bt=ft.data;if(bt.length!==mt.length)throw new Error("array length mismatch");for(let $t=0;$t<mt.length;$t++){const Ct=mt[$t];g.default.isLong(Ct)?bt[$t]=_(Ct,dt.dataType):bt[$t]=Ct}}return ft}static fromData(dt,ct,pt){return new $(ct,pt,void 0,void 0,dt)}static fromOrtTensor(dt){if(!dt)throw new Error("cannot construct Value from an empty tensor");const ct=ot.ProtoUtil.tensorDimsFromORTFormat(dt),pt=ot.ProtoUtil.tensorDataTypeFromProto(dt.dataType()),ft=new $(ct,pt);if(pt==="string")for(let mt=0;mt<dt.stringDataLength();mt++)ft.data[mt]=dt.stringData(mt);else if(dt.rawDataArray()&&typeof dt.rawDataLength()=="number"&&dt.rawDataLength()>0){const mt=ft.data,bt=new DataView(dt.rawDataArray().buffer,dt.rawDataArray().byteOffset,dt.rawDataLength()),$t=c(dt.dataType()),Ct=dt.rawDataLength()/$t;if(dt.rawDataLength()%$t!=0)throw new Error("invalid buffer length");if(mt.length!==Ct)throw new Error("buffer length mismatch");for(let It=0;It<Ct;It++){const Tt=b(bt,dt.dataType(),It*$t);mt[It]=Tt}}return ft}}function c(st){switch(st){case h.onnx.TensorProto.DataType.UINT8:case h.onnx.TensorProto.DataType.INT8:case h.onnx.TensorProto.DataType.BOOL:return 1;case h.onnx.TensorProto.DataType.UINT16:case h.onnx.TensorProto.DataType.INT16:return 2;case h.onnx.TensorProto.DataType.FLOAT:case h.onnx.TensorProto.DataType.INT32:case h.onnx.TensorProto.DataType.UINT32:return 4;case h.onnx.TensorProto.DataType.INT64:case h.onnx.TensorProto.DataType.DOUBLE:case h.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${h.onnx.TensorProto.DataType[st]}`)}}function s(st){switch(st){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function _(st,dt){if(dt===h.onnx.TensorProto.DataType.INT64||dt===it.TensorDataType.INT64){if(st.greaterThanOrEqual(2147483648)||st.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(dt!==h.onnx.TensorProto.DataType.UINT32&&dt!==it.TensorDataType.UINT32&&dt!==h.onnx.TensorProto.DataType.UINT64&&dt!==it.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${h.onnx.TensorProto.DataType[dt]}`);if(st.greaterThanOrEqual(4294967296)||st.lessThan(0))throw new TypeError("uint64 is not supported")}return st.toNumber()}function b(st,dt,ct){switch(dt){case h.onnx.TensorProto.DataType.BOOL:case h.onnx.TensorProto.DataType.UINT8:return st.getUint8(ct);case h.onnx.TensorProto.DataType.INT8:return st.getInt8(ct);case h.onnx.TensorProto.DataType.UINT16:return st.getUint16(ct,!0);case h.onnx.TensorProto.DataType.INT16:return st.getInt16(ct,!0);case h.onnx.TensorProto.DataType.FLOAT:return st.getFloat32(ct,!0);case h.onnx.TensorProto.DataType.INT32:return st.getInt32(ct,!0);case h.onnx.TensorProto.DataType.UINT32:return st.getUint32(ct,!0);case h.onnx.TensorProto.DataType.INT64:return _(g.default.fromBits(st.getUint32(ct,!0),st.getUint32(ct+4,!0),!1),dt);case h.onnx.TensorProto.DataType.DOUBLE:return st.getFloat64(ct,!0);case h.onnx.TensorProto.DataType.UINT64:return _(g.default.fromBits(st.getUint32(ct,!0),st.getUint32(ct+4,!0),!0),dt);default:throw new Error(`cannot read from DataView for type ${h.onnx.TensorProto.DataType[dt]}`)}}e.Tensor=$},2517:function(i,e,o){var a=this&&this.__importDefault||function(dt){return dt&&dt.__esModule?dt:{default:dt}};Object.defineProperty(e,"__esModule",{value:!0}),e.decodeUtf8String=e.MAX_CLIP=e.MIN_CLIP=e.PoolConvUtil=e.ReduceUtil=e.SplitUtil=e.MathUtil=e.ShapeUtil=e.LongUtil=e.ProtoUtil=e.GemmUtil=e.arrayCopyHelper=e.BroadcastUtil=e.MatMulUtil=e.ArrayUtil=e.assert=e.checkInputsShape=void 0;const d=o(5686),g=a(o(3720)),h=o(1446),et=o(9162);e.checkInputsShape=function(dt,...ct){if(!dt||dt.length!==ct.length)return!1;for(let pt=0;pt<dt.length;pt++)if(!dt[pt].dims||dt[pt].dims.length!==ct[pt])return!1;return!0},e.assert=function(dt,ct){if(!dt)throw new Error(typeof ct=="string"?ct:ct())},e.ArrayUtil=class{static arraysEqual(dt,ct){if(dt.length!==ct.length)return!1;for(let pt=0;pt<dt.length;pt++)if(dt[pt]!==ct[pt])return!1;return!0}};class ot{static preprocessInputShapes(ct,pt){return[ct.length===1?[1,ct[0]]:ct,pt.length===1?[pt[0],1]:pt]}static postprocessOutputShape(ct,pt,ft){pt===1&&ct.splice(ct.length-2,1),ft===1&&ct.pop()}static calcMatMulShape(ct,pt){return ct[1]!==pt[0]?void 0:[ct[0],pt[1]]}}e.MatMulUtil=ot;class it{static calcShape(ct,pt,ft=!1){const mt=ct.length,bt=pt.length;if(mt===0)return pt;if(bt===0)return ct;const $t=Math.max(ct.length,pt.length),Ct=new Array($t);if(ft){if(mt<2||bt<2)return;const It=ot.calcMatMulShape([ct[mt-2],ct[mt-1]],[pt[bt-2],pt[bt-1]]);if(It===void 0)return;[Ct[$t-2],Ct[$t-1]]=It}for(let It=ft?3:1;It<=$t;It++){const Tt=mt-It<0?1:ct[mt-It],jt=bt-It<0?1:pt[bt-It];if(Tt!==jt&&Tt>1&&jt>1)return;Ct[$t-It]=Math.max(Tt,jt)}return Ct}static index(ct,pt){const ft=new Array(pt.length);return it.fillIndex(ct,pt,ft),ft}static fillIndex(ct,pt,ft){const mt=ct.length-pt.length;for(let bt=0;bt<pt.length;bt++)ft[bt]=ct[mt+bt]%pt[bt]}static calc(ct,pt,ft,mt,bt){const $t=it.calcShape(ct.dims,pt.dims);if($t){if(mt&&!s.areEqual($t,ct.dims))return;const Ct=s.size($t),It=mt?ct:new et.Tensor($t,bt||ct.type);if($t.length===0)It.set([],ft(ct.get([]),pt.get([])));else{const Tt=new Array($t.length),jt=new Array(ct.dims.length),dn=new Array(pt.dims.length);let yn,mn=0,fn=0,un=!1,Wt=!1;ct.dims.length===0&&(mn=ct.get([]),un=!0),pt.dims.length===0&&(fn=pt.get([]),Wt=!0);for(let Jt=0;Jt<Ct;Jt++){yn=Jt;for(let _n=$t.length-1;_n>=0;_n--)Tt[_n]=yn%$t[_n],yn=Math.floor(yn/$t[_n]);un||(it.fillIndex(Tt,ct.dims,jt),mn=ct.get(jt)),Wt||(it.fillIndex(Tt,pt.dims,dn),fn=pt.get(dn)),It.set(Tt,ft(mn,fn))}}return It}}static isValidBroadcast(ct,pt){const ft=ct.length,mt=pt.length;if(ft>mt)return!1;for(let bt=1;bt<=ft;bt++)if(ct[ft-bt]!==1&&ct[ft-bt]!==pt[mt-bt])return!1;return!0}static getBroadcastDims(ct,pt){const ft=ct.length,mt=[];for(let bt=0;bt<ft;bt++){const $t=ft-1-bt,Ct=ct[$t]||1;(pt[pt.length-1-bt]||1)>1&&Ct===1&&mt.unshift($t)}return mt}}e.BroadcastUtil=it,e.arrayCopyHelper=function(dt,ct,pt,ft,mt){if(ft<0||ft>=ct.length)throw new Error("sourceIndex out of bounds");if(pt<0||pt>=dt.length)throw new Error("targetIndex out of bounds");if(ft+mt>ct.length)throw new Error("source indices to be copied are outside bounds");if(pt+mt>dt.length)throw new Error("target array is too small to hold result");for(let bt=0;bt<mt;bt++)dt[pt+bt]=ct[ft+bt]},e.GemmUtil=class{static getShapeOfGemmResult(dt,ct,pt,ft,mt){if(dt.length!==2||pt.length!==2)throw new Error("shape need to be of size 2");let bt,$t,Ct;ct?(bt=dt[1],$t=dt[0]):(bt=dt[0],$t=dt[1]);let It=-1;if(ft?(Ct=pt[0],It=1):(Ct=pt[1],It=0),pt[It]!==$t)throw new Error("dimension mismatch");if(bt<=0||Ct<=0||$t<=0)throw new Error("invalid shape specified");if(mt&&!it.isValidBroadcast(mt,[bt,Ct]))throw new Error("gemm: invalid bias shape for broadcast");return[bt,Ct,$t]}};class ${static tensorDataTypeFromProto(ct){switch(ct){case h.onnx.TensorProto.DataType.INT8:return"int8";case h.onnx.TensorProto.DataType.UINT8:return"uint8";case h.onnx.TensorProto.DataType.BOOL:return"bool";case h.onnx.TensorProto.DataType.INT16:return"int16";case h.onnx.TensorProto.DataType.UINT16:return"uint16";case h.onnx.TensorProto.DataType.INT32:return"int32";case h.onnx.TensorProto.DataType.UINT32:return"uint32";case h.onnx.TensorProto.DataType.FLOAT:return"float32";case h.onnx.TensorProto.DataType.DOUBLE:return"float64";case h.onnx.TensorProto.DataType.STRING:return"string";case h.onnx.TensorProto.DataType.INT64:return"int32";case h.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${h.onnx.TensorProto.DataType[ct]}`)}}static tensorDataTypeStringToEnum(ct){switch(ct){case"int8":return h.onnx.TensorProto.DataType.INT8;case"uint8":return h.onnx.TensorProto.DataType.UINT8;case"bool":return h.onnx.TensorProto.DataType.BOOL;case"int16":return h.onnx.TensorProto.DataType.INT16;case"uint16":return h.onnx.TensorProto.DataType.UINT16;case"int32":return h.onnx.TensorProto.DataType.INT32;case"uint32":return h.onnx.TensorProto.DataType.UINT32;case"float32":return h.onnx.TensorProto.DataType.FLOAT;case"float64":return h.onnx.TensorProto.DataType.DOUBLE;case"string":return h.onnx.TensorProto.DataType.STRING;case"int64":return h.onnx.TensorProto.DataType.INT64;case"uint64":return h.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${ct}`)}}static tensorDimsFromProto(ct){return ct.map(pt=>g.default.isLong(pt)?pt.toNumber():pt)}static tensorValueTypeFromProto(ct){return{tensorType:$.tensorDataTypeFromProto(ct.elemType),shape:{dims:$.tensorDimsFromProto(ct.shape.dim.map(pt=>pt.dimValue))}}}static tensorDimsFromORTFormat(ct){const pt=[];for(let ft=0;ft<ct.dimsLength();ft++)pt.push(c.longToNumber(ct.dims(ft)));return pt}static tensorAttributesFromORTFormat(ct){const pt=[];for(let ft=0;ft<ct.attributesLength();ft++)pt.push(ct.attributes(ft));return pt}}e.ProtoUtil=$;class c{static longToNumber(ct,pt){return g.default.isLong(ct)?ct.toNumber():ct instanceof d.flatbuffers.Long?g.default.fromValue({low:ct.low,high:ct.high,unsigned:pt!=null&&pt}).toNumber():ct}static isLong(ct){return g.default.isLong(ct)||ct instanceof d.flatbuffers.Long}}e.LongUtil=c;class s{static size(ct){return s.getSizeFromDimensionRange(ct,0,ct.length)}static sizeFromDimension(ct,pt){if(pt<0||pt>ct.length)throw new Error(`invalid dimension of ${pt} for sizeFromDimension as Tensor has ${ct.length} dimensions.`);return s.getSizeFromDimensionRange(ct,pt,ct.length)}static sizeToDimension(ct,pt){if(pt<0||pt>ct.length)throw new Error(`invalid dimension of ${pt} for sizeToDimension as Tensor has ${ct.length} dimensions.`);return s.getSizeFromDimensionRange(ct,0,pt)}static getSizeFromDimensionRange(ct,pt,ft){let mt=1;for(let bt=pt;bt<ft;bt++){if(ct[bt]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");mt*=ct[bt]}return mt}static computeStrides(ct){const pt=ct.length;if(pt===0)return[];if(pt===1)return[1];const ft=new Array(pt);ft[pt-1]=1,ft[pt-2]=ct[pt-1];for(let mt=pt-3;mt>=0;--mt)ft[mt]=ft[mt+1]*ct[mt+1];return ft}static transpose(ct){return ct.slice().reverse()}static indicesToOffset(ct,pt,ft){ft===void 0&&(ft=ct.length);let mt=0;for(let bt=0;bt<ft;++bt)mt+=pt[bt]*ct[bt];return mt}static offsetToIndices(ct,pt){const ft=pt.length;if(ft===0)return[];if(ft===1)return[ct*pt[0]];const mt=new Array(pt.length);for(let bt=0;bt<mt.length-1;++bt)mt[bt]=Math.floor(ct/pt[bt]),ct-=mt[bt]*pt[bt];return mt[mt.length-1]=ct,mt}static normalizeAxis(ct,pt){if(ct<-pt&&ct>=pt)throw new Error("unsupported axis for this operation.");return ct<0?ct+pt:ct}static normalizeAxes(ct,pt){return ct.map(ft=>this.normalizeAxis(ft,pt))}static incrementIndex(ct,pt,ft){if(pt.length===0||ct.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(ft===void 0)ft=pt.length;else if(ft<=0||ft>pt.length)throw new Error("Incorrect axis to increment on");for(let mt=ft-1;mt>=0&&(ct[mt]++,!(ct[mt]<pt[mt]));--mt)ct[mt]=0}static calculateReshapedDims(ct,pt){if(pt.length===0){if(ct.length===0||s.size(ct)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const ft=pt.length,mt=new Array(ft);let bt=-1,$t=1;for(let It=0;It<ft;It++){if(pt[It]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(pt[It]===-1){if(bt!==-1)throw new Error("at most one dimension in shape hints can be -1");bt=It}else{if(pt[It]===0){if(It>=ct.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");mt[It]=ct[It]}else mt[It]=pt[It];$t*=mt[It]}}const Ct=s.size(ct);if(bt!==-1){if(Ct%$t!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${ct}] Output shape: [${pt}]`);mt[bt]=Ct/$t}else if($t!==Ct)throw new Error("reshapedDims and originalDims don't have matching sizes");return mt}static sortBasedOnPerm(ct,pt){return pt?pt.map(ft=>ct[ft]):ct.slice().reverse()}static padShape(ct,pt){const ft=ct.length;return ct.map((mt,bt)=>mt+pt[bt]+pt[bt+ft])}static areEqual(ct,pt){return ct.length===pt.length&&ct.every((ft,mt)=>ft===pt[mt])}static validateDimsAndCalcSize(ct){if(ct.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let pt=1;for(const ft of ct){if(!Number.isInteger(ft))throw new TypeError(`Invalid shape: ${ft} is not an integer`);if(ft<0||ft>2147483647)throw new TypeError(`Invalid shape: length ${ft} is not allowed`);pt*=ft}return pt}static flattenShape(ct,pt){pt<0&&(pt+=ct.length);const ft=ct.reduce((bt,$t)=>bt*$t,1),mt=ct.slice(pt).reduce((bt,$t)=>bt*$t,1);return[ft/mt,mt]}static squeezeShape(ct,pt){const ft=new Array;pt=s.normalizeAxes(pt,ct.length);for(let mt=0;mt<ct.length;mt++){const bt=pt.indexOf(mt)>=0;if(bt&&ct[mt]!==1)throw new Error("squeeze an axis of size different than 1");(pt.length===0&&ct[mt]>1||pt.length>0&&!bt)&&ft.push(ct[mt])}return ft}static unsqueezeShape(ct,pt){const ft=new Array(ct.length+pt.length);ft.fill(0);for(let bt=0;bt<pt.length;bt++){const $t=s.normalizeAxis(pt[bt],ft.length);if($t>=ft.length)throw new Error("'axes' has an out of range axis");if(ft[$t]!==0)throw new Error("'axes' has a duplicate axis");ft[$t]=1}let mt=0;for(let bt=0;bt<ft.length;bt++)ft[bt]===0&&(ft[bt]=ct[mt++]);if(mt!==ct.length)throw new Error("the unsqueezed dimension could not be established");return ft}}e.ShapeUtil=s,e.MathUtil=class{static sqr(dt,ct,pt,ft,mt){if(ft<0||ft>=ct.length)throw new Error("sourceIndex out of bounds");if(pt<0||pt>=dt.length)throw new Error("targetIndex out of bounds");if(ft+mt>ct.length)throw new Error("source indices to be copied are outside bounds");if(pt+mt>dt.length)throw new Error("target array is too small to hold result");for(let bt=0;bt<mt;bt++)dt[pt+bt]+=Math.pow(ct[ft+bt],2)}static axpy(dt,ct,pt,ft,mt,bt){if(ft<0||ft>=ct.length)throw new Error("sourceIndex out of bounds");if(pt<0||pt>=dt.length)throw new Error("targetIndex out of bounds");if(ft+mt>ct.length)throw new Error("source indices to be copied are outside bounds");if(pt+mt>dt.length)throw new Error("target array is too small to hold result");for(let $t=0;$t<mt;$t++)dt[pt+$t]+=bt*ct[ft+$t]}static powx(dt,ct,pt,ft,mt,bt){if(ft<0||ft>=ct.length)throw new Error("sourceIndex out of bounds");if(pt<0||pt>=dt.length)throw new Error("targetIndex out of bounds");if(ft+mt>ct.length)throw new Error("source indices to be copied are outside bounds");if(pt+mt>dt.length)throw new Error("target array is too small to hold result");for(let $t=0;$t<mt;$t++)dt[pt+$t]=Math.pow(ct[ft+$t],bt)}static mul(dt,ct,pt,ft,mt){if(ft<0||ft>=ct.length)throw new Error("sourceIndex out of bounds");if(pt<0||pt>=dt.length)throw new Error("targetIndex out of bounds");if(ft+mt>ct.length)throw new Error("source indices to be copied are outside bounds");if(pt+mt>dt.length)throw new Error("target array is too small to hold result");for(let bt=0;bt<mt;bt++)dt[pt+bt]=ct[ft+bt]*dt[pt+bt]}};class _{static splitShape(ct,pt,ft,mt){if(ft.length===0){if(!mt)throw new Error("need to know number of outputs when the 'split' attribute is not specified");_.determineSplit(ct[pt],mt,ft)}const bt=[],$t=[0];for(let Ct=0;Ct<ft.length;++Ct){Ct!==0&&$t.push($t[Ct-1]+ft[Ct-1]);const It=ct.slice();It[pt]=ft[Ct],bt.push(It)}return[bt,$t]}static determineSplit(ct,pt,ft){if(ct%pt!=0)throw new Error("cannot split tensor to equal sized parts");for(let mt=0;mt<pt;++mt)ft.push(ct/pt)}}e.SplitUtil=_;class b{static calcReduce(ct,pt,ft,mt,bt){const $t=ct.dims.slice(0);pt.length===0&&$t.forEach((mn,fn)=>pt.push(fn));const Ct=b.calcReduceShape($t,pt,!0),It=s.size(Ct),Tt=new et.Tensor(Ct,ct.type),jt=s.computeStrides(Ct),dn=s.computeStrides($t),yn=new Array($t.length);for(let mn=0;mn<It;mn++){const fn=s.offsetToIndices(mn,jt);it.fillIndex(fn,$t,yn),Tt.set(fn,b.calcReduceByAxis(ct.numberData,pt,$t,0,s.indicesToOffset(yn,dn),mt,bt))}return ft?Tt:new et.Tensor(b.calcReduceShape($t,pt,ft),Tt.type,void 0,void 0,Tt.data,Tt.dataId)}static calcReduceByAxis(ct,pt,ft,mt,bt,$t,Ct){let It=0;if(mt>=pt.length)return $t(ct[bt]);const Tt=pt[mt],jt=Tt>=ft.length?1:s.size(ft.slice(Tt+1));for(let dn=0;dn<ft[Tt];dn++)It=dn===0?b.calcReduceByAxis(ct,pt,ft,mt+1,bt,$t,Ct):Ct(It,b.calcReduceByAxis(ct,pt,ft,mt+1,bt,$t,Ct)),bt+=jt;return It}static calcReduceShape(ct,pt,ft){const mt=ct.slice();for(let bt=0;bt<pt.length;bt++)mt[pt[bt]]=ft?1:0;return mt.filter(bt=>bt!==0)}}e.ReduceUtil=b;class st{static adjustPoolAttributes(ct,pt,ft,mt,bt,$t){if(!ct&&ft.length!==pt.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(ct)for(let Ct=0;Ct<pt.length-2;Ct++)Ct>=ft.length?ft.push(pt[Ct+2]):ft[Ct]=pt[Ct+2];for(let Ct=0;Ct<ft.length;Ct++)if(Ct<mt.length){if(mt[Ct]<0)throw new Error("strides should be greater than or equal to 1")}else mt.push(1);for(let Ct=0;Ct<ft.length;Ct++)if(Ct<bt.length){if(bt[Ct]<0)throw new Error("dilations should be greater than or equal to 1")}else bt.push(1);for(let Ct=0;Ct<2*ft.length;Ct++)if(Ct<$t.length){if($t[Ct]<0)throw new Error("pad should be greater than or equal to 1")}else $t.push(0);for(let Ct=0;Ct<ft.length;Ct++){if(ft[Ct]<=0)throw new Error("kernel shapes need to be greater than 0");if($t[Ct]>=ft[Ct]||$t[Ct+ft.length]>=ft[Ct])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(ct,pt,ft,mt,bt,$t){if($t){if(bt.length!==2*(ct.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(pt.length!==ct.length-2)throw new Error("length of strides should be the length of data dimensions");if(mt.length!==ct.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let Ct=0;Ct<ct.length-2;Ct++)st.adjustPadAndReturnShape(ct[Ct+2],pt[Ct],ft[Ct],mt[Ct],bt,Ct,Ct+ct.length-2,$t)}}static computePoolOutputShape(ct,pt,ft,mt,bt,$t,Ct){if(pt.length<=0)throw new Error("input shape must be of size greater than 0");const It=[pt[0],pt[1]];return st.computeShapeHelper(ct,pt,It,ft,mt,bt,$t,Ct),It}static computeConvOutputShape(ct,pt,ft,mt,bt,$t,Ct){if(ct.length<=0||pt.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const It=[ct[0],pt[0]];return st.computeShapeHelper(!1,ct,It,ft,mt,bt,$t,Ct),It}static computeShapeHelper(ct,pt,ft,mt,bt,$t,Ct,It){if(ct)for(let Tt=0;Tt<pt.length-2;Tt++)ft.push(1);else for(let Tt=0;Tt<pt.length-2;Tt++)ft.push(st.adjustPadAndReturnShape(pt[Tt+2],mt[Tt],bt[Tt],$t[Tt],Ct,Tt,Tt+pt.length-2,It))}static adjustPadAndReturnShape(ct,pt,ft,mt,bt,$t,Ct,It){const Tt=ft*(mt-1)+1;if(!It||It==="NOTSET")return Math.floor((ct+bt[$t]+bt[Ct]-Tt)/pt+1);switch(It){case"VALID":return bt[$t]=0,bt[Ct]=0,Math.floor((ct-Tt)/pt+1);case"SAME_LOWER":case"SAME_UPPER":if(ft!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const jt=((ct+pt-1)/pt-1)*pt+mt-ct;return bt[$t]=Math.floor(It==="SAME_LOWER"?(jt+1)/2:jt/2),bt[Ct]=jt-bt[$t],Math.floor((ct+jt-mt)/pt+1)}default:throw new Error("Unsupported AutoPad type")}}}e.PoolConvUtil=st,e.MIN_CLIP=-34028234663852886e22,e.MAX_CLIP=34028234663852886e22,e.decodeUtf8String=function(dt){return new TextDecoder().decode(dt)}},7967:(i,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(o,a,d,g)=>{if(typeof o=="object"&&o!==null){if(d.has(o))throw new Error("Circular reference in options");d.add(o)}Object.entries(o).forEach(([h,et])=>{const ot=a?a+h:h;if(typeof et=="object")(0,e.iterateExtraOptions)(et,ot+".",d,g);else if(typeof et=="string"||typeof et=="number")g(ot,et.toString());else{if(typeof et!="boolean")throw new Error("Can't handle extra config type: "+typeof et);g(ot,et?"1":"0")}})}},2157:function(i,e,o){var a,d=this&&this.__createBinding||(Object.create?function(jt,dn,yn,mn){mn===void 0&&(mn=yn);var fn=Object.getOwnPropertyDescriptor(dn,yn);fn&&!("get"in fn?!dn.__esModule:fn.writable||fn.configurable)||(fn={enumerable:!0,get:function(){return dn[yn]}}),Object.defineProperty(jt,mn,fn)}:function(jt,dn,yn,mn){mn===void 0&&(mn=yn),jt[mn]=dn[yn]}),g=this&&this.__setModuleDefault||(Object.create?function(jt,dn){Object.defineProperty(jt,"default",{enumerable:!0,value:dn})}:function(jt,dn){jt.default=dn}),h=this&&this.__importStar||function(jt){if(jt&&jt.__esModule)return jt;var dn={};if(jt!=null)for(var yn in jt)yn!=="default"&&Object.prototype.hasOwnProperty.call(jt,yn)&&d(dn,jt,yn);return g(dn,jt),dn};Object.defineProperty(e,"__esModule",{value:!0}),e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=e.initWasm=void 0;const et=o(1670),ot=h(o(349)),it=o(6361),$=()=>!!et.env.wasm.proxy&&typeof document<"u";let c,s,_,b=!1,st=!1,dt=!1;const ct=[],pt=[],ft=[],mt=[],bt=[],$t=[],Ct=()=>{if(b||!st||dt||!c)throw new Error("worker not ready")},It=jt=>{switch(jt.data.type){case"init-wasm":b=!1,jt.data.err?(dt=!0,s[1](jt.data.err)):(st=!0,s[0]());break;case"init-ort":jt.data.err?_[1](jt.data.err):_[0]();break;case"create_allocate":jt.data.err?ct.shift()[1](jt.data.err):ct.shift()[0](jt.data.out);break;case"create_finalize":jt.data.err?pt.shift()[1](jt.data.err):pt.shift()[0](jt.data.out);break;case"create":jt.data.err?ft.shift()[1](jt.data.err):ft.shift()[0](jt.data.out);break;case"release":jt.data.err?mt.shift()[1](jt.data.err):mt.shift()[0]();break;case"run":jt.data.err?bt.shift()[1](jt.data.err):bt.shift()[0](jt.data.out);break;case"end-profiling":jt.data.err?$t.shift()[1](jt.data.err):$t.shift()[0]()}},Tt=typeof document<"u"?(a=document==null?void 0:document.currentScript)===null||a===void 0?void 0:a.src:void 0;e.initWasm=async()=>{if($()){if(st)return;if(b)throw new Error("multiple calls to 'initWasm()' detected.");if(dt)throw new Error("previous call to 'initWasm()' failed.");return b=!0,et.env.wasm.wasmPaths===void 0&&Tt&&Tt.indexOf("blob:")!==0&&(et.env.wasm.wasmPaths=Tt.substr(0,+Tt.lastIndexOf("/")+1)),new Promise((jt,dn)=>{c==null||c.terminate(),c=o(9710).Z(),c.onmessage=It,s=[jt,dn];const yn={type:"init-wasm",in:et.env.wasm};c.postMessage(yn)})}return(0,it.initializeWebAssembly)(et.env.wasm)},e.initOrt=async(jt,dn)=>{if($())return Ct(),new Promise((yn,mn)=>{_=[yn,mn];const fn={type:"init-ort",in:{numThreads:jt,loggingLevel:dn}};c.postMessage(fn)});ot.initOrt(jt,dn)},e.createSessionAllocate=async jt=>$()?(Ct(),new Promise((dn,yn)=>{ct.push([dn,yn]);const mn={type:"create_allocate",in:{model:jt}};c.postMessage(mn,[jt.buffer])})):ot.createSessionAllocate(jt),e.createSessionFinalize=async(jt,dn)=>$()?(Ct(),new Promise((yn,mn)=>{pt.push([yn,mn]);const fn={type:"create_finalize",in:{modeldata:jt,options:dn}};c.postMessage(fn)})):ot.createSessionFinalize(jt,dn),e.createSession=async(jt,dn)=>$()?(Ct(),new Promise((yn,mn)=>{ft.push([yn,mn]);const fn={type:"create",in:{model:jt,options:dn}};c.postMessage(fn,[jt.buffer])})):ot.createSession(jt,dn),e.releaseSession=async jt=>{if($())return Ct(),new Promise((dn,yn)=>{mt.push([dn,yn]);const mn={type:"release",in:jt};c.postMessage(mn)});ot.releaseSession(jt)},e.run=async(jt,dn,yn,mn,fn)=>$()?(Ct(),new Promise((un,Wt)=>{bt.push([un,Wt]);const Jt={type:"run",in:{sessionId:jt,inputIndices:dn,inputs:yn,outputIndices:mn,options:fn}};c.postMessage(Jt,ot.extractTransferableBuffers(yn))})):ot.run(jt,dn,yn,mn,fn),e.endProfiling=async jt=>{if($())return Ct(),new Promise((dn,yn)=>{$t.push([dn,yn]);const mn={type:"end-profiling",in:jt};c.postMessage(mn)});ot.endProfiling(jt)}},586:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const a=o(7967),d=o(4983),g=o(6361);e.setRunOptions=h=>{const et=(0,g.getInstance)();let ot=0;const it=[],$=h||{};try{if((h==null?void 0:h.logSeverityLevel)===void 0)$.logSeverityLevel=2;else if(typeof h.logSeverityLevel!="number"||!Number.isInteger(h.logSeverityLevel)||h.logSeverityLevel<0||h.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${h.logSeverityLevel}`);if((h==null?void 0:h.logVerbosityLevel)===void 0)$.logVerbosityLevel=0;else if(typeof h.logVerbosityLevel!="number"||!Number.isInteger(h.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${h.logVerbosityLevel}`);(h==null?void 0:h.terminate)===void 0&&($.terminate=!1);let c=0;if((h==null?void 0:h.tag)!==void 0&&(c=(0,d.allocWasmString)(h.tag,it)),ot=et._OrtCreateRunOptions($.logSeverityLevel,$.logVerbosityLevel,!!$.terminate,c),ot===0)throw new Error("Can't create run options");return(h==null?void 0:h.extra)!==void 0&&(0,a.iterateExtraOptions)(h.extra,"",new WeakSet,(s,_)=>{const b=(0,d.allocWasmString)(s,it),st=(0,d.allocWasmString)(_,it);if(et._OrtAddRunConfigEntry(ot,b,st)!==0)throw new Error(`Can't set a run config entry: ${s} - ${_}`)}),[ot,it]}catch(c){throw ot!==0&&et._OrtReleaseRunOptions(ot),it.forEach(et._free),c}}},2306:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.OnnxruntimeWebAssemblySessionHandler=void 0;const a=o(2806),d=o(1670),g=o(2850),h=o(2157);let et;e.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(ot){const it=await fetch(ot),$=await it.arrayBuffer();return(0,h.createSessionAllocate)(new Uint8Array($))}async loadModel(ot,it){if(et||(await(0,h.initOrt)(d.env.wasm.numThreads,($=>{switch($){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${$}`)}})(d.env.logLevel)),et=!0),typeof ot=="string")if(typeof fetch>"u"){const $=await(0,g.promisify)(a.readFile)(ot);[this.sessionId,this.inputNames,this.outputNames]=await(0,h.createSession)($,it)}else{const $=await this.createSessionAllocate(ot);[this.sessionId,this.inputNames,this.outputNames]=await(0,h.createSessionFinalize)($,it)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,h.createSession)(ot,it)}async dispose(){return(0,h.releaseSession)(this.sessionId)}async run(ot,it,$){const c=[],s=[];Object.entries(ot).forEach(dt=>{const ct=dt[0],pt=dt[1],ft=this.inputNames.indexOf(ct);if(ft===-1)throw new Error(`invalid input '${ct}'`);c.push(pt),s.push(ft)});const _=[];Object.entries(it).forEach(dt=>{const ct=dt[0],pt=this.outputNames.indexOf(ct);if(pt===-1)throw new Error(`invalid output '${ct}'`);_.push(pt)});const b=await(0,h.run)(this.sessionId,s,c.map(dt=>[dt.type,dt.dims,dt.data]),_,$),st={};for(let dt=0;dt<b.length;dt++)st[this.outputNames[_[dt]]]=new d.Tensor(b[dt][0],b[dt][2],b[dt][1]);return st}startProfiling(){}endProfiling(){(0,h.endProfiling)(this.sessionId)}}},4919:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const a=o(7967),d=o(4983),g=o(6361);e.setSessionOptions=h=>{const et=(0,g.getInstance)();let ot=0;const it=[],$=h||{};(c=>{c.extra||(c.extra={}),c.extra.session||(c.extra.session={});const s=c.extra.session;s.use_ort_model_bytes_directly||(s.use_ort_model_bytes_directly="1")})($);try{(h==null?void 0:h.graphOptimizationLevel)===void 0&&($.graphOptimizationLevel="all");const c=(b=>{switch(b){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${b}`)}})($.graphOptimizationLevel);(h==null?void 0:h.enableCpuMemArena)===void 0&&($.enableCpuMemArena=!0),(h==null?void 0:h.enableMemPattern)===void 0&&($.enableMemPattern=!0),(h==null?void 0:h.executionMode)===void 0&&($.executionMode="sequential");const s=(b=>{switch(b){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${b}`)}})($.executionMode);let _=0;if((h==null?void 0:h.logId)!==void 0&&(_=(0,d.allocWasmString)(h.logId,it)),(h==null?void 0:h.logSeverityLevel)===void 0)$.logSeverityLevel=2;else if(typeof h.logSeverityLevel!="number"||!Number.isInteger(h.logSeverityLevel)||h.logSeverityLevel<0||h.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${h.logSeverityLevel}`);if((h==null?void 0:h.logVerbosityLevel)===void 0)$.logVerbosityLevel=0;else if(typeof h.logVerbosityLevel!="number"||!Number.isInteger(h.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${h.logVerbosityLevel}`);if((h==null?void 0:h.enableProfiling)===void 0&&($.enableProfiling=!1),ot=et._OrtCreateSessionOptions(c,!!$.enableCpuMemArena,!!$.enableMemPattern,s,!!$.enableProfiling,0,_,$.logSeverityLevel,$.logVerbosityLevel),ot===0)throw new Error("Can't create session options");return h!=null&&h.executionProviders&&((b,st,dt)=>{for(const ct of st){let pt=typeof ct=="string"?ct:ct.name;switch(pt){case"xnnpack":pt="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${pt}`)}const ft=(0,d.allocWasmString)(pt,dt);if((0,g.getInstance)()._OrtAppendExecutionProvider(b,ft)!==0)throw new Error(`Can't append execution provider: ${pt}`)}})(ot,h.executionProviders,it),(h==null?void 0:h.extra)!==void 0&&(0,a.iterateExtraOptions)(h.extra,"",new WeakSet,(b,st)=>{const dt=(0,d.allocWasmString)(b,it),ct=(0,d.allocWasmString)(st,it);if(et._OrtAddSessionConfigEntry(ot,dt,ct)!==0)throw new Error(`Can't set a session config entry: ${b} - ${st}`)}),[ot,it]}catch(c){throw ot!==0&&et._OrtReleaseSessionOptions(ot),it.forEach(et._free),c}}},4983:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const a=o(6361);e.allocWasmString=(d,g)=>{const h=(0,a.getInstance)(),et=h.lengthBytesUTF8(d)+1,ot=h._malloc(et);return h.stringToUTF8(d,ot,et),g.push(ot),ot}},349:(i,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const a=o(586),d=o(4919),g=o(4983),h=o(6361);e.initOrt=(c,s)=>{const _=(0,h.getInstance)()._OrtInit(c,s);if(_!==0)throw new Error(`Can't initialize onnxruntime. error code = ${_}`)};const et=new Map;e.createSessionAllocate=c=>{const s=(0,h.getInstance)(),_=s._malloc(c.byteLength);return s.HEAPU8.set(c,_),[_,c.byteLength]},e.createSessionFinalize=(c,s)=>{const _=(0,h.getInstance)();let b=0,st=0,dt=[];try{if([st,dt]=(0,d.setSessionOptions)(s),b=_._OrtCreateSession(c[0],c[1],st),b===0)throw new Error("Can't create a session")}finally{_._free(c[0]),_._OrtReleaseSessionOptions(st),dt.forEach(_._free)}const ct=_._OrtGetInputCount(b),pt=_._OrtGetOutputCount(b),ft=[],mt=[],bt=[],$t=[];for(let Ct=0;Ct<ct;Ct++){const It=_._OrtGetInputName(b,Ct);if(It===0)throw new Error("Can't get an input name");mt.push(It),ft.push(_.UTF8ToString(It))}for(let Ct=0;Ct<pt;Ct++){const It=_._OrtGetOutputName(b,Ct);if(It===0)throw new Error("Can't get an output name");$t.push(It),bt.push(_.UTF8ToString(It))}return et.set(b,[b,mt,$t]),[b,ft,bt]},e.createSession=(c,s)=>{const _=(0,e.createSessionAllocate)(c);return(0,e.createSessionFinalize)(_,s)},e.releaseSession=c=>{const s=(0,h.getInstance)(),_=et.get(c);if(!_)throw new Error("invalid session id");const b=_[0],st=_[1],dt=_[2];st.forEach(s._OrtFree),dt.forEach(s._OrtFree),s._OrtReleaseSession(b),et.delete(c)};const ot=c=>{switch(c){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${c}`)}},it=c=>{switch(c){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${c}`)}},$=c=>{switch(c){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${c}`)}};e.run=(c,s,_,b,st)=>{const dt=(0,h.getInstance)(),ct=et.get(c);if(!ct)throw new Error("invalid session id");const pt=ct[0],ft=ct[1],mt=ct[2],bt=s.length,$t=b.length;let Ct=0,It=[];const Tt=[],jt=[];try{[Ct,It]=(0,a.setRunOptions)(st);for(let Wt=0;Wt<bt;Wt++){const Jt=_[Wt][0],_n=_[Wt][1],vn=_[Wt][2];let Sn,hn;if(Array.isArray(vn)){hn=4*vn.length,Sn=dt._malloc(hn),jt.push(Sn);let Ir=Sn/4;for(let $r=0;$r<vn.length;$r++){if(typeof vn[$r]!="string")throw new TypeError(`tensor data at index ${$r} is not a string`);dt.HEAPU32[Ir++]=(0,g.allocWasmString)(vn[$r],jt)}}else hn=vn.byteLength,Sn=dt._malloc(hn),jt.push(Sn),dt.HEAPU8.set(new Uint8Array(vn.buffer,vn.byteOffset,hn),Sn);const rr=dt.stackSave(),vr=dt.stackAlloc(4*_n.length);try{let Ir=vr/4;_n.forEach(Ur=>dt.HEAP32[Ir++]=Ur);const $r=dt._OrtCreateTensor(ot(Jt),Sn,hn,vr,_n.length);if($r===0)throw new Error("Can't create a tensor");Tt.push($r)}finally{dt.stackRestore(rr)}}const dn=dt.stackSave(),yn=dt.stackAlloc(4*bt),mn=dt.stackAlloc(4*bt),fn=dt.stackAlloc(4*$t),un=dt.stackAlloc(4*$t);try{let Wt=yn/4,Jt=mn/4,_n=fn/4,vn=un/4;for(let rr=0;rr<bt;rr++)dt.HEAPU32[Wt++]=Tt[rr],dt.HEAPU32[Jt++]=ft[s[rr]];for(let rr=0;rr<$t;rr++)dt.HEAPU32[_n++]=0,dt.HEAPU32[vn++]=mt[b[rr]];let Sn=dt._OrtRun(pt,mn,yn,bt,un,$t,fn,Ct);const hn=[];if(Sn===0)for(let rr=0;rr<$t;rr++){const vr=dt.HEAPU32[fn/4+rr],Ir=dt.stackSave(),$r=dt.stackAlloc(16);let Ur,Yr=0;try{if(Sn=dt._OrtGetTensorData(vr,$r,$r+4,$r+8,$r+12),Sn!==0)throw new Error(`Can't access output tensor data. error code = ${Sn}`);let r0=$r/4;const b0=dt.HEAPU32[r0++];Yr=dt.HEAPU32[r0++];const t0=dt.HEAPU32[r0++],l0=dt.HEAPU32[r0++],_i=[];for(let vm=0;vm<l0;vm++)_i.push(dt.HEAPU32[t0/4+vm]);dt._OrtFree(t0);const Po=_i.length===0?1:_i.reduce((vm,s0)=>vm*s0);if(Ur=it(b0),Ur==="string"){const vm=[];let s0=Yr/4;for(let k0=0;k0<Po;k0++){const E0=dt.HEAPU32[s0++],O0=k0===Po-1?void 0:dt.HEAPU32[s0]-E0;vm.push(dt.UTF8ToString(E0,O0))}hn.push([Ur,_i,vm])}else{const vm=new($(Ur))(Po);new Uint8Array(vm.buffer,vm.byteOffset,vm.byteLength).set(dt.HEAPU8.subarray(Yr,Yr+vm.byteLength)),hn.push([Ur,_i,vm])}}finally{dt.stackRestore(Ir),Ur==="string"&&Yr&&dt._free(Yr),dt._OrtReleaseTensor(vr)}}if(Sn===0)return hn;throw new Error(`failed to call OrtRun(). error code = ${Sn}.`)}finally{dt.stackRestore(dn)}}finally{Tt.forEach(dt._OrtReleaseTensor),jt.forEach(dt._free),dt._OrtReleaseRunOptions(Ct),It.forEach(dt._free)}},e.endProfiling=c=>{const s=(0,h.getInstance)(),_=et.get(c);if(!_)throw new Error("invalid session id");const b=_[0],st=s._OrtEndProfiling(b);if(st===0)throw new Error("Can't get an profile file name");s._OrtFree(st)},e.extractTransferableBuffers=c=>{const s=[];for(const _ of c){const b=_[2];!Array.isArray(b)&&b.buffer&&s.push(b.buffer)}return s}},6361:function(i,e,o){var a=this&&this.__createBinding||(Object.create?function(st,dt,ct,pt){pt===void 0&&(pt=ct);var ft=Object.getOwnPropertyDescriptor(dt,ct);ft&&!("get"in ft?!dt.__esModule:ft.writable||ft.configurable)||(ft={enumerable:!0,get:function(){return dt[ct]}}),Object.defineProperty(st,pt,ft)}:function(st,dt,ct,pt){pt===void 0&&(pt=ct),st[pt]=dt[ct]}),d=this&&this.__setModuleDefault||(Object.create?function(st,dt){Object.defineProperty(st,"default",{enumerable:!0,value:dt})}:function(st,dt){st.default=dt}),g=this&&this.__importStar||function(st){if(st&&st.__esModule)return st;var dt={};if(st!=null)for(var ct in st)ct!=="default"&&Object.prototype.hasOwnProperty.call(st,ct)&&a(dt,st,ct);return d(dt,st),dt},h=this&&this.__importDefault||function(st){return st&&st.__esModule?st:{default:st}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const et=g(o(6449)),ot=h(o(932)),it=o(3474);let $,c=!1,s=!1,_=!1;const b=(st,dt)=>dt?st?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":st?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async st=>{if(c)return Promise.resolve();if(s)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(_)throw new Error("previous call to 'initializeWebAssembly()' failed.");s=!0;const dt=st.initTimeout,ct=st.numThreads,pt=st.simd,ft=ct>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),mt=pt&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),bt=typeof st.wasmPaths=="string"?st.wasmPaths:void 0,$t=b(!1,ft),Ct=b(mt,ft),It=typeof st.wasmPaths=="object"?st.wasmPaths[Ct]:void 0;let Tt=!1;const jt=[];if(dt>0&&jt.push(new Promise(dn=>{setTimeout(()=>{Tt=!0,dn()},dt)})),jt.push(new Promise((dn,yn)=>{const mn=ft?it:ot.default,fn={locateFile:(un,Wt)=>ft&&un.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([o(4154)],{type:"text/javascript"})):un===$t?It??(bt??Wt)+Ct:Wt+un};if(ft)if(typeof Blob>"u")fn.mainScriptUrlOrBlob=et.join("/","ort-wasm-threaded.js");else{const un=`var ortWasmThreaded=(function(){var _scriptDir;return ${mn.toString()}})();`;fn.mainScriptUrlOrBlob=new Blob([un],{type:"text/javascript"})}mn(fn).then(un=>{s=!1,c=!0,$=un,dn()},un=>{s=!1,_=!0,yn(un)})})),await Promise.race(jt),Tt)throw new Error(`WebAssembly backend initializing failed due to timeout: ${dt}ms`)},e.getInstance=()=>{if(c&&$)return $;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var st;!c||s||_||(s=!0,(st=$.PThread)===null||st===void 0||st.terminateAllThreads(),$=void 0,s=!1,c=!1,_=!0)}},9710:(i,e,o)=>{o.d(e,{Z:()=>g});var a=o(477),d=o.n(a);function g(){return d()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:i=>{i.exports=function(e,o,a,d){var g=self||window;try{try{var h;try{h=new g.Blob([e])}catch{(h=new(g.BlobBuilder||g.WebKitBlobBuilder||g.MozBlobBuilder||g.MSBlobBuilder)).append(e),h=h.getBlob()}var et=g.URL||g.webkitURL,ot=et.createObjectURL(h),it=new g[o](ot,a);return et.revokeObjectURL(ot),it}catch{return new g[o]("data:application/javascript,".concat(encodeURIComponent(e)),a)}}catch{if(!d)throw Error("Inline worker is not supported");return new g[o](d,a)}}},4154:i=>{i.exports=`"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`},1670:i=>{i.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(i,e,o)=>{o.r(e),o.d(e,{flatbuffers:()=>a});var a={};a.Offset,a.Table,a.SIZEOF_SHORT=2,a.SIZEOF_INT=4,a.FILE_IDENTIFIER_LENGTH=4,a.SIZE_PREFIX_LENGTH=4,a.Encoding={UTF8_BYTES:1,UTF16_STRING:2},a.int32=new Int32Array(2),a.float32=new Float32Array(a.int32.buffer),a.float64=new Float64Array(a.int32.buffer),a.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,a.Long=function(d,g){this.low=0|d,this.high=0|g},a.Long.create=function(d,g){return d==0&&g==0?a.Long.ZERO:new a.Long(d,g)},a.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},a.Long.prototype.equals=function(d){return this.low==d.low&&this.high==d.high},a.Long.ZERO=new a.Long(0,0),a.Builder=function(d){if(d)g=d;else var g=1024;this.bb=a.ByteBuffer.allocate(g),this.space=g,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},a.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},a.Builder.prototype.forceDefaults=function(d){this.force_defaults=d},a.Builder.prototype.dataBuffer=function(){return this.bb},a.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},a.Builder.prototype.prep=function(d,g){d>this.minalign&&(this.minalign=d);for(var h=1+~(this.bb.capacity()-this.space+g)&d-1;this.space<h+d+g;){var et=this.bb.capacity();this.bb=a.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-et}this.pad(h)},a.Builder.prototype.pad=function(d){for(var g=0;g<d;g++)this.bb.writeInt8(--this.space,0)},a.Builder.prototype.writeInt8=function(d){this.bb.writeInt8(this.space-=1,d)},a.Builder.prototype.writeInt16=function(d){this.bb.writeInt16(this.space-=2,d)},a.Builder.prototype.writeInt32=function(d){this.bb.writeInt32(this.space-=4,d)},a.Builder.prototype.writeInt64=function(d){this.bb.writeInt64(this.space-=8,d)},a.Builder.prototype.writeFloat32=function(d){this.bb.writeFloat32(this.space-=4,d)},a.Builder.prototype.writeFloat64=function(d){this.bb.writeFloat64(this.space-=8,d)},a.Builder.prototype.addInt8=function(d){this.prep(1,0),this.writeInt8(d)},a.Builder.prototype.addInt16=function(d){this.prep(2,0),this.writeInt16(d)},a.Builder.prototype.addInt32=function(d){this.prep(4,0),this.writeInt32(d)},a.Builder.prototype.addInt64=function(d){this.prep(8,0),this.writeInt64(d)},a.Builder.prototype.addFloat32=function(d){this.prep(4,0),this.writeFloat32(d)},a.Builder.prototype.addFloat64=function(d){this.prep(8,0),this.writeFloat64(d)},a.Builder.prototype.addFieldInt8=function(d,g,h){(this.force_defaults||g!=h)&&(this.addInt8(g),this.slot(d))},a.Builder.prototype.addFieldInt16=function(d,g,h){(this.force_defaults||g!=h)&&(this.addInt16(g),this.slot(d))},a.Builder.prototype.addFieldInt32=function(d,g,h){(this.force_defaults||g!=h)&&(this.addInt32(g),this.slot(d))},a.Builder.prototype.addFieldInt64=function(d,g,h){!this.force_defaults&&g.equals(h)||(this.addInt64(g),this.slot(d))},a.Builder.prototype.addFieldFloat32=function(d,g,h){(this.force_defaults||g!=h)&&(this.addFloat32(g),this.slot(d))},a.Builder.prototype.addFieldFloat64=function(d,g,h){(this.force_defaults||g!=h)&&(this.addFloat64(g),this.slot(d))},a.Builder.prototype.addFieldOffset=function(d,g,h){(this.force_defaults||g!=h)&&(this.addOffset(g),this.slot(d))},a.Builder.prototype.addFieldStruct=function(d,g,h){g!=h&&(this.nested(g),this.slot(d))},a.Builder.prototype.nested=function(d){if(d!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},a.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},a.Builder.prototype.slot=function(d){this.vtable[d]=this.offset()},a.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},a.Builder.growByteBuffer=function(d){var g=d.capacity();if(3221225472&g)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var h=g<<1,et=a.ByteBuffer.allocate(h);return et.setPosition(h-g),et.bytes().set(d.bytes(),h-g),et},a.Builder.prototype.addOffset=function(d){this.prep(a.SIZEOF_INT,0),this.writeInt32(this.offset()-d+a.SIZEOF_INT)},a.Builder.prototype.startObject=function(d){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=d;for(var g=0;g<d;g++)this.vtable[g]=0;this.isNested=!0,this.object_start=this.offset()},a.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var d=this.offset(),g=this.vtable_in_use-1;g>=0&&this.vtable[g]==0;g--);for(var h=g+1;g>=0;g--)this.addInt16(this.vtable[g]!=0?d-this.vtable[g]:0);this.addInt16(d-this.object_start);var et=(h+2)*a.SIZEOF_SHORT;this.addInt16(et);var ot=0,it=this.space;e:for(g=0;g<this.vtables.length;g++){var $=this.bb.capacity()-this.vtables[g];if(et==this.bb.readInt16($)){for(var c=a.SIZEOF_SHORT;c<et;c+=a.SIZEOF_SHORT)if(this.bb.readInt16(it+c)!=this.bb.readInt16($+c))continue e;ot=this.vtables[g];break}}return ot?(this.space=this.bb.capacity()-d,this.bb.writeInt32(this.space,ot-d)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-d,this.offset()-d)),this.isNested=!1,d},a.Builder.prototype.finish=function(d,g,h){var et=h?a.SIZE_PREFIX_LENGTH:0;if(g){var ot=g;if(this.prep(this.minalign,a.SIZEOF_INT+a.FILE_IDENTIFIER_LENGTH+et),ot.length!=a.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+a.FILE_IDENTIFIER_LENGTH);for(var it=a.FILE_IDENTIFIER_LENGTH-1;it>=0;it--)this.writeInt8(ot.charCodeAt(it))}this.prep(this.minalign,a.SIZEOF_INT+et),this.addOffset(d),et&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},a.Builder.prototype.finishSizePrefixed=function(d,g){this.finish(d,g,!0)},a.Builder.prototype.requiredField=function(d,g){var h=this.bb.capacity()-d,et=h-this.bb.readInt32(h);if(this.bb.readInt16(et+g)==0)throw new Error("FlatBuffers: field "+g+" must be set")},a.Builder.prototype.startVector=function(d,g,h){this.notNested(),this.vector_num_elems=g,this.prep(a.SIZEOF_INT,d*g),this.prep(h,d*g)},a.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},a.Builder.prototype.createString=function(d){if(d instanceof Uint8Array)var g=d;else{g=[];for(var h=0;h<d.length;){var et,ot=d.charCodeAt(h++);(et=ot<55296||ot>=56320?ot:(ot<<10)+d.charCodeAt(h++)+-56613888)<128?g.push(et):(et<2048?g.push(et>>6&31|192):(et<65536?g.push(et>>12&15|224):g.push(et>>18&7|240,et>>12&63|128),g.push(et>>6&63|128)),g.push(63&et|128))}}this.addInt8(0),this.startVector(1,g.length,1),this.bb.setPosition(this.space-=g.length),h=0;for(var it=this.space,$=this.bb.bytes();h<g.length;h++)$[it++]=g[h];return this.endVector()},a.Builder.prototype.createLong=function(d,g){return a.Long.create(d,g)},a.ByteBuffer=function(d){this.bytes_=d,this.position_=0},a.ByteBuffer.allocate=function(d){return new a.ByteBuffer(new Uint8Array(d))},a.ByteBuffer.prototype.clear=function(){this.position_=0},a.ByteBuffer.prototype.bytes=function(){return this.bytes_},a.ByteBuffer.prototype.position=function(){return this.position_},a.ByteBuffer.prototype.setPosition=function(d){this.position_=d},a.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},a.ByteBuffer.prototype.readInt8=function(d){return this.readUint8(d)<<24>>24},a.ByteBuffer.prototype.readUint8=function(d){return this.bytes_[d]},a.ByteBuffer.prototype.readInt16=function(d){return this.readUint16(d)<<16>>16},a.ByteBuffer.prototype.readUint16=function(d){return this.bytes_[d]|this.bytes_[d+1]<<8},a.ByteBuffer.prototype.readInt32=function(d){return this.bytes_[d]|this.bytes_[d+1]<<8|this.bytes_[d+2]<<16|this.bytes_[d+3]<<24},a.ByteBuffer.prototype.readUint32=function(d){return this.readInt32(d)>>>0},a.ByteBuffer.prototype.readInt64=function(d){return new a.Long(this.readInt32(d),this.readInt32(d+4))},a.ByteBuffer.prototype.readUint64=function(d){return new a.Long(this.readUint32(d),this.readUint32(d+4))},a.ByteBuffer.prototype.readFloat32=function(d){return a.int32[0]=this.readInt32(d),a.float32[0]},a.ByteBuffer.prototype.readFloat64=function(d){return a.int32[a.isLittleEndian?0:1]=this.readInt32(d),a.int32[a.isLittleEndian?1:0]=this.readInt32(d+4),a.float64[0]},a.ByteBuffer.prototype.writeInt8=function(d,g){this.bytes_[d]=g},a.ByteBuffer.prototype.writeUint8=function(d,g){this.bytes_[d]=g},a.ByteBuffer.prototype.writeInt16=function(d,g){this.bytes_[d]=g,this.bytes_[d+1]=g>>8},a.ByteBuffer.prototype.writeUint16=function(d,g){this.bytes_[d]=g,this.bytes_[d+1]=g>>8},a.ByteBuffer.prototype.writeInt32=function(d,g){this.bytes_[d]=g,this.bytes_[d+1]=g>>8,this.bytes_[d+2]=g>>16,this.bytes_[d+3]=g>>24},a.ByteBuffer.prototype.writeUint32=function(d,g){this.bytes_[d]=g,this.bytes_[d+1]=g>>8,this.bytes_[d+2]=g>>16,this.bytes_[d+3]=g>>24},a.ByteBuffer.prototype.writeInt64=function(d,g){this.writeInt32(d,g.low),this.writeInt32(d+4,g.high)},a.ByteBuffer.prototype.writeUint64=function(d,g){this.writeUint32(d,g.low),this.writeUint32(d+4,g.high)},a.ByteBuffer.prototype.writeFloat32=function(d,g){a.float32[0]=g,this.writeInt32(d,a.int32[0])},a.ByteBuffer.prototype.writeFloat64=function(d,g){a.float64[0]=g,this.writeInt32(d,a.int32[a.isLittleEndian?0:1]),this.writeInt32(d+4,a.int32[a.isLittleEndian?1:0])},a.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+a.SIZEOF_INT+a.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var d="",g=0;g<a.FILE_IDENTIFIER_LENGTH;g++)d+=String.fromCharCode(this.readInt8(this.position_+a.SIZEOF_INT+g));return d},a.ByteBuffer.prototype.__offset=function(d,g){var h=d-this.readInt32(d);return g<this.readInt16(h)?this.readInt16(h+g):0},a.ByteBuffer.prototype.__union=function(d,g){return d.bb_pos=g+this.readInt32(g),d.bb=this,d},a.ByteBuffer.prototype.__string=function(d,g){d+=this.readInt32(d);var h=this.readInt32(d),et="",ot=0;if(d+=a.SIZEOF_INT,g===a.Encoding.UTF8_BYTES)return this.bytes_.subarray(d,d+h);for(;ot<h;){var it,$=this.readUint8(d+ot++);if($<192)it=$;else{var c=this.readUint8(d+ot++);if($<224)it=(31&$)<<6|63&c;else{var s=this.readUint8(d+ot++);it=$<240?(15&$)<<12|(63&c)<<6|63&s:(7&$)<<18|(63&c)<<12|(63&s)<<6|63&this.readUint8(d+ot++)}}it<65536?et+=String.fromCharCode(it):(it-=65536,et+=String.fromCharCode(55296+(it>>10),56320+(1023&it)))}return et},a.ByteBuffer.prototype.__indirect=function(d){return d+this.readInt32(d)},a.ByteBuffer.prototype.__vector=function(d){return d+this.readInt32(d)+a.SIZEOF_INT},a.ByteBuffer.prototype.__vector_len=function(d){return this.readInt32(d+this.readInt32(d))},a.ByteBuffer.prototype.__has_identifier=function(d){if(d.length!=a.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+a.FILE_IDENTIFIER_LENGTH);for(var g=0;g<a.FILE_IDENTIFIER_LENGTH;g++)if(d.charCodeAt(g)!=this.readInt8(this.position_+a.SIZEOF_INT+g))return!1;return!0},a.ByteBuffer.prototype.createLong=function(d,g){return a.Long.create(d,g)}}},__webpack_module_cache__={};function __webpack_require__(i){var e=__webpack_module_cache__[i];if(e!==void 0)return e.exports;var o=__webpack_module_cache__[i]={exports:{}};return __webpack_modules__[i].call(o.exports,o,o.exports,__webpack_require__),o.exports}__webpack_require__.n=i=>{var e=i&&i.__esModule?()=>i.default:()=>i;return __webpack_require__.d(e,{a:e}),e},__webpack_require__.d=(i,e)=>{for(var o in e)__webpack_require__.o(e,o)&&!__webpack_require__.o(i,o)&&Object.defineProperty(i,o,{enumerable:!0,get:e[o]})},__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),__webpack_require__.o=(i,e)=>Object.prototype.hasOwnProperty.call(i,e),__webpack_require__.r=i=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(i,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(i,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(6018);return __webpack_exports__})())})(ortWeb_min$1);var ortWeb_minExports=ortWeb_min$1.exports;const ortWeb_min=getDefaultExportFromCjs(ortWeb_minExports),ONNX_WEB=_mergeNamespaces({__proto__:null,default:ortWeb_min},[ortWeb_minExports]);let ONNX;const executionProviders=["wasm"];var c_;typeof process<"u"&&((c_=process==null?void 0:process.release)==null?void 0:c_.name)==="node"?(ONNX=sharp??ONNX_NODE,executionProviders.unshift("cpu")):(ONNX=ortWeb_min??ONNX_WEB,typeof navigator<"u"&&/iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent)&&(ONNX.env.wasm.simd=!1));const{env:onnx_env}=ONNX,VERSION="2.17.2",WEB_CACHE_AVAILABLE=typeof self<"u"&&"caches"in self,FS_AVAILABLE=!isEmpty(sharp),PATH_AVAILABLE=!isEmpty(sharp),RUNNING_LOCALLY=FS_AVAILABLE&&PATH_AVAILABLE,__dirname$1=RUNNING_LOCALLY?sharp.dirname(sharp.dirname(sharp.fileURLToPath(import.meta.url))):"./",DEFAULT_CACHE_DIR=RUNNING_LOCALLY?sharp.join(__dirname$1,"/.cache/"):null,DEFAULT_LOCAL_MODEL_PATH="/models/",localModelPath=RUNNING_LOCALLY?sharp.join(__dirname$1,DEFAULT_LOCAL_MODEL_PATH):DEFAULT_LOCAL_MODEL_PATH;onnx_env!=null&&onnx_env.wasm&&(onnx_env.wasm.wasmPaths=RUNNING_LOCALLY?sharp.join(__dirname$1,"/dist/"):`https://cdn.jsdelivr.net/npm/@xenova/transformers@${VERSION}/dist/`);const env$1={backends:{onnx:onnx_env,tfjs:{}},__dirname:__dirname$1,version:VERSION,allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!0,localModelPath,useFS:FS_AVAILABLE,useBrowserCache:WEB_CACHE_AVAILABLE,useFSCache:FS_AVAILABLE,cacheDir:DEFAULT_CACHE_DIR,useCustomCache:!1,customCache:null};function isEmpty(i){return Object.keys(i).length===0}var define_process_env_default={};class FileResponse{constructor(e){ir(this,"_CONTENT_TYPE_MAP",{txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"});if(this.filePath=e,this.headers=new Headers,this.exists=sharp.existsSync(e),this.exists){this.status=200,this.statusText="OK";let o=sharp.statSync(e);this.headers.set("content-length",o.size.toString()),this.updateContentType();let a=this;this.body=new ReadableStream({start(d){a.arrayBuffer().then(g=>{d.enqueue(new Uint8Array(g)),d.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",this._CONTENT_TYPE_MAP[e]??"application/octet-stream")}clone(){let e=new FileResponse(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await sharp.promises.readFile(this.filePath)).buffer}async blob(){const e=await sharp.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await sharp.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function isValidUrl(i,e=null,o=null){let a;try{a=new URL(i)}catch{return!1}return!(e&&!e.includes(a.protocol)||o&&!o.includes(a.hostname))}async function getFile(i){var e;if(env$1.useFS&&!isValidUrl(i,["http:","https:","blob:"]))return new FileResponse(i);if(typeof process<"u"&&((e=process==null?void 0:process.release)==null?void 0:e.name)==="node"){const o=!!(define_process_env_default!=null&&define_process_env_default.TESTING_REMOTELY),a=env$1.version,d=new Headers;if(d.set("User-Agent",`transformers.js/${a}; is_ci/${o};`),isValidUrl(i,["http:","https:"],["huggingface.co","hf.co"])){const h=(define_process_env_default==null?void 0:define_process_env_default.HF_TOKEN)??(define_process_env_default==null?void 0:define_process_env_default.HF_ACCESS_TOKEN);h&&d.set("Authorization",`Bearer ${h}`)}return fetch(i,{headers:d})}else return fetch(i)}const ERROR_MAPPING={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function handleError(i,e,o){if(!o)return null;const a=ERROR_MAPPING[i]??`Error (${i}) occurred while trying to load file`;throw Error(`${a}: "${e}".`)}class FileCache{constructor(e){this.path=e}async match(e){let o=sharp.join(this.path,e),a=new FileResponse(o);if(a.exists)return a}async put(e,o){const a=Buffer.from(await o.arrayBuffer());let d=sharp.join(this.path,e);try{await sharp.promises.mkdir(sharp.dirname(d),{recursive:!0}),await sharp.promises.writeFile(d,a)}catch(g){console.warn("An error occurred while writing the file to cache:",g)}}}async function tryCache(i,...e){for(let o of e)try{let a=await i.match(o);if(a)return a}catch{continue}}async function getModelFile(i,e,o=!0,a={}){if(!env$1.allowLocalModels){if(a.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!env$1.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}dispatchCallback(a.progress_callback,{status:"initiate",name:i,file:e});let d;if(!d&&env$1.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{d=await caches.open("transformers-cache")}catch(ct){console.warn("An error occurred while opening the browser cache:",ct)}}if(!d&&env$1.useFSCache&&(d=new FileCache(a.cache_dir??env$1.cacheDir)),!d&&env$1.useCustomCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");const g=a.revision??"main";let h=pathJoin(i,e),et=pathJoin(env$1.localModelPath,h),ot=pathJoin(env$1.remoteHost,env$1.remotePathTemplate.replaceAll("{model}",i).replaceAll("{revision}",encodeURIComponent(g)),e),it=g==="main"?h:pathJoin(i,g,e),$,c=d instanceof FileCache?it:ot,s=!1,_;d&&(_=await tryCache(d,et,c));const b=_!==void 0;if(_===void 0){if(env$1.allowLocalModels)if(isValidUrl(h,["http:","https:"])){if(a.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${h}.`);if(!env$1.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${h}.`)}else try{_=await getFile(et),$=et}catch(pt){console.warn(`Unable to load from local path "${et}": "${pt}"`)}if(_===void 0||_.status===404){if(a.local_files_only||!env$1.allowRemoteModels){if(o)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${et}".`);return null}if(_=await getFile(ot),_.status!==200)return handleError(_.status,ot,o);$=c}s=d&&typeof Response<"u"&&_ instanceof Response&&_.status===200}dispatchCallback(a.progress_callback,{status:"download",name:i,file:e});const st={status:"progress",name:i,file:e};let dt;return a.progress_callback?b&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(dt=new Uint8Array(await _.arrayBuffer()),dispatchCallback(a.progress_callback,{...st,progress:100,loaded:dt.length,total:dt.length})):dt=await readResponse(_,ct=>{dispatchCallback(a.progress_callback,{...st,...ct})}):dt=new Uint8Array(await _.arrayBuffer()),s&&$&&await d.match($)===void 0&&await d.put($,new Response(dt,{headers:_.headers})).catch(ct=>{console.warn(`Unable to add response to browser cache: ${ct}.`)}),dispatchCallback(a.progress_callback,{status:"done",name:i,file:e}),dt}async function getModelJSON(i,e,o=!0,a={}){let d=await getModelFile(i,e,o,a);if(d===null)return{};let h=new TextDecoder("utf-8").decode(d);return JSON.parse(h)}async function readResponse(i,e){const o=i.headers.get("Content-Length");o===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let a=parseInt(o??"0"),d=new Uint8Array(a),g=0;const h=i.body.getReader();async function et(){const{done:ot,value:it}=await h.read();if(ot)return;let $=g+it.length;if($>a){a=$;let s=new Uint8Array(a);s.set(d),d=s}d.set(it,g),g=$;const c=g/a*100;return e({progress:c,loaded:g,total:a}),et()}return await et(),d}function pathJoin(...i){return i=i.map((e,o)=>(o&&(e=e.replace(new RegExp("^/"),"")),o!==i.length-1&&(e=e.replace(new RegExp("/$"),"")),e)),i.join("/")}function permute_data(i,e,o){const a=new Array(o.length),d=new Array(o.length);for(let et=o.length-1,ot=1;et>=0;--et)d[et]=ot,a[et]=e[o[et]],ot*=a[et];const g=o.map((et,ot)=>d[o.indexOf(ot)]),h=new i.constructor(i.length);for(let et=0;et<i.length;++et){let ot=0;for(let it=e.length-1,$=et;it>=0;--it)ot+=$%e[it]*g[it],$=Math.floor($/e[it]);h[ot]=i[et]}return[h,a]}function softmax(i){const e=max(i)[0],o=i.map(g=>Math.exp(g-e)),a=o.reduce((g,h)=>g+h,0);return o.map(g=>g/a)}function log_softmax(i){return softmax(i).map(a=>Math.log(a))}function getTopItems(i,e=0){return i=Array.from(i).map((o,a)=>[a,o]).sort((o,a)=>a[1]-o[1]),e!==null&&e>0&&(i=i.slice(0,e)),i}function min(i){if(i.length===0)throw Error("Array must not be empty");let e=i[0],o=0;for(let a=1;a<i.length;++a)i[a]<e&&(e=i[a],o=a);return[e,o]}function max(i){if(i.length===0)throw Error("Array must not be empty");let e=i[0],o=0;for(let a=1;a<i.length;++a)i[a]>e&&(e=i[a],o=a);return[Number(e),o]}function medianFilter(i,e){if(e%2===0||e<=0)throw new Error("Window size must be a positive odd number");const o=new i.constructor(i.length),a=new i.constructor(e),d=Math.floor(e/2);for(let g=0;g<i.length;++g){let h=0;for(let et=-d;et<=d;++et){let ot=g+et;ot<0?ot=Math.abs(ot):ot>=i.length&&(ot=2*(i.length-1)-ot),a[h++]=i[ot]}a.sort(),o[g]=a[d]}return o}function round(i,e){const o=Math.pow(10,e);return Math.round(i*o)/o}const DataTypeMap=Object.freeze({float32:Float32Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array}),ONNXTensor$1=ONNX.Tensor;class Tensor{constructor(...e){ir(this,"dims");ir(this,"type");ir(this,"data");ir(this,"size");return e[0]instanceof ONNXTensor$1?Object.assign(this,e[0]):Object.assign(this,new ONNXTensor$1(e[0],e[1],e[2])),new Proxy(this,{get:(o,a)=>{if(typeof a=="string"){let d=Number(a);if(Number.isInteger(d))return o._getitem(d)}return o[a]},set:(o,a,d)=>o[a]=d})}*[Symbol.iterator](){const[e,...o]=this.dims;if(o.length>0){const a=o.reduce((d,g)=>d*g);for(let d=0;d<e;++d)yield this._subarray(d,a,o)}else yield*this.data}_getitem(e){const[o,...a]=this.dims;if(e=safeIndex(e,o),a.length>0){const d=a.reduce((g,h)=>g*h);return this._subarray(e,d,a)}else return new Tensor(this.type,[this.data[e]],a)}indexOf(e){for(let o=0;o<this.data.length;++o)if(this.data[o]==e)return o;return-1}_subarray(e,o,a){const d=e*o,g=(e+1)*o,h="subarray"in this.data?this.data.subarray(d,g):this.data.slice(d,g);return new Tensor(this.type,h,a)}item(){if(this.data.length!==1)throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);return this.data[0]}tolist(){return reshape(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){for(let e=0;e<this.data.length;++e)this.data[e]=1/(1+Math.exp(-this.data[e]));return this}mul(e){return this.clone().mul_(e)}mul_(e){for(let o=0;o<this.data.length;++o)this.data[o]*=e;return this}add(e){return this.clone().add_(e)}add_(e){for(let o=0;o<this.data.length;++o)this.data[o]+=e;return this}clone(){return new Tensor(this.type,this.data.slice(),this.dims.slice())}slice(...e){let o=[],a=[];for(let ot=0;ot<this.dims.length;++ot){let it=e[ot];if(it==null)a.push([0,this.dims[ot]]),o.push(this.dims[ot]);else if(typeof it=="number")it=safeIndex(it,this.dims[ot],ot),a.push([it,it+1]);else if(Array.isArray(it)&&it.length===2){if(it[0]>it[1])throw new Error(`Invalid slice: ${it}`);let $=[Math.max(it[0],0),Math.min(it[1],this.dims[ot])];a.push($),o.push($[1]-$[0])}else throw new Error(`Invalid slice: ${it}`)}let d=a.map(([ot,it])=>it-ot),g=d.reduce((ot,it)=>ot*it),h=new this.data.constructor(g);const et=this.stride();for(let ot=0;ot<g;++ot){let it=0;for(let $=d.length-1,c=ot;$>=0;--$){const s=d[$];it+=(c%s+a[$][0])*et[$],c=Math.floor(c/s)}h[ot]=this.data[it]}return new Tensor(this.type,h,o)}permute(...e){return permute(this,e)}transpose(...e){return this.permute(...e)}sum(e=null,o=!1){return this.norm(1,e,o)}norm(e="fro",o=null,a=!1){if(e==="fro")e=2;else if(typeof e=="string")throw Error(`Unsupported norm: ${e}`);if(o===null){let h=this.data.reduce((et,ot)=>et+ot**e,0)**(1/e);return new Tensor(this.type,[h],[])}o=safeIndex(o,this.dims.length);const d=this.dims.slice();d[o]=1;const g=new this.data.constructor(this.data.length/this.dims[o]);for(let h=0;h<this.data.length;++h){let et=0;for(let ot=this.dims.length-1,it=h,$=1;ot>=0;--ot){const c=this.dims[ot];if(ot!==o){const s=it%c;et+=s*$,$*=d[ot]}it=Math.floor(it/c)}g[et]+=this.data[h]**e}if(e!==1)for(let h=0;h<g.length;++h)g[h]=g[h]**(1/e);return a||d.splice(o,1),new Tensor(this.type,g,d)}normalize_(e=2,o=1){o=safeIndex(o,this.dims.length);const a=this.norm(e,o,!0);for(let d=0;d<this.data.length;++d){let g=0;for(let h=this.dims.length-1,et=d,ot=1;h>=0;--h){const it=this.dims[h];if(h!==o){const $=et%it;g+=$*ot,ot*=this.dims[h]}et=Math.floor(et/it)}this.data[d]/=a.data[g]}return this}normalize(e=2,o=1){return this.clone().normalize_(e,o)}stride(){return dimsToStride(this.dims)}squeeze(e=null){return new Tensor(this.type,this.data,calc_squeeze_dims(this.dims,e))}squeeze_(e=null){return this.dims=calc_squeeze_dims(this.dims,e),this}unsqueeze(e=null){return new Tensor(this.type,this.data,calc_unsqueeze_dims(this.dims,e))}unsqueeze_(e=null){return this.dims=calc_unsqueeze_dims(this.dims,e),this}flatten_(e=0,o=-1){o=(o+this.dims.length)%this.dims.length;let a=this.dims.slice(0,e),d=this.dims.slice(e,o+1),g=this.dims.slice(o+1);return this.dims=[...a,d.reduce((h,et)=>h*et,1),...g],this}flatten(e=0,o=-1){return this.clone().flatten_(e,o)}view(...e){let o=-1;for(let a=0;a<e.length;++a)if(e[a]===-1){if(o!==-1)throw new Error("Only one dimension can be inferred");o=a}if(o!==-1){const a=e.reduce((d,g,h)=>h!==o?d*g:d,1);e[o]=this.data.length/a}return new Tensor(this.type,this.data,e)}neg_(){for(let e=0;e<this.data.length;++e)this.data[e]=-this.data[e];return this}neg(){return this.clone().neg_()}clamp_(e,o){for(let a=0;a<this.data.length;++a)this.data[a]=Math.min(Math.max(this.data[a],e),o);return this}clamp(e,o){return this.clone().clamp_(e,o)}round_(){for(let e=0;e<this.data.length;++e)this.data[e]=Math.round(this.data[e]);return this}round(){return this.clone().round_()}to(e){if(this.type===e)return this;if(!DataTypeMap.hasOwnProperty(e))throw new Error(`Unsupported type: ${e}`);return new Tensor(e,DataTypeMap[e].from(this.data),this.dims)}}function reshape(i,e){const o=i.length,a=e.reduce((g,h)=>g*h);if(o!==a)throw Error(`cannot reshape array of size ${o} into shape (${e})`);let d=i;for(let g=e.length-1;g>=0;g--)d=d.reduce((h,et)=>{let ot=h[h.length-1];return ot.length<e[g]?ot.push(et):h.push([et]),h},[[]]);return d[0]}function permute(i,e){const[o,a]=permute_data(i.data,i.dims,e);return new Tensor(i.type,o,a)}function calc_squeeze_dims(i,e){return i=i.slice(),e===null?i=i.filter(o=>o!==1):typeof e=="number"?i[e]===1&&i.splice(e,1):Array.isArray(e)&&(i=i.filter((o,a)=>o!==1||!e.includes(a))),i}function calc_unsqueeze_dims(i,e){return e=safeIndex(e,i.length+1),i=i.slice(),i.splice(e,0,1),i}function safeIndex(i,e,o=null){if(i<-e||i>=e)throw new Error(`IndexError: index ${i} is out of bounds for dimension${o===null?"":" "+o} with size ${e}`);return i<0&&(i=(i%e+e)%e),i}function cat(i,e=0){e=safeIndex(e,i[0].dims.length);const o=i[0].dims.slice();o[e]=i.reduce((h,et)=>h+et.dims[e],0);const a=o.reduce((h,et)=>h*et,1),d=new i[0].data.constructor(a),g=i[0].type;if(e===0){let h=0;for(let et of i)d.set(et.data,h),h+=et.data.length}else{let h=0;for(let et=0;et<i.length;++et){let ot=i[et];for(let it=0;it<ot.data.length;++it){let $=0;for(let c=ot.dims.length-1,s=it,_=1;c>=0;--c){const b=ot.dims[c];let st=s%b;c===e&&(st+=h),$+=st*_,_*=o[c],s=Math.floor(s/b)}d[$]=ot.data[it]}h+=ot.dims[e]}}return new Tensor(g,d,o)}function stack(i,e=0){return cat(i.map(o=>o.unsqueeze(e)),e)}function std_mean(i,e=null,o=1,a=!1){if(e===null){const it=i.data.reduce((_,b)=>_+b,0)/i.data.length,$=Math.sqrt(i.data.reduce((_,b)=>_+(b-it)**2,0)/(i.data.length-o)),c=new Tensor(i.type,[it],[]);return[new Tensor(i.type,[$],[]),c]}e=safeIndex(e,i.dims.length);const d=mean(i,e,a),g=i.dims.slice();g[e]=1;const h=new i.data.constructor(i.data.length/i.dims[e]);for(let ot=0;ot<i.data.length;++ot){let it=0;for(let $=i.dims.length-1,c=ot,s=1;$>=0;--$){const _=i.dims[$];if($!==e){const b=c%_;it+=b*s,s*=g[$]}c=Math.floor(c/_)}h[it]+=(i.data[ot]-d.data[it])**2}for(let ot=0;ot<h.length;++ot)h[ot]=Math.sqrt(h[ot]/(i.dims[e]-o));return a||g.splice(e,1),[new Tensor(i.type,h,g),d]}function mean(i,e=null,o=!1){if(e===null){let g=i.data.reduce((h,et)=>h+et,0);return new Tensor(i.type,[g/i.data.length],[])}e=safeIndex(e,i.dims.length);const a=i.dims.slice();a[e]=1;const d=new i.data.constructor(i.data.length/i.dims[e]);for(let g=0;g<i.data.length;++g){let h=0;for(let et=i.dims.length-1,ot=g,it=1;et>=0;--et){const $=i.dims[et];if(et!==e){const c=ot%$;h+=c*it,it*=a[et]}ot=Math.floor(ot/$)}d[h]+=i.data[g]}if(i.dims[e]!==1)for(let g=0;g<d.length;++g)d[g]=d[g]/i.dims[e];return o||a.splice(e,1),new Tensor(i.type,d,a)}function dynamicTimeWarping(i){const[e,o]=i.dims,a=[e+1,o+1],d=new Tensor("float32",new Float32Array(a[0]*a[1]).fill(1/0),a),g=new Tensor("float32",new Float32Array(a[0]*a[1]).fill(-1),a);d[0].data[0]=0;for(let $=1;$<o+1;++$)for(let c=1;c<e+1;++c){const s=d[c-1][$-1].item(),_=d[c-1][$].item(),b=d[c][$-1].item();let st,dt;s<_&&s<b?(st=s,dt=0):_<s&&_<b?(st=_,dt=1):(st=b,dt=2),d[c].data[$]=i[c-1][$-1].item()+st,g[c].data[$]=dt}let h=e,et=o;g.data.fill(2,0,a[1]);for(let $=0;$<a[0];++$)g[$].data[0]=1;let ot=[],it=[];for(;h>0||et>0;)switch(ot.push(h-1),it.push(et-1),g[h][et].item()){case 0:--h,--et;break;case 1:--h;break;case 2:--et;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${h}, ${et}]. Please file a bug report.`)}return ot.reverse(),it.reverse(),[ot,it]}function dimsToStride(i){const e=new Array(i.length);for(let o=i.length-1,a=1;o>=0;--o)e[o]=a,a*=i[o];return e}function ones(i){const e=i.reduce((o,a)=>o*a,1);return new Tensor("int64",new BigInt64Array(e).fill(1n),i)}function ones_like(i){return ones(i.dims)}class PriorityQueue{constructor(e=(o,a)=>o>a){this._heap=[],this._comparator=e}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const o of e)this._heap.push(o),this._siftUp();return this.size}pop(){const e=this.peek(),o=this.size-1;return o>0&&this._swap(0,o),this._heap.pop(),this._siftDown(),e}replace(e){const o=this.peek();return this._heap[0]=e,this._siftDown(),o}_parent(e){return(e+1>>>1)-1}_left(e){return(e<<1)+1}_right(e){return e+1<<1}_greater(e,o){return this._comparator(this._heap[e],this._heap[o])}_swap(e,o){const a=this._heap[e];this._heap[e]=this._heap[o],this._heap[o]=a}_siftUp(){let e=this.size-1;for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const o=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,o),e=o}}}class CharTrie{constructor(){this.root=CharTrieNode.default()}extend(e){for(let o of e)this.push(o)}push(e){let o=this.root;for(let a of e){let d=o.children.get(a);d===void 0&&(d=CharTrieNode.default(),o.children.set(a,d)),o=d}o.isLeaf=!0}*commonPrefixSearch(e){let o=this.root,a="";for(let d=0;d<e.length&&o!==void 0;++d){const g=e[d];a+=g,o=o.children.get(g),o!==void 0&&o.isLeaf&&(yield a)}}}class CharTrieNode{constructor(e,o){this.isLeaf=e,this.children=o}static default(){return new CharTrieNode(!1,new Map)}}class TokenLattice{constructor(e,o,a){this.sentence=e,this.len=e.length,this.bosTokenId=o,this.eosTokenId=a,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const d=new TokenLatticeNode(this.bosTokenId,0,0,0,0),g=new TokenLatticeNode(this.eosTokenId,1,this.len,0,0);this.nodes.push(d.clone()),this.nodes.push(g.clone()),this.beginNodes[this.len].push(g),this.endNodes[0].push(d)}insert(e,o,a,d){const g=this.nodes.length,h=new TokenLatticeNode(d,g,e,o,a);this.beginNodes[e].push(h),this.endNodes[e+o].push(h),this.nodes.push(h)}viterbi(){const e=this.len;let o=0;for(;o<=e;){if(this.beginNodes[o].length==0)return[];for(let et of this.beginNodes[o]){et.prev=null;let ot=0,it=null;for(let $ of this.endNodes[o]){const c=$.backtraceScore+et.score;(it===null||c>ot)&&(it=$.clone(),ot=c)}if(it!==null)et.prev=it,et.backtraceScore=ot;else return[]}++o}const a=[],g=this.beginNodes[e][0].prev;if(g===null)return[];let h=g.clone();for(;h.prev!==null;)a.push(h.clone()),h=h.clone().prev.clone();return a.reverse(),a}piece(e){return this.sentence.slice(e.pos,e.pos+e.length)}tokens(){return this.viterbi().map(o=>this.piece(o))}tokenIds(){return this.viterbi().map(o=>o.tokenId)}}class TokenLatticeNode{constructor(e,o,a,d,g){this.tokenId=e,this.nodeId=o,this.pos=a,this.length=d,this.score=g,this.prev=null,this.backtraceScore=0}clone(){const e=new TokenLatticeNode(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}var TOKEN_TYPES=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator"}),KEYWORDS=Object.freeze({set:TOKEN_TYPES.Set,for:TOKEN_TYPES.For,in:TOKEN_TYPES.In,is:TOKEN_TYPES.Is,if:TOKEN_TYPES.If,else:TOKEN_TYPES.Else,endif:TOKEN_TYPES.EndIf,elif:TOKEN_TYPES.ElseIf,endfor:TOKEN_TYPES.EndFor,and:TOKEN_TYPES.And,or:TOKEN_TYPES.Or,not:TOKEN_TYPES.Not,"not in":TOKEN_TYPES.NotIn,true:TOKEN_TYPES.BooleanLiteral,false:TOKEN_TYPES.BooleanLiteral}),Token=class{constructor(i,e){this.value=i,this.type=e}};function isWord(i){return/\w/.test(i)}function isInteger(i){return/[0-9]/.test(i)}var ORDERED_MAPPING_TABLE=[["{%",TOKEN_TYPES.OpenStatement],["%}",TOKEN_TYPES.CloseStatement],["{{",TOKEN_TYPES.OpenExpression],["}}",TOKEN_TYPES.CloseExpression],["(",TOKEN_TYPES.OpenParen],[")",TOKEN_TYPES.CloseParen],["{",TOKEN_TYPES.OpenCurlyBracket],["}",TOKEN_TYPES.CloseCurlyBracket],["[",TOKEN_TYPES.OpenSquareBracket],["]",TOKEN_TYPES.CloseSquareBracket],[",",TOKEN_TYPES.Comma],[".",TOKEN_TYPES.Dot],[":",TOKEN_TYPES.Colon],["|",TOKEN_TYPES.Pipe],["<=",TOKEN_TYPES.ComparisonBinaryOperator],[">=",TOKEN_TYPES.ComparisonBinaryOperator],["==",TOKEN_TYPES.ComparisonBinaryOperator],["!=",TOKEN_TYPES.ComparisonBinaryOperator],["<",TOKEN_TYPES.ComparisonBinaryOperator],[">",TOKEN_TYPES.ComparisonBinaryOperator],["+",TOKEN_TYPES.AdditiveBinaryOperator],["-",TOKEN_TYPES.AdditiveBinaryOperator],["*",TOKEN_TYPES.MultiplicativeBinaryOperator],["/",TOKEN_TYPES.MultiplicativeBinaryOperator],["%",TOKEN_TYPES.MultiplicativeBinaryOperator],["=",TOKEN_TYPES.Equals]],ESCAPE_CHARACTERS=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function preprocess(i,e={}){return i.endsWith(`
`)&&(i=i.slice(0,-1)),i=i.replace(/{#.*?#}/gs,"{##}"),e.lstrip_blocks&&(i=i.replace(/^[ \t]*({[#%])/gm,"$1")),e.trim_blocks&&(i=i.replace(/([#%]})\n/g,"$1")),i.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function tokenize(i,e={}){var h,et,ot;const o=[],a=preprocess(i,e);let d=0;const g=it=>{let $="";for(;it(a[d]);){if(a[d]==="\\"){if(++d,d>=a.length)throw new SyntaxError("Unexpected end of input");const c=a[d++],s=ESCAPE_CHARACTERS.get(c);if(s===void 0)throw new SyntaxError(`Unexpected escaped character: ${c}`);$+=s;continue}if($+=a[d++],d>=a.length)throw new SyntaxError("Unexpected end of input")}return $};e:for(;d<a.length;){const it=(h=o.at(-1))==null?void 0:h.type;if(it===void 0||it===TOKEN_TYPES.CloseStatement||it===TOKEN_TYPES.CloseExpression){let c="";for(;d<a.length&&!(a[d]==="{"&&(a[d+1]==="%"||a[d+1]==="{"));)c+=a[d++];if(c.length>0){o.push(new Token(c,TOKEN_TYPES.Text));continue}}g(c=>/\s/.test(c));const $=a[d];if($==="-"||$==="+"){const c=(et=o.at(-1))==null?void 0:et.type;if(c===TOKEN_TYPES.Text||c===void 0)throw new SyntaxError(`Unexpected character: ${$}`);switch(c){case TOKEN_TYPES.Identifier:case TOKEN_TYPES.NumericLiteral:case TOKEN_TYPES.BooleanLiteral:case TOKEN_TYPES.StringLiteral:case TOKEN_TYPES.CloseParen:case TOKEN_TYPES.CloseSquareBracket:break;default:{++d;const s=g(isInteger);o.push(new Token(`${$}${s}`,s.length>0?TOKEN_TYPES.NumericLiteral:TOKEN_TYPES.UnaryOperator));continue}}}for(const[c,s]of ORDERED_MAPPING_TABLE)if(a.slice(d,d+c.length)===c){o.push(new Token(c,s)),d+=c.length;continue e}if($==="'"||$==='"'){++d;const c=g(s=>s!==$);o.push(new Token(c,TOKEN_TYPES.StringLiteral)),++d;continue}if(isInteger($)){const c=g(isInteger);o.push(new Token(c,TOKEN_TYPES.NumericLiteral));continue}if(isWord($)){const c=g(isWord),s=Object.hasOwn(KEYWORDS,c)?KEYWORDS[c]:TOKEN_TYPES.Identifier;s===TOKEN_TYPES.In&&((ot=o.at(-1))==null?void 0:ot.type)===TOKEN_TYPES.Not?(o.pop(),o.push(new Token("not in",TOKEN_TYPES.NotIn))):o.push(new Token(c,s));continue}throw new SyntaxError(`Unexpected character: ${$}`)}return o}var Statement=class{constructor(){ir(this,"type","Statement")}},Program=class extends Statement{constructor(e){super();ir(this,"type","Program");this.body=e}},If=class extends Statement{constructor(e,o,a){super();ir(this,"type","If");this.test=e,this.body=o,this.alternate=a}},For=class extends Statement{constructor(e,o,a){super();ir(this,"type","For");this.loopvar=e,this.iterable=o,this.body=a}},SetStatement=class extends Statement{constructor(e,o){super();ir(this,"type","Set");this.assignee=e,this.value=o}},Expression=class extends Statement{constructor(){super(...arguments);ir(this,"type","Expression")}},MemberExpression=class extends Expression{constructor(e,o,a){super();ir(this,"type","MemberExpression");this.object=e,this.property=o,this.computed=a}},CallExpression=class extends Expression{constructor(e,o){super();ir(this,"type","CallExpression");this.callee=e,this.args=o}},Identifier=class extends Expression{constructor(e){super();ir(this,"type","Identifier");this.value=e}},Literal=class extends Expression{constructor(e){super();ir(this,"type","Literal");this.value=e}},NumericLiteral=class extends Literal{constructor(){super(...arguments);ir(this,"type","NumericLiteral")}},StringLiteral=class extends Literal{constructor(){super(...arguments);ir(this,"type","StringLiteral")}},BooleanLiteral=class extends Literal{constructor(){super(...arguments);ir(this,"type","BooleanLiteral")}},ArrayLiteral=class extends Literal{constructor(){super(...arguments);ir(this,"type","ArrayLiteral")}},TupleLiteral=class extends Literal{constructor(){super(...arguments);ir(this,"type","TupleLiteral")}},ObjectLiteral=class extends Literal{constructor(){super(...arguments);ir(this,"type","ObjectLiteral")}},BinaryExpression=class extends Expression{constructor(e,o,a){super();ir(this,"type","BinaryExpression");this.operator=e,this.left=o,this.right=a}},FilterExpression=class extends Expression{constructor(e,o){super();ir(this,"type","FilterExpression");this.operand=e,this.filter=o}},TestExpression=class extends Expression{constructor(e,o,a){super();ir(this,"type","TestExpression");this.operand=e,this.negate=o,this.test=a}},UnaryExpression=class extends Expression{constructor(e,o){super();ir(this,"type","UnaryExpression");this.operator=e,this.argument=o}},SliceExpression=class extends Expression{constructor(e=void 0,o=void 0,a=void 0){super();ir(this,"type","SliceExpression");this.start=e,this.stop=o,this.step=a}},KeywordArgumentExpression=class extends Expression{constructor(e,o){super();ir(this,"type","KeywordArgumentExpression");this.key=e,this.value=o}};function parse(i){const e=new Program([]);let o=0;function a(un,Wt){const Jt=i[o++];if(!Jt||Jt.type!==un)throw new Error(`Parser Error: ${Wt}. ${Jt.type} !== ${un}.`);return Jt}function d(){switch(i[o].type){case TOKEN_TYPES.Text:return et();case TOKEN_TYPES.OpenStatement:return ot();case TOKEN_TYPES.OpenExpression:return it();default:throw new SyntaxError(`Unexpected token type: ${i[o].type}`)}}function g(...un){return o+un.length<=i.length&&un.some((Wt,Jt)=>Wt!==i[o+Jt].type)}function h(...un){return o+un.length<=i.length&&un.every((Wt,Jt)=>Wt===i[o+Jt].type)}function et(){return new StringLiteral(a(TOKEN_TYPES.Text,"Expected text token").value)}function ot(){a(TOKEN_TYPES.OpenStatement,"Expected opening statement token");let un;switch(i[o].type){case TOKEN_TYPES.Set:++o,un=$(),a(TOKEN_TYPES.CloseStatement,"Expected closing statement token");break;case TOKEN_TYPES.If:++o,un=c(),a(TOKEN_TYPES.OpenStatement,"Expected {% token"),a(TOKEN_TYPES.EndIf,"Expected endif token"),a(TOKEN_TYPES.CloseStatement,"Expected %} token");break;case TOKEN_TYPES.For:++o,un=_(),a(TOKEN_TYPES.OpenStatement,"Expected {% token"),a(TOKEN_TYPES.EndFor,"Expected endfor token"),a(TOKEN_TYPES.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${i[o].type}`)}return un}function it(){a(TOKEN_TYPES.OpenExpression,"Expected opening expression token");const un=b();return a(TOKEN_TYPES.CloseExpression,"Expected closing expression token"),un}function $(){const un=b();if(h(TOKEN_TYPES.Equals)){++o;const Wt=$();return new SetStatement(un,Wt)}return un}function c(){var _n,vn,Sn,hn,rr,vr,Ir,$r;const un=b();a(TOKEN_TYPES.CloseStatement,"Expected closing statement token");const Wt=[],Jt=[];for(;!(((_n=i[o])==null?void 0:_n.type)===TOKEN_TYPES.OpenStatement&&(((vn=i[o+1])==null?void 0:vn.type)===TOKEN_TYPES.ElseIf||((Sn=i[o+1])==null?void 0:Sn.type)===TOKEN_TYPES.Else||((hn=i[o+1])==null?void 0:hn.type)===TOKEN_TYPES.EndIf));)Wt.push(d());if(((rr=i[o])==null?void 0:rr.type)===TOKEN_TYPES.OpenStatement&&((vr=i[o+1])==null?void 0:vr.type)!==TOKEN_TYPES.EndIf)if(++o,h(TOKEN_TYPES.ElseIf))a(TOKEN_TYPES.ElseIf,"Expected elseif token"),Jt.push(c());else for(a(TOKEN_TYPES.Else,"Expected else token"),a(TOKEN_TYPES.CloseStatement,"Expected closing statement token");!(((Ir=i[o])==null?void 0:Ir.type)===TOKEN_TYPES.OpenStatement&&(($r=i[o+1])==null?void 0:$r.type)===TOKEN_TYPES.EndIf);)Jt.push(d());return new If(un,Wt,Jt)}function s(un=!1){const Wt=un?fn:b,Jt=[Wt()],_n=h(TOKEN_TYPES.Comma);for(;_n&&(++o,Jt.push(Wt()),!!h(TOKEN_TYPES.Comma)););return _n?new TupleLiteral(Jt):Jt[0]}function _(){const un=s(!0);if(!(un instanceof Identifier||un instanceof TupleLiteral))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${un.type} instead`);a(TOKEN_TYPES.In,"Expected `in` keyword following loop variable");const Wt=b();a(TOKEN_TYPES.CloseStatement,"Expected closing statement token");const Jt=[];for(;g(TOKEN_TYPES.OpenStatement,TOKEN_TYPES.EndFor);)Jt.push(d());return new For(un,Wt,Jt)}function b(){return st()}function st(){const un=dt();if(h(TOKEN_TYPES.If)){++o;const Wt=dt();a(TOKEN_TYPES.Else,"Expected else token");const Jt=dt();return new If(Wt,[un],[Jt])}return un}function dt(){let un=ct();for(;h(TOKEN_TYPES.Or);){const Wt=i[o];++o;const Jt=ct();un=new BinaryExpression(Wt,un,Jt)}return un}function ct(){let un=pt();for(;h(TOKEN_TYPES.And);){const Wt=i[o];++o;const Jt=pt();un=new BinaryExpression(Wt,un,Jt)}return un}function pt(){let un;for(;h(TOKEN_TYPES.Not);){const Wt=i[o];++o;const Jt=pt();un=new UnaryExpression(Wt,Jt)}return un??ft()}function ft(){let un=mt();for(;h(TOKEN_TYPES.ComparisonBinaryOperator)||h(TOKEN_TYPES.In)||h(TOKEN_TYPES.NotIn);){const Wt=i[o];++o;const Jt=mt();un=new BinaryExpression(Wt,un,Jt)}return un}function mt(){let un=dn();for(;h(TOKEN_TYPES.AdditiveBinaryOperator);){const Wt=i[o];++o;const Jt=dn();un=new BinaryExpression(Wt,un,Jt)}return un}function bt(){const un=jt();return h(TOKEN_TYPES.OpenParen)?$t(un):un}function $t(un){let Wt=new CallExpression(un,Ct());return h(TOKEN_TYPES.OpenParen)&&(Wt=$t(Wt)),Wt}function Ct(){a(TOKEN_TYPES.OpenParen,"Expected opening parenthesis for arguments list");const un=It();return a(TOKEN_TYPES.CloseParen,"Expected closing parenthesis for arguments list"),un}function It(){const un=[];for(;!h(TOKEN_TYPES.CloseParen);){let Wt=b();if(h(TOKEN_TYPES.Equals)){if(++o,!(Wt instanceof Identifier))throw new SyntaxError("Expected identifier for keyword argument");const Jt=b();Wt=new KeywordArgumentExpression(Wt,Jt)}un.push(Wt),h(TOKEN_TYPES.Comma)&&++o}return un}function Tt(){const un=[];let Wt=!1;for(;!h(TOKEN_TYPES.CloseSquareBracket);)h(TOKEN_TYPES.Colon)?(un.push(void 0),++o,Wt=!0):(un.push(b()),h(TOKEN_TYPES.Colon)&&(++o,Wt=!0));if(un.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(Wt){if(un.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new SliceExpression(...un)}return un[0]}function jt(){let un=fn();for(;h(TOKEN_TYPES.Dot)||h(TOKEN_TYPES.OpenSquareBracket);){const Wt=i[o];++o;let Jt;const _n=Wt.type!==TOKEN_TYPES.Dot;if(_n)Jt=Tt(),a(TOKEN_TYPES.CloseSquareBracket,"Expected closing square bracket");else if(Jt=fn(),Jt.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");un=new MemberExpression(un,Jt,_n)}return un}function dn(){let un=yn();for(;h(TOKEN_TYPES.MultiplicativeBinaryOperator);){const Wt=i[o];++o;const Jt=yn();un=new BinaryExpression(Wt,un,Jt)}return un}function yn(){let un=mn();for(;h(TOKEN_TYPES.Is);){++o;const Wt=h(TOKEN_TYPES.Not);Wt&&++o;let Jt=fn();if(Jt instanceof BooleanLiteral&&(Jt=new Identifier(Jt.value.toString())),!(Jt instanceof Identifier))throw new SyntaxError("Expected identifier for the test");un=new TestExpression(un,Wt,Jt)}return un}function mn(){let un=bt();for(;h(TOKEN_TYPES.Pipe);){++o;let Wt=fn();if(!(Wt instanceof Identifier))throw new SyntaxError("Expected identifier for the filter");h(TOKEN_TYPES.OpenParen)&&(Wt=$t(Wt)),un=new FilterExpression(un,Wt)}return un}function fn(){const un=i[o];switch(un.type){case TOKEN_TYPES.NumericLiteral:return++o,new NumericLiteral(Number(un.value));case TOKEN_TYPES.StringLiteral:return++o,new StringLiteral(un.value);case TOKEN_TYPES.BooleanLiteral:return++o,new BooleanLiteral(un.value==="true");case TOKEN_TYPES.Identifier:return++o,new Identifier(un.value);case TOKEN_TYPES.OpenParen:{++o;const Wt=s();if(i[o].type!==TOKEN_TYPES.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${i[o].type} instead`);return++o,Wt}case TOKEN_TYPES.OpenSquareBracket:{++o;const Wt=[];for(;!h(TOKEN_TYPES.CloseSquareBracket);)Wt.push(b()),h(TOKEN_TYPES.Comma)&&++o;return++o,new ArrayLiteral(Wt)}case TOKEN_TYPES.OpenCurlyBracket:{++o;const Wt=new Map;for(;!h(TOKEN_TYPES.CloseCurlyBracket);){const Jt=b();a(TOKEN_TYPES.Colon,"Expected colon between key and value in object literal");const _n=b();Wt.set(Jt,_n),h(TOKEN_TYPES.Comma)&&++o}return++o,new ObjectLiteral(Wt)}default:throw new SyntaxError(`Unexpected token: ${un.type}`)}}for(;o<i.length;)e.body.push(d());return e}function range(i,e,o=1){e===void 0&&(e=i,i=0);const a=[];for(let d=i;d<e;d+=o)a.push(d);return a}function slice(i,e,o,a=1){const d=Math.sign(a);d>=0?(e=(e??(e=0))<0?Math.max(i.length+e,0):Math.min(e,i.length),o=(o??(o=i.length))<0?Math.max(i.length+o,0):Math.min(o,i.length)):(e=(e??(e=i.length-1))<0?Math.max(i.length+e,-1):Math.min(e,i.length-1),o=(o??(o=-1))<-1?Math.max(i.length+o,-1):Math.min(o,i.length-1));const g=[];for(let h=e;d*h<d*o;h+=a)g.push(i[h]);return g}function titleCase(i){return i.replace(/\b\w/g,e=>e.toUpperCase())}var RuntimeValue=class{constructor(i=void 0){ir(this,"type","RuntimeValue");ir(this,"value");ir(this,"builtins",new Map);this.value=i}__bool__(){return new BooleanValue(!!this.value)}},NumericValue=class extends RuntimeValue{constructor(){super(...arguments);ir(this,"type","NumericValue")}},StringValue=class extends RuntimeValue{constructor(){super(...arguments);ir(this,"type","StringValue");ir(this,"builtins",new Map([["upper",new FunctionValue(()=>new StringValue(this.value.toUpperCase()))],["lower",new FunctionValue(()=>new StringValue(this.value.toLowerCase()))],["strip",new FunctionValue(()=>new StringValue(this.value.trim()))],["title",new FunctionValue(()=>new StringValue(titleCase(this.value)))],["length",new NumericValue(this.value.length)]]))}},BooleanValue=class extends RuntimeValue{constructor(){super(...arguments);ir(this,"type","BooleanValue")}},ObjectValue=class extends RuntimeValue{constructor(){super(...arguments);ir(this,"type","ObjectValue");ir(this,"builtins",new Map([["get",new FunctionValue(([e,o])=>{if(!(e instanceof StringValue))throw new Error(`Object key must be a string: got ${e.type}`);return this.value.get(e.value)??o??new NullValue})],["items",new FunctionValue(()=>new ArrayValue(Array.from(this.value.entries()).map(([e,o])=>new ArrayValue([new StringValue(e),o]))))]]))}__bool__(){return new BooleanValue(this.value.size>0)}},ArrayValue=class extends RuntimeValue{constructor(){super(...arguments);ir(this,"type","ArrayValue");ir(this,"builtins",new Map([["length",new NumericValue(this.value.length)]]))}__bool__(){return new BooleanValue(this.value.length>0)}},TupleValue=class extends ArrayValue{constructor(){super(...arguments);ir(this,"type","TupleValue")}},FunctionValue=class extends RuntimeValue{constructor(){super(...arguments);ir(this,"type","FunctionValue")}},NullValue=class extends RuntimeValue{constructor(){super(...arguments);ir(this,"type","NullValue")}},UndefinedValue=class extends RuntimeValue{constructor(){super(...arguments);ir(this,"type","UndefinedValue")}},Environment=class{constructor(i){ir(this,"variables",new Map([["namespace",new FunctionValue(i=>{if(i.length===0)return new ObjectValue(new Map);if(i.length!==1||!(i[0]instanceof ObjectValue))throw new Error("`namespace` expects either zero arguments or a single object argument");return i[0]})]]));ir(this,"tests",new Map([["boolean",i=>i.type==="BooleanValue"],["callable",i=>i instanceof FunctionValue],["odd",i=>{if(i.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${i.type}`);return i.value%2!==0}],["even",i=>{if(i.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${i.type}`);return i.value%2===0}],["false",i=>i.type==="BooleanValue"&&!i.value],["true",i=>i.type==="BooleanValue"&&i.value],["number",i=>i.type==="NumericValue"],["integer",i=>i.type==="NumericValue"&&Number.isInteger(i.value)],["iterable",i=>i instanceof ArrayValue||i instanceof StringValue],["lower",i=>{const e=i.value;return i.type==="StringValue"&&e===e.toLowerCase()}],["upper",i=>{const e=i.value;return i.type==="StringValue"&&e===e.toUpperCase()}],["none",i=>i.type==="NullValue"],["defined",i=>i.type!=="UndefinedValue"],["undefined",i=>i.type==="UndefinedValue"],["equalto",(i,e)=>i.value===e.value]]));this.parent=i}set(i,e){return this.declareVariable(i,convertToRuntimeValues(e))}declareVariable(i,e){if(this.variables.has(i))throw new SyntaxError(`Variable already declared: ${i}`);return this.variables.set(i,e),e}setVariable(i,e){return this.variables.set(i,e),e}resolve(i){if(this.variables.has(i))return this;if(this.parent)return this.parent.resolve(i);throw new Error(`Unknown variable: ${i}`)}lookupVariable(i){try{return this.resolve(i).variables.get(i)??new UndefinedValue}catch{return new UndefinedValue}}},Interpreter=class{constructor(i){ir(this,"global");this.global=i??new Environment}run(i){return this.evaluate(i,this.global)}evaluateBinaryExpression(i,e){const o=this.evaluate(i.left,e);switch(i.operator.value){case"and":return o.__bool__().value?this.evaluate(i.right,e):o;case"or":return o.__bool__().value?o:this.evaluate(i.right,e)}const a=this.evaluate(i.right,e);switch(i.operator.value){case"==":return new BooleanValue(o.value==a.value);case"!=":return new BooleanValue(o.value!=a.value)}if(o instanceof UndefinedValue||a instanceof UndefinedValue)throw new Error("Cannot perform operation on undefined values");if(o instanceof NullValue||a instanceof NullValue)throw new Error("Cannot perform operation on null values");if(o instanceof NumericValue&&a instanceof NumericValue)switch(i.operator.value){case"+":return new NumericValue(o.value+a.value);case"-":return new NumericValue(o.value-a.value);case"*":return new NumericValue(o.value*a.value);case"/":return new NumericValue(o.value/a.value);case"%":return new NumericValue(o.value%a.value);case"<":return new BooleanValue(o.value<a.value);case">":return new BooleanValue(o.value>a.value);case">=":return new BooleanValue(o.value>=a.value);case"<=":return new BooleanValue(o.value<=a.value)}else if(o instanceof ArrayValue&&a instanceof ArrayValue)switch(i.operator.value){case"+":return new ArrayValue(o.value.concat(a.value))}else if(a instanceof ArrayValue){const d=a.value.find(g=>g.value===o.value)!==void 0;switch(i.operator.value){case"in":return new BooleanValue(d);case"not in":return new BooleanValue(!d)}}if(o instanceof StringValue||a instanceof StringValue)switch(i.operator.value){case"+":return new StringValue(o.value.toString()+a.value.toString())}if(o instanceof StringValue&&a instanceof StringValue)switch(i.operator.value){case"in":return new BooleanValue(a.value.includes(o.value));case"not in":return new BooleanValue(!a.value.includes(o.value))}if(o instanceof StringValue&&a instanceof ObjectValue)switch(i.operator.value){case"in":return new BooleanValue(a.value.has(o.value));case"not in":return new BooleanValue(!a.value.has(o.value))}throw new SyntaxError(`Unknown operator "${i.operator.value}" between ${o.type} and ${a.type}`)}evaluateFilterExpression(i,e){const o=this.evaluate(i.operand,e);if(i.filter.type==="Identifier"){const a=i.filter;if(o instanceof ArrayValue)switch(a.value){case"list":return o;case"first":return o.value[0];case"last":return o.value[o.value.length-1];case"length":return new NumericValue(o.value.length);case"reverse":return new ArrayValue(o.value.reverse());case"sort":return new ArrayValue(o.value.sort((d,g)=>{if(d.type!==g.type)throw new Error(`Cannot compare different types: ${d.type} and ${g.type}`);switch(d.type){case"NumericValue":return d.value-g.value;case"StringValue":return d.value.localeCompare(g.value);default:throw new Error(`Cannot compare type: ${d.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${a.value}`)}else if(o instanceof StringValue)switch(a.value){case"length":return new NumericValue(o.value.length);case"upper":return new StringValue(o.value.toUpperCase());case"lower":return new StringValue(o.value.toLowerCase());case"title":return new StringValue(titleCase(o.value));case"capitalize":return new StringValue(o.value.charAt(0).toUpperCase()+o.value.slice(1));case"trim":return new StringValue(o.value.trim());default:throw new Error(`Unknown StringValue filter: ${a.value}`)}else if(o instanceof NumericValue)switch(a.value){case"abs":return new NumericValue(Math.abs(o.value));default:throw new Error(`Unknown NumericValue filter: ${a.value}`)}else if(o instanceof ObjectValue)switch(a.value){case"items":return new ArrayValue(Array.from(o.value.entries()).map(([d,g])=>new ArrayValue([new StringValue(d),g])));case"length":return new NumericValue(o.value.size);default:throw new Error(`Unknown ObjectValue filter: ${a.value}`)}throw new Error(`Cannot apply filter "${a.value}" to type: ${o.type}`)}else if(i.filter.type==="CallExpression"){const a=i.filter;if(a.callee.type!=="Identifier")throw new Error(`Unknown filter: ${a.callee.type}`);const d=a.callee.value;if(o instanceof ArrayValue){switch(d){case"selectattr":{if(o.value.some($=>!($ instanceof ObjectValue)))throw new Error("`selectattr` can only be applied to array of objects");if(a.args.some($=>$.type!=="StringLiteral"))throw new Error("arguments of `selectattr` must be strings");const[g,h,et]=a.args.map($=>this.evaluate($,e));let ot;if(h){const $=e.tests.get(h.value);if(!$)throw new Error(`Unknown test: ${h.value}`);ot=$}else ot=(...$)=>$[0].__bool__().value;const it=o.value.filter($=>{const c=$.value.get(g.value);return c?ot(c,et):!1});return new ArrayValue(it)}}throw new Error(`Unknown ArrayValue filter: ${d}`)}else throw new Error(`Cannot apply filter "${d}" to type: ${o.type}`)}throw new Error(`Unknown filter: ${i.filter.type}`)}evaluateTestExpression(i,e){const o=this.evaluate(i.operand,e),a=e.tests.get(i.test.value);if(!a)throw new Error(`Unknown test: ${i.test.value}`);const d=a(o);return new BooleanValue(i.negate?!d:d)}evaluateUnaryExpression(i,e){const o=this.evaluate(i.argument,e);switch(i.operator.value){case"not":return new BooleanValue(!o.value);default:throw new SyntaxError(`Unknown operator: ${i.operator.value}`)}}evalProgram(i,e){return this.evaluateBlock(i.body,e)}evaluateBlock(i,e){let o="";for(const a of i){const d=this.evaluate(a,e);d.type!=="NullValue"&&d.type!=="UndefinedValue"&&(o+=d.value)}return new StringValue(o)}evaluateIdentifier(i,e){return e.lookupVariable(i.value)}evaluateCallExpression(i,e){const o=[],a=new Map;for(const g of i.args)if(g.type==="KeywordArgumentExpression"){const h=g;a.set(h.key.value,this.evaluate(h.value,e))}else o.push(this.evaluate(g,e));a.size>0&&o.push(new ObjectValue(a));const d=this.evaluate(i.callee,e);if(d.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${d.type}`);return d.value(o,e)}evaluateSliceExpression(i,e,o){if(!(i instanceof ArrayValue||i instanceof StringValue))throw new Error("Slice object must be an array or string");const a=this.evaluate(e.start,o),d=this.evaluate(e.stop,o),g=this.evaluate(e.step,o);if(!(a instanceof NumericValue||a instanceof UndefinedValue))throw new Error("Slice start must be numeric or undefined");if(!(d instanceof NumericValue||d instanceof UndefinedValue))throw new Error("Slice stop must be numeric or undefined");if(!(g instanceof NumericValue||g instanceof UndefinedValue))throw new Error("Slice step must be numeric or undefined");return i instanceof ArrayValue?new ArrayValue(slice(i.value,a.value,d.value,g.value)):new StringValue(slice(Array.from(i.value),a.value,d.value,g.value).join(""))}evaluateMemberExpression(i,e){const o=this.evaluate(i.object,e);let a;if(i.computed){if(i.property.type==="SliceExpression")return this.evaluateSliceExpression(o,i.property,e);a=this.evaluate(i.property,e)}else a=new StringValue(i.property.value);let d;if(o instanceof ObjectValue){if(!(a instanceof StringValue))throw new Error(`Cannot access property with non-string: got ${a.type}`);d=o.value.get(a.value)??o.builtins.get(a.value)}else if(o instanceof ArrayValue||o instanceof StringValue)if(a instanceof NumericValue)d=o.value.at(a.value),o instanceof StringValue&&(d=new StringValue(o.value.at(a.value)));else if(a instanceof StringValue)d=o.builtins.get(a.value);else throw new Error(`Cannot access property with non-string/non-number: got ${a.type}`);else{if(!(a instanceof StringValue))throw new Error(`Cannot access property with non-string: got ${a.type}`);d=o.builtins.get(a.value)}return d instanceof RuntimeValue?d:new UndefinedValue}evaluateSet(i,e){const o=this.evaluate(i.value,e);if(i.assignee.type==="Identifier"){const a=i.assignee.value;e.setVariable(a,o)}else if(i.assignee.type==="MemberExpression"){const a=i.assignee,d=this.evaluate(a.object,e);if(!(d instanceof ObjectValue))throw new Error("Cannot assign to member of non-object");if(a.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");d.value.set(a.property.value,o)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(i.assignee)}`);return new NullValue}evaluateIf(i,e){const o=this.evaluate(i.test,e);return this.evaluateBlock(o.__bool__().value?i.body:i.alternate,e)}evaluateFor(i,e){const o=new Environment(e),a=this.evaluate(i.iterable,o);if(!(a instanceof ArrayValue))throw new Error(`Expected iterable type in for loop: got ${a.type}`);let d="";for(let g=0;g<a.value.length;++g){const h=new Map([["index",new NumericValue(g+1)],["index0",new NumericValue(g)],["revindex",new NumericValue(a.value.length-g)],["revindex0",new NumericValue(a.value.length-g-1)],["first",new BooleanValue(g===0)],["last",new BooleanValue(g===a.value.length-1)],["length",new NumericValue(a.value.length)],["previtem",g>0?a.value[g-1]:new UndefinedValue],["nextitem",g<a.value.length-1?a.value[g+1]:new UndefinedValue]]);o.setVariable("loop",new ObjectValue(h));const et=a.value[g];if(i.loopvar.type==="Identifier")o.setVariable(i.loopvar.value,et);else if(i.loopvar.type==="TupleLiteral"){const it=i.loopvar;if(et.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${et.type}`);const $=et;if(it.value.length!==$.value.length)throw new Error(`Too ${it.value.length>$.value.length?"few":"many"} items to unpack`);for(let c=0;c<it.value.length;++c){if(it.value[c].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${it.value[c].type}`);o.setVariable(it.value[c].value,$.value[c])}}const ot=this.evaluateBlock(i.body,o);d+=ot.value}return new StringValue(d)}evaluate(i,e){if(i===void 0)return new UndefinedValue;switch(i.type){case"Program":return this.evalProgram(i,e);case"Set":return this.evaluateSet(i,e);case"If":return this.evaluateIf(i,e);case"For":return this.evaluateFor(i,e);case"NumericLiteral":return new NumericValue(Number(i.value));case"StringLiteral":return new StringValue(i.value);case"BooleanLiteral":return new BooleanValue(i.value);case"ArrayLiteral":return new ArrayValue(i.value.map(o=>this.evaluate(o,e)));case"TupleLiteral":return new TupleValue(i.value.map(o=>this.evaluate(o,e)));case"ObjectLiteral":{const o=new Map;for(const[a,d]of i.value){const g=this.evaluate(a,e);if(!(g instanceof StringValue))throw new Error(`Object keys must be strings: got ${g.type}`);o.set(g.value,this.evaluate(d,e))}return new ObjectValue(o)}case"Identifier":return this.evaluateIdentifier(i,e);case"CallExpression":return this.evaluateCallExpression(i,e);case"MemberExpression":return this.evaluateMemberExpression(i,e);case"UnaryExpression":return this.evaluateUnaryExpression(i,e);case"BinaryExpression":return this.evaluateBinaryExpression(i,e);case"FilterExpression":return this.evaluateFilterExpression(i,e);case"TestExpression":return this.evaluateTestExpression(i,e);default:throw new SyntaxError(`Unknown node type: ${i.type}`)}}};function convertToRuntimeValues(i){switch(typeof i){case"number":return new NumericValue(i);case"string":return new StringValue(i);case"boolean":return new BooleanValue(i);case"object":return i===null?new NullValue:Array.isArray(i)?new ArrayValue(i.map(convertToRuntimeValues)):new ObjectValue(new Map(Object.entries(i).map(([e,o])=>[e,convertToRuntimeValues(o)])));case"function":return new FunctionValue((e,o)=>{const a=i(...e.map(d=>d.value))??null;return convertToRuntimeValues(a)});default:throw new Error(`Cannot convert to runtime value: ${i}`)}}var Template=class{constructor(i){ir(this,"parsed");const e=tokenize(i,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=parse(e)}render(i){const e=new Environment;e.set("false",!1),e.set("true",!0),e.set("raise_exception",d=>{throw new Error(d)}),e.set("range",range);for(const[d,g]of Object.entries(i))e.set(d,g);return new Interpreter(e).run(this.parsed).value}};async function loadTokenizer(i,e){const o=await Promise.all([getModelJSON(i,"tokenizer.json",!0,e),getModelJSON(i,"tokenizer_config.json",!0,e)]);return e.legacy!==null&&(o[1].legacy=e.legacy),o}function regexSplit(i,e){const o=[];let a=0;for(const d of i.matchAll(e)){const g=d[0];a<d.index&&o.push(i.slice(a,d.index)),g.length>0&&o.push(g),a=d.index+g.length}return a<i.length&&o.push(i.slice(a)),o}function createPattern(i,e=!0){if(i.Regex!==void 0){let o=i.Regex.replace(/\\([#&~])/g,"$1");for(const[a,d]of PROBLEMATIC_REGEX_MAP)o=o.replaceAll(a,d);return new RegExp(o,"gu")}else if(i.String!==void 0){const o=escapeRegExp(i.String);return new RegExp(e?o:`(${o})`,"gu")}else return console.warn("Unknown pattern type:",i),null}function objectToMap(i){return new Map(Object.entries(i))}function prepareTensorForDecode(i){const e=i.dims;switch(e.length){case 1:return i.tolist();case 2:if(e[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return i.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${e.length}.`)}}function clean_up_tokenization(i){return i.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function remove_accents(i){return i.replace(/[\u0300-\u036f]/g,"")}function lowercase_and_remove_accent(i){return remove_accents(i.toLowerCase())}function fuse(i,e,o){const a=[];let d=0;for(;d<i.length;){if(a.push(i[d]),(o.get(i[d])??e)!==e){++d;continue}for(;d<i.length&&(o.get(i[d])??e)===e;)++d}return a}function whitespace_split(i){return i.match(/\S+/g)||[]}const PUNCTUATION_REGEX="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",PROBLEMATIC_REGEX_MAP=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"]]);class AddedToken{constructor(e){this.content=e.content,this.id=e.id,this.single_word=e.single_word??!1,this.lstrip=e.lstrip??!1,this.rstrip=e.rstrip??!1,this.special=e.special??!1,this.normalized=e.normalized??null}}class TokenizerModel extends Callable{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(e,...o){switch(e.type){case"WordPiece":return new WordPieceTokenizer(e);case"Unigram":return new Unigram(e,...o);case"BPE":return new BPE(e);default:if(e.vocab)return new LegacyTokenizerModel(e,...o);throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){let o=this.encode(e);return this.fuse_unk&&(o=fuse(o,this.unk_token_id,this.tokens_to_ids)),o}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){return e.map(o=>this.tokens_to_ids.get(o)??this.unk_token_id)}convert_ids_to_tokens(e){return e.map(o=>this.vocab[o]??this.unk_token)}}class WordPieceTokenizer extends TokenizerModel{constructor(e){super(e),this.tokens_to_ids=objectToMap(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.max_input_chars_per_word=e.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[o,a]of this.tokens_to_ids)this.vocab[a]=o}encode(e){const o=[];for(const a of e){const d=[...a];if(d.length>this.max_input_chars_per_word){o.push(this.unk_token);continue}let g=!1,h=0;const et=[];for(;h<d.length;){let ot=d.length,it=null;for(;h<ot;){let $=d.slice(h,ot).join("");if(h>0&&($=this.config.continuing_subword_prefix+$),this.tokens_to_ids.has($)){it=$;break}--ot}if(it===null){g=!0;break}et.push(it),h=ot}g?o.push(this.unk_token):o.push(...et)}return o}}class Unigram extends TokenizerModel{constructor(e,o){super(e);const a=e.vocab.length;this.vocab=new Array(a),this.scores=new Array(a);for(let d=0;d<a;++d){const g=e.vocab[d];this.vocab[d]=g[0],this.scores[d]=g[1]}this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map((d,g)=>[d,g])),this.bosToken=" ",this.bosTokenId=this.tokens_to_ids.get(this.bosToken),this.eosToken=o.eos_token,this.eosTokenId=this.tokens_to_ids.get(this.eosToken),this.unkToken=this.vocab[this.unk_token_id],this.minScore=min(this.scores)[0],this.unkScore=this.minScore-10,this.scores[this.unk_token_id]=this.unkScore,this.trie=new CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const o=e.sentence,a=o.length;let d=0;for(;d<a;){let h=!1;for(let et of this.trie.commonPrefixSearch(o.slice(d))){const ot=this.tokens_to_ids.get(et),it=this.scores[ot],$=et.length;e.insert(d,$,it,ot),!h&&$===1&&(h=!0)}h||e.insert(d,1,this.unkScore,this.unk_token_id),d+=1}}tokenize(e){const o=new TokenLattice(e,this.bosTokenId,this.eosTokenId);return this.populateNodes(o),o.tokens()}encode(e){const o=[];for(const a of e){const d=this.tokenize(a);o.push(...d)}return o}}const BYTES_TO_UNICODE=(()=>{const i=[...Array.from({length:94},(d,g)=>g+33),...Array.from({length:12},(d,g)=>g+161),...Array.from({length:82},(d,g)=>g+174)],e=i.slice();let o=0;for(let d=0;d<256;++d)i.includes(d)||(i.push(d),e.push(256+o),o+=1);const a=e.map(d=>String.fromCharCode(d));return Object.fromEntries(i.map((d,g)=>[d,a[g]]))})(),UNICODE_TO_BYTES=reverseDictionary(BYTES_TO_UNICODE);class BPE extends TokenizerModel{constructor(e){super(e),this.BPE_SPLIT_TOKEN=" ",this.tokens_to_ids=objectToMap(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[o,a]of this.tokens_to_ids)this.vocab[a]=o;this.bpe_ranks=new Map(e.merges.map((o,a)=>[o,a])),this.merges=e.merges.map(o=>o.split(this.BPE_SPLIT_TOKEN)),this.end_of_word_suffix=e.end_of_word_suffix,this.continuing_subword_suffix=e.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(e){if(e.length===0)return[];const o=this.cache.get(e);if(o!==void 0)return o;const a=Array.from(e);this.end_of_word_suffix&&(a[a.length-1]+=this.end_of_word_suffix);let d=[];if(a.length>1){const g=new PriorityQueue((ot,it)=>ot.score<it.score);let h={token:a[0],bias:0,prev:null,next:null},et=h;for(let ot=1;ot<a.length;++ot){const it={bias:ot/a.length,token:a[ot],prev:et,next:null};et.next=it,this._add_node(g,et),et=it}for(;!g.isEmpty();){const ot=g.pop();if(ot.deleted||!ot.next||ot.next.deleted)continue;if(ot.deleted=!0,ot.next.deleted=!0,ot.prev){const $={...ot.prev};ot.prev.deleted=!0,ot.prev=$,$.prev?$.prev.next=$:h=$}const it={token:ot.token+ot.next.token,bias:ot.bias,prev:ot.prev,next:ot.next.next};it.prev?(it.prev.next=it,this._add_node(g,it.prev)):h=it,it.next&&(it.next.prev=it,this._add_node(g,it))}for(let ot=h;ot!==null;ot=ot.next)d.push(ot.token)}else d=a;if(this.continuing_subword_suffix)for(let g=0;g<d.length-1;++g)d[g]+=this.continuing_subword_suffix;return this.cache.set(e,d),d}_add_node(e,o){const a=this.bpe_ranks.get(o.token+this.BPE_SPLIT_TOKEN+o.next.token);a!==void 0&&(o.score=a+o.bias,e.push(o))}encode(e){const o=[];for(const a of e){if(this.ignore_merges&&this.tokens_to_ids.has(a)){o.push(a);continue}const d=this.bpe(a);for(const g of d)this.tokens_to_ids.has(g)?o.push(g):this.byte_fallback?o.push(...Array.from(this.text_encoder.encode(g)).map(h=>`<0x${h.toString(16).toUpperCase().padStart(2,"0")}>`)):o.push(this.unk_token)}return o}}class LegacyTokenizerModel extends TokenizerModel{constructor(e,o){super(e),this.tokens_to_ids=objectToMap(o.target_lang?e.vocab[o.target_lang]:e.vocab),this.bos_token=o.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=o.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=o.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=o.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[a,d]of this.tokens_to_ids)this.vocab[d]=a}encode(e){return e}}class Normalizer extends Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(e===null)return null;switch(e.type){case"BertNormalizer":return new BertNormalizer(e);case"Precompiled":return new Precompiled(e);case"Sequence":return new NormalizerSequence(e);case"Replace":return new Replace(e);case"NFC":return new NFC(e);case"NFKC":return new NFKC(e);case"NFKD":return new NFKD(e);case"Strip":return new StripNormalizer(e);case"StripAccents":return new StripAccents(e);case"Lowercase":return new Lowercase(e);case"Prepend":return new Prepend(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class Replace extends Normalizer{normalize(e){const o=createPattern(this.config.pattern);return o===null?e:e.replaceAll(o,this.config.content)}}class NFC extends Normalizer{normalize(e){return e=e.normalize("NFC"),e}}class NFKC extends Normalizer{normalize(e){return e=e.normalize("NFKC"),e}}class NFKD extends Normalizer{normalize(e){return e=e.normalize("NFKD"),e}}class StripNormalizer extends Normalizer{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class StripAccents extends Normalizer{normalize(e){return e=remove_accents(e),e}}class Lowercase extends Normalizer{normalize(e){return e=e.toLowerCase(),e}}class Prepend extends Normalizer{normalize(e){return e=this.config.prepend+e,e}}class NormalizerSequence extends Normalizer{constructor(e){super(e),this.normalizers=e.normalizers.map(o=>Normalizer.fromConfig(o))}normalize(e){return this.normalizers.reduce((o,a)=>a.normalize(o),e)}}class BertNormalizer extends Normalizer{_tokenize_chinese_chars(e){const o=[];for(let a=0;a<e.length;++a){const d=e[a],g=d.charCodeAt(0);this._is_chinese_char(g)?(o.push(" "),o.push(d),o.push(" ")):o.push(d)}return o.join("")}_is_chinese_char(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}stripAccents(e){return e.normalize("NFD").replace(/[\u0300-\u036f]/g,"")}_is_control(e){switch(e){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(e)}}_clean_text(e){const o=[];for(const a of e){const d=a.charCodeAt(0);d===0||d===65533||this._is_control(a)||(/^\s$/.test(a)?o.push(" "):o.push(a))}return o.join("")}normalize(e){return this.config.clean_text&&(e=this._clean_text(e)),this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),this.config.strip_accents!==!1&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class PreTokenizer extends Callable{static fromConfig(e){if(e===null)return null;switch(e.type){case"BertPreTokenizer":return new BertPreTokenizer(e);case"Sequence":return new PreTokenizerSequence(e);case"Whitespace":return new WhitespacePreTokenizer(e);case"WhitespaceSplit":return new WhitespaceSplit(e);case"Metaspace":return new MetaspacePreTokenizer(e);case"ByteLevel":return new ByteLevelPreTokenizer(e);case"Split":return new SplitPreTokenizer(e);case"Punctuation":return new PunctuationPreTokenizer(e);case"Digits":return new DigitsPreTokenizer(e);case"Replace":return new ReplacePreTokenizer(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e,o){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e,o){return(Array.isArray(e)?e.map(a=>this.pre_tokenize_text(a,o)):this.pre_tokenize_text(e,o)).flat()}_call(e,o){return this.pre_tokenize(e,o)}}class BertPreTokenizer extends PreTokenizer{constructor(e){super(),this.pattern=new RegExp(`[^\\s${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]`,"gu")}pre_tokenize_text(e,o){return e.trim().match(this.pattern)||[]}}class ByteLevelPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=BYTES_TO_UNICODE,this.text_encoder=new TextEncoder}pre_tokenize_text(e,o){return this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e),(this.use_regex?e.match(this.pattern)||[]:[e]).map(d=>Array.from(this.text_encoder.encode(d),g=>this.byte_encoder[g]).join(""))}}class SplitPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.pattern=createPattern(this.config.pattern,this.config.invert)}pre_tokenize_text(e,o){return this.pattern===null?[]:this.config.invert?e.match(this.pattern)||[]:regexSplit(e,this.pattern)}}class PunctuationPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]+`,"gu")}pre_tokenize_text(e,o){return e.match(this.pattern)||[]}}class DigitsPreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e;const o=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(o,"gu")}pre_tokenize_text(e,o){return e.match(this.pattern)||[]}}class PostProcessor extends Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(e===null)return null;switch(e.type){case"TemplateProcessing":return new TemplateProcessing(e);case"ByteLevel":return new ByteLevelPostProcessor(e);case"RobertaProcessing":return new RobertaProcessing(e);case"BertProcessing":return new BertProcessing(e);case"Sequence":return new PostProcessorSequence(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...o){throw Error("post_process should be implemented in subclass.")}_call(e,...o){return this.post_process(e,...o)}}class BertProcessing extends PostProcessor{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,o=null,{add_special_tokens:a=!0}={}){a&&(e=mergeArrays([this.cls],e,[this.sep]));let d=new Array(e.length).fill(0);if(o!==null){const g=a&&this instanceof RobertaProcessing?[this.sep]:[],h=a?[this.sep]:[];e=mergeArrays(e,g,o,h),d=mergeArrays(d,new Array(o.length+g.length+h.length).fill(1))}return{tokens:e,token_type_ids:d}}}class RobertaProcessing extends BertProcessing{}class TemplateProcessing extends PostProcessor{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,o=null,{add_special_tokens:a=!0}={}){const d=o===null?this.single:this.pair;let g=[],h=[];for(const et of d)"SpecialToken"in et?a&&(g.push(et.SpecialToken.id),h.push(et.SpecialToken.type_id)):"Sequence"in et&&(et.Sequence.id==="A"?(g=mergeArrays(g,e),h=mergeArrays(h,new Array(e.length).fill(et.Sequence.type_id))):et.Sequence.id==="B"&&(g=mergeArrays(g,o),h=mergeArrays(h,new Array(o.length).fill(et.Sequence.type_id))));return{tokens:g,token_type_ids:h}}}class ByteLevelPostProcessor extends PostProcessor{post_process(e,o=null){return o&&(e=mergeArrays(e,o)),{tokens:e}}}class PostProcessorSequence extends PostProcessor{constructor(e){super(e),this.processors=e.processors.map(o=>PostProcessor.fromConfig(o))}post_process(e,o=null,a={}){let d;for(const g of this.processors)if(g instanceof ByteLevelPostProcessor)e=g.post_process(e).tokens,o&&(o=g.post_process(o).tokens);else{const h=g.post_process(e,o,a);e=h.tokens,d=h.token_type_ids}return{tokens:e,token_type_ids:d}}}class Decoder extends Callable{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){if(e===null)return null;switch(e.type){case"WordPiece":return new WordPieceDecoder(e);case"Metaspace":return new MetaspaceDecoder(e);case"ByteLevel":return new ByteLevelDecoder(e);case"Replace":return new ReplaceDecoder(e);case"ByteFallback":return new ByteFallback(e);case"Fuse":return new FuseDecoder(e);case"Strip":return new StripDecoder(e);case"Sequence":return new DecoderSequence(e);case"CTC":return new CTCDecoder(e);case"BPEDecoder":return new BPEDecoder(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class ReplaceDecoder extends Decoder{decode_chain(e){const o=createPattern(this.config.pattern);return o===null?e:e.map(a=>a.replaceAll(o,this.config.content))}}class ByteFallback extends Decoder{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){const o=[];let a=[];for(const d of e){let g=null;if(d.length===6&&d.startsWith("<0x")&&d.endsWith(">")){const h=parseInt(d.slice(3,5),16);isNaN(h)||(g=h)}if(g!==null)a.push(g);else{if(a.length>0){const h=this.text_decoder.decode(Uint8Array.from(a));o.push(h),a=[]}o.push(d)}}if(a.length>0){const d=this.text_decoder.decode(Uint8Array.from(a));o.push(d),a=[]}return o}}class FuseDecoder extends Decoder{decode_chain(e){return[e.join("")]}}class StripDecoder extends Decoder{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map(o=>{let a=0;for(let g=0;g<this.start&&o[g]===this.content;++g){a=g+1;continue}let d=o.length;for(let g=0;g<this.stop;++g){const h=o.length-g-1;if(o[h]===this.content){d=h;continue}else break}return o.slice(a,d)})}}class WordPieceDecoder extends Decoder{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map((o,a)=>(a!==0&&(o.startsWith(this.config.prefix)?o=o.replace(this.config.prefix,""):o=" "+o),this.cleanup&&(o=clean_up_tokenization(o)),o))}}class ByteLevelDecoder extends Decoder{constructor(e){super(e),this.byte_decoder=UNICODE_TO_BYTES,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){const o=e.join(""),a=new Uint8Array([...o].map(g=>this.byte_decoder[g]));return this.text_decoder.decode(a)}decode_chain(e){const o=[];let a=[];for(const d of e)this.added_tokens.find(g=>g.content===d)!==void 0?(a.length>0&&(o.push(this.convert_tokens_to_string(a)),a=[]),o.push(d)):a.push(d);return a.length>0&&o.push(this.convert_tokens_to_string(a)),o}}class CTCDecoder extends Decoder{constructor(e){super(e),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(e){if(e.length===0)return"";const o=[e[0]];for(let g=1;g<e.length;++g)e[g]!==o.at(-1)&&o.push(e[g]);let d=o.filter(g=>g!==this.pad_token).join("");return this.cleanup&&(d=clean_up_tokenization(d).replaceAll(this.word_delimiter_token," ").trim()),d}decode_chain(e){return[this.convert_tokens_to_string(e)]}}class DecoderSequence extends Decoder{constructor(e){super(e),this.decoders=e.decoders.map(o=>Decoder.fromConfig(o))}decode_chain(e){return this.decoders.reduce((o,a)=>a.decode_chain(o),e)}}class BPEDecoder extends Decoder{constructor(e){super(e),this.suffix=this.config.suffix}decode_chain(e){return e.map((o,a)=>o.replaceAll(this.suffix,a===e.length-1?"":" "))}}class VitsDecoder extends Decoder{decode_chain(e){let o="";for(let a=1;a<e.length;a+=2)o+=e[a];return[o]}}class MetaspacePreTokenizer extends PreTokenizer{constructor(e){super(),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement,this.prepend_scheme=e.prepend_scheme??"always"}pre_tokenize_text(e,{section_index:o=void 0}={}){let a=e.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!a.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&o===0)&&(a=this.strRep+a),[a]}}class MetaspaceDecoder extends Decoder{constructor(e){super(e),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement}decode_chain(e){const o=[];for(let a=0;a<e.length;++a){let d=e[a].replaceAll(this.replacement," ");this.addPrefixSpace&&a==0&&d.startsWith(" ")&&(d=d.substring(1)),o.push(d)}return o}}class Precompiled extends Normalizer{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){return e=e.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),e=e.replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm," "),e.includes("")?e=e.split("").map(a=>a.normalize("NFKC")).join(""):e=e.normalize("NFKC"),e}}class PreTokenizerSequence extends PreTokenizer{constructor(e){super(),this.tokenizers=e.pretokenizers.map(o=>PreTokenizer.fromConfig(o))}pre_tokenize_text(e,o){return this.tokenizers.reduce((a,d)=>d.pre_tokenize(a,o),[e])}}class WhitespacePreTokenizer extends PreTokenizer{constructor(e){super()}pre_tokenize_text(e,o){return e.match(/\w+|[^\w\s]+/g)||[]}}class WhitespaceSplit extends PreTokenizer{constructor(e){super()}pre_tokenize_text(e,o){return whitespace_split(e)}}class ReplacePreTokenizer extends PreTokenizer{constructor(e){super(),this.config=e,this.pattern=createPattern(this.config.pattern),this.content=this.config.content}pre_tokenize_text(e,o){return this.pattern===null?[e]:[e.replaceAll(this.pattern,this.config.content)]}}const SPECIAL_TOKEN_ATTRIBUTES=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function padHelper(i,e,o,a){for(const d of Object.keys(i)){const g=e-i[d].length,h=o(d),et=new Array(g).fill(h);i[d]=a==="right"?mergeArrays(i[d],et):mergeArrays(et,i[d])}}function truncateHelper(i,e){for(const o of Object.keys(i))i[o].length=e}class PreTrainedTokenizer extends Callable{constructor(o,a){super();ir(this,"return_token_type_ids",!1);ir(this,"_default_chat_template",`{% for message in messages %}{{'<|im_start|>' + message['role'] + '
' + message['content'] + '<|im_end|>' + '
'}}{% endfor %}{% if add_generation_prompt %}{{ '<|im_start|>assistant
' }}{% endif %}`);this._tokenizer_config=a,this.normalizer=Normalizer.fromConfig(o.normalizer),this.pre_tokenizer=PreTokenizer.fromConfig(o.pre_tokenizer),this.model=TokenizerModel.fromConfig(o.model,a),this.post_processor=PostProcessor.fromConfig(o.post_processor),this.decoder=Decoder.fromConfig(o.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const d of o.added_tokens){const g=new AddedToken(d);this.added_tokens.push(g),this.model.tokens_to_ids.set(g.content,g.id),this.model.vocab[g.id]=g.content,g.special&&(this.special_tokens.push(g.content),this.all_special_ids.push(g.id))}if(this.additional_special_tokens=a.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.map(d=>`${d.lstrip?"\\s*":""}(${escapeRegExp(d.content)})${d.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=a.model_max_length,this.remove_space=a.remove_space,this.clean_up_tokenization_spaces=a.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=a.do_lowercase_and_remove_accent??!1,this.padding_side="right",this.legacy=!1,this.chat_template=a.chat_template??null,Array.isArray(this.chat_template)){const d=Object.create(null);for(const{name:g,template:h}of this.chat_template){if(typeof g!="string"||typeof h!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');d[g]=h}this.chat_template=d}this._compiled_template_cache=new Map}getToken(...o){for(const a of o){const d=this._tokenizer_config[a];if(d)if(typeof d=="object"){if(d.__type==="AddedToken")return d.content;throw Error(`Unknown token: ${d}`)}else return d}return null}static async from_pretrained(o,{progress_callback:a=null,config:d=null,cache_dir:g=null,local_files_only:h=!1,revision:et="main",legacy:ot=null}={}){const it=await loadTokenizer(o,{progress_callback:a,config:d,cache_dir:g,local_files_only:h,revision:et,legacy:ot});return new this(...it)}_call(o,{text_pair:a=null,add_special_tokens:d=!0,padding:g=!1,truncation:h=null,max_length:et=null,return_tensor:ot=!0,return_token_type_ids:it=null}={}){const $=Array.isArray(o);let c;if($){if(o.length===0)throw Error("text array must be non-empty");if(a!==null){if(Array.isArray(a)){if(o.length!==a.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");c=o.map((_,b)=>this._encode_plus(_,a[b],{add_special_tokens:d,return_token_type_ids:it}))}else c=o.map(_=>this._encode_plus(_,null,{add_special_tokens:d,return_token_type_ids:it}))}else{if(o==null)throw Error("text may not be null or undefined");if(Array.isArray(a))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");c=[this._encode_plus(o,a,{add_special_tokens:d,return_token_type_ids:it})]}if(et===null?g==="max_length"?et=this.model_max_length:et=max(c.map(_=>_.input_ids.length))[0]:h||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),et=Math.min(et,this.model_max_length),g||h)for(let _=0;_<c.length;++_)c[_].input_ids.length!==et&&(c[_].input_ids.length>et?h&&truncateHelper(c[_],et):g&&padHelper(c[_],et,b=>b==="input_ids"?this.pad_token_id:0,this.padding_side));const s={};if(ot){if(!(g&&h)&&c.some(b=>{var st;for(const dt of Object.keys(b))if(b[dt].length!==((st=c[0][dt])==null?void 0:st.length))return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const _=[c.length,c[0].input_ids.length];for(const b of Object.keys(c[0]))s[b]=new Tensor("int64",BigInt64Array.from(c.flatMap(st=>st[b]).map(BigInt)),_)}else{for(const _ of Object.keys(c[0]))s[_]=c.map(b=>b[_]);if(!$)for(const _ of Object.keys(s))s[_]=s[_][0]}return s}_encode_text(o){return o===null?null:(this.added_tokens_regex?o.split(this.added_tokens_regex).filter(g=>g):[o]).map((g,h)=>{if(this.added_tokens.find(ot=>ot.content===g)!==void 0)return g;{if(this.remove_space===!0&&(g=g.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(g=lowercase_and_remove_accent(g)),this.normalizer!==null&&(g=this.normalizer(g)),g.length===0)return[];const ot=this.pre_tokenizer!==null?this.pre_tokenizer(g,{section_index:h}):[g];return this.model(ot)}}).flat()}_encode_plus(o,a=null,{add_special_tokens:d=!0,return_token_type_ids:g=null}={}){const h=this._encode_text(o),et=this._encode_text(a),ot=this.post_processor?this.post_processor(h,et,{add_special_tokens:d}):{tokens:mergeArrays(h??[],et??[])},it=this.model.convert_tokens_to_ids(ot.tokens),$={input_ids:it,attention_mask:new Array(it.length).fill(1)};return(g??this.return_token_type_ids)&&ot.token_type_ids&&($.token_type_ids=ot.token_type_ids),$}encode(o,a=null,{add_special_tokens:d=!0,return_token_type_ids:g=null}={}){const{input_ids:h}=this._encode_plus(o,a,{add_special_tokens:d,return_token_type_ids:g});return h}batch_decode(o,a={}){return o instanceof Tensor&&(o=o.tolist()),o.map(d=>this.decode(d,a))}decode(o,a={}){if(o instanceof Tensor&&(o=prepareTensorForDecode(o)),!Array.isArray(o)||o.length===0||!isIntegralNumber(o[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(o,a)}decode_single(o,{skip_special_tokens:a=!1,clean_up_tokenization_spaces:d=null}){let g=this.model.convert_ids_to_tokens(o);a&&(g=g.filter(et=>!this.special_tokens.includes(et)));let h=this.decoder?this.decoder(g):g.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(h=h.replaceAll(this.decoder.end_of_word_suffix," "),a&&(h=h.trim())),(d??this.clean_up_tokenization_spaces)&&(h=clean_up_tokenization(h)),h}get default_chat_template(){return this._warned_about_chat_template||(console.warn("No chat template is defined for this tokenizer - using a default chat template that implements the ChatML format. If the default is not appropriate for your model, please set `tokenizer.chat_template` to an appropriate template. See https://huggingface.co/docs/transformers/main/chat_templating for more information."),this._warned_about_chat_template=!0),this._default_chat_template}apply_chat_template(o,{chat_template:a=null,add_generation_prompt:d=!1,tokenize:g=!0,padding:h=!1,truncation:et=!1,max_length:ot=null,return_tensor:it=!0,tokenizer_kwargs:$={},...c}={}){if(this.chat_template&&typeof this.chat_template=="object"||this.chat_template===null&&this.default_chat_template&&typeof this.default_chat_template=="object"){const st=this.chat_template??this.default_chat_template;if(a!==null&&Object.hasOwn(st,a))a=st[a];else if(a===null&&"default"in st)a=st.default;else if(a===null)throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(st).sort()}.`)}else a??(a=this.chat_template??this.default_chat_template);if(typeof a!="string")throw Error(`chat_template must be a string, but got ${typeof a}`);let s=this._compiled_template_cache.get(a);s===void 0&&(s=new Template(a),this._compiled_template_cache.set(a,s));const _=Object.create(null);for(const st of SPECIAL_TOKEN_ATTRIBUTES){const dt=this.getToken(st);dt&&(_[st]=dt)}const b=s.render({messages:o,add_generation_prompt:d,..._,...c});return g?this._call(b,{add_special_tokens:!1,padding:h,truncation:et,max_length:ot,return_tensor:it,...$}).input_ids:b}}class BertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"return_token_type_ids",!0)}}class AlbertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"return_token_type_ids",!0)}}class MobileBertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"return_token_type_ids",!0)}}class SqueezeBertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"return_token_type_ids",!0)}}class DebertaTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"return_token_type_ids",!0)}}class DebertaV2Tokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"return_token_type_ids",!0)}}class HerbertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"return_token_type_ids",!0)}}class ConvBertTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"return_token_type_ids",!0)}}class RoFormerTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"return_token_type_ids",!0)}}class DistilBertTokenizer extends PreTrainedTokenizer{}class CamembertTokenizer extends PreTrainedTokenizer{}class XLMTokenizer extends PreTrainedTokenizer{constructor(o,a){super(o,a);ir(this,"return_token_type_ids",!0);console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class ElectraTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"return_token_type_ids",!0)}}class T5Tokenizer extends PreTrainedTokenizer{}class GPT2Tokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"_default_chat_template",'{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}')}}class BartTokenizer extends PreTrainedTokenizer{}class MBartTokenizer extends PreTrainedTokenizer{constructor(e,o){super(e,o),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(a=>this.languageRegex.test(a)),this.lang_to_token=a=>a}_build_translation_inputs(e,o,a){return _build_translation_inputs(this,e,o,a)}}class MBart50Tokenizer extends MBartTokenizer{}class RobertaTokenizer extends PreTrainedTokenizer{}class BloomTokenizer extends GPT2Tokenizer{constructor(e,o){var g,h;const a=".,!?",d=(h=(g=e.pre_tokenizer)==null?void 0:g.pretokenizers[0])==null?void 0:h.pattern;d&&d.Regex===` ?[^(\\s|[${a}])]+`&&(d.Regex=` ?[^\\s${a}]+`),super(e,o)}}const SPIECE_UNDERLINE="";class LlamaTokenizer extends PreTrainedTokenizer{constructor(o,a){super(o,a);ir(this,"_default_chat_template",`{% if messages[0]['role'] == 'system' %}{% set loop_messages = messages[1:] %}{% set system_message = messages[0]['content'] %}{% elif USE_DEFAULT_PROMPT == true and not '<<SYS>>' in messages[0]['content'] %}{% set loop_messages = messages %}{% set system_message = 'DEFAULT_SYSTEM_MESSAGE' %}{% else %}{% set loop_messages = messages %}{% set system_message = false %}{% endif %}{% for message in loop_messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if loop.index0 == 0 and system_message != false %}{% set content = '<<SYS>>
' + system_message + '
<</SYS>>

' + message['content'] %}{% else %}{% set content = message['content'] %}{% endif %}{% if message['role'] == 'user' %}{{ bos_token + '[INST] ' + content.strip() + ' [/INST]' }}{% elif message['role'] == 'system' %}{{ '<<SYS>>
' + content.strip() + '
<</SYS>>

' }}{% elif message['role'] == 'assistant' %}{{ ' '  + content.strip() + ' ' + eos_token }}{% endif %}{% endfor %}`);ir(this,"DEFAULT_SYSTEM_PROMPT",`You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.

If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.`);this.use_default_system_prompt=a.use_default_system_prompt??!1,this.legacy=a.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new MetaspacePreTokenizer({replacement:SPIECE_UNDERLINE,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(o){if(o===null)return null;if(this.legacy||o.length===0)return super._encode_text(o);let a=super._encode_text(SPIECE_UNDERLINE+o.replaceAll(SPIECE_UNDERLINE," "));return a.length>1&&a[0]===SPIECE_UNDERLINE&&this.special_tokens.includes(a[1])&&(a=a.slice(1)),a}get default_chat_template(){return super.default_chat_template.replaceAll("USE_DEFAULT_PROMPT",this.use_default_system_prompt?"true":"false").replaceAll("DEFAULT_SYSTEM_MESSAGE",this.DEFAULT_SYSTEM_PROMPT.replaceAll(`
`,"\\n").replaceAll("'","\\'"))}}class CodeLlamaTokenizer extends LlamaTokenizer{}class XLMRobertaTokenizer extends PreTrainedTokenizer{}class MPNetTokenizer extends PreTrainedTokenizer{}class FalconTokenizer extends PreTrainedTokenizer{}class GPTNeoXTokenizer extends PreTrainedTokenizer{}class EsmTokenizer extends PreTrainedTokenizer{}class Qwen2Tokenizer extends PreTrainedTokenizer{}class GemmaTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"_default_chat_template",`{% if messages[0]['role'] == 'system' %}{{ raise_exception('System role not supported') }}{% endif %}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if (message['role'] == 'assistant') %}{% set role = 'model' %}{% else %}{% set role = message['role'] %}{% endif %}{{ '<start_of_turn>' + role + '
' + message['content'] | trim + '<end_of_turn>
' }}{% endfor %}{% if add_generation_prompt %}{{'<start_of_turn>model
'}}{% endif %}`)}}class Grok1Tokenizer extends PreTrainedTokenizer{}function _build_translation_inputs(i,e,o,a){if(!("language_codes"in i)||!Array.isArray(i.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in i)||!(i.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in i)||typeof i.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const d=a.src_lang,g=a.tgt_lang;if(!i.language_codes.includes(g))throw new Error(`Target language code "${g}" is not valid. Must be one of: {${i.language_codes.join(", ")}}`);if(d!==void 0){if(!i.language_codes.includes(d))throw new Error(`Source language code "${d}" is not valid. Must be one of: {${i.language_codes.join(", ")}}`);for(const h of i.post_processor.config.single)if("SpecialToken"in h&&i.languageRegex.test(h.SpecialToken.id)){h.SpecialToken.id=i.lang_to_token(d);break}}return a.forced_bos_token_id=i.model.convert_tokens_to_ids([i.lang_to_token(g)])[0],i._call(e,o)}class NllbTokenizer extends PreTrainedTokenizer{constructor(e,o){super(e,o),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(a=>this.languageRegex.test(a)),this.lang_to_token=a=>a}_build_translation_inputs(e,o,a){return _build_translation_inputs(this,e,o,a)}}class M2M100Tokenizer extends PreTrainedTokenizer{constructor(e,o){super(e,o),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(a=>this.languageRegex.test(a)).map(a=>a.slice(2,-2)),this.lang_to_token=a=>`__${a}__`}_build_translation_inputs(e,o,a){return _build_translation_inputs(this,e,o,a)}}const WHISPER_LANGUAGES=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],WHISPER_LANGUAGE_MAPPING=new Map(WHISPER_LANGUAGES),WHISPER_TO_LANGUAGE_CODE_MAPPING=new Map([...WHISPER_LANGUAGES.map(([i,e])=>[e,i]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);class WhisperTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"_default_chat_template",'{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}')}_decode_asr(o,{return_timestamps:a=!1,return_language:d=!1,time_precision:g=null,force_full_sequences:h=!0}={}){if(g===null)throw Error("Must specify time_precision");let et=null;const ot=a==="word";function it(){return{language:et,timestamp:[null,null],text:""}}const $=[];let c=it(),s=0;const _=this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1;let b=[],st=[],dt=!1,ct=null;const pt=new Set(this.all_special_ids);for(const bt of o){const $t=bt.tokens,Ct=ot?bt.token_timestamps:null;let It=null,Tt=_;if("stride"in bt){const[yn,mn,fn]=bt.stride;if(s-=mn,ct=yn-fn,mn&&(Tt=mn/g+_),fn)for(let un=$t.length-1;un>=0;--un){const Wt=$t[un];if(Wt>=_){if(It!==null&&(Wt-_)*g<ct)break;It=Wt}}}let jt=[],dn=[];for(let yn=0;yn<$t.length;++yn){const mn=$t[yn];if(pt.has(mn)){const fn=this.decode([mn]),un=WHISPER_LANGUAGE_MAPPING.get(fn.slice(2,-2));if(un!==void 0){if(et!==null&&un!==et&&!a){b.push(jt);const Wt=this.findLongestCommonSequence(b)[0],Jt=this.decode(Wt);c.text=Jt,$.push(c),b=[],jt=[],c=it()}et=c.language=un}}else if(mn>=_){const fn=(mn-_)*g+s,un=round(fn,2);if(It!==null&&mn>=It)dt=!0;else if(dt||b.length>0&&mn<Tt)dt=!1;else if(c.timestamp[0]===null)c.timestamp[0]=un;else if(un!==c.timestamp[0]){c.timestamp[1]=un,b.push(jt),ot&&st.push(dn);const[Wt,Jt]=this.findLongestCommonSequence(b,st),_n=this.decode(Wt);c.text=_n,ot&&(c.words=this.collateWordTimestamps(Wt,Jt,et)),$.push(c),b=[],jt=[],st=[],dn=[],c=it()}}else if(jt.push(mn),ot){let fn=round(Ct[yn]+s,2),un;yn+1<Ct.length?un=round(Ct[yn+1]+s,2):un=null,dn.push([fn,un])}}if("stride"in bt){const[yn,mn,fn]=bt.stride;s+=yn-fn}jt.length>0?(b.push(jt),ot&&st.push(dn)):b.every(yn=>yn.length===0)&&(c=it(),b=[],jt=[],st=[],dn=[])}if(b.length>0){if(h&&a)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[bt,$t]=this.findLongestCommonSequence(b,st),Ct=this.decode(bt);c.text=Ct,ot&&(c.words=this.collateWordTimestamps(bt,$t,et)),$.push(c)}let ft=Object.create(null);const mt=$.map(bt=>bt.text).join("");if(a||d){for(let bt=0;bt<$.length;++bt){const $t=$[bt];a||delete $t.timestamp,d||delete $t.language}if(ot){const bt=[];for(const $t of $)for(const Ct of $t.words)bt.push(Ct);ft={chunks:bt}}else ft={chunks:$}}return[mt,ft]}findLongestCommonSequence(o,a=null){let d=o[0],g=d.length,h=[];const et=Array.isArray(a)&&a.length>0;let ot=et?[]:null,it=et?a[0]:null;for(let $=1;$<o.length;++$){const c=o[$];let s=0,_=[g,g,0,0];const b=c.length;for(let bt=1;bt<g+b;++bt){const $t=bt/1e4,Ct=Math.max(0,g-bt),It=Math.min(g,g+b-bt),Tt=d.slice(Ct,It),jt=Math.max(0,bt-g),dn=Math.min(b,bt),yn=c.slice(jt,dn);if(Tt.length!==yn.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");const mn=Tt.filter((un,Wt)=>un===yn[Wt]).length,fn=mn/bt+$t;mn>1&&fn>s&&(s=fn,_=[Ct,It,jt,dn])}const[st,dt,ct,pt]=_,ft=Math.floor((dt+st)/2),mt=Math.floor((pt+ct)/2);h.push(...d.slice(0,ft)),d=c.slice(mt),g=d.length,et&&(ot.push(...it.slice(0,ft)),it=a[$].slice(mt))}return h.push(...d),et?(ot.push(...it),[h,ot]):[h,[]]}collateWordTimestamps(o,a,d){const[g,h,et]=this.combineTokensIntoWords(o,d),ot=[];for(let it=0;it<g.length;++it){const $=et[it];ot.push({text:g[it],timestamp:[a[$.at(0)][0],a[$.at(-1)][1]]})}return ot}combineTokensIntoWords(o,a,d=`"'([{-`,g=`"'.,!?:)]}`){a=a??"english";let h,et,ot;return["chinese","japanese","thai","lao","myanmar"].includes(a)?[h,et,ot]=this.splitTokensOnUnicode(o):[h,et,ot]=this.splitTokensOnSpaces(o),this.mergePunctuations(h,et,ot,d,g)}decode(o,a){let d;return a&&a.decode_with_timestamps?(o instanceof Tensor&&(o=prepareTensorForDecode(o)),d=this.decodeWithTimestamps(o,a)):d=super.decode(o,a),d}decodeWithTimestamps(o,a){const d=(a==null?void 0:a.time_precision)??.02,g=Array.from(this.all_special_ids).at(-1)+1;let h=[[]];for(const et of o)if(et>=g){const ot=round((et-g)*d,2);h.push(`<|${ot}|>`),h.push([])}else h[h.length-1].push(et);return h=h.map(et=>typeof et=="string"?et:super.decode(et,a)),h.join("")}splitTokensOnUnicode(o){const a=this.decode(o,{decode_with_timestamps:!0}),d="",g=[],h=[],et=[];let ot=[],it=[],$=0;for(let c=0;c<o.length;++c){const s=o[c];ot.push(s),it.push(c);const _=this.decode(ot,{decode_with_timestamps:!0});(!_.includes(d)||a[$+_.indexOf(d)]===d)&&(g.push(_),h.push(ot),et.push(it),ot=[],it=[],$+=_.length)}return[g,h,et]}splitTokensOnSpaces(o){const[a,d,g]=this.splitTokensOnUnicode(o),h=[],et=[],ot=[],it=new RegExp(`^[${PUNCTUATION_REGEX}]$`,"gu");for(let $=0;$<a.length;++$){const c=a[$],s=d[$],_=g[$],b=s[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),st=c.startsWith(" "),dt=c.trim(),ct=it.test(dt);if(b||st||ct||h.length===0)h.push(c),et.push(s),ot.push(_);else{const pt=h.length-1;h[pt]+=c,et[pt].push(...s),ot[pt].push(..._)}}return[h,et,ot]}mergePunctuations(o,a,d,g,h){const et=structuredClone(o),ot=structuredClone(a),it=structuredClone(d);let $=et.length-2,c=et.length-1;for(;$>=0;)et[$].startsWith(" ")&&g.includes(et[$].trim())?(et[c]=et[$]+et[c],ot[c]=mergeArrays(ot[$],ot[c]),it[c]=mergeArrays(it[$],it[c]),et[$]="",ot[$]=[],it[$]=[]):c=$,--$;for($=0,c=1;c<et.length;)!et[$].endsWith(" ")&&h.includes(et[c])?(et[$]+=et[c],ot[$]=mergeArrays(ot[$],ot[c]),it[$]=mergeArrays(it[$],it[c]),et[c]="",ot[c]=[],it[c]=[]):$=c,++c;return[et.filter(s=>s),ot.filter(s=>s.length>0),it.filter(s=>s.length>0)]}get_decoder_prompt_ids({language:o=null,task:a=null,no_timestamps:d=!0}={}){const g=[];if(o){o=o.toLowerCase();let h=WHISPER_TO_LANGUAGE_CODE_MAPPING.get(o);if(h===void 0)if(WHISPER_LANGUAGE_MAPPING.has(o))h=o;else{const it=o.length===2?WHISPER_LANGUAGE_MAPPING.keys():WHISPER_LANGUAGE_MAPPING.values();throw new Error(`Language "${o}" is not supported. Must be one of: ${JSON.stringify(it)}`)}const et=this.model.tokens_to_ids.get(`<|${h}|>`);if(et===void 0)throw new Error(`Unable to find language "${h}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);g.push(et)}else g.push(null);if(a){if(a=a.toLowerCase(),a!=="transcribe"&&a!=="translate")throw new Error(`Task "${a}" is not supported. Must be one of: ["transcribe", "translate"]`);const h=this.model.tokens_to_ids.get(`<|${a}|>`);if(h===void 0)throw new Error(`Unable to find task "${a}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);g.push(h)}else g.push(null);if(d){const h=this.model.tokens_to_ids.get("<|notimestamps|>");if(h===void 0)throw new Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.');g.push(h)}return g.map((h,et)=>[et+1,h]).filter(h=>h[1]!==null)}}class CodeGenTokenizer extends PreTrainedTokenizer{}class CLIPTokenizer extends PreTrainedTokenizer{}class SiglipTokenizer extends PreTrainedTokenizer{}class MarianTokenizer extends PreTrainedTokenizer{constructor(e,o){super(e,o),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(a=>this.languageRegex.test(a)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(e){if(e===null)return null;const[o,...a]=e.trim().split(this.languageRegex);if(a.length===0)return super._encode_text(o);if(a.length===2){const[d,g]=a;return this.supported_language_codes.includes(d)||console.warn(`Unsupported language code "${d}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),mergeArrays([d],super._encode_text(g))}}}class Wav2Vec2CTCTokenizer extends PreTrainedTokenizer{}class BlenderbotTokenizer extends PreTrainedTokenizer{constructor(){super(...arguments);ir(this,"_default_chat_template","{% for message in messages %}{% if message['role'] == 'user' %}{{ ' ' }}{% endif %}{{ message['content'] }}{% if not loop.last %}{{ '  ' }}{% endif %}{% endfor %}{{ eos_token }}")}}class BlenderbotSmallTokenizer extends BlenderbotTokenizer{}class SpeechT5Tokenizer extends PreTrainedTokenizer{}class NougatTokenizer extends PreTrainedTokenizer{}class VitsTokenizer extends PreTrainedTokenizer{constructor(e,o){super(e,o),this.decoder=new VitsDecoder({})}}class CohereTokenizer extends PreTrainedTokenizer{}class AutoTokenizer{static async from_pretrained(e,{quantized:o=!0,progress_callback:a=null,config:d=null,cache_dir:g=null,local_files_only:h=!1,revision:et="main",legacy:ot=null}={}){var _;const[it,$]=await loadTokenizer(e,{quantized:o,progress_callback:a,config:d,cache_dir:g,local_files_only:h,revision:et,legacy:ot}),c=((_=$.tokenizer_class)==null?void 0:_.replace(/Fast$/,""))??"PreTrainedTokenizer";let s=this.TOKENIZER_CLASS_MAPPING[c];return s||(console.warn(`Unknown tokenizer class "${c}", attempting to construct from base class.`),s=PreTrainedTokenizer),new s(it,$)}}ir(AutoTokenizer,"TOKENIZER_CLASS_MAPPING",{T5Tokenizer,DistilBertTokenizer,CamembertTokenizer,DebertaTokenizer,DebertaV2Tokenizer,BertTokenizer,HerbertTokenizer,ConvBertTokenizer,RoFormerTokenizer,XLMTokenizer,ElectraTokenizer,MobileBertTokenizer,SqueezeBertTokenizer,AlbertTokenizer,GPT2Tokenizer,BartTokenizer,MBartTokenizer,MBart50Tokenizer,RobertaTokenizer,WhisperTokenizer,CodeGenTokenizer,CLIPTokenizer,SiglipTokenizer,MarianTokenizer,BloomTokenizer,NllbTokenizer,M2M100Tokenizer,LlamaTokenizer,CodeLlamaTokenizer,XLMRobertaTokenizer,MPNetTokenizer,FalconTokenizer,GPTNeoXTokenizer,EsmTokenizer,Wav2Vec2CTCTokenizer,BlenderbotTokenizer,BlenderbotSmallTokenizer,SpeechT5Tokenizer,NougatTokenizer,VitsTokenizer,Qwen2Tokenizer,GemmaTokenizer,Grok1Tokenizer,CohereTokenizer,PreTrainedTokenizer});async function loadConfig(i,e){return await getModelJSON(i,"config.json",!0,e)}class PretrainedConfig{constructor(e){this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,e)}static async from_pretrained(e,{progress_callback:o=null,config:a=null,cache_dir:d=null,local_files_only:g=!1,revision:h="main"}={}){let et=a??await loadConfig(e,{progress_callback:o,config:a,cache_dir:d,local_files_only:g,revision:h});return new this(et)}}class AutoConfig{static async from_pretrained(...e){return PretrainedConfig.from_pretrained(...e)}}class LogitsProcessorList extends Callable{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,o){for(let a of o)this.processors.forEach(d=>d(e,a))}[Symbol.iterator](){return this.processors.values()}}class LogitsProcessor extends Callable{_call(e,o){throw Error("`_call` should be implemented in a subclass")}}class ForceTokensLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.force_token_map=Object.fromEntries(e??[])}_call(e,o){let a=this.force_token_map[e.length];return exists(a)&&(o.data.fill(-1/0),o.data[a]=0),o}}class ForcedBOSTokenLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.bos_token_id=e}_call(e,o){return e.length===1&&(o.data.fill(-1/0),o.data[this.bos_token_id]=0),o}}class ForcedEOSTokenLogitsProcessor extends LogitsProcessor{constructor(e,o){super(),this.max_length=e,this.forced_eos_token_id=o}_call(e,o){}}class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor{constructor(e,o){super(),this.begin_suppress_tokens=e,this.begin_index=o}_call(e,o){if(e.length===this.begin_index)for(let a of this.begin_suppress_tokens)o.data[a]=-1/0;return o}}class WhisperTimeStampLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.eos_token_id=e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=(e.forced_decoder_ids||[]).length+2,e.forced_decoder_ids.slice(-1)[0][1]===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,o){const a=o.data;if(a[this.no_timestamps_token_id]=-1/0,e.length===this.begin_index-1)return a.fill(-1/0),a[this.timestamp_begin]=0,o;const d=e.slice(this.begin_index),g=d.length>=1&&d[d.length-1]>=this.timestamp_begin,h=d.length<2||d[d.length-2]>=this.timestamp_begin;if(g&&(h?a.subarray(this.timestamp_begin).fill(-1/0):a.subarray(0,this.eos_token_id).fill(-1/0)),e.length===this.begin_index&&this.max_initial_timestamp_index!==null){const $=this.timestamp_begin+this.max_initial_timestamp_index;a.subarray($+1).fill(-1/0)}const et=log_softmax(a),ot=Math.log(et.subarray(this.timestamp_begin).map(Math.exp).reduce(($,c)=>$+c)),it=max(et.subarray(0,this.timestamp_begin))[0];return ot>it&&a.subarray(0,this.timestamp_begin).fill(-1/0),o}}class NoRepeatNGramLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const o=e.length,a=[];for(let g=0;g<o+1-this.no_repeat_ngram_size;++g){const h=[];for(let et=0;et<this.no_repeat_ngram_size;++et)h.push(e[g+et]);a.push(h)}const d=new Map;for(const g of a){const h=g.slice(0,g.length-1),et=JSON.stringify(h),ot=d.get(et)??[];ot.push(g[g.length-1]),d.set(et,ot)}return d}getGeneratedNgrams(e,o){const a=o.slice(o.length+1-this.no_repeat_ngram_size,o.length);return e.get(JSON.stringify(a))??[]}calcBannedNgramTokens(e){const o=[];if(e.length+1<this.no_repeat_ngram_size)return o;{const a=this.getNgrams(e);return this.getGeneratedNgrams(a,e)}}_call(e,o){const a=this.calcBannedNgramTokens(e);for(const d of a)o.data[d]=-1/0;return o}}class RepetitionPenaltyLogitsProcessor extends LogitsProcessor{constructor(e){super(),this.penalty=e}_call(e,o){for(const a of e)o.data[a]<0?o.data[a]*=this.penalty:o.data[a]/=this.penalty;return o}}class MinLengthLogitsProcessor extends LogitsProcessor{constructor(e,o){super(),this.min_length=e,this.eos_token_id=Array.isArray(o)?o:[o]}_call(e,o){if(e.length<this.min_length)for(const a of this.eos_token_id)o.data[a]=-1/0;return o}}class MinNewTokensLengthLogitsProcessor extends LogitsProcessor{constructor(e,o,a){super(),this.prompt_length_to_skip=e,this.min_new_tokens=o,this.eos_token_id=Array.isArray(a)?a:[a]}_call(e,o){if(e.length-this.prompt_length_to_skip<this.min_new_tokens)for(const d of this.eos_token_id)o.data[d]=-1/0;return o}}class NoBadWordsLogitsProcessor extends LogitsProcessor{constructor(e,o){super(),this.bad_words_ids=e,this.eos_token_id=Array.isArray(o)?o:[o]}_call(e,o){for(const a of this.bad_words_ids){let d=!0;for(let g=1;g<=a.length-1&&a.length<e.length;++g)if(a.at(-g-1)!==e.at(-g)){d=!1;break}d&&(o.data[a.at(-1)]=-1/0)}return o}}const GenerationConfig=class{constructor(i={}){this.max_length=i.max_length??20,this.max_new_tokens=i.max_new_tokens??null,this.min_length=i.min_length??0,this.min_new_tokens=i.min_new_tokens??null,this.early_stopping=i.early_stopping??!1,this.max_time=i.max_time??null,this.do_sample=i.do_sample??!1,this.num_beams=i.num_beams??1,this.num_beam_groups=i.num_beam_groups??1,this.penalty_alpha=i.penalty_alpha??null,this.use_cache=i.use_cache??!0,this.temperature=i.temperature??1,this.top_k=i.top_k??50,this.top_p=i.top_p??1,this.typical_p=i.typical_p??1,this.epsilon_cutoff=i.epsilon_cutoff??0,this.eta_cutoff=i.eta_cutoff??0,this.diversity_penalty=i.diversity_penalty??0,this.repetition_penalty=i.repetition_penalty??1,this.encoder_repetition_penalty=i.encoder_repetition_penalty??1,this.length_penalty=i.length_penalty??1,this.no_repeat_ngram_size=i.no_repeat_ngram_size??0,this.bad_words_ids=i.bad_words_ids??null,this.force_words_ids=i.force_words_ids??null,this.renormalize_logits=i.renormalize_logits??!1,this.constraints=i.constraints??null,this.forced_bos_token_id=i.forced_bos_token_id??null,this.forced_eos_token_id=i.forced_eos_token_id??null,this.remove_invalid_values=i.remove_invalid_values??!1,this.exponential_decay_length_penalty=i.exponential_decay_length_penalty??null,this.suppress_tokens=i.suppress_tokens??null,this.begin_suppress_tokens=i.begin_suppress_tokens??null,this.forced_decoder_ids=i.forced_decoder_ids??null,this.num_return_sequences=i.num_return_sequences??1,this.output_attentions=i.output_attentions??!1,this.output_hidden_states=i.output_hidden_states??!1,this.output_scores=i.output_scores??!1,this.return_dict_in_generate=i.return_dict_in_generate??!1,this.pad_token_id=i.pad_token_id??null,this.bos_token_id=i.bos_token_id??null,this.eos_token_id=i.eos_token_id??null,this.encoder_no_repeat_ngram_size=i.encoder_no_repeat_ngram_size??0,this.decoder_start_token_id=i.decoder_start_token_id??null,this.generation_kwargs=i.generation_kwargs??{}}};class Sampler extends Callable{constructor(e){super(),this.generation_config=e}_call(e,o=-1){return this.sample(e,o)}sample(e,o){throw Error("sample should be implemented in subclasses.")}getLogits(e,o){let a=e.dims.at(-1),d=e.data;if(o===-1)d=d.slice(-a);else{let g=o*a;d=d.slice(g,g+a)}return this.generation_config.temperature>0&&(d=d.map(g=>g/this.generation_config.temperature)),d}randomSelect(e){let o=e.reduce((d,g)=>d+g,0),a=Math.random()*o;for(let d=0;d<e.length;++d)if(a-=e[d],a<=0)return d;return 0}static getSampler(e){if(e.do_sample)return new MultinomialSampler(e);if(e.num_beams>1)return new BeamSearchSampler(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new GreedySampler(e)}}class GreedySampler extends Sampler{sample(e,o=-1){let a=this.getLogits(e,o);return[[max(a)[1],0]]}}class MultinomialSampler extends Sampler{sample(e,o=-1){let a=e.dims.at(-1);this.generation_config.top_k>0&&(a=Math.min(this.generation_config.top_k,a));const d=this.getLogits(e,o),g=getTopItems(d,a),h=softmax(g.map(et=>et[1]));return Array.from({length:this.generation_config.num_beams},()=>{const et=this.randomSelect(h);return[g[et][0],Math.log(h[et])]})}}class BeamSearchSampler extends Sampler{sample(e,o=-1){let a=e.dims.at(-1);this.generation_config.top_k>0&&(a=Math.min(this.generation_config.top_k,a));const d=this.getLogits(e,o),g=getTopItems(d,a),h=softmax(g.map(et=>et[1]));return Array.from({length:this.generation_config.num_beams},(et,ot)=>[g[ot][0],Math.log(h[ot])])}}const{InferenceSession,Tensor:ONNXTensor,env}=ONNX,MODEL_TYPES={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5},MODEL_TYPE_MAPPING=new Map,MODEL_NAME_TO_CLASS_MAPPING=new Map,MODEL_CLASS_TO_NAME_MAPPING=new Map;async function constructSession(i,e,o){let a=`onnx/${e}${o.quantized?"_quantized":""}.onnx`,d=await getModelFile(i,a,!0,o);try{return await InferenceSession.create(d,{executionProviders})}catch(g){if(executionProviders.length===1&&executionProviders[0]==="wasm")throw g;return console.warn(g),console.warn("Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "),await InferenceSession.create(d,{executionProviders:["wasm"]})}}function validateInputs(i,e){const o=Object.create(null),a=[];for(const h of i.inputNames){const et=e[h];if(!(et instanceof Tensor)){a.push(h);continue}o[h]=env.wasm.proxy?et.clone():et}if(a.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${a.join(", ")}.`);const d=Object.keys(e).length,g=i.inputNames.length;if(d>g){let h=Object.keys(e).filter(et=>!i.inputNames.includes(et));console.warn(`WARNING: Too many inputs were provided (${d} > ${g}). The following inputs will be ignored: "${h.join(", ")}".`)}return o}async function sessionRun(i,e){const o=validateInputs(i,e);try{let a=await i.run(o);return a=replaceTensors(a),a}catch(a){throw console.error(`An error occurred during model execution: "${a}".`),console.error("Inputs given to model:",o),a}}function replaceTensors(i){for(let e in i)i[e]instanceof ONNXTensor?i[e]=new Tensor(i[e]):typeof i[e]=="object"&&replaceTensors(i[e]);return i}function toI64Tensor(i){if(i instanceof Tensor)return i;if(i.length===0)throw Error("items must be non-empty");if(Array.isArray(i[0])){if(i.some(e=>e.length!==i[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new Tensor("int64",BigInt64Array.from(i.flat().map(e=>BigInt(e))),[i.length,i[0].length])}else return new Tensor("int64",BigInt64Array.from(i.map(e=>BigInt(e))),[1,i.length])}function prepareAttentionMask(i,e){let o=i.config.pad_token_id??null,a=i.config.eos_token_id??null;isIntegralNumber(a)&&(a=[a]);let d=e.indexOf(o)!==-1,g=a===null||!a.includes(o);if(d&&g){let h=BigInt64Array.from(e.data.map(et=>et!=o));return new Tensor("int64",h,e.dims)}else return ones_like(e)}function preparePositionIds(i,e,o){if(!i.inputNames.includes("position_ids"))return;const a=new BigInt64Array(e.attention_mask.data.length);for(let d=0;d<e.attention_mask.dims[0];++d){let g=d*e.attention_mask.dims[1],h=BigInt(0);for(let et=0;et<e.attention_mask.dims[1];++et){const ot=g+et;e.attention_mask.data[ot]===0n?a[ot]=BigInt(1):(a[ot]=h,h+=e.attention_mask.data[ot])}}e.position_ids=new Tensor("int64",a,e.attention_mask.dims),o&&(e.position_ids=e.position_ids.slice(null,-1).unsqueeze_(-1))}function boolTensor(i){return new Tensor("bool",[i],[1])}async function seq2seqForward(i,e){let{encoder_outputs:o,past_key_values:a}=e;o||(o=(await encoderForward(i,e)).last_hidden_state);let d={input_ids:e.decoder_input_ids,encoder_hidden_states:o};const g=!!a;i.decoder_merged_session.inputNames.includes("use_cache_branch")&&(d.use_cache_branch=boolTensor(g)),i.decoder_merged_session.inputNames.includes("encoder_attention_mask")&&(d.encoder_attention_mask=e.attention_mask),preparePositionIds(i.decoder_merged_session,d,g),i.addPastKeyValues(d,a);const h=await sessionRun(i.decoder_merged_session,d);let et=h.logits;a=i.getPastKeyValues(h,a);const ot=i.getAttentions(h);return new Seq2SeqLMOutput({logits:et,past_key_values:a,encoder_outputs:o,...ot})}function seq2seqStartBeams(i,e,o,a){let d=[],g=0;const h=i.requires_attention_mask??!0;let et=o.decoder_input_ids??o.decoder_start_token_id??o.bos_token_id??o.eos_token_id;et instanceof Tensor?et=et.tolist().flat():Array.isArray(et)||(et=[et]);for(let ot of e){ot.dims=[1,...ot.dims];let it={inputs:ot,encoder_outputs:null,prev_model_outputs:null,output_token_ids:et,done:!1,score:0,id:g++};h&&(it.attention_mask=prepareAttentionMask(i,ot)),d.push(it)}return d}async function seq2seqRunBeam(i,e){var h;const o=i.main_input_name;let a=e.output_token_ids;e.prev_model_outputs&&(a=a.slice(-1));let d={[o]:e.inputs,decoder_input_ids:toI64Tensor(a),encoder_outputs:e.encoder_outputs,past_key_values:(h=e.prev_model_outputs)==null?void 0:h.past_key_values};e.attention_mask&&(d.attention_mask=e.attention_mask);let g=await i.forward(d);return e.prev_model_outputs=g,e.encoder_outputs=g.encoder_outputs,g}function seq2seqUpdatebeam(i,e){i.output_token_ids=[...i.output_token_ids,e]}async function encoderForward(i,e){const o=Object.create(null);for(const a of i.session.inputNames)o[a]=e[a];return i.session.inputNames.includes("token_type_ids")&&!o.token_type_ids&&(o.token_type_ids=new Tensor("int64",new BigInt64Array(o.input_ids.data.length),o.input_ids.dims)),await sessionRun(i.session,o)}async function decoderForward(i,e){let{input_ids:o,past_key_values:a,attention_mask:d}=e,g={input_ids:o,attention_mask:d??prepareAttentionMask(i,o)};const h=!!a;i.session.inputNames.includes("use_cache_branch")&&(g.use_cache_branch=boolTensor(h)),preparePositionIds(i.session,g,h),i.addPastKeyValues(g,a);let et=await sessionRun(i.session,g),ot=et.logits;return a=i.getPastKeyValues(et,a),{logits:ot,past_key_values:a}}function decoderStartBeams(i,e,o,a,d){let g=[],h=0;for(let et of e){let ot=et.tolist().map(Number);et.dims=[1,...et.dims];let it;d?(it=d[h],it.dims=[1,...it.dims]):it=prepareAttentionMask(i,et);let $={input:et,model_input_ids:et,attention_mask:it,prev_model_outputs:null,output_token_ids:ot,num_output_tokens:a,done:!1,score:0,id:h++};g.push($)}return g}async function decoderRunBeam(i,e){var g;let o=new BigInt64Array(e.output_token_ids.length).fill(1n),a={input_ids:e.model_input_ids,attention_mask:new Tensor("int64",o,[1,o.length]),past_key_values:(g=e.prev_model_outputs)==null?void 0:g.past_key_values},d=await i.forward(a);return e.prev_model_outputs=d,d}function decoderUpdatebeam(i,e){i.output_token_ids=[...i.output_token_ids,e],i.model_input_ids=new Tensor("int64",[BigInt(e)],[1,1])}class PreTrainedModel extends Callable{constructor(o,a){super();ir(this,"main_input_name","input_ids");this.config=o,this.session=a;const d=MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor),g=MODEL_TYPE_MAPPING.get(d);this.can_generate=!1,this._runBeam=null,this._getStartBeams=null,this._updateBeam=null,this._forward=null,g===MODEL_TYPES.DecoderOnly?(this.can_generate=!0,this._runBeam=decoderRunBeam,this._getStartBeams=decoderStartBeams,this._updateBeam=decoderUpdatebeam,this._forward=decoderForward):g===MODEL_TYPES.Seq2Seq||g===MODEL_TYPES.Vision2Seq?(this.can_generate=!0,this._runBeam=seq2seqRunBeam,this._getStartBeams=seq2seqStartBeams,this._updateBeam=seq2seqUpdatebeam,this._forward=seq2seqForward):g===MODEL_TYPES.EncoderDecoder?this._forward=encoderForward:this._forward=encoderForward}async dispose(){const o=[];for(let a of Object.keys(this)){const d=this[a];d instanceof InferenceSession&&o.push(d.handler.dispose())}return await Promise.all(o)}static async from_pretrained(o,{quantized:a=!0,progress_callback:d=null,config:g=null,cache_dir:h=null,local_files_only:et=!1,revision:ot="main",model_file_name:it=null}={}){let $={quantized:a,progress_callback:d,config:g,cache_dir:h,local_files_only:et,revision:ot,model_file_name:it};const c=MODEL_CLASS_TO_NAME_MAPPING.get(this),s=MODEL_TYPE_MAPPING.get(c);let _;return s===MODEL_TYPES.DecoderOnly?_=await Promise.all([AutoConfig.from_pretrained(o,$),constructSession(o,$.model_file_name??"decoder_model_merged",$),getModelJSON(o,"generation_config.json",!1,$)]):s===MODEL_TYPES.Seq2Seq||s===MODEL_TYPES.Vision2Seq?_=await Promise.all([AutoConfig.from_pretrained(o,$),constructSession(o,"encoder_model",$),constructSession(o,"decoder_model_merged",$),getModelJSON(o,"generation_config.json",!1,$)]):s===MODEL_TYPES.MaskGeneration?_=await Promise.all([AutoConfig.from_pretrained(o,$),constructSession(o,"vision_encoder",$),constructSession(o,"prompt_encoder_mask_decoder",$)]):s===MODEL_TYPES.EncoderDecoder?_=await Promise.all([AutoConfig.from_pretrained(o,$),constructSession(o,"encoder_model",$),constructSession(o,"decoder_model_merged",$)]):(s!==MODEL_TYPES.EncoderOnly&&console.warn(`Model type for '${c??(g==null?void 0:g.model_type)}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`),_=await Promise.all([AutoConfig.from_pretrained(o,$),constructSession(o,$.model_file_name??"model",$)])),new this(..._)}async _call(o){return await this.forward(o)}async forward(o){return await this._forward(this,o)}_get_logits_processor(o,a,d=null){const g=new LogitsProcessorList;if(o.repetition_penalty!==null&&o.repetition_penalty!==1&&g.push(new RepetitionPenaltyLogitsProcessor(o.repetition_penalty)),o.no_repeat_ngram_size!==null&&o.no_repeat_ngram_size>0&&g.push(new NoRepeatNGramLogitsProcessor(o.no_repeat_ngram_size)),o.bad_words_ids!==null&&g.push(new NoBadWordsLogitsProcessor(o.bad_words_ids,o.eos_token_id)),o.min_length!==null&&o.eos_token_id!==null&&o.min_length>0&&g.push(new MinLengthLogitsProcessor(o.min_length,o.eos_token_id)),o.min_new_tokens!==null&&o.eos_token_id!==null&&o.min_new_tokens>0&&g.push(new MinNewTokensLengthLogitsProcessor(a,o.min_new_tokens,o.eos_token_id)),o.forced_bos_token_id!==null&&g.push(new ForcedBOSTokenLogitsProcessor(o.forced_bos_token_id)),o.forced_eos_token_id!==null&&g.push(new ForcedEOSTokenLogitsProcessor(o.max_length,o.forced_eos_token_id)),o.begin_suppress_tokens!==null){let h=a>1||o.forced_bos_token_id===null?a:a+1;o.forced_decoder_ids!==null&&(h+=o.forced_decoder_ids[o.forced_decoder_ids.length-1][0]),g.push(new SuppressTokensAtBeginLogitsProcessor(o.begin_suppress_tokens,h))}return o.forced_decoder_ids!==null&&g.push(new ForceTokensLogitsProcessor(o.forced_decoder_ids)),d!==null&&g.extend(d),g}_get_generation_config(o){let a=new GenerationConfig(this.config);return"generation_config"in this&&Object.assign(a,this.generation_config),o!==null&&Object.assign(a,o),a}async generate(o,a=null,d=null,{inputs_attention_mask:g=null}={}){if(!this.can_generate){let ct=`The current model class (${MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor)}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;const pt=this.config.model_type,ft=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(pt)??MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES.get(pt)??MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES.get(pt)??MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES.get(pt);throw ft&&(ct+=` Please use the following class instead: '${ft[0]}'`),Error(ct)}if(!(o instanceof Tensor)&&!isTypedArray(o)&&!Array.isArray(o))throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${o.constructor.name}".`);let h;if(this.config.is_encoder_decoder)h=0;else if(h=o instanceof Tensor?o.dims.at(-1):o.length,h===0)throw Error("Must supply a non-empty array of input token ids.");a=this._get_generation_config(a),d=d??new LogitsProcessorList,d=this._get_logits_processor(a,h,d);let et=a.eos_token_id;et!==null&&!Array.isArray(et)&&(et=[et]);let ot=1;const it=ot+(a.max_new_tokens??1/0),$=Number.isInteger(a.max_length)&&(a.max_new_tokens??null)===null;let c=Sampler.getSampler(a),s=this.getStartBeams(o,a,ot,g);for(;s.some(dt=>!dt.done)&&ot<it;){let dt=[];for(let ct of s){if(ct.done){dt.push(ct);continue}if($&&ct.output_token_ids.length>=a.max_length){ct.done=!0,dt.push(ct);continue}let pt=await this.runBeam(ct);a.output_attentions&&this.addAttentionsToBeam(ct,pt),a.output_scores;let ft=pt.logits.slice(null,-1,null);d(ct.output_token_ids,ft);let mt=c(ft);for(let[bt,$t]of mt){let Ct={...ct};this.updateBeam(Ct,bt),Ct.score+=$t,et&&et.includes(bt)&&(Ct.done=!0),dt.push(Ct)}}++ot,dt=this.groupBeams(dt).map(ct=>ct.sort((pt,ft)=>ft.score-pt.score).slice(0,a.num_beams)),s=dt.flat(),a.callback_function&&a.callback_function(s)}const _=this.groupBeams(s),b=dt=>_.map(ct=>a.num_return_sequences>1?ct.slice(0,a.num_return_sequences).map(pt=>pt[dt]):[ct[0][dt]]).flat(),st=b("output_token_ids");if(a.return_dict_in_generate){const dt=b("decoder_attentions"),ct=b("cross_attentions");return{sequences:st,decoder_attentions:dt,cross_attentions:ct}}else return st}addAttentionsToBeam(o,a){if(this.config.is_encoder_decoder){if(!a.cross_attentions||a.cross_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`.");o.cross_attentions||(o.cross_attentions=[]),o.cross_attentions.push(a.cross_attentions)}if(!a.decoder_attentions||a.decoder_attentions.length===0)throw Error("`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`.");o.decoder_attentions||(o.decoder_attentions=[]),o.decoder_attentions.push(a.decoder_attentions)}groupBeams(o){const a=Object.create(null);for(const d of o)a[d.id]===void 0?a[d.id]=[d]:a[d.id].push(d);return Object.values(a)}getPastKeyValues(o,a){const d=Object.create(null);for(const g in o)if(g.startsWith("present")){let h=g.replace("present","past_key_values");a&&g.includes("encoder")?d[h]=a[h]:d[h]=o[g]}return d}getAttentions(o){const a=Object.create(null);for(const d of["cross_attentions","decoder_attentions"]){const g=[];for(const h in o)if(h.startsWith(d)){const et=h.split(".").pop();g[et]=o[h]}a[d]=g}return a}addPastKeyValues(o,a){if(a)Object.assign(o,a);else if(this.config.is_encoder_decoder&&(this.add_encoder_pkv??!0)){let g=[1,this.num_encoder_heads,0,this.encoder_dim_kv],h=[1,this.num_decoder_heads,0,this.decoder_dim_kv];for(let et=0;et<this.num_decoder_layers;++et)o[`past_key_values.${et}.encoder.key`]=new Tensor("float32",[],g),o[`past_key_values.${et}.encoder.value`]=new Tensor("float32",[],g),o[`past_key_values.${et}.decoder.key`]=new Tensor("float32",[],h),o[`past_key_values.${et}.decoder.value`]=new Tensor("float32",[],h)}else if(this.config.model_type==="falcon"){let g=[1*this.num_heads,0,this.dim_kv];for(let h=0;h<this.num_layers;++h)o[`past_key_values.${h}.key`]=new Tensor("float32",[],g),o[`past_key_values.${h}.value`]=new Tensor("float32",[],g)}else if(this.config.multi_query){let g=[1*this.num_heads,0,2*this.dim_kv];for(let h=0;h<this.num_layers;++h)o[`past_key_values.${h}.key_value`]=new Tensor("float32",[],g)}else if(this.config.model_type==="bloom"){let g=[1*this.num_heads,this.dim_kv,0],h=[1*this.num_heads,0,this.dim_kv];for(let et=0;et<this.num_layers;++et)o[`past_key_values.${et}.key`]=new Tensor("float32",[],g),o[`past_key_values.${et}.value`]=new Tensor("float32",[],h)}else{let g=[1,this.num_heads,0,this.dim_kv];for(let h=0;h<this.num_layers;++h)o[`past_key_values.${h}.key`]=new Tensor("float32",[],g),o[`past_key_values.${h}.value`]=new Tensor("float32",[],g)}}getStartBeams(o,a,d,g){return this._getStartBeams(this,o,a,d,g)}async runBeam(o){return await this._runBeam(this,o)}updateBeam(o,a){return this._updateBeam(o,a)}}class ModelOutput{}class BertPreTrainedModel extends PreTrainedModel{}class BertModel extends BertPreTrainedModel{}class BertForMaskedLM extends BertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class BertForSequenceClassification extends BertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class BertForTokenClassification extends BertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class BertForQuestionAnswering extends BertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class NomicBertPreTrainedModel extends PreTrainedModel{}class NomicBertModel extends NomicBertPreTrainedModel{}class RoFormerPreTrainedModel extends PreTrainedModel{}class RoFormerModel extends RoFormerPreTrainedModel{}class RoFormerForMaskedLM extends RoFormerPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class RoFormerForSequenceClassification extends RoFormerPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class RoFormerForTokenClassification extends RoFormerPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class RoFormerForQuestionAnswering extends RoFormerPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class ConvBertPreTrainedModel extends PreTrainedModel{}class ConvBertModel extends ConvBertPreTrainedModel{}class ConvBertForMaskedLM extends ConvBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class ConvBertForSequenceClassification extends ConvBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ConvBertForTokenClassification extends ConvBertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class ConvBertForQuestionAnswering extends ConvBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class ElectraPreTrainedModel extends PreTrainedModel{}class ElectraModel extends ElectraPreTrainedModel{}class ElectraForMaskedLM extends ElectraPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class ElectraForSequenceClassification extends ElectraPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ElectraForTokenClassification extends ElectraPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class ElectraForQuestionAnswering extends ElectraPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class CamembertPreTrainedModel extends PreTrainedModel{}class CamembertModel extends CamembertPreTrainedModel{}class CamembertForMaskedLM extends CamembertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class CamembertForSequenceClassification extends CamembertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class CamembertForTokenClassification extends CamembertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class CamembertForQuestionAnswering extends CamembertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DebertaPreTrainedModel extends PreTrainedModel{}class DebertaModel extends DebertaPreTrainedModel{}class DebertaForMaskedLM extends DebertaPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class DebertaForSequenceClassification extends DebertaPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DebertaForTokenClassification extends DebertaPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class DebertaForQuestionAnswering extends DebertaPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DebertaV2PreTrainedModel extends PreTrainedModel{}class DebertaV2Model extends DebertaV2PreTrainedModel{}class DebertaV2ForMaskedLM extends DebertaV2PreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class DebertaV2ForSequenceClassification extends DebertaV2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DebertaV2ForTokenClassification extends DebertaV2PreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class DebertaV2ForQuestionAnswering extends DebertaV2PreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DistilBertPreTrainedModel extends PreTrainedModel{}class DistilBertModel extends DistilBertPreTrainedModel{}class DistilBertForSequenceClassification extends DistilBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DistilBertForTokenClassification extends DistilBertPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class DistilBertForQuestionAnswering extends DistilBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class DistilBertForMaskedLM extends DistilBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class EsmPreTrainedModel extends PreTrainedModel{}class EsmModel extends EsmPreTrainedModel{}class EsmForMaskedLM extends EsmPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class EsmForSequenceClassification extends EsmPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class EsmForTokenClassification extends EsmPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class MobileBertPreTrainedModel extends PreTrainedModel{}class MobileBertModel extends MobileBertPreTrainedModel{}class MobileBertForMaskedLM extends MobileBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class MobileBertForSequenceClassification extends MobileBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MobileBertForQuestionAnswering extends MobileBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class MPNetPreTrainedModel extends PreTrainedModel{}class MPNetModel extends MPNetPreTrainedModel{}class MPNetForMaskedLM extends MPNetPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class MPNetForSequenceClassification extends MPNetPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MPNetForTokenClassification extends MPNetPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class MPNetForQuestionAnswering extends MPNetPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class SqueezeBertPreTrainedModel extends PreTrainedModel{}class SqueezeBertModel extends SqueezeBertPreTrainedModel{}class SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class AlbertPreTrainedModel extends PreTrainedModel{}class AlbertModel extends AlbertPreTrainedModel{}class AlbertForSequenceClassification extends AlbertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class AlbertForQuestionAnswering extends AlbertPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class AlbertForMaskedLM extends AlbertPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class T5PreTrainedModel extends PreTrainedModel{}class T5Model extends T5PreTrainedModel{}class T5ForConditionalGeneration extends T5PreTrainedModel{constructor(e,o,a,d){super(e,o),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class LongT5PreTrainedModel extends PreTrainedModel{}class LongT5Model extends LongT5PreTrainedModel{}class LongT5ForConditionalGeneration extends LongT5PreTrainedModel{constructor(e,o,a,d){super(e,o),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class MT5PreTrainedModel extends PreTrainedModel{}class MT5Model extends MT5PreTrainedModel{}class MT5ForConditionalGeneration extends MT5PreTrainedModel{constructor(e,o,a,d){super(e,o),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class BartPretrainedModel extends PreTrainedModel{}class BartModel extends BartPretrainedModel{}class BartForConditionalGeneration extends BartPretrainedModel{constructor(e,o,a,d){super(e,o),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BartForSequenceClassification extends BartPretrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MBartPreTrainedModel extends PreTrainedModel{}class MBartModel extends MBartPreTrainedModel{}class MBartForConditionalGeneration extends MBartPreTrainedModel{constructor(e,o,a,d){super(e,o),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class MBartForSequenceClassification extends MBartPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MBartForCausalLM extends MBartPreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotPreTrainedModel extends PreTrainedModel{}class BlenderbotModel extends BlenderbotPreTrainedModel{}class BlenderbotForConditionalGeneration extends BlenderbotPreTrainedModel{constructor(e,o,a,d){super(e,o),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class BlenderbotSmallPreTrainedModel extends PreTrainedModel{}class BlenderbotSmallModel extends BlenderbotSmallPreTrainedModel{}class BlenderbotSmallForConditionalGeneration extends BlenderbotSmallPreTrainedModel{constructor(e,o,a,d){super(e,o),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class RobertaPreTrainedModel extends PreTrainedModel{}class RobertaModel extends RobertaPreTrainedModel{}class RobertaForMaskedLM extends RobertaPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class RobertaForSequenceClassification extends RobertaPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class RobertaForTokenClassification extends RobertaPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class RobertaForQuestionAnswering extends RobertaPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class XLMPreTrainedModel extends PreTrainedModel{}class XLMModel extends XLMPreTrainedModel{}class XLMWithLMHeadModel extends XLMPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class XLMForSequenceClassification extends XLMPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class XLMForTokenClassification extends XLMPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class XLMForQuestionAnswering extends XLMPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class XLMRobertaPreTrainedModel extends PreTrainedModel{}class XLMRobertaModel extends XLMRobertaPreTrainedModel{}class XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel{async _call(e){return new MaskedLMOutput(await super._call(e))}}class XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel{async _call(e){return new QuestionAnsweringModelOutput(await super._call(e))}}class ASTPreTrainedModel extends PreTrainedModel{}class ASTModel extends ASTPreTrainedModel{}class ASTForAudioClassification extends ASTPreTrainedModel{}class WhisperPreTrainedModel extends PreTrainedModel{}class WhisperModel extends WhisperPreTrainedModel{}class WhisperForConditionalGeneration extends WhisperPreTrainedModel{constructor(o,a,d,g){super(o,a);ir(this,"requires_attention_mask",!1);ir(this,"main_input_name","input_features");this.decoder_merged_session=d,this.generation_config=g,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}async generate(o,a=null,d=null){if(a=this._get_generation_config(a),a.return_timestamps??(a.return_timestamps=!1),a.return_timestamps&&(d=[new WhisperTimeStampLogitsProcessor(a)]),a.return_token_timestamps&&(a.output_attentions=!0,a.return_dict_in_generate=!0,a.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),!a.alignment_heads))throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");const g=await super.generate(o,a,d);return a.return_token_timestamps&&a.alignment_heads&&(g.token_timestamps=this._extract_token_timestamps(g,a.alignment_heads,a.num_frames)),g}_extract_token_timestamps(o,a,d=null,g=.02){if(!o.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");let h=this.config.median_filter_width;h===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),h=7);const et=o.cross_attentions.map($=>{let c=Array.from({length:this.config.decoder_layers},(ct,pt)=>cat($.map(ft=>ft[pt]),2)),s=stack(a.map(([ct,pt])=>d?c[ct].slice(null,pt,null,[0,d]):c[ct].slice(null,pt)));s=s.transpose(1,0,2,3);let[_,b]=std_mean(s,-2,0,!0),st=s.clone();for(let ct=0;ct<st.dims[0];++ct){let pt=st[ct];for(let ft=0;ft<pt.dims[0];++ft){let mt=pt[ft];const bt=_[ct][ft][0],$t=b[ct][ft][0];for(let Ct=0;Ct<mt.dims[0];++Ct){let It=mt[Ct];for(let Tt=0;Tt<It.data.length;++Tt)It.data[Tt]=(It.data[Tt]-$t.data[Tt])/bt.data[Tt];It.data.set(medianFilter(It.data,h))}}}return mean(st,1)}),ot=[o.sequences.length,o.sequences[0].length],it=new Tensor("float32",new Float32Array(ot[0]*ot[1]),ot);for(let $=0;$<ot[0];++$){const c=et[$].neg().squeeze_(0);let[s,_]=dynamicTimeWarping(c),b=Array.from({length:s.length-1},(ct,pt)=>s[pt+1]-s[pt]),st=mergeArrays([1],b).map(ct=>!!ct),dt=[];for(let ct=0;ct<st.length;++ct)st[ct]&&dt.push(_[ct]*g);it[$].data.set(dt,1)}return it}}class VisionEncoderDecoderModel extends PreTrainedModel{constructor(o,a,d,g){super(o,a);ir(this,"main_input_name","pixel_values");this.decoder_merged_session=d,this.generation_config=g;const h=this.config.encoder,et=this.config.decoder,ot=h.model_type;(MODEL_MAPPING_NAMES_ENCODER_ONLY.get(ot)??MODEL_MAPPING_NAMES_ENCODER_DECODER.get(ot))||console.warn(`Model type for encoder '${ot}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);const $=MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(et.model_type);if(!$)throw new Error(`Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`);const c=$[1],s=new c(et,d,g);this.add_encoder_pkv="num_decoder_layers"in s,this.add_encoder_pkv?(this.num_decoder_layers=s.num_decoder_layers,this.num_decoder_heads=s.num_decoder_heads,this.decoder_dim_kv=s.decoder_dim_kv,this.num_encoder_layers=s.num_encoder_layers,this.num_encoder_heads=s.num_encoder_heads,this.encoder_dim_kv=s.encoder_dim_kv):(this.num_layers=s.num_layers,this.num_heads=s.num_heads,this.dim_kv=s.dim_kv)}}class CLIPPreTrainedModel extends PreTrainedModel{}class CLIPModel extends CLIPPreTrainedModel{}class CLIPTextModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(e,o={}){return o.model_file_name??(o.model_file_name="text_model"),super.from_pretrained(e,o)}}class CLIPVisionModelWithProjection extends CLIPPreTrainedModel{static async from_pretrained(e,o={}){return o.model_file_name??(o.model_file_name="vision_model"),super.from_pretrained(e,o)}}class SiglipPreTrainedModel extends PreTrainedModel{}class SiglipModel extends SiglipPreTrainedModel{}class SiglipTextModel extends SiglipPreTrainedModel{static async from_pretrained(e,o={}){return o.model_file_name??(o.model_file_name="text_model"),super.from_pretrained(e,o)}}class SiglipVisionModel extends CLIPPreTrainedModel{static async from_pretrained(e,o={}){return o.model_file_name??(o.model_file_name="vision_model"),super.from_pretrained(e,o)}}class ChineseCLIPPreTrainedModel extends PreTrainedModel{}class ChineseCLIPModel extends ChineseCLIPPreTrainedModel{}class CLIPSegPreTrainedModel extends PreTrainedModel{}class CLIPSegModel extends CLIPSegPreTrainedModel{}class CLIPSegForImageSegmentation extends CLIPSegPreTrainedModel{}class GPT2PreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPT2Model extends GPT2PreTrainedModel{}class GPT2LMHeadModel extends GPT2PreTrainedModel{}class GPTNeoPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_heads,this.num_layers=this.config.num_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoModel extends GPTNeoPreTrainedModel{}class GPTNeoForCausalLM extends GPTNeoPreTrainedModel{}class GPTNeoXPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class GPTNeoXModel extends GPTNeoXPreTrainedModel{}class GPTNeoXForCausalLM extends GPTNeoXPreTrainedModel{}class GPTJPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTJModel extends GPTJPreTrainedModel{}class GPTJForCausalLM extends GPTJPreTrainedModel{}class GPTBigCodePreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class GPTBigCodeModel extends GPTBigCodePreTrainedModel{}class GPTBigCodeForCausalLM extends GPTBigCodePreTrainedModel{}class CodeGenPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class CodeGenModel extends CodeGenPreTrainedModel{}class CodeGenForCausalLM extends CodeGenPreTrainedModel{}class LlamaPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class LlamaModel extends LlamaPreTrainedModel{}class LlamaForCausalLM extends LlamaPreTrainedModel{}class Qwen2PreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads??this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Qwen2Model extends Qwen2PreTrainedModel{}class Qwen2ForCausalLM extends Qwen2PreTrainedModel{}class PhiPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class PhiModel extends PhiPreTrainedModel{}class PhiForCausalLM extends PhiPreTrainedModel{}class BloomPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.hidden_size/this.num_heads}}class BloomModel extends BloomPreTrainedModel{}class BloomForCausalLM extends BloomPreTrainedModel{}class MptPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_heads,this.num_layers=this.config.n_layers,this.dim_kv=this.config.d_model/this.num_heads}}class MptModel extends MptPreTrainedModel{}class MptForCausalLM extends MptPreTrainedModel{}class OPTPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class OPTModel extends OPTPreTrainedModel{}class OPTForCausalLM extends OPTPreTrainedModel{}class ViTPreTrainedModel extends PreTrainedModel{}class ViTModel extends ViTPreTrainedModel{}class ViTForImageClassification extends ViTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class FastViTPreTrainedModel extends PreTrainedModel{}class FastViTModel extends FastViTPreTrainedModel{}class FastViTForImageClassification extends FastViTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class VitMattePreTrainedModel extends PreTrainedModel{}class VitMatteForImageMatting extends VitMattePreTrainedModel{async _call(e){return new ImageMattingOutput(await super._call(e))}}class MobileViTPreTrainedModel extends PreTrainedModel{}class MobileViTModel extends MobileViTPreTrainedModel{}class MobileViTForImageClassification extends MobileViTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class MobileViTV2PreTrainedModel extends PreTrainedModel{}class MobileViTV2Model extends MobileViTV2PreTrainedModel{}class MobileViTV2ForImageClassification extends MobileViTV2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class OwlViTPreTrainedModel extends PreTrainedModel{}class OwlViTModel extends OwlViTPreTrainedModel{}class OwlViTForObjectDetection extends OwlViTPreTrainedModel{}class Owlv2PreTrainedModel extends PreTrainedModel{}class Owlv2Model extends Owlv2PreTrainedModel{}class Owlv2ForObjectDetection extends Owlv2PreTrainedModel{}class BeitPreTrainedModel extends PreTrainedModel{}class BeitModel extends BeitPreTrainedModel{}class BeitForImageClassification extends BeitPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class DetrPreTrainedModel extends PreTrainedModel{}class DetrModel extends DetrPreTrainedModel{}class DetrForObjectDetection extends DetrPreTrainedModel{async _call(e){return new DetrObjectDetectionOutput(await super._call(e))}}class DetrForSegmentation extends DetrPreTrainedModel{async _call(e){return new DetrSegmentationOutput(await super._call(e))}}class DetrObjectDetectionOutput extends ModelOutput{constructor({logits:e,pred_boxes:o}){super(),this.logits=e,this.pred_boxes=o}}class DetrSegmentationOutput extends ModelOutput{constructor({logits:e,pred_boxes:o,pred_masks:a}){super(),this.logits=e,this.pred_boxes=o,this.pred_masks=a}}class TableTransformerPreTrainedModel extends PreTrainedModel{}class TableTransformerModel extends TableTransformerPreTrainedModel{}class TableTransformerForObjectDetection extends TableTransformerPreTrainedModel{async _call(e){return new TableTransformerObjectDetectionOutput(await super._call(e))}}class TableTransformerObjectDetectionOutput extends DetrObjectDetectionOutput{}class DeiTPreTrainedModel extends PreTrainedModel{}class DeiTModel extends DeiTPreTrainedModel{}class DeiTForImageClassification extends DeiTPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ResNetPreTrainedModel extends PreTrainedModel{}class ResNetModel extends ResNetPreTrainedModel{}class ResNetForImageClassification extends ResNetPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class SwinPreTrainedModel extends PreTrainedModel{}class SwinModel extends SwinPreTrainedModel{}class SwinForImageClassification extends SwinPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class Swin2SRPreTrainedModel extends PreTrainedModel{}class Swin2SRModel extends Swin2SRPreTrainedModel{}class Swin2SRForImageSuperResolution extends Swin2SRPreTrainedModel{}class DPTPreTrainedModel extends PreTrainedModel{}class DPTModel extends DPTPreTrainedModel{}class DPTForDepthEstimation extends DPTPreTrainedModel{}class DepthAnythingPreTrainedModel extends PreTrainedModel{}class DepthAnythingForDepthEstimation extends DepthAnythingPreTrainedModel{}class GLPNPreTrainedModel extends PreTrainedModel{}class GLPNModel extends GLPNPreTrainedModel{}class GLPNForDepthEstimation extends GLPNPreTrainedModel{}class DonutSwinPreTrainedModel extends PreTrainedModel{}class DonutSwinModel extends DonutSwinPreTrainedModel{}class ConvNextPreTrainedModel extends PreTrainedModel{}class ConvNextModel extends ConvNextPreTrainedModel{}class ConvNextForImageClassification extends ConvNextPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class ConvNextV2PreTrainedModel extends PreTrainedModel{}class ConvNextV2Model extends ConvNextV2PreTrainedModel{}class ConvNextV2ForImageClassification extends ConvNextV2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class Dinov2PreTrainedModel extends PreTrainedModel{}class Dinov2Model extends Dinov2PreTrainedModel{}class Dinov2ForImageClassification extends Dinov2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class YolosPreTrainedModel extends PreTrainedModel{}class YolosModel extends YolosPreTrainedModel{}class YolosForObjectDetection extends YolosPreTrainedModel{async _call(e){return new YolosObjectDetectionOutput(await super._call(e))}}class YolosObjectDetectionOutput extends ModelOutput{constructor({logits:e,pred_boxes:o}){super(),this.logits=e,this.pred_boxes=o}}class SamPreTrainedModel extends PreTrainedModel{}class SamModel extends SamPreTrainedModel{constructor(e,o,a){super(e,o),this.prompt_encoder_mask_decoder=a}async get_image_embeddings({pixel_values:e}){return await encoderForward(this,{pixel_values:e})}async forward(e){if((!e.image_embeddings||!e.image_positional_embeddings)&&(e={...e,...await this.get_image_embeddings(e)}),!e.input_labels){const o=e.input_points.dims.slice(0,-1),a=o.reduce((d,g)=>d*g,1);e.input_labels=new Tensor("int64",new BigInt64Array(a).fill(1n),o)}return await sessionRun(this.prompt_encoder_mask_decoder,{input_points:e.input_points,input_labels:e.input_labels,image_embeddings:e.image_embeddings,image_positional_embeddings:e.image_positional_embeddings})}async _call(e){return new SamImageSegmentationOutput(await super._call(e))}}class SamImageSegmentationOutput extends ModelOutput{constructor({iou_scores:e,pred_masks:o}){super(),this.iou_scores=e,this.pred_masks=o}}class MarianPreTrainedModel extends PreTrainedModel{}class MarianModel extends MarianPreTrainedModel{}class MarianMTModel extends MarianPreTrainedModel{constructor(e,o,a,d){super(e,o),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class M2M100PreTrainedModel extends PreTrainedModel{}class M2M100Model extends M2M100PreTrainedModel{}class M2M100ForConditionalGeneration extends M2M100PreTrainedModel{constructor(e,o,a,d){super(e,o),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class Wav2Vec2PreTrainedModel extends PreTrainedModel{}class Wav2Vec2Model extends Wav2Vec2PreTrainedModel{}class Wav2Vec2ForCTC extends Wav2Vec2PreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class Wav2Vec2ForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class Wav2Vec2ForAudioFrameClassification extends Wav2Vec2PreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class UniSpeechPreTrainedModel extends PreTrainedModel{}class UniSpeechModel extends UniSpeechPreTrainedModel{}class UniSpeechForCTC extends UniSpeechPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class UniSpeechForSequenceClassification extends UniSpeechPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class UniSpeechSatPreTrainedModel extends PreTrainedModel{}class UniSpeechSatModel extends UniSpeechSatPreTrainedModel{}class UniSpeechSatForCTC extends UniSpeechSatPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class UniSpeechSatForSequenceClassification extends UniSpeechSatPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class UniSpeechSatForAudioFrameClassification extends UniSpeechSatPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class Wav2Vec2BertPreTrainedModel extends PreTrainedModel{}class Wav2Vec2BertModel extends Wav2Vec2BertPreTrainedModel{}class Wav2Vec2BertForCTC extends Wav2Vec2BertPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class Wav2Vec2BertForSequenceClassification extends Wav2Vec2BertPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class HubertModel extends Wav2Vec2PreTrainedModel{}class HubertForCTC extends Wav2Vec2PreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class HubertForSequenceClassification extends Wav2Vec2PreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class WavLMPreTrainedModel extends PreTrainedModel{}class WavLMModel extends WavLMPreTrainedModel{}class WavLMForCTC extends WavLMPreTrainedModel{async _call(e){return new CausalLMOutput(await super._call(e))}}class WavLMForSequenceClassification extends WavLMPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class WavLMForXVector extends WavLMPreTrainedModel{async _call(e){return new XVectorOutput(await super._call(e))}}class WavLMForAudioFrameClassification extends WavLMPreTrainedModel{async _call(e){return new TokenClassifierOutput(await super._call(e))}}class SpeechT5PreTrainedModel extends PreTrainedModel{}class SpeechT5ForSpeechToText extends SpeechT5PreTrainedModel{}class SpeechT5ForTextToSpeech extends SpeechT5PreTrainedModel{constructor(e,o,a,d){super(e,o),this.decoder_merged_session=a,this.generation_config=d,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.hidden_size/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.hidden_size/this.num_encoder_heads}async generate_speech(e,o,{threshold:a=.5,minlenratio:d=0,maxlenratio:g=20,vocoder:h=null}={}){const et={input_ids:e},{encoder_outputs:ot,encoder_attention_mask:it}=await encoderForward(this,et),$=ot.dims[1]/this.config.reduction_factor,c=Math.floor($*g),s=Math.floor($*d),_=this.config.num_mel_bins;let b=[],st=null,dt=null,ct=0;for(;;){++ct;const mt=boolTensor(!!dt);let bt;dt?bt=dt.output_sequence_out:bt=new Tensor("float32",new Float32Array(_),[1,1,_]);let $t={use_cache_branch:mt,output_sequence:bt,encoder_attention_mask:it,speaker_embeddings:o,encoder_hidden_states:ot};this.addPastKeyValues($t,st),dt=await sessionRun(this.decoder_merged_session,$t),st=this.getPastKeyValues(dt,st);const{prob:Ct,spectrum:It}=dt;if(b.push(It),ct>=s&&(Array.from(Ct.data).filter(Tt=>Tt>=a).length>0||ct>=c))break}const pt=cat(b),{waveform:ft}=await sessionRun(h.session,{spectrogram:pt});return{spectrogram:pt,waveform:ft}}}class SpeechT5HifiGan extends PreTrainedModel{constructor(){super(...arguments);ir(this,"main_input_name","spectrogram")}}class TrOCRPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_encoder_layers=this.num_decoder_layers=this.config.decoder_layers,this.num_encoder_heads=this.num_decoder_heads=this.config.decoder_attention_heads,this.encoder_dim_kv=this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads}}class TrOCRForCausalLM extends TrOCRPreTrainedModel{}class MistralPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class MistralModel extends MistralPreTrainedModel{}class MistralForCausalLM extends MistralPreTrainedModel{}class Starcoder2PreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_key_value_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class Starcoder2Model extends Starcoder2PreTrainedModel{}class Starcoder2ForCausalLM extends Starcoder2PreTrainedModel{}class FalconPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.config.num_attention_heads}}class FalconModel extends FalconPreTrainedModel{}class FalconForCausalLM extends FalconPreTrainedModel{}class ClapPreTrainedModel extends PreTrainedModel{}class ClapModel extends ClapPreTrainedModel{}class ClapTextModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(e,o={}){return o.model_file_name??(o.model_file_name="text_model"),super.from_pretrained(e,o)}}class ClapAudioModelWithProjection extends ClapPreTrainedModel{static async from_pretrained(e,o={}){return o.model_file_name??(o.model_file_name="audio_model"),super.from_pretrained(e,o)}}class VitsPreTrainedModel extends PreTrainedModel{}class VitsModel extends VitsPreTrainedModel{async _call(e){return new VitsModelOutput(await super._call(e))}}class SegformerPreTrainedModel extends PreTrainedModel{}class SegformerForImageClassification extends SegformerPreTrainedModel{}class SegformerForSemanticSegmentation extends SegformerPreTrainedModel{}class StableLmPreTrainedModel extends PreTrainedModel{constructor(e,o,a){super(e,o),this.generation_config=a,this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class StableLmForCausalLM extends StableLmPreTrainedModel{}class EfficientNetPreTrainedModel extends PreTrainedModel{}class EfficientNetModel extends EfficientNetPreTrainedModel{}class EfficientNetForImageClassification extends EfficientNetPreTrainedModel{async _call(e){return new SequenceClassifierOutput(await super._call(e))}}class PretrainedMixin{static async from_pretrained(e,{quantized:o=!0,progress_callback:a=null,config:d=null,cache_dir:g=null,local_files_only:h=!1,revision:et="main",model_file_name:ot=null}={}){let it={quantized:o,progress_callback:a,config:d,cache_dir:g,local_files_only:h,revision:et,model_file_name:ot};if(d=await AutoConfig.from_pretrained(e,it),it.config||(it.config=d),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(let $ of this.MODEL_CLASS_MAPPINGS){const c=$.get(d.model_type);if(c)return await c[1].from_pretrained(e,it)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${d.model_type}", attempting to construct from base class.`),await PreTrainedModel.from_pretrained(e,it);throw Error(`Unsupported model type: ${d.model_type}`)}}ir(PretrainedMixin,"MODEL_CLASS_MAPPINGS",null),ir(PretrainedMixin,"BASE_IF_FAIL",!1);const MODEL_MAPPING_NAMES_ENCODER_ONLY=new Map([["bert",["BertModel",BertModel]],["nomic_bert",["NomicBertModel",NomicBertModel]],["roformer",["RoFormerModel",RoFormerModel]],["electra",["ElectraModel",ElectraModel]],["esm",["EsmModel",EsmModel]],["convbert",["ConvBertModel",ConvBertModel]],["camembert",["CamembertModel",CamembertModel]],["deberta",["DebertaModel",DebertaModel]],["deberta-v2",["DebertaV2Model",DebertaV2Model]],["mpnet",["MPNetModel",MPNetModel]],["albert",["AlbertModel",AlbertModel]],["distilbert",["DistilBertModel",DistilBertModel]],["roberta",["RobertaModel",RobertaModel]],["xlm",["XLMModel",XLMModel]],["xlm-roberta",["XLMRobertaModel",XLMRobertaModel]],["clap",["ClapModel",ClapModel]],["clip",["CLIPModel",CLIPModel]],["clipseg",["CLIPSegModel",CLIPSegModel]],["chinese_clip",["ChineseCLIPModel",ChineseCLIPModel]],["siglip",["SiglipModel",SiglipModel]],["mobilebert",["MobileBertModel",MobileBertModel]],["squeezebert",["SqueezeBertModel",SqueezeBertModel]],["wav2vec2",["Wav2Vec2Model",Wav2Vec2Model]],["wav2vec2-bert",["Wav2Vec2BertModel",Wav2Vec2BertModel]],["unispeech",["UniSpeechModel",UniSpeechModel]],["unispeech-sat",["UniSpeechSatModel",UniSpeechSatModel]],["hubert",["HubertModel",HubertModel]],["wavlm",["WavLMModel",WavLMModel]],["audio-spectrogram-transformer",["ASTModel",ASTModel]],["vits",["VitsModel",VitsModel]],["detr",["DetrModel",DetrModel]],["table-transformer",["TableTransformerModel",TableTransformerModel]],["vit",["ViTModel",ViTModel]],["fastvit",["FastViTModel",FastViTModel]],["mobilevit",["MobileViTModel",MobileViTModel]],["mobilevitv2",["MobileViTV2Model",MobileViTV2Model]],["owlvit",["OwlViTModel",OwlViTModel]],["owlv2",["Owlv2Model",Owlv2Model]],["beit",["BeitModel",BeitModel]],["deit",["DeiTModel",DeiTModel]],["convnext",["ConvNextModel",ConvNextModel]],["convnextv2",["ConvNextV2Model",ConvNextV2Model]],["dinov2",["Dinov2Model",Dinov2Model]],["resnet",["ResNetModel",ResNetModel]],["swin",["SwinModel",SwinModel]],["swin2sr",["Swin2SRModel",Swin2SRModel]],["donut-swin",["DonutSwinModel",DonutSwinModel]],["yolos",["YolosModel",YolosModel]],["dpt",["DPTModel",DPTModel]],["glpn",["GLPNModel",GLPNModel]],["hifigan",["SpeechT5HifiGan",SpeechT5HifiGan]],["efficientnet",["EfficientNetModel",EfficientNetModel]]]),MODEL_MAPPING_NAMES_ENCODER_DECODER=new Map([["t5",["T5Model",T5Model]],["longt5",["LongT5Model",LongT5Model]],["mt5",["MT5Model",MT5Model]],["bart",["BartModel",BartModel]],["mbart",["MBartModel",MBartModel]],["marian",["MarianModel",MarianModel]],["whisper",["WhisperModel",WhisperModel]],["m2m_100",["M2M100Model",M2M100Model]],["blenderbot",["BlenderbotModel",BlenderbotModel]],["blenderbot-small",["BlenderbotSmallModel",BlenderbotSmallModel]]]),MODEL_MAPPING_NAMES_DECODER_ONLY=new Map([["bloom",["BloomModel",BloomModel]],["gpt2",["GPT2Model",GPT2Model]],["gptj",["GPTJModel",GPTJModel]],["gpt_bigcode",["GPTBigCodeModel",GPTBigCodeModel]],["gpt_neo",["GPTNeoModel",GPTNeoModel]],["gpt_neox",["GPTNeoXModel",GPTNeoXModel]],["codegen",["CodeGenModel",CodeGenModel]],["llama",["LlamaModel",LlamaModel]],["qwen2",["Qwen2Model",Qwen2Model]],["phi",["PhiModel",PhiModel]],["mpt",["MptModel",MptModel]],["opt",["OPTModel",OPTModel]],["mistral",["MistralModel",MistralModel]],["starcoder2",["Starcoder2Model",Starcoder2Model]],["falcon",["FalconModel",FalconModel]]]),MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForSpeechToText",SpeechT5ForSpeechToText]],["whisper",["WhisperForConditionalGeneration",WhisperForConditionalGeneration]]]),MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES=new Map([["speecht5",["SpeechT5ForTextToSpeech",SpeechT5ForTextToSpeech]]]),MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES=new Map([["vits",["VitsModel",VitsModel]]]),MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForSequenceClassification",BertForSequenceClassification]],["roformer",["RoFormerForSequenceClassification",RoFormerForSequenceClassification]],["electra",["ElectraForSequenceClassification",ElectraForSequenceClassification]],["esm",["EsmForSequenceClassification",EsmForSequenceClassification]],["convbert",["ConvBertForSequenceClassification",ConvBertForSequenceClassification]],["camembert",["CamembertForSequenceClassification",CamembertForSequenceClassification]],["deberta",["DebertaForSequenceClassification",DebertaForSequenceClassification]],["deberta-v2",["DebertaV2ForSequenceClassification",DebertaV2ForSequenceClassification]],["mpnet",["MPNetForSequenceClassification",MPNetForSequenceClassification]],["albert",["AlbertForSequenceClassification",AlbertForSequenceClassification]],["distilbert",["DistilBertForSequenceClassification",DistilBertForSequenceClassification]],["roberta",["RobertaForSequenceClassification",RobertaForSequenceClassification]],["xlm",["XLMForSequenceClassification",XLMForSequenceClassification]],["xlm-roberta",["XLMRobertaForSequenceClassification",XLMRobertaForSequenceClassification]],["bart",["BartForSequenceClassification",BartForSequenceClassification]],["mbart",["MBartForSequenceClassification",MBartForSequenceClassification]],["mobilebert",["MobileBertForSequenceClassification",MobileBertForSequenceClassification]],["squeezebert",["SqueezeBertForSequenceClassification",SqueezeBertForSequenceClassification]]]),MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForTokenClassification",BertForTokenClassification]],["roformer",["RoFormerForTokenClassification",RoFormerForTokenClassification]],["electra",["ElectraForTokenClassification",ElectraForTokenClassification]],["esm",["EsmForTokenClassification",EsmForTokenClassification]],["convbert",["ConvBertForTokenClassification",ConvBertForTokenClassification]],["camembert",["CamembertForTokenClassification",CamembertForTokenClassification]],["deberta",["DebertaForTokenClassification",DebertaForTokenClassification]],["deberta-v2",["DebertaV2ForTokenClassification",DebertaV2ForTokenClassification]],["mpnet",["MPNetForTokenClassification",MPNetForTokenClassification]],["distilbert",["DistilBertForTokenClassification",DistilBertForTokenClassification]],["roberta",["RobertaForTokenClassification",RobertaForTokenClassification]],["xlm",["XLMForTokenClassification",XLMForTokenClassification]],["xlm-roberta",["XLMRobertaForTokenClassification",XLMRobertaForTokenClassification]]]),MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES=new Map([["t5",["T5ForConditionalGeneration",T5ForConditionalGeneration]],["longt5",["LongT5ForConditionalGeneration",LongT5ForConditionalGeneration]],["mt5",["MT5ForConditionalGeneration",MT5ForConditionalGeneration]],["bart",["BartForConditionalGeneration",BartForConditionalGeneration]],["mbart",["MBartForConditionalGeneration",MBartForConditionalGeneration]],["marian",["MarianMTModel",MarianMTModel]],["m2m_100",["M2M100ForConditionalGeneration",M2M100ForConditionalGeneration]],["blenderbot",["BlenderbotForConditionalGeneration",BlenderbotForConditionalGeneration]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",BlenderbotSmallForConditionalGeneration]]]),MODEL_WITH_LM_HEAD_MAPPING_NAMES=new Map([["bloom",["BloomForCausalLM",BloomForCausalLM]],["gpt2",["GPT2LMHeadModel",GPT2LMHeadModel]],["gptj",["GPTJForCausalLM",GPTJForCausalLM]],["gpt_bigcode",["GPTBigCodeForCausalLM",GPTBigCodeForCausalLM]],["gpt_neo",["GPTNeoForCausalLM",GPTNeoForCausalLM]],["gpt_neox",["GPTNeoXForCausalLM",GPTNeoXForCausalLM]],["codegen",["CodeGenForCausalLM",CodeGenForCausalLM]],["llama",["LlamaForCausalLM",LlamaForCausalLM]],["qwen2",["Qwen2ForCausalLM",Qwen2ForCausalLM]],["phi",["PhiForCausalLM",PhiForCausalLM]],["mpt",["MptForCausalLM",MptForCausalLM]],["opt",["OPTForCausalLM",OPTForCausalLM]],["mbart",["MBartForCausalLM",MBartForCausalLM]],["mistral",["MistralForCausalLM",MistralForCausalLM]],["starcoder2",["Starcoder2ForCausalLM",Starcoder2ForCausalLM]],["falcon",["FalconForCausalLM",FalconForCausalLM]],["trocr",["TrOCRForCausalLM",TrOCRForCausalLM]],["stablelm",["StableLmForCausalLM",StableLmForCausalLM]]]),MODEL_FOR_MASKED_LM_MAPPING_NAMES=new Map([["bert",["BertForMaskedLM",BertForMaskedLM]],["roformer",["RoFormerForMaskedLM",RoFormerForMaskedLM]],["electra",["ElectraForMaskedLM",ElectraForMaskedLM]],["esm",["EsmForMaskedLM",EsmForMaskedLM]],["convbert",["ConvBertForMaskedLM",ConvBertForMaskedLM]],["camembert",["CamembertForMaskedLM",CamembertForMaskedLM]],["deberta",["DebertaForMaskedLM",DebertaForMaskedLM]],["deberta-v2",["DebertaV2ForMaskedLM",DebertaV2ForMaskedLM]],["mpnet",["MPNetForMaskedLM",MPNetForMaskedLM]],["albert",["AlbertForMaskedLM",AlbertForMaskedLM]],["distilbert",["DistilBertForMaskedLM",DistilBertForMaskedLM]],["roberta",["RobertaForMaskedLM",RobertaForMaskedLM]],["xlm",["XLMWithLMHeadModel",XLMWithLMHeadModel]],["xlm-roberta",["XLMRobertaForMaskedLM",XLMRobertaForMaskedLM]],["mobilebert",["MobileBertForMaskedLM",MobileBertForMaskedLM]],["squeezebert",["SqueezeBertForMaskedLM",SqueezeBertForMaskedLM]]]),MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES=new Map([["bert",["BertForQuestionAnswering",BertForQuestionAnswering]],["roformer",["RoFormerForQuestionAnswering",RoFormerForQuestionAnswering]],["electra",["ElectraForQuestionAnswering",ElectraForQuestionAnswering]],["convbert",["ConvBertForQuestionAnswering",ConvBertForQuestionAnswering]],["camembert",["CamembertForQuestionAnswering",CamembertForQuestionAnswering]],["deberta",["DebertaForQuestionAnswering",DebertaForQuestionAnswering]],["deberta-v2",["DebertaV2ForQuestionAnswering",DebertaV2ForQuestionAnswering]],["mpnet",["MPNetForQuestionAnswering",MPNetForQuestionAnswering]],["albert",["AlbertForQuestionAnswering",AlbertForQuestionAnswering]],["distilbert",["DistilBertForQuestionAnswering",DistilBertForQuestionAnswering]],["roberta",["RobertaForQuestionAnswering",RobertaForQuestionAnswering]],["xlm",["XLMForQuestionAnswering",XLMForQuestionAnswering]],["xlm-roberta",["XLMRobertaForQuestionAnswering",XLMRobertaForQuestionAnswering]],["mobilebert",["MobileBertForQuestionAnswering",MobileBertForQuestionAnswering]],["squeezebert",["SqueezeBertForQuestionAnswering",SqueezeBertForQuestionAnswering]]]),MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",VisionEncoderDecoderModel]]]),MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES=new Map([["vit",["ViTForImageClassification",ViTForImageClassification]],["fastvit",["FastViTForImageClassification",FastViTForImageClassification]],["mobilevit",["MobileViTForImageClassification",MobileViTForImageClassification]],["mobilevitv2",["MobileViTV2ForImageClassification",MobileViTV2ForImageClassification]],["beit",["BeitForImageClassification",BeitForImageClassification]],["deit",["DeiTForImageClassification",DeiTForImageClassification]],["convnext",["ConvNextForImageClassification",ConvNextForImageClassification]],["convnextv2",["ConvNextV2ForImageClassification",ConvNextV2ForImageClassification]],["dinov2",["Dinov2ForImageClassification",Dinov2ForImageClassification]],["resnet",["ResNetForImageClassification",ResNetForImageClassification]],["swin",["SwinForImageClassification",SwinForImageClassification]],["segformer",["SegformerForImageClassification",SegformerForImageClassification]],["efficientnet",["EfficientNetForImageClassification",EfficientNetForImageClassification]]]),MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES=new Map([["detr",["DetrForObjectDetection",DetrForObjectDetection]],["table-transformer",["TableTransformerForObjectDetection",TableTransformerForObjectDetection]],["yolos",["YolosForObjectDetection",YolosForObjectDetection]]]),MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES=new Map([["owlvit",["OwlViTForObjectDetection",OwlViTForObjectDetection]],["owlv2",["Owlv2ForObjectDetection",Owlv2ForObjectDetection]]]),MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES=new Map([["detr",["DetrForSegmentation",DetrForSegmentation]],["clipseg",["CLIPSegForImageSegmentation",CLIPSegForImageSegmentation]]]),MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES=new Map([["segformer",["SegformerForSemanticSegmentation",SegformerForSemanticSegmentation]]]),MODEL_FOR_MASK_GENERATION_MAPPING_NAMES=new Map([["sam",["SamModel",SamModel]]]),MODEL_FOR_CTC_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForCTC",Wav2Vec2ForCTC]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Wav2Vec2BertForCTC]],["unispeech",["UniSpeechForCTC",UniSpeechForCTC]],["unispeech-sat",["UniSpeechSatForCTC",UniSpeechSatForCTC]],["wavlm",["WavLMForCTC",WavLMForCTC]],["hubert",["HubertForCTC",HubertForCTC]]]),MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Wav2Vec2ForSequenceClassification]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Wav2Vec2BertForSequenceClassification]],["unispeech",["UniSpeechForSequenceClassification",UniSpeechForSequenceClassification]],["unispeech-sat",["UniSpeechSatForSequenceClassification",UniSpeechSatForSequenceClassification]],["wavlm",["WavLMForSequenceClassification",WavLMForSequenceClassification]],["hubert",["HubertForSequenceClassification",HubertForSequenceClassification]],["audio-spectrogram-transformer",["ASTForAudioClassification",ASTForAudioClassification]]]),MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES=new Map([["wavlm",["WavLMForXVector",WavLMForXVector]]]),MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",UniSpeechSatForAudioFrameClassification]],["wavlm",["WavLMForAudioFrameClassification",WavLMForAudioFrameClassification]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Wav2Vec2ForAudioFrameClassification]]]),MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES=new Map([["vitmatte",["VitMatteForImageMatting",VitMatteForImageMatting]]]),MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Swin2SRForImageSuperResolution]]]),MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES=new Map([["dpt",["DPTForDepthEstimation",DPTForDepthEstimation]],["depth_anything",["DepthAnythingForDepthEstimation",DepthAnythingForDepthEstimation]],["glpn",["GLPNForDepthEstimation",GLPNForDepthEstimation]]]),MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES=new Map([["clip",["CLIPVisionModelWithProjection",CLIPVisionModelWithProjection]],["siglip",["SiglipVisionModel",SiglipVisionModel]]]),MODEL_CLASS_TYPE_MAPPING=[[MODEL_MAPPING_NAMES_ENCODER_ONLY,MODEL_TYPES.EncoderOnly],[MODEL_MAPPING_NAMES_ENCODER_DECODER,MODEL_TYPES.EncoderDecoder],[MODEL_MAPPING_NAMES_DECODER_ONLY,MODEL_TYPES.DecoderOnly],[MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_WITH_LM_HEAD_MAPPING_NAMES,MODEL_TYPES.DecoderOnly],[MODEL_FOR_MASKED_LM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES,MODEL_TYPES.Vision2Seq],[MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_MASK_GENERATION_MAPPING_NAMES,MODEL_TYPES.MaskGeneration],[MODEL_FOR_CTC_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES,MODEL_TYPES.Seq2Seq],[MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly],[MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES,MODEL_TYPES.EncoderOnly]];for(const[i,e]of MODEL_CLASS_TYPE_MAPPING)for(const[o,a]of i.values())MODEL_TYPE_MAPPING.set(o,e),MODEL_CLASS_TO_NAME_MAPPING.set(a,o),MODEL_NAME_TO_CLASS_MAPPING.set(o,a);const CUSTOM_MAPPING=[["CLIPTextModelWithProjection",CLIPTextModelWithProjection,MODEL_TYPES.EncoderOnly],["SiglipTextModel",SiglipTextModel,MODEL_TYPES.EncoderOnly],["ClapTextModelWithProjection",ClapTextModelWithProjection,MODEL_TYPES.EncoderOnly],["ClapAudioModelWithProjection",ClapAudioModelWithProjection,MODEL_TYPES.EncoderOnly]];for(const[i,e,o]of CUSTOM_MAPPING)MODEL_TYPE_MAPPING.set(i,o),MODEL_CLASS_TO_NAME_MAPPING.set(e,i),MODEL_NAME_TO_CLASS_MAPPING.set(i,e);class AutoModel extends PretrainedMixin{}ir(AutoModel,"MODEL_CLASS_MAPPINGS",MODEL_CLASS_TYPE_MAPPING.map(e=>e[0])),ir(AutoModel,"BASE_IF_FAIL",!0);class Seq2SeqLMOutput extends ModelOutput{constructor({logits:e,past_key_values:o,encoder_outputs:a,decoder_attentions:d=null,cross_attentions:g=null}){super(),this.logits=e,this.past_key_values=o,this.encoder_outputs=a,this.decoder_attentions=d,this.cross_attentions=g}}class SequenceClassifierOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class XVectorOutput extends ModelOutput{constructor({logits:e,embeddings:o}){super(),this.logits=e,this.embeddings=o}}class TokenClassifierOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class MaskedLMOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class QuestionAnsweringModelOutput extends ModelOutput{constructor({start_logits:e,end_logits:o}){super(),this.start_logits=e,this.end_logits=o}}class CausalLMOutput extends ModelOutput{constructor({logits:e}){super(),this.logits=e}}class ImageMattingOutput extends ModelOutput{constructor({alphas:e}){super(),this.alphas=e}}class VitsModelOutput extends ModelOutput{constructor({waveform:e,spectrogram:o}){super(),this.waveform=e,this.spectrogram=o}}const BROWSER_ENV=typeof self<"u";if(!BROWSER_ENV){if(!sharp)throw new Error("Unable to load image processing library.")}/*!
 * ONNX Runtime Web v1.19.0-dev.20240509-69cfcba38a
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var Oi=Object.defineProperty,nc=Object.getOwnPropertyDescriptor,ic=Object.getOwnPropertyNames,ac=Object.prototype.hasOwnProperty,j=(i,e)=>()=>(i&&(e=i(i=0)),e),Er=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),kr=(i,e)=>{for(var o in e)Oi(i,o,{get:e[o],enumerable:!0})},oc=(i,e,o,a)=>{if(e&&typeof e=="object"||typeof e=="function")for(let d of ic(e))!ac.call(i,d)&&d!==o&&Oi(i,d,{get:()=>e[d],enumerable:!(a=nc(e,d))||a.enumerable});return i},sr=i=>oc(Oi({},"__esModule",{value:!0}),i),kn,ur,lr,sc,On,Pn=j(()=>{kn=new Map,ur=[],lr=(i,e,o)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let a=kn.get(i);if(a===void 0)kn.set(i,{backend:e,priority:o});else{if(a.priority>o)return;if(a.priority===o&&a.backend!==e)throw new Error(`cannot register backend "${i}" using priority ${o}`)}if(o>=0){let d=ur.indexOf(i);d!==-1&&ur.splice(d,1);for(let g=0;g<ur.length;g++)if(kn.get(ur[g]).priority<=o){ur.splice(g,0,i);return}ur.push(i)}return}throw new TypeError("not a valid backend")},sc=async i=>{let e=kn.get(i);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let o=!!e.initPromise;try{return o||(e.initPromise=e.backend.init(i)),await e.initPromise,e.initialized=!0,e.backend}catch(a){return o||(e.error=`${a}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},On=async i=>{let e=i.executionProviders||[],o=e.map(ot=>typeof ot=="string"?ot:ot.name),a=o.length===0?ur:o,d,g=[],h=new Set;for(let ot of a){let it=await sc(ot);typeof it=="string"?g.push({name:ot,err:it}):(d||(d=it),d===it&&h.add(ot))}if(!d)throw new Error(`no available backend found. ERR: ${g.map(ot=>`[${ot.name}] ${ot.err}`).join(", ")}`);for(let{name:ot,err:it}of g)o.includes(ot)&&console.warn(`removing requested execution provider "${ot}" from session options because it is not available: ${it}`);let et=e.filter(ot=>h.has(typeof ot=="string"?ot:ot.name));return[d,new Proxy(i,{get:(ot,it)=>it==="executionProviders"?et:Reflect.get(ot,it)})]}}),to=j(()=>{Pn()}),ro,no=j(()=>{ro="1.18.0-dev.20240424-218b6b0a73"}),io,gt,Pi=j(()=>{no(),io="warning",gt={wasm:{},webgl:{},webgpu:{},versions:{common:ro},set logLevel(i){if(i!==void 0){if(typeof i!="string"||["verbose","info","warning","error","fatal"].indexOf(i)===-1)throw new Error(`Unsupported logging level: ${i}`);io=i}},get logLevel(){return io}},Object.defineProperty(gt,"logLevel",{enumerable:!0})}),ke,ao=j(()=>{Pi(),ke=gt}),oo,so,uo=j(()=>{oo=(i,e)=>{let o=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);o.width=i.dims[3],o.height=i.dims[2];let a=o.getContext("2d");if(a!=null){let d,g;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(d=i.dims[2],g=i.dims[3]):(d=i.dims[3],g=i.dims[2]);let h=(e==null?void 0:e.format)!==void 0?e.format:"RGB",et=e==null?void 0:e.norm,ot,it;et===void 0||et.mean===void 0?ot=[255,255,255,255]:typeof et.mean=="number"?ot=[et.mean,et.mean,et.mean,et.mean]:(ot=[et.mean[0],et.mean[1],et.mean[2],0],et.mean[3]!==void 0&&(ot[3]=et.mean[3])),et===void 0||et.bias===void 0?it=[0,0,0,0]:typeof et.bias=="number"?it=[et.bias,et.bias,et.bias,et.bias]:(it=[et.bias[0],et.bias[1],et.bias[2],0],et.bias[3]!==void 0&&(it[3]=et.bias[3]));let $=g*d,c=0,s=$,_=$*2,b=-1;h==="RGBA"?(c=0,s=$,_=$*2,b=$*3):h==="RGB"?(c=0,s=$,_=$*2):h==="RBG"&&(c=0,_=$,s=$*2);for(let st=0;st<g;st++)for(let dt=0;dt<d;dt++){let ct=(i.data[c++]-it[0])*ot[0],pt=(i.data[s++]-it[1])*ot[1],ft=(i.data[_++]-it[2])*ot[2],mt=b===-1?255:(i.data[b++]-it[3])*ot[3];a.fillStyle="rgba("+ct+","+pt+","+ft+","+mt+")",a.fillRect(dt,st,1,1)}if("toDataURL"in o)return o.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},so=(i,e)=>{let o=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),a;if(o!=null){let d,g,h;(e==null?void 0:e.tensorLayout)!==void 0&&e.tensorLayout==="NHWC"?(d=i.dims[2],g=i.dims[1],h=i.dims[3]):(d=i.dims[3],g=i.dims[2],h=i.dims[1]);let et=e!==void 0&&e.format!==void 0?e.format:"RGB",ot=e==null?void 0:e.norm,it,$;ot===void 0||ot.mean===void 0?it=[255,255,255,255]:typeof ot.mean=="number"?it=[ot.mean,ot.mean,ot.mean,ot.mean]:(it=[ot.mean[0],ot.mean[1],ot.mean[2],255],ot.mean[3]!==void 0&&(it[3]=ot.mean[3])),ot===void 0||ot.bias===void 0?$=[0,0,0,0]:typeof ot.bias=="number"?$=[ot.bias,ot.bias,ot.bias,ot.bias]:($=[ot.bias[0],ot.bias[1],ot.bias[2],0],ot.bias[3]!==void 0&&($[3]=ot.bias[3]));let c=g*d;if(e!==void 0&&(e.format!==void 0&&h===4&&e.format!=="RGBA"||h===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let s=4,_=0,b=1,st=2,dt=3,ct=0,pt=c,ft=c*2,mt=-1;et==="RGBA"?(ct=0,pt=c,ft=c*2,mt=c*3):et==="RGB"?(ct=0,pt=c,ft=c*2):et==="RBG"&&(ct=0,ft=c,pt=c*2),a=o.createImageData(d,g);for(let bt=0;bt<g*d;_+=s,b+=s,st+=s,dt+=s,bt++)a.data[_]=(i.data[ct++]-$[0])*it[0],a.data[b]=(i.data[pt++]-$[1])*it[1],a.data[st]=(i.data[ft++]-$[2])*it[2],a.data[dt]=mt===-1?255:(i.data[mt++]-$[3])*it[3]}else throw new Error("Can not access image data");return a}}),Ri,lo,co,po,mo,fo=j(()=>{Rn(),Ri=(i,e)=>{if(i===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:o,width:a}=e,d=e.norm??{mean:255,bias:0},g,h;typeof d.mean=="number"?g=[d.mean,d.mean,d.mean,d.mean]:g=[d.mean[0],d.mean[1],d.mean[2],d.mean[3]??255],typeof d.bias=="number"?h=[d.bias,d.bias,d.bias,d.bias]:h=[d.bias[0],d.bias[1],d.bias[2],d.bias[3]??0];let et=e.format!==void 0?e.format:"RGBA",ot=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",it=o*a,$=ot==="RGBA"?new Float32Array(it*4):new Float32Array(it*3),c=4,s=0,_=1,b=2,st=3,dt=0,ct=it,pt=it*2,ft=-1;et==="RGB"&&(c=3,s=0,_=1,b=2,st=-1),ot==="RGBA"?ft=it*3:ot==="RBG"?(dt=0,pt=it,ct=it*2):ot==="BGR"&&(pt=0,ct=it,dt=it*2);for(let mt=0;mt<it;mt++,s+=c,b+=c,_+=c,st+=c)$[dt++]=(i[s]+h[0])/g[0],$[ct++]=(i[_]+h[1])/g[1],$[pt++]=(i[b]+h[2])/g[2],ft!==-1&&st!==-1&&($[ft++]=(i[st]+h[3])/g[3]);return ot==="RGBA"?new at("float32",$,[1,4,o,a]):new at("float32",$,[1,3,o,a])},lo=async(i,e)=>{let o=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,a=typeof ImageData<"u"&&i instanceof ImageData,d=typeof ImageBitmap<"u"&&i instanceof ImageBitmap,g=typeof i=="string",h,et=e??{},ot=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},it=$=>$ instanceof HTMLCanvasElement||$ instanceof OffscreenCanvas?$.getContext("2d"):null;if(o){let $=ot();$.width=i.width,$.height=i.height;let c=it($);if(c!=null){let s=i.height,_=i.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(s=e.resizedHeight,_=e.resizedWidth),e!==void 0){if(et=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");et.tensorFormat="RGBA",et.height=s,et.width=_}else et.tensorFormat="RGBA",et.height=s,et.width=_;c.drawImage(i,0,0),h=c.getImageData(0,0,_,s).data}else throw new Error("Can not access image data")}else if(a){let $,c;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?($=e.resizedHeight,c=e.resizedWidth):($=i.height,c=i.width),e!==void 0&&(et=e),et.format="RGBA",et.height=$,et.width=c,e!==void 0){let s=ot();s.width=c,s.height=$;let _=it(s);if(_!=null)_.putImageData(i,0,0),h=_.getImageData(0,0,c,$).data;else throw new Error("Can not access image data")}else h=i.data}else if(d){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let $=ot();$.width=i.width,$.height=i.height;let c=it($);if(c!=null){let s=i.height,_=i.width;return c.drawImage(i,0,0,_,s),h=c.getImageData(0,0,_,s).data,et.height=s,et.width=_,Ri(h,et)}else throw new Error("Can not access image data")}else{if(g)return new Promise(($,c)=>{let s=ot(),_=it(s);if(!i||!_)return c();let b=new Image;b.crossOrigin="Anonymous",b.src=i,b.onload=()=>{s.width=b.width,s.height=b.height,_.drawImage(b,0,0,s.width,s.height);let st=_.getImageData(0,0,s.width,s.height);et.height=s.height,et.width=s.width,$(Ri(st.data,et))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(h!==void 0)return Ri(h,et);throw new Error("Input data provided is not supported - aborted tensor creation")},co=(i,e)=>{let{width:o,height:a,download:d,dispose:g}=e,h=[1,a,o,4];return new at({location:"texture",type:"float32",texture:i,dims:h,download:d,dispose:g})},po=(i,e)=>{let{dataType:o,dims:a,download:d,dispose:g}=e;return new at({location:"gpu-buffer",type:o??"float32",gpuBuffer:i,dims:a,download:d,dispose:g})},mo=(i,e,o)=>new at({location:"cpu-pinned",type:i,data:e,dims:o??[e.length]})}),dr,Qr,ho,go,yo=j(()=>{dr=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Qr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),ho=!1,go=()=>{if(!ho){ho=!0;let i=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,o=typeof Float16Array<"u"&&Float16Array.from;i&&(dr.set("int64",BigInt64Array),Qr.set(BigInt64Array,"int64")),e&&(dr.set("uint64",BigUint64Array),Qr.set(BigUint64Array,"uint64")),o?(dr.set("float16",Float16Array),Qr.set(Float16Array,"float16")):dr.set("float16",Uint16Array)}}}),bo,vo,wo=j(()=>{Rn(),bo=i=>{let e=1;for(let o=0;o<i.length;o++){let a=i[o];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${o}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${o}] must be a non-negative integer, got: ${a}`);e*=a}return e},vo=(i,e)=>{switch(i.location){case"cpu":return new at(i.type,i.data,e);case"cpu-pinned":return new at({location:"cpu-pinned",data:i.data,type:i.type,dims:e});case"texture":return new at({location:"texture",texture:i.texture,type:i.type,dims:e});case"gpu-buffer":return new at({location:"gpu-buffer",gpuBuffer:i.gpuBuffer,type:i.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${i.location} is not supported`)}}}),at,Rn=j(()=>{uo(),fo(),yo(),wo(),at=class{constructor(i,e,o){go();let a,d;if(typeof i=="object"&&"location"in i)switch(this.dataLocation=i.location,a=i.type,d=i.dims,i.location){case"cpu-pinned":{let h=dr.get(a);if(!h)throw new TypeError(`unsupported type "${a}" to create tensor from pinned buffer`);if(!(i.data instanceof h))throw new TypeError(`buffer should be of type ${h.name}`);this.cpuData=i.data;break}case"texture":{if(a!=="float32")throw new TypeError(`unsupported type "${a}" to create tensor from texture`);this.gpuTextureData=i.texture,this.downloader=i.download,this.disposer=i.dispose;break}case"gpu-buffer":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="uint8"&&a!=="bool")throw new TypeError(`unsupported type "${a}" to create tensor from gpu buffer`);this.gpuBufferData=i.gpuBuffer,this.downloader=i.download,this.disposer=i.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let h,et;if(typeof i=="string")if(a=i,et=o,i==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");h=e}else{let ot=dr.get(i);if(ot===void 0)throw new TypeError(`Unsupported tensor type: ${i}.`);if(Array.isArray(e)){if(i==="float16"&&ot===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");i==="uint64"||i==="int64"?h=ot.from(e,BigInt):h=ot.from(e)}else if(e instanceof ot)h=e;else throw new TypeError(`A ${a} tensor's data must be type of ${ot}`)}else if(et=e,Array.isArray(i)){if(i.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let ot=typeof i[0];if(ot==="string")a="string",h=i;else if(ot==="boolean")a="bool",h=Uint8Array.from(i);else throw new TypeError(`Invalid element type of data array: ${ot}.`)}else{let ot=Qr.get(i.constructor);if(ot===void 0)throw new TypeError(`Unsupported type for tensor data: ${i.constructor}.`);a=ot,h=i}if(et===void 0)et=[h.length];else if(!Array.isArray(et))throw new TypeError("A tensor's dims must be a number array");d=et,this.cpuData=h,this.dataLocation="cpu"}let g=bo(d);if(this.cpuData&&g!==this.cpuData.length)throw new Error(`Tensor's size(${g}) does not match data length(${this.cpuData.length}).`);this.type=a,this.dims=d,this.size=g}static async fromImage(i,e){return lo(i,e)}static fromTexture(i,e){return co(i,e)}static fromGpuBuffer(i,e){return po(i,e)}static fromPinnedBuffer(i,e,o){return mo(i,e,o)}toDataURL(i){return oo(this,i)}toImageData(i){return so(this,i)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(i){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,i&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(i){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return vo(this,i)}}}),tt,zn=j(()=>{Rn(),tt=at}),Bn,$o,yt,ut,zi=j(()=>{Pi(),Bn=(i,e)=>{(typeof gt.trace>"u"?!gt.wasm.trace:!gt.trace)||console.timeStamp(`${i}::ORT::${e}`)},$o=(i,e)=>{var d;let o=((d=new Error().stack)==null?void 0:d.split(/\r\n|\r|\n/g))||[],a=!1;for(let g=0;g<o.length;g++){if(a&&!o[g].includes("TRACE_FUNC")){let h=`FUNC_${i}::${o[g].trim().split(" ")[1]}`;e&&(h+=`::${e}`),Bn("CPU",h);return}o[g].includes("TRACE_FUNC")&&(a=!0)}},yt=i=>{(typeof gt.trace>"u"?!gt.wasm.trace:!gt.trace)||$o("BEGIN",i)},ut=i=>{(typeof gt.trace>"u"?!gt.wasm.trace:!gt.trace)||$o("END",i)}}),Dn,_o=j(()=>{Pn(),zn(),zi(),Dn=class f_{constructor(e){this.handler=e}async run(e,o,a){yt();let d={},g={};if(typeof e!="object"||e===null||e instanceof tt||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let h=!0;if(typeof o=="object"){if(o===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(o instanceof tt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(o)){if(o.length===0)throw new TypeError("'fetches' cannot be an empty array.");h=!1;for(let it of o){if(typeof it!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(it)===-1)throw new RangeError(`'fetches' contains invalid output name: ${it}.`);d[it]=null}if(typeof a=="object"&&a!==null)g=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let it=!1,$=Object.getOwnPropertyNames(o);for(let c of this.outputNames)if($.indexOf(c)!==-1){let s=o[c];(s===null||s instanceof tt)&&(it=!0,h=!1,d[c]=s)}if(it){if(typeof a=="object"&&a!==null)g=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else g=o}}else if(typeof o<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let it of this.inputNames)if(typeof e[it]>"u")throw new Error(`input '${it}' is missing in 'feeds'.`);if(h)for(let it of this.outputNames)d[it]=null;let et=await this.handler.run(e,d,g),ot={};for(let it in et)if(Object.hasOwnProperty.call(et,it)){let $=et[it];$ instanceof tt?ot[it]=$:ot[it]=new tt($.type,$.data,$.dims)}return ut(),ot}async release(){return this.handler.dispose()}static async create(e,o,a,d){yt();let g,h={};if(typeof e=="string"){if(g=e,typeof o=="object"&&o!==null)h=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(g=e,typeof o=="object"&&o!==null)h=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let $=e,c=0,s=e.byteLength;if(typeof o=="object"&&o!==null)h=o;else if(typeof o=="number"){if(c=o,!Number.isSafeInteger(c))throw new RangeError("'byteOffset' must be an integer.");if(c<0||c>=$.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${$.byteLength}).`);if(s=e.byteLength-c,typeof a=="number"){if(s=a,!Number.isSafeInteger(s))throw new RangeError("'byteLength' must be an integer.");if(s<=0||c+s>$.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${$.byteLength-c}].`);if(typeof d=="object"&&d!==null)h=d;else if(typeof d<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof o<"u")throw new TypeError("'options' must be an object.");g=new Uint8Array($,c,s)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[et,ot]=await On(h),it=await et.createInferenceSessionHandler(g,ot);return ut(),new f_(it)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),uc,xo=j(()=>{_o(),uc=Dn}),So=j(()=>{}),Co=j(()=>{}),Io=j(()=>{}),To=j(()=>{}),lc,Mn,Ao=j(()=>{Pn(),zn(),lc="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Mn=class h_{constructor(e,o,a){this.handler=e,this.hasOptimizerModel=o,this.hasEvalModel=a}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,o){let a=e.evalModel||"",d=e.optimizerModel||"",g=o||{},[h,et]=await On(g);if(h.createTrainingSessionHandler){let ot=await h.createTrainingSessionHandler(e.checkpointState,e.trainModel,a,d,et);return new h_(ot,!!e.optimizerModel,!!e.evalModel)}else throw new Error(lc)}typeNarrowingForRunStep(e,o,a,d,g){let h={},et={};if(typeof a!="object"||a===null||a instanceof tt||Array.isArray(a))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let ot=!0;if(typeof d=="object"){if(d===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(d instanceof tt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(d)){if(d.length===0)throw new TypeError("'fetches' cannot be an empty array.");ot=!1;for(let it of d){if(typeof it!="string")throw new TypeError("'fetches' must be a string array or an object.");if(o.indexOf(it)===-1)throw new RangeError(`'fetches' contains invalid output name: ${it}.`);h[it]=null}if(typeof g=="object"&&g!==null)et=g;else if(typeof g<"u")throw new TypeError("'options' must be an object.")}else{let it=!1,$=Object.getOwnPropertyNames(d);for(let c of o)if($.indexOf(c)!==-1){let s=d[c];(s===null||s instanceof tt)&&(it=!0,ot=!1,h[c]=s)}if(it){if(typeof g=="object"&&g!==null)et=g;else if(typeof g<"u")throw new TypeError("'options' must be an object.")}else et=d}}else if(typeof d<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let it of e)if(typeof a[it]>"u")throw new Error(`input '${it}' is missing in 'feeds'.`);if(ot)for(let it of o)h[it]=null;return[h,et]}convertHandlerReturnTypeToMapOfTensors(e){let o={};for(let a in e)if(Object.hasOwnProperty.call(e,a)){let d=e[a];d instanceof tt?o[a]=d:o[a]=new tt(d.type,d.data,d.dims)}return o}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,o,a){let[d,g]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,o,a),h=await this.handler.runTrainStep(e,d,g);return this.convertHandlerReturnTypeToMapOfTensors(h)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,o,a){if(this.hasEvalModel){let[d,g]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,o,a),h=await this.handler.runEvalStep(e,d,g);return this.convertHandlerReturnTypeToMapOfTensors(h)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,o=!0){let a=await this.getParametersSize(o);if(e.length!==4*a)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,o)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}}),dc,Eo=j(()=>{Ao(),dc=Mn}),Bi={};kr(Bi,{InferenceSession:()=>uc,TRACE:()=>Bn,TRACE_FUNC_BEGIN:()=>yt,TRACE_FUNC_END:()=>ut,Tensor:()=>tt,TrainingSession:()=>dc,env:()=>ke,registerBackend:()=>lr});var _t=j(()=>{to(),ao(),xo(),zn(),So(),Co(),zi(),Io(),To(),Eo()}),Di={};kr(Di,{createReadStream:()=>Oo,readFile:()=>cc,readFileSync:()=>pc});var cc,pc,Oo,Mi=j(()=>{cc=void 0,pc=void 0,Oo=void 0}),Ui={};kr(Ui,{join:()=>mc});var mc,Wi=j(()=>{mc=void 0}),zo=Er((i,e)=>{var o=(()=>{var d;var a=typeof document<"u"?(d=document.currentScript)==null?void 0:d.src:void 0;return typeof __filename<"u"&&(a||(a=__filename)),function(g={}){var h=g,et,ot,it=new Promise((wt,Pt)=>{et=wt,ot=Pt});h.mountExternalData=(wt,Pt)=>{(h.eb||(h.eb=new Map)).set(wt,Pt)},h.unmountExternalData=()=>{delete h.eb};let $=()=>{let wt=(Vt,Qt,gn)=>(...En)=>{let or=T0,yr=Qt==null?void 0:Qt();En=Vt(...En);let Cr=Qt==null?void 0:Qt();return yr!==Cr&&(Vt=Cr,gn(yr),Qt=gn=null),T0!=or?$n():En},Pt=Vt=>async(...Qt)=>{var gn;try{if(h.cb)throw Error("Session already started");let En=h.cb={xb:Qt[0],errors:[]},or=await Vt(...Qt);if(h.cb!==En)throw Error("Session mismatch");(gn=h.kb)==null||gn.flush();let yr=En.errors;if(0<yr.length){let Cr=await Promise.all(yr);if(Cr=Cr.filter(Tr=>Tr),0<Cr.length)throw Error(Cr.join(`
`))}return or}finally{h.cb=null}};h._OrtCreateSession=wt(h._OrtCreateSession,()=>h._OrtCreateSession,Vt=>h._OrtCreateSession=Vt),h._OrtRun=Pt(wt(h._OrtRun,()=>h._OrtRun,Vt=>h._OrtRun=Vt)),h._OrtRunWithBinding=Pt(wt(h._OrtRunWithBinding,()=>h._OrtRunWithBinding,Vt=>h._OrtRunWithBinding=Vt)),h._OrtBindInput=wt(h._OrtBindInput,()=>h._OrtBindInput,Vt=>h._OrtBindInput=Vt),$=void 0};h.jsepInit=(wt,Pt)=>{if($==null||$(),wt==="webgpu"){[h.kb,h.pb,h.tb,h.lb,h.sb,h.Ra,h.ub,h.wb,h.qb,h.rb,h.vb]=Pt;let Vt=h.kb;h.jsepRegisterBuffer=(Qt,gn,En,or)=>Vt.registerBuffer(Qt,gn,En,or),h.jsepGetBuffer=Qt=>Vt.getBuffer(Qt),h.jsepCreateDownloader=(Qt,gn,En)=>Vt.createDownloader(Qt,gn,En),h.jsepOnReleaseSession=Qt=>{Vt.onReleaseSession(Qt)},h.jsepOnRunStart=Qt=>Vt.onRunStart(Qt)}};var c=Object.assign({},h),s="./this.program",_=(wt,Pt)=>{throw Pt},b=typeof window=="object",st=typeof importScripts=="function",dt=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",ct="",pt,ft,mt;if(dt){var bt=(Mi(),sr(Di)),$t=(Wi(),sr(Ui));ct=st?$t.dirname(ct)+"/":__dirname+"/",pt=(wt,Pt)=>(wt=t0(wt)?new URL(wt):$t.normalize(wt),bt.readFileSync(wt,Pt?void 0:"utf8")),mt=wt=>(wt=pt(wt,!0),wt.buffer||(wt=new Uint8Array(wt)),wt),ft=(wt,Pt,Vt,Qt=!0)=>{wt=t0(wt)?new URL(wt):$t.normalize(wt),bt.readFile(wt,Qt?void 0:"utf8",(gn,En)=>{gn?Vt(gn):Pt(Qt?En.buffer:En)})},!h.thisProgram&&1<process.argv.length&&(s=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),_=(wt,Pt)=>{throw process.exitCode=wt,Pt}}else(b||st)&&(st?ct=self.location.href:typeof document<"u"&&document.currentScript&&(ct=document.currentScript.src),a&&(ct=a),ct.startsWith("blob:")?ct="":ct=ct.substr(0,ct.replace(/[?#].*/,"").lastIndexOf("/")+1),pt=wt=>{var Pt=new XMLHttpRequest;return Pt.open("GET",wt,!1),Pt.send(null),Pt.responseText},st&&(mt=wt=>{var Pt=new XMLHttpRequest;return Pt.open("GET",wt,!1),Pt.responseType="arraybuffer",Pt.send(null),new Uint8Array(Pt.response)}),ft=(wt,Pt,Vt)=>{var Qt=new XMLHttpRequest;Qt.open("GET",wt,!0),Qt.responseType="arraybuffer",Qt.onload=()=>{Qt.status==200||Qt.status==0&&Qt.response?Pt(Qt.response):Vt()},Qt.onerror=Vt,Qt.send(null)});var Ct=console.log.bind(console),It=console.error.bind(console);Object.assign(h,c),c=null;var Tt,jt=!1,dn,yn,mn,fn,un,Wt,Jt,_n,vn,Sn,hn;function rr(){var wt=Tt.buffer;h.HEAP8=yn=new Int8Array(wt),h.HEAP16=fn=new Int16Array(wt),h.HEAPU8=mn=new Uint8Array(wt),h.HEAPU16=un=new Uint16Array(wt),h.HEAP32=Wt=new Int32Array(wt),h.HEAPU32=Jt=new Uint32Array(wt),h.HEAPF32=_n=new Float32Array(wt),h.HEAPF64=hn=new Float64Array(wt),h.HEAP64=vn=new BigInt64Array(wt),h.HEAPU64=Sn=new BigUint64Array(wt)}var vr=[],Ir=[],$r=[],Ur=0,Yr=null;function r0(wt){throw wt="Aborted("+wt+")",It(wt),jt=!0,dn=1,wt=new WebAssembly.RuntimeError(wt+". Build with -sASSERTIONS for more info."),ot(wt),wt}var b0=wt=>wt.startsWith("data:application/octet-stream;base64,"),t0=wt=>wt.startsWith("file://"),l0;if(l0="ort-wasm-simd.wasm",!b0(l0)){var _i=l0;l0=h.locateFile?h.locateFile(_i,ct):ct+_i}function Po(wt){if(mt)return mt(wt);throw"both async and sync fetching of the wasm failed"}function vm(wt){if(b||st){if(typeof fetch=="function"&&!t0(wt))return fetch(wt,{credentials:"same-origin"}).then(Pt=>{if(!Pt.ok)throw`failed to load wasm binary file at '${wt}'`;return Pt.arrayBuffer()}).catch(()=>Po(wt));if(ft)return new Promise((Pt,Vt)=>{ft(wt,Qt=>Pt(new Uint8Array(Qt)),Vt)})}return Promise.resolve().then(()=>Po(wt))}function s0(wt,Pt,Vt){return vm(wt).then(Qt=>WebAssembly.instantiate(Qt,Pt)).then(Vt,Qt=>{It(`failed to asynchronously prepare wasm: ${Qt}`),r0(Qt)})}function k0(wt,Pt){var Vt=l0;return typeof WebAssembly.instantiateStreaming!="function"||b0(Vt)||t0(Vt)||dt||typeof fetch!="function"?s0(Vt,wt,Pt):fetch(Vt,{credentials:"same-origin"}).then(Qt=>WebAssembly.instantiateStreaming(Qt,wt).then(Pt,function(gn){return It(`wasm streaming compile failed: ${gn}`),It("falling back to ArrayBuffer instantiation"),s0(Vt,wt,Pt)}))}var E0={824936:(wt,Pt,Vt,Qt)=>{if(typeof h>"u"||!h.eb)return 1;if(wt=e0(wt>>>0),wt.startsWith("./")&&(wt=wt.substring(2)),wt=h.eb.get(wt),!wt)return 2;if(Pt>>>=0,Vt>>>=0,Pt+Vt>wt.byteLength)return 3;try{return mn.set(wt.subarray(Pt,Pt+Vt),Qt>>>0>>>0),0}catch{return 4}},825437:()=>{h.qb()},825468:()=>{h.rb()},825497:()=>{h.vb()},825522:wt=>h.pb(wt),825555:wt=>h.tb(wt),825587:(wt,Pt,Vt)=>{h.lb(wt,Pt,Vt,!0)},825626:(wt,Pt,Vt)=>{h.lb(wt,Pt,Vt)},825659:wt=>{h.Ra("Abs",wt,void 0)},825710:wt=>{h.Ra("Neg",wt,void 0)},825761:wt=>{h.Ra("Floor",wt,void 0)},825814:wt=>{h.Ra("Ceil",wt,void 0)},825866:wt=>{h.Ra("Reciprocal",wt,void 0)},825924:wt=>{h.Ra("Sqrt",wt,void 0)},825976:wt=>{h.Ra("Exp",wt,void 0)},826027:wt=>{h.Ra("Erf",wt,void 0)},826078:wt=>{h.Ra("Sigmoid",wt,void 0)},826133:(wt,Pt,Vt)=>{h.Ra("HardSigmoid",wt,{alpha:Pt,beta:Vt})},826212:wt=>{h.Ra("Log",wt,void 0)},826263:wt=>{h.Ra("Sin",wt,void 0)},826314:wt=>{h.Ra("Cos",wt,void 0)},826365:wt=>{h.Ra("Tan",wt,void 0)},826416:wt=>{h.Ra("Asin",wt,void 0)},826468:wt=>{h.Ra("Acos",wt,void 0)},826520:wt=>{h.Ra("Atan",wt,void 0)},826572:wt=>{h.Ra("Sinh",wt,void 0)},826624:wt=>{h.Ra("Cosh",wt,void 0)},826676:wt=>{h.Ra("Asinh",wt,void 0)},826729:wt=>{h.Ra("Acosh",wt,void 0)},826782:wt=>{h.Ra("Atanh",wt,void 0)},826835:wt=>{h.Ra("Tanh",wt,void 0)},826887:wt=>{h.Ra("Not",wt,void 0)},826938:(wt,Pt,Vt)=>{h.Ra("Clip",wt,{min:Pt,max:Vt})},827007:wt=>{h.Ra("Clip",wt,void 0)},827059:(wt,Pt)=>{h.Ra("Elu",wt,{alpha:Pt})},827117:wt=>{h.Ra("Relu",wt,void 0)},827169:(wt,Pt)=>{h.Ra("LeakyRelu",wt,{alpha:Pt})},827233:(wt,Pt)=>{h.Ra("ThresholdedRelu",wt,{alpha:Pt})},827303:(wt,Pt)=>{h.Ra("Cast",wt,{to:Pt})},827361:wt=>{h.Ra("Add",wt,void 0)},827412:wt=>{h.Ra("Sub",wt,void 0)},827463:wt=>{h.Ra("Mul",wt,void 0)},827514:wt=>{h.Ra("Div",wt,void 0)},827565:wt=>{h.Ra("Pow",wt,void 0)},827616:wt=>{h.Ra("Equal",wt,void 0)},827669:wt=>{h.Ra("Greater",wt,void 0)},827724:wt=>{h.Ra("GreaterOrEqual",wt,void 0)},827786:wt=>{h.Ra("Less",wt,void 0)},827838:wt=>{h.Ra("LessOrEqual",wt,void 0)},827897:(wt,Pt,Vt,Qt,gn)=>{h.Ra("ReduceMean",wt,{keepDims:!!Pt,noopWithEmptyAxes:!!Vt,axes:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},828056:(wt,Pt,Vt,Qt,gn)=>{h.Ra("ReduceMax",wt,{keepDims:!!Pt,noopWithEmptyAxes:!!Vt,axes:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},828214:(wt,Pt,Vt,Qt,gn)=>{h.Ra("ReduceMin",wt,{keepDims:!!Pt,noopWithEmptyAxes:!!Vt,axes:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},828372:(wt,Pt,Vt,Qt,gn)=>{h.Ra("ReduceProd",wt,{keepDims:!!Pt,noopWithEmptyAxes:!!Vt,axes:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},828531:(wt,Pt,Vt,Qt,gn)=>{h.Ra("ReduceSum",wt,{keepDims:!!Pt,noopWithEmptyAxes:!!Vt,axes:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},828689:(wt,Pt,Vt,Qt,gn)=>{h.Ra("ReduceL1",wt,{keepDims:!!Pt,noopWithEmptyAxes:!!Vt,axes:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},828846:(wt,Pt,Vt,Qt,gn)=>{h.Ra("ReduceL2",wt,{keepDims:!!Pt,noopWithEmptyAxes:!!Vt,axes:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},829003:(wt,Pt,Vt,Qt,gn)=>{h.Ra("ReduceLogSum",wt,{keepDims:!!Pt,noopWithEmptyAxes:!!Vt,axes:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},829164:(wt,Pt,Vt,Qt,gn)=>{h.Ra("ReduceSumSquare",wt,{keepDims:!!Pt,noopWithEmptyAxes:!!Vt,axes:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},829328:(wt,Pt,Vt,Qt,gn)=>{h.Ra("ReduceLogSumExp",wt,{keepDims:!!Pt,noopWithEmptyAxes:!!Vt,axes:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},829492:wt=>{h.Ra("Where",wt,void 0)},829545:(wt,Pt,Vt)=>{h.Ra("Transpose",wt,{perm:Pt?Array.from(Wt.subarray(Pt>>>0,Vt>>>0)):[]})},829653:(wt,Pt,Vt,Qt)=>{h.Ra("DepthToSpace",wt,{blocksize:Pt,mode:e0(Vt),format:Qt?"NHWC":"NCHW"})},829786:(wt,Pt,Vt,Qt)=>{h.Ra("DepthToSpace",wt,{blocksize:Pt,mode:e0(Vt),format:Qt?"NHWC":"NCHW"})},829919:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr,Fr,n0,Nt,Lt,qt)=>{h.Ra("ConvTranspose",wt,{format:Cr?"NHWC":"NCHW",autoPad:Pt,dilations:[Vt],group:Qt,kernelShape:[gn],pads:[En,or],strides:[yr],wIsConst:()=>!!yn[Tr>>>0],outputPadding:Fr?Array.from(Wt.subarray(Fr>>>0,n0>>>0)):[],outputShape:Nt?Array.from(Wt.subarray(Nt>>>0,Lt>>>0)):[],activation:e0(qt)})},830320:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr,Fr,n0,Nt,Lt)=>{h.Ra("ConvTranspose",wt,{format:yr?"NHWC":"NCHW",autoPad:Pt,dilations:Array.from(Wt.subarray(Vt>>>0,(Vt>>>0)+2>>>0)),group:Qt,kernelShape:Array.from(Wt.subarray(gn>>>0,(gn>>>0)+2>>>0)),pads:Array.from(Wt.subarray(En>>>0,(En>>>0)+4>>>0)),strides:Array.from(Wt.subarray(or>>>0,(or>>>0)+2>>>0)),wIsConst:()=>!!yn[Cr>>>0],outputPadding:Tr?Array.from(Wt.subarray(Tr>>>0,Fr>>>0)):[],outputShape:n0?Array.from(Wt.subarray(n0>>>0,Nt>>>0)):[],activation:e0(Lt)})},830885:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr,Fr,n0,Nt,Lt,qt)=>{h.Ra("ConvTranspose",wt,{format:Cr?"NHWC":"NCHW",autoPad:Pt,dilations:[Vt],group:Qt,kernelShape:[gn],pads:[En,or],strides:[yr],wIsConst:()=>!!yn[Tr>>>0],outputPadding:Fr?Array.from(Wt.subarray(Fr>>>0,n0>>>0)):[],outputShape:Nt?Array.from(Wt.subarray(Nt>>>0,Lt>>>0)):[],activation:e0(qt)})},831286:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr,Fr,n0,Nt,Lt)=>{h.Ra("ConvTranspose",wt,{format:yr?"NHWC":"NCHW",autoPad:Pt,dilations:Array.from(Wt.subarray(Vt>>>0,(Vt>>>0)+2>>>0)),group:Qt,kernelShape:Array.from(Wt.subarray(gn>>>0,(gn>>>0)+2>>>0)),pads:Array.from(Wt.subarray(En>>>0,(En>>>0)+4>>>0)),strides:Array.from(Wt.subarray(or>>>0,(or>>>0)+2>>>0)),wIsConst:()=>!!yn[Cr>>>0],outputPadding:Tr?Array.from(Wt.subarray(Tr>>>0,Fr>>>0)):[],outputShape:n0?Array.from(Wt.subarray(n0>>>0,Nt>>>0)):[],activation:e0(Lt)})},831851:(wt,Pt)=>{h.Ra("GlobalAveragePool",wt,{format:Pt?"NHWC":"NCHW"})},831942:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr,Fr,n0,Nt,Lt,qt,ln)=>{h.Ra("AveragePool",wt,{format:ln?"NHWC":"NCHW",auto_pad:Pt,ceil_mode:Vt,count_include_pad:Qt,storage_order:gn,dilations:[En,or],kernel_shape:[yr,Cr],pads:[Tr,Fr,n0,Nt],strides:[Lt,qt]})},832226:(wt,Pt)=>{h.Ra("GlobalAveragePool",wt,{format:Pt?"NHWC":"NCHW"})},832317:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr,Fr,n0,Nt,Lt,qt,ln)=>{h.Ra("AveragePool",wt,{format:ln?"NHWC":"NCHW",auto_pad:Pt,ceil_mode:Vt,count_include_pad:Qt,storage_order:gn,dilations:[En,or],kernel_shape:[yr,Cr],pads:[Tr,Fr,n0,Nt],strides:[Lt,qt]})},832601:(wt,Pt)=>{h.Ra("GlobalMaxPool",wt,{format:Pt?"NHWC":"NCHW"})},832688:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr,Fr,n0,Nt,Lt,qt,ln)=>{h.Ra("MaxPool",wt,{format:ln?"NHWC":"NCHW",auto_pad:Pt,ceil_mode:Vt,count_include_pad:Qt,storage_order:gn,dilations:[En,or],kernel_shape:[yr,Cr],pads:[Tr,Fr,n0,Nt],strides:[Lt,qt]})},832968:(wt,Pt)=>{h.Ra("GlobalMaxPool",wt,{format:Pt?"NHWC":"NCHW"})},833055:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr,Fr,n0,Nt,Lt,qt,ln)=>{h.Ra("MaxPool",wt,{format:ln?"NHWC":"NCHW",auto_pad:Pt,ceil_mode:Vt,count_include_pad:Qt,storage_order:gn,dilations:[En,or],kernel_shape:[yr,Cr],pads:[Tr,Fr,n0,Nt],strides:[Lt,qt]})},833335:(wt,Pt,Vt,Qt,gn)=>{h.Ra("Gemm",wt,{alpha:Pt,beta:Vt,transA:Qt,transB:gn})},833439:wt=>{h.Ra("MatMul",wt,void 0)},833493:(wt,Pt,Vt,Qt)=>{h.Ra("ArgMax",wt,{keepDims:!!Pt,selectLastIndex:!!Vt,axis:Qt})},833601:(wt,Pt,Vt,Qt)=>{h.Ra("ArgMin",wt,{keepDims:!!Pt,selectLastIndex:!!Vt,axis:Qt})},833709:(wt,Pt)=>{h.Ra("Softmax",wt,{axis:Pt})},833772:(wt,Pt)=>{h.Ra("Concat",wt,{axis:Pt})},833832:(wt,Pt,Vt,Qt,gn)=>{h.Ra("Split",wt,{axis:Pt,numOutputs:Vt,splitSizes:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},833972:wt=>{h.Ra("Expand",wt,void 0)},834026:(wt,Pt)=>{h.Ra("Gather",wt,{axis:Number(Pt)})},834097:(wt,Pt)=>{h.Ra("GatherElements",wt,{axis:Number(Pt)})},834176:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr,Fr)=>{h.Ra("Resize",wt,{antialias:Pt,axes:Vt?Array.from(Wt.subarray(Vt>>>0,Qt>>>0)):[],coordinateTransformMode:e0(gn),cubicCoeffA:En,excludeOutside:or,extrapolationValue:yr,keepAspectRatioPolicy:e0(Cr),mode:e0(Tr),nearestMode:e0(Fr)})},834522:(wt,Pt,Vt,Qt,gn,En,or)=>{h.Ra("Slice",wt,{starts:Pt?Array.from(Wt.subarray(Pt>>>0,Vt>>>0)):[],ends:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[],axes:En?Array.from(Wt.subarray(En>>>0,or>>>0)):[]})},834738:wt=>{h.Ra("Tile",wt,void 0)},834790:(wt,Pt,Vt,Qt)=>{h.Ra("LayerNormalization",wt,{axis:Pt,epsilon:Vt,simplified:!!Qt})},834901:(wt,Pt,Vt)=>{h.Ra("InstanceNormalization",wt,{epsilon:Pt,format:Vt?"NHWC":"NCHW"})},835015:(wt,Pt,Vt)=>{h.Ra("InstanceNormalization",wt,{epsilon:Pt,format:Vt?"NHWC":"NCHW"})},835129:wt=>{h.Ra("Range",wt,void 0)},835182:(wt,Pt)=>{h.Ra("Einsum",wt,{equation:e0(Pt)})},835263:(wt,Pt,Vt,Qt,gn)=>{h.Ra("Pad",wt,{mode:Pt,value:Vt,pads:Qt?Array.from(Wt.subarray(Qt>>>0,gn>>>0)):[]})},835390:(wt,Pt,Vt,Qt,gn,En)=>{h.Ra("BatchNormalization",wt,{epsilon:Pt,momentum:Vt,spatial:!!gn,trainingMode:!!Qt,format:En?"NHWC":"NCHW"})},835559:(wt,Pt,Vt,Qt,gn,En)=>{h.Ra("BatchNormalization",wt,{epsilon:Pt,momentum:Vt,spatial:!!gn,trainingMode:!!Qt,format:En?"NHWC":"NCHW"})},835728:(wt,Pt,Vt)=>{h.Ra("CumSum",wt,{exclusive:Number(Pt),reverse:Number(Vt)})},835825:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr)=>{h.Ra("Attention",wt,{numHeads:Pt,isUnidirectional:Vt,maskFilterValue:Qt,scale:gn,doRotary:En,qkvHiddenSizes:or?Array.from(Wt.subarray(Number(yr)>>>0,Number(yr)+or>>>0)):[],pastPresentShareBuffer:!!Cr})},836097:wt=>{h.Ra("BiasAdd",wt,void 0)},836152:wt=>{h.Ra("BiasSplitGelu",wt,void 0)},836213:wt=>{h.Ra("FastGelu",wt,void 0)},836269:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr,Fr,n0,Nt)=>{h.Ra("Conv",wt,{format:Cr?"NHWC":"NCHW",auto_pad:Pt,dilations:[Vt],group:Qt,kernel_shape:[gn],pads:En?Array.from(Wt.subarray(En>>>0,or>>>0)):[],strides:[yr],w_is_const:()=>!!yn[Tr>>>0],activation:e0(Fr),activation_params:n0?Array.from(_n.subarray(n0>>>0,Nt>>>0)):[]})},836639:(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr,Fr,n0,Nt,Lt,qt,ln)=>{h.Ra("Conv",wt,{format:n0?"NHWC":"NCHW",auto_pad:Pt,dilations:[Vt,Qt],group:gn,kernel_shape:[En,or],pads:yr?Array.from(Wt.subarray(yr>>>0,Cr>>>0)):[],strides:[Tr,Fr],w_is_const:()=>!!yn[Nt>>>0],activation:e0(Lt),activation_params:qt?Array.from(_n.subarray(qt>>>0,ln>>>0)):[]})},837030:wt=>{h.Ra("Gelu",wt,void 0)},837082:(wt,Pt,Vt,Qt,gn,En)=>{h.Ra("MatMulNBits",wt,{k:Pt,n:Vt,accuracyLevel:Qt,bits:gn,blockSize:En})},837209:(wt,Pt,Vt,Qt,gn,En)=>{h.Ra("MultiHeadAttention",wt,{numHeads:Pt,isUnidirectional:Vt,maskFilterValue:Qt,scale:gn,doRotary:En})},837368:(wt,Pt,Vt,Qt,gn)=>{h.Ra("RotaryEmbedding",wt,{interleaved:!!Pt,numHeads:Vt,rotaryEmbeddingDim:Qt,scale:gn})},837507:(wt,Pt,Vt)=>{h.Ra("SkipLayerNormalization",wt,{epsilon:Pt,simplified:!!Vt})},837609:(wt,Pt,Vt)=>{h.Ra("SkipLayerNormalization",wt,{epsilon:Pt,simplified:!!Vt})},837711:(wt,Pt,Vt,Qt)=>{h.Ra("LayerNormalization",wt,{axis:Pt,epsilon:Vt,simplified:!!Qt})},837822:wt=>{h.ub(wt)},837856:(wt,Pt)=>h.wb(wt,Pt,h.cb.xb,h.cb.errors)};function O0(wt){this.name="ExitStatus",this.message=`Program terminated with exit(${wt})`,this.status=wt}class U0{constructor(Pt){this.hb=Pt-24}}var w0=0,v0=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,a0=(wt,Pt,Vt)=>{Pt>>>=0;var Qt=Pt+Vt;for(Vt=Pt;wt[Vt]&&!(Vt>=Qt);)++Vt;if(16<Vt-Pt&&wt.buffer&&v0)return v0.decode(wt.subarray(Pt,Vt));for(Qt="";Pt<Vt;){var gn=wt[Pt++];if(gn&128){var En=wt[Pt++]&63;if((gn&224)==192)Qt+=String.fromCharCode((gn&31)<<6|En);else{var or=wt[Pt++]&63;gn=(gn&240)==224?(gn&15)<<12|En<<6|or:(gn&7)<<18|En<<12|or<<6|wt[Pt++]&63,65536>gn?Qt+=String.fromCharCode(gn):(gn-=65536,Qt+=String.fromCharCode(55296|gn>>10,56320|gn&1023))}}else Qt+=String.fromCharCode(gn)}return Qt},e0=(wt,Pt)=>(wt>>>=0)?a0(mn,wt,Pt):"",C0=wt=>{for(var Pt=0,Vt=0;Vt<wt.length;++Vt){var Qt=wt.charCodeAt(Vt);127>=Qt?Pt++:2047>=Qt?Pt+=2:55296<=Qt&&57343>=Qt?(Pt+=4,++Vt):Pt+=3}return Pt},qr=(wt,Pt,Vt,Qt)=>{if(Vt>>>=0,!(0<Qt))return 0;var gn=Vt;Qt=Vt+Qt-1;for(var En=0;En<wt.length;++En){var or=wt.charCodeAt(En);if(55296<=or&&57343>=or){var yr=wt.charCodeAt(++En);or=65536+((or&1023)<<10)|yr&1023}if(127>=or){if(Vt>=Qt)break;Pt[Vt++>>>0]=or}else{if(2047>=or){if(Vt+1>=Qt)break;Pt[Vt++>>>0]=192|or>>6}else{if(65535>=or){if(Vt+2>=Qt)break;Pt[Vt++>>>0]=224|or>>12}else{if(Vt+3>=Qt)break;Pt[Vt++>>>0]=240|or>>18,Pt[Vt++>>>0]=128|or>>12&63}Pt[Vt++>>>0]=128|or>>6&63}Pt[Vt++>>>0]=128|or&63}}return Pt[Vt>>>0]=0,Vt-gn},L0,$0=wt=>{for(var Pt="";mn[wt>>>0];)Pt+=L0[mn[wt++>>>0]];return Pt},ry={},D0={},P0;function G0(wt,Pt,Vt={}){var Qt=Pt.name;if(!wt)throw new P0(`type "${Qt}" must have a positive integer typeid pointer`);if(D0.hasOwnProperty(wt)){if(Vt.nb)return;throw new P0(`Cannot register type '${Qt}' twice`)}D0[wt]=Pt,ry.hasOwnProperty(wt)&&(Pt=ry[wt],delete ry[wt],Pt.forEach(gn=>gn()))}function i0(wt,Pt,Vt={}){if(!("argPackAdvance"in Pt))throw new TypeError("registerType registeredInstance requires argPackAdvance");return G0(wt,Pt,Vt)}var B0=(wt,Pt,Vt)=>{switch(Pt){case 1:return Vt?Qt=>yn[Qt>>>0]:Qt=>mn[Qt>>>0];case 2:return Vt?Qt=>fn[Qt>>>1>>>0]:Qt=>un[Qt>>>1>>>0];case 4:return Vt?Qt=>Wt[Qt>>>2>>>0]:Qt=>Jt[Qt>>>2>>>0];case 8:return Vt?Qt=>vn[Qt>>>3]:Qt=>Sn[Qt>>>3];default:throw new TypeError(`invalid integer width (${Pt}): ${wt}`)}},jr=[],p0=[];function iy(wt){wt>>>=0,9<wt&&--p0[wt+1]===0&&(p0[wt]=void 0,jr.push(wt))}var eo=wt=>{if(!wt)throw new P0("Cannot use deleted val. handle = "+wt);return p0[wt]},y0=wt=>{switch(wt){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let Pt=jr.pop()||p0.length;return p0[Pt]=wt,p0[Pt+1]=1,Pt}};function bp(wt){return this.fromWireType(Jt[wt>>>2>>>0])}var Q0={name:"emscripten::val",fromWireType:wt=>{var Pt=eo(wt);return iy(wt),Pt},toWireType:(wt,Pt)=>y0(Pt),argPackAdvance:8,readValueFromPointer:bp,bb:null},oy=(wt,Pt)=>{switch(Pt){case 4:return function(Vt){return this.fromWireType(_n[Vt>>>2>>>0])};case 8:return function(Vt){return this.fromWireType(hn[Vt>>>3>>>0])};default:throw new TypeError(`invalid float width (${Pt}): ${wt}`)}},H0=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,_r=(wt,Pt)=>{for(var Vt=wt>>1,Qt=Vt+Pt/2;!(Vt>=Qt)&&un[Vt>>>0];)++Vt;if(Vt<<=1,32<Vt-wt&&H0)return H0.decode(mn.subarray(wt>>>0,Vt>>>0));for(Vt="",Qt=0;!(Qt>=Pt/2);++Qt){var gn=fn[wt+2*Qt>>>1>>>0];if(gn==0)break;Vt+=String.fromCharCode(gn)}return Vt},Vr=(wt,Pt,Vt)=>{if(Vt??(Vt=2147483647),2>Vt)return 0;Vt-=2;var Qt=Pt;Vt=Vt<2*wt.length?Vt/2:wt.length;for(var gn=0;gn<Vt;++gn)fn[Pt>>>1>>>0]=wt.charCodeAt(gn),Pt+=2;return fn[Pt>>>1>>>0]=0,Pt-Qt},Kr=wt=>2*wt.length,hy=(wt,Pt)=>{for(var Vt=0,Qt="";!(Vt>=Pt/4);){var gn=Wt[wt+4*Vt>>>2>>>0];if(gn==0)break;++Vt,65536<=gn?(gn-=65536,Qt+=String.fromCharCode(55296|gn>>10,56320|gn&1023)):Qt+=String.fromCharCode(gn)}return Qt},q0=(wt,Pt,Vt)=>{if(Pt>>>=0,Vt??(Vt=2147483647),4>Vt)return 0;var Qt=Pt;Vt=Qt+Vt-4;for(var gn=0;gn<wt.length;++gn){var En=wt.charCodeAt(gn);if(55296<=En&&57343>=En){var or=wt.charCodeAt(++gn);En=65536+((En&1023)<<10)|or&1023}if(Wt[Pt>>>2>>>0]=En,Pt+=4,Pt+4>Vt)break}return Wt[Pt>>>2>>>0]=0,Pt-Qt},ay=wt=>{for(var Pt=0,Vt=0;Vt<wt.length;++Vt){var Qt=wt.charCodeAt(Vt);55296<=Qt&&57343>=Qt&&++Vt,Pt+=4}return Pt},K0=(wt,Pt)=>{var Vt=D0[wt];if(Vt===void 0)throw wt=vy(wt),Vt=$0(wt),S0(wt),new P0(`${Pt} has unknown type ${Vt}`);return Vt},Z0=(wt,Pt,Vt)=>{var Qt=[];return wt=wt.toWireType(Qt,Vt),Qt.length&&(Jt[Pt>>>2>>>0]=y0(Qt)),wt},j0=wt=>{try{wt()}catch(Pt){r0(Pt)}},f0=wt=>{var Pt;if(!jt)try{wt();try{dn=dn=wt=dn,(Pt=h.onExit)==null||Pt.call(h,wt),jt=!0,_(wt,new O0(wt))}catch(Vt){Vt instanceof O0||Vt=="unwind"||_(1,Vt)}}catch(Vt){Vt instanceof O0||Vt=="unwind"||_(1,Vt)}};function sy(){var wt=Wr,Pt={};for(let[Vt,Qt]of Object.entries(wt))Pt[Vt]=typeof Qt=="function"?(...gn)=>{M0.push(Vt);try{return Qt(...gn)}finally{jt||(M0.pop(),T0&&I0===1&&M0.length===0&&(I0=0,j0(Wo),typeof Fibers<"u"&&Fibers.Db()))}}:Qt;return Pt}var I0=0,T0=null,J0=0,M0=[],ey={},ty={},Ht=0,cn=null,bn=[];function $n(){return new Promise((wt,Pt)=>{cn={resolve:wt,reject:Pt}})}function Tn(){var wt=ny(65548),Pt=wt+12;Jt[wt>>>2>>>0]=Pt,Jt[wt+4>>>2>>>0]=Pt+65536,Pt=M0[0];var Vt=ey[Pt];return Vt===void 0&&(Vt=Ht++,ey[Pt]=Vt,ty[Vt]=Pt),Wt[wt+8>>>2>>>0]=Vt,wt}function In(wt){if(!jt){if(I0===0){var Pt=!1,Vt=!1;wt((Qt=0)=>{if(!jt&&(J0=Qt,Pt=!0,Vt)){I0=2,j0(()=>F0(T0)),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.resume(),Qt=!1;try{var gn=(0,Wr[ty[Wt[T0+8>>>2>>>0]]])()}catch(yr){gn=yr,Qt=!0}var En=!1;if(!T0){var or=cn;or&&(cn=null,(Qt?or.reject:or.resolve)(gn),En=!0)}if(Qt&&!En)throw gn}}),Vt=!0,Pt||(I0=1,T0=Tn(),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.pause(),j0(()=>cy(T0)))}else I0===2?(I0=0,j0(Gr),S0(T0),T0=null,bn.forEach(f0)):r0(`invalid state: ${I0}`);return J0}}function wr(wt){return In(Pt=>{wt().then(Pt)})}var Dr=[],Sr={},Xr=wt=>{var Pt=Sr[wt];return Pt===void 0?$0(wt):Pt},Ro=()=>typeof globalThis=="object"?globalThis:Function("return this")(),_0=wt=>{var Pt=Dr.length;return Dr.push(wt),Pt},g0=(wt,Pt)=>{for(var Vt=Array(wt),Qt=0;Qt<wt;++Qt)Vt[Qt]=K0(Jt[Pt+4*Qt>>>2>>>0],"parameter "+Qt);return Vt},An=(wt,Pt)=>Object.defineProperty(Pt,"name",{value:wt});function _f(wt){var Pt=Function;if(!(Pt instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof Pt} which is not a function`);var Vt=An(Pt.name||"unknownFunctionName",function(){});return Vt.prototype=Pt.prototype,Vt=new Vt,wt=Pt.apply(Vt,wt),wt instanceof Object?wt:Vt}var No=wt=>wt%4===0&&(wt%100!==0||wt%400===0),A0=[0,31,60,91,121,152,182,213,244,274,305,335],z0=[0,31,59,90,120,151,181,212,243,273,304,334],R0=[],uy=(wt,Pt)=>{R0.length=0;for(var Vt;Vt=mn[wt++>>>0];){var Qt=Vt!=105;Qt&=Vt!=112,Pt+=Qt&&Pt%8?4:0,R0.push(Vt==112?Jt[Pt>>>2>>>0]:Vt==106?vn[Pt>>>3]:Vt==105?Wt[Pt>>>2>>>0]:hn[Pt>>>3>>>0]),Pt+=Qt?8:4}return R0},x0={},c0=()=>{if(!Y0){var wt={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:s||"./this.program"},Pt;for(Pt in x0)x0[Pt]===void 0?delete wt[Pt]:wt[Pt]=x0[Pt];var Vt=[];for(Pt in wt)Vt.push(`${Pt}=${wt[Pt]}`);Y0=Vt}return Y0},Y0,ky=[null,[],[]],xy=[31,29,31,30,31,30,31,31,30,31,30,31],wy=[31,28,31,30,31,30,31,31,30,31,30,31];function Ay(wt){var Pt=Array(C0(wt)+1);return qr(wt,Pt,0,Pt.length),Pt}function Ey(wt,Pt,Vt,Qt){function gn(Lt,qt,ln){for(Lt=typeof Lt=="number"?Lt.toString():Lt||"";Lt.length<qt;)Lt=ln[0]+Lt;return Lt}function En(Lt,qt){return gn(Lt,qt,"0")}function or(Lt,qt){function ln(Cn){return 0>Cn?-1:0<Cn?1:0}var xn;return(xn=ln(Lt.getFullYear()-qt.getFullYear()))===0&&(xn=ln(Lt.getMonth()-qt.getMonth()))===0&&(xn=ln(Lt.getDate()-qt.getDate())),xn}function yr(Lt){switch(Lt.getDay()){case 0:return new Date(Lt.getFullYear()-1,11,29);case 1:return Lt;case 2:return new Date(Lt.getFullYear(),0,3);case 3:return new Date(Lt.getFullYear(),0,2);case 4:return new Date(Lt.getFullYear(),0,1);case 5:return new Date(Lt.getFullYear()-1,11,31);case 6:return new Date(Lt.getFullYear()-1,11,30)}}function Cr(Lt){var qt=Lt.$a;for(Lt=new Date(new Date(Lt.ab+1900,0,1).getTime());0<qt;){var ln=Lt.getMonth(),xn=(No(Lt.getFullYear())?xy:wy)[ln];if(qt>xn-Lt.getDate())qt-=xn-Lt.getDate()+1,Lt.setDate(1),11>ln?Lt.setMonth(ln+1):(Lt.setMonth(0),Lt.setFullYear(Lt.getFullYear()+1));else{Lt.setDate(Lt.getDate()+qt);break}}return ln=new Date(Lt.getFullYear()+1,0,4),qt=yr(new Date(Lt.getFullYear(),0,4)),ln=yr(ln),0>=or(qt,Lt)?0>=or(ln,Lt)?Lt.getFullYear()+1:Lt.getFullYear():Lt.getFullYear()-1}wt>>>=0,Pt>>>=0,Vt>>>=0,Qt>>>=0;var Tr=Jt[Qt+40>>>2>>>0];Qt={Ab:Wt[Qt>>>2>>>0],zb:Wt[Qt+4>>>2>>>0],fb:Wt[Qt+8>>>2>>>0],jb:Wt[Qt+12>>>2>>>0],gb:Wt[Qt+16>>>2>>>0],ab:Wt[Qt+20>>>2>>>0],Va:Wt[Qt+24>>>2>>>0],$a:Wt[Qt+28>>>2>>>0],Cb:Wt[Qt+32>>>2>>>0],yb:Wt[Qt+36>>>2>>>0],Bb:Tr?e0(Tr):""},Vt=e0(Vt),Tr={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Fr in Tr)Vt=Vt.replace(new RegExp(Fr,"g"),Tr[Fr]);var n0="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Nt="January February March April May June July August September October November December".split(" ");Tr={"%a":Lt=>n0[Lt.Va].substring(0,3),"%A":Lt=>n0[Lt.Va],"%b":Lt=>Nt[Lt.gb].substring(0,3),"%B":Lt=>Nt[Lt.gb],"%C":Lt=>En((Lt.ab+1900)/100|0,2),"%d":Lt=>En(Lt.jb,2),"%e":Lt=>gn(Lt.jb,2," "),"%g":Lt=>Cr(Lt).toString().substring(2),"%G":Cr,"%H":Lt=>En(Lt.fb,2),"%I":Lt=>(Lt=Lt.fb,Lt==0?Lt=12:12<Lt&&(Lt-=12),En(Lt,2)),"%j":Lt=>{for(var qt=0,ln=0;ln<=Lt.gb-1;qt+=(No(Lt.ab+1900)?xy:wy)[ln++]);return En(Lt.jb+qt,3)},"%m":Lt=>En(Lt.gb+1,2),"%M":Lt=>En(Lt.zb,2),"%n":()=>`
`,"%p":Lt=>0<=Lt.fb&&12>Lt.fb?"AM":"PM","%S":Lt=>En(Lt.Ab,2),"%t":()=>"	","%u":Lt=>Lt.Va||7,"%U":Lt=>En(Math.floor((Lt.$a+7-Lt.Va)/7),2),"%V":Lt=>{var qt=Math.floor((Lt.$a+7-(Lt.Va+6)%7)/7);if(2>=(Lt.Va+371-Lt.$a-2)%7&&qt++,qt)qt==53&&(ln=(Lt.Va+371-Lt.$a)%7,ln==4||ln==3&&No(Lt.ab)||(qt=1));else{qt=52;var ln=(Lt.Va+7-Lt.$a-1)%7;(ln==4||ln==5&&No(Lt.ab%400-1))&&qt++}return En(qt,2)},"%w":Lt=>Lt.Va,"%W":Lt=>En(Math.floor((Lt.$a+7-(Lt.Va+6)%7)/7),2),"%y":Lt=>(Lt.ab+1900).toString().substring(2),"%Y":Lt=>Lt.ab+1900,"%z":Lt=>{Lt=Lt.yb;var qt=0<=Lt;return Lt=Math.abs(Lt)/60,(qt?"+":"-")+("0000"+(Lt/60*100+Lt%60)).slice(-4)},"%Z":Lt=>Lt.Bb,"%%":()=>"%"},Vt=Vt.replace(/%%/g,"\0\0");for(Fr in Tr)Vt.includes(Fr)&&(Vt=Vt.replace(new RegExp(Fr,"g"),Tr[Fr](Qt)));return Vt=Vt.replace(/\0\0/g,"%"),Fr=Ay(Vt),Fr.length>Pt?0:(yn.set(Fr,wt>>>0),Fr.length-1)}for(var my=Array(256),ly=0;256>ly;++ly)my[ly]=String.fromCharCode(ly);L0=my,P0=h.BindingError=class extends Error{constructor(wt){super(wt),this.name="BindingError"}},h.InternalError=class extends Error{constructor(wt){super(wt),this.name="InternalError"}},p0.push(0,1,void 0,1,null,1,!0,1,!1,1),h.count_emval_handles=()=>p0.length/2-5-jr.length;var Oy={ia:function(wt,Pt,Vt){return wr(async()=>{await h.sb(wt,Pt,Vt)})},a:function(wt,Pt,Vt){wt>>>=0;var Qt=new U0(wt);throw Jt[Qt.hb+16>>>2>>>0]=0,Jt[Qt.hb+4>>>2>>>0]=Pt>>>0,Jt[Qt.hb+8>>>2>>>0]=Vt>>>0,w0=wt,w0},z:function(){return 0},ea:function(){},R:function(){},T:function(){},ga:function(){return 0},ca:function(){},Z:function(){},ba:function(){},G:function(){},S:function(){},P:function(){},da:function(){},Q:function(){},C:function(wt,Pt,Vt){Pt=$0(Pt>>>0),i0(wt>>>0,{name:Pt,fromWireType:Qt=>Qt,toWireType:function(Qt,gn){if(typeof gn!="bigint"&&typeof gn!="number")throw gn===null?gn="null":(Qt=typeof gn,gn=Qt==="object"||Qt==="array"||Qt==="function"?gn.toString():""+gn),new TypeError(`Cannot convert "${gn}" to ${this.name}`);return typeof gn=="number"&&(gn=BigInt(gn)),gn},argPackAdvance:8,readValueFromPointer:B0(Pt,Vt>>>0,Pt.indexOf("u")==-1),bb:null})},K:function(wt,Pt,Vt,Qt){Pt=$0(Pt>>>0),i0(wt>>>0,{name:Pt,fromWireType:function(gn){return!!gn},toWireType:function(gn,En){return En?Vt:Qt},argPackAdvance:8,readValueFromPointer:function(gn){return this.fromWireType(mn[gn>>>0])},bb:null})},J:function(wt){return i0(wt>>>0,Q0)},B:function(wt,Pt,Vt){Pt=$0(Pt>>>0),i0(wt>>>0,{name:Pt,fromWireType:Qt=>Qt,toWireType:(Qt,gn)=>gn,argPackAdvance:8,readValueFromPointer:oy(Pt,Vt>>>0),bb:null})},s:function(wt,Pt,Vt,Qt,gn){if(wt>>>=0,Vt>>>=0,Pt=$0(Pt>>>0),gn===-1&&(gn=4294967295),gn=yr=>yr,Qt===0){var En=32-8*Vt;gn=yr=>yr<<En>>>En}var or=Pt.includes("unsigned")?function(yr,Cr){return Cr>>>0}:function(yr,Cr){return Cr};i0(wt,{name:Pt,fromWireType:gn,toWireType:or,argPackAdvance:8,readValueFromPointer:B0(Pt,Vt,Qt!==0),bb:null})},o:function(wt,Pt,Vt){function Qt(En){return new gn(yn.buffer,Jt[En+4>>>2>>>0],Jt[En>>>2>>>0])}var gn=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][Pt];Vt=$0(Vt>>>0),i0(wt>>>0,{name:Vt,fromWireType:Qt,argPackAdvance:8,readValueFromPointer:Qt},{nb:!0})},D:function(wt,Pt){Pt=$0(Pt>>>0);var Vt=Pt==="std::string";i0(wt>>>0,{name:Pt,fromWireType:function(Qt){var gn=Jt[Qt>>>2>>>0],En=Qt+4;if(Vt)for(var or=En,yr=0;yr<=gn;++yr){var Cr=En+yr;if(yr==gn||mn[Cr>>>0]==0){if(or=e0(or,Cr-or),Tr===void 0)var Tr=or;else Tr+="\0",Tr+=or;or=Cr+1}}else{for(Tr=Array(gn),yr=0;yr<gn;++yr)Tr[yr]=String.fromCharCode(mn[En+yr>>>0]);Tr=Tr.join("")}return S0(Qt),Tr},toWireType:function(Qt,gn){gn instanceof ArrayBuffer&&(gn=new Uint8Array(gn));var En=typeof gn=="string";if(!(En||gn instanceof Uint8Array||gn instanceof Uint8ClampedArray||gn instanceof Int8Array))throw new P0("Cannot pass non-string to std::string");var or=Vt&&En?C0(gn):gn.length,yr=ny(4+or+1),Cr=yr+4;if(Jt[yr>>>2>>>0]=or,Vt&&En)qr(gn,mn,Cr,or+1);else if(En)for(En=0;En<or;++En){var Tr=gn.charCodeAt(En);if(255<Tr)throw S0(Cr),new P0("String has UTF-16 code units that do not fit in 8 bits");mn[Cr+En>>>0]=Tr}else for(En=0;En<or;++En)mn[Cr+En>>>0]=gn[En];return Qt!==null&&Qt.push(S0,yr),yr},argPackAdvance:8,readValueFromPointer:bp,bb(Qt){S0(Qt)}})},y:function(wt,Pt,Vt){if(Pt>>>=0,Vt>>>=0,Vt=$0(Vt),Pt===2)var Qt=_r,gn=Vr,En=Kr,or=yr=>un[yr>>>1>>>0];else Pt===4&&(Qt=hy,gn=q0,En=ay,or=yr=>Jt[yr>>>2>>>0]);i0(wt>>>0,{name:Vt,fromWireType:yr=>{for(var Cr=Jt[yr>>>2>>>0],Tr,Fr=yr+4,n0=0;n0<=Cr;++n0){var Nt=yr+4+n0*Pt;(n0==Cr||or(Nt)==0)&&(Fr=Qt(Fr,Nt-Fr),Tr===void 0?Tr=Fr:(Tr+="\0",Tr+=Fr),Fr=Nt+Pt)}return S0(yr),Tr},toWireType:(yr,Cr)=>{if(typeof Cr!="string")throw new P0(`Cannot pass non-string to C++ string type ${Vt}`);var Tr=En(Cr),Fr=ny(4+Tr+Pt);return Jt[Fr>>>2>>>0]=Tr/Pt,gn(Cr,Fr+4,Tr+Pt),yr!==null&&yr.push(S0,Fr),Fr},argPackAdvance:8,readValueFromPointer:bp,bb(yr){S0(yr)}})},L:function(wt,Pt){Pt=$0(Pt>>>0),i0(wt>>>0,{ob:!0,name:Pt,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ha:()=>1,u:function(wt,Pt,Vt){return Pt>>>=0,Vt>>>=0,wt=eo(wt>>>0),Pt=K0(Pt,"emval::as"),Z0(Pt,Vt,wt)},x:function(wt){return wt>>>=0,wr(()=>(wt=eo(wt),wt.then(y0)))},n:function(wt,Pt,Vt,Qt){return Vt>>>=0,Qt>>>=0,wt=Dr[wt>>>0],Pt=eo(Pt>>>0),wt(null,Pt,Vt,Qt)},j:function(wt,Pt,Vt,Qt,gn){return Vt>>>=0,Qt>>>=0,gn>>>=0,wt=Dr[wt>>>0],Pt=eo(Pt>>>0),Vt=Xr(Vt),wt(Pt,Pt[Vt],Qt,gn)},b:iy,w:function(wt,Pt){return Pt>>>=0,wt=eo(wt>>>0),Pt=eo(Pt),wt==Pt},m:function(wt){return wt>>>=0,wt===0?y0(Ro()):(wt=Xr(wt),y0(Ro()[wt]))},i:function(wt,Pt,Vt){Pt=g0(wt,Pt>>>0);var Qt=Pt.shift();wt--;var gn=`return function (obj, func, destructorsRef, args) {
`,En=0,or=[];Vt===0&&or.push("obj");for(var yr=["retType"],Cr=[Qt],Tr=0;Tr<wt;++Tr)or.push("arg"+Tr),yr.push("argType"+Tr),Cr.push(Pt[Tr]),gn+=`  var arg${Tr} = argType${Tr}.readValueFromPointer(args${En?"+"+En:""});
`,En+=Pt[Tr].argPackAdvance;return gn+=`  var rv = ${Vt===1?"new func":"func.call"}(${or.join(", ")});
`,Qt.ob||(yr.push("emval_returnValue"),Cr.push(Z0),gn+=`  return emval_returnValue(retType, destructorsRef, rv);
`),yr.push(gn+`};
`),wt=_f(yr)(...Cr),Vt=`methodCaller<(${Pt.map(Fr=>Fr.name).join(", ")}) => ${Qt.name}>`,_0(An(Vt,wt))},r:function(wt,Pt){return Pt>>>=0,wt=eo(wt>>>0),Pt=eo(Pt),y0(wt[Pt])},e:function(wt){wt>>>=0,9<wt&&(p0[wt+1]+=1)},t:function(){return y0([])},l:function(wt){wt=eo(wt>>>0);for(var Pt=Array(wt.length),Vt=0;Vt<wt.length;Vt++)Pt[Vt]=wt[Vt];return y0(Pt)},f:function(wt){return y0(Xr(wt>>>0))},k:function(){return y0({})},h:function(wt){wt>>>=0;for(var Pt=eo(wt);Pt.length;){var Vt=Pt.pop();Pt.pop()(Vt)}iy(wt)},g:function(wt,Pt,Vt){Pt>>>=0,Vt>>>=0,wt=eo(wt>>>0),Pt=eo(Pt),Vt=eo(Vt),wt[Pt]=Vt},c:function(wt,Pt){return Pt>>>=0,wt=K0(wt>>>0,"_emval_take_value"),wt=wt.readValueFromPointer(Pt),y0(wt)},W:function(wt,Pt){wt=-9007199254740992>wt||9007199254740992<wt?NaN:Number(wt),Pt>>>=0,wt=new Date(1e3*wt),Wt[Pt>>>2>>>0]=wt.getUTCSeconds(),Wt[Pt+4>>>2>>>0]=wt.getUTCMinutes(),Wt[Pt+8>>>2>>>0]=wt.getUTCHours(),Wt[Pt+12>>>2>>>0]=wt.getUTCDate(),Wt[Pt+16>>>2>>>0]=wt.getUTCMonth(),Wt[Pt+20>>>2>>>0]=wt.getUTCFullYear()-1900,Wt[Pt+24>>>2>>>0]=wt.getUTCDay(),Wt[Pt+28>>>2>>>0]=(wt.getTime()-Date.UTC(wt.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},X:function(wt,Pt){wt=-9007199254740992>wt||9007199254740992<wt?NaN:Number(wt),Pt>>>=0,wt=new Date(1e3*wt),Wt[Pt>>>2>>>0]=wt.getSeconds(),Wt[Pt+4>>>2>>>0]=wt.getMinutes(),Wt[Pt+8>>>2>>>0]=wt.getHours(),Wt[Pt+12>>>2>>>0]=wt.getDate(),Wt[Pt+16>>>2>>>0]=wt.getMonth(),Wt[Pt+20>>>2>>>0]=wt.getFullYear()-1900,Wt[Pt+24>>>2>>>0]=wt.getDay(),Wt[Pt+28>>>2>>>0]=(No(wt.getFullYear())?A0:z0)[wt.getMonth()]+wt.getDate()-1|0,Wt[Pt+36>>>2>>>0]=-(60*wt.getTimezoneOffset());var Vt=new Date(wt.getFullYear(),6,1).getTimezoneOffset(),Qt=new Date(wt.getFullYear(),0,1).getTimezoneOffset();Wt[Pt+32>>>2>>>0]=(Vt!=Qt&&wt.getTimezoneOffset()==Math.min(Qt,Vt))|0},Y:function(wt){wt>>>=0;var Pt=new Date(Wt[wt+20>>>2>>>0]+1900,Wt[wt+16>>>2>>>0],Wt[wt+12>>>2>>>0],Wt[wt+8>>>2>>>0],Wt[wt+4>>>2>>>0],Wt[wt>>>2>>>0],0),Vt=Wt[wt+32>>>2>>>0],Qt=Pt.getTimezoneOffset(),gn=new Date(Pt.getFullYear(),6,1).getTimezoneOffset(),En=new Date(Pt.getFullYear(),0,1).getTimezoneOffset(),or=Math.min(En,gn);return 0>Vt?Wt[wt+32>>>2>>>0]=+(gn!=En&&or==Qt):0<Vt!=(or==Qt)&&(gn=Math.max(En,gn),Pt.setTime(Pt.getTime()+6e4*((0<Vt?or:gn)-Qt))),Wt[wt+24>>>2>>>0]=Pt.getDay(),Wt[wt+28>>>2>>>0]=(No(Pt.getFullYear())?A0:z0)[Pt.getMonth()]+Pt.getDate()-1|0,Wt[wt>>>2>>>0]=Pt.getSeconds(),Wt[wt+4>>>2>>>0]=Pt.getMinutes(),Wt[wt+8>>>2>>>0]=Pt.getHours(),Wt[wt+12>>>2>>>0]=Pt.getDate(),Wt[wt+16>>>2>>>0]=Pt.getMonth(),Wt[wt+20>>>2>>>0]=Pt.getYear(),wt=Pt.getTime(),BigInt(isNaN(wt)?-1:wt/1e3)},U:function(){return-52},V:function(){},N:function(wt,Pt,Vt,Qt){Vt>>>=0,Qt>>>=0;var gn=new Date().getFullYear(),En=new Date(gn,0,1),or=new Date(gn,6,1);gn=En.getTimezoneOffset();var yr=or.getTimezoneOffset();Jt[wt>>>0>>>2>>>0]=60*Math.max(gn,yr),Wt[Pt>>>0>>>2>>>0]=+(gn!=yr),wt=Cr=>Cr.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],En=wt(En),or=wt(or),yr<gn?(qr(En,mn,Vt,17),qr(or,mn,Qt,17)):(qr(En,mn,Qt,17),qr(or,mn,Vt,17))},v:()=>{r0("")},d:function(wt,Pt,Vt){return wt>>>=0,Pt=uy(Pt>>>0,Vt>>>0),E0[wt](...Pt)},I:function(wt,Pt,Vt){return wt>>>=0,Pt=uy(Pt>>>0,Vt>>>0),E0[wt](...Pt)},H:()=>Date.now(),O:function(){return 4294901760},q:()=>performance.now(),M:function(wt){wt>>>=0;var Pt=mn.length;if(4294901760<wt)return!1;for(var Vt=1;4>=Vt;Vt*=2){var Qt=Pt*(1+.2/Vt);Qt=Math.min(Qt,wt+100663296);var gn=Math;Qt=Math.max(wt,Qt);e:{gn=(gn.min.call(gn,4294901760,Qt+(65536-Qt%65536)%65536)-Tt.buffer.byteLength+65535)/65536;try{Tt.grow(gn),rr();var En=1;break e}catch{}En=void 0}if(En)return!0}return!1},$:function(wt,Pt){wt>>>=0,Pt>>>=0;var Vt=0;return c0().forEach((Qt,gn)=>{var En=Pt+Vt;for(gn=Jt[wt+4*gn>>>2>>>0]=En,En=0;En<Qt.length;++En)yn[gn++>>>0]=Qt.charCodeAt(En);yn[gn>>>0]=0,Vt+=Qt.length+1}),0},aa:function(wt,Pt){wt>>>=0,Pt>>>=0;var Vt=c0();Jt[wt>>>2>>>0]=Vt.length;var Qt=0;return Vt.forEach(gn=>Qt+=gn.length+1),Jt[Pt>>>2>>>0]=Qt,0},A:()=>52,F:function(){return 52},_:function(){return 70},E:function(wt,Pt,Vt,Qt){Pt>>>=0,Vt>>>=0,Qt>>>=0;for(var gn=0,En=0;En<Vt;En++){var or=Jt[Pt>>>2>>>0],yr=Jt[Pt+4>>>2>>>0];Pt+=8;for(var Cr=0;Cr<yr;Cr++){var Tr=mn[or+Cr>>>0],Fr=ky[wt];Tr===0||Tr===10?((wt===1?Ct:It)(a0(Fr,0)),Fr.length=0):Fr.push(Tr)}gn+=yr}return Jt[Qt>>>2>>>0]=gn,0},fa:Ey,p:function(wt,Pt,Vt,Qt){return Ey(wt>>>0,Pt>>>0,Vt>>>0,Qt>>>0)}},Wr=function(){function wt(Vt){return Wr=Vt.exports,Wr=sy(),Wr=Zr(),Tt=Wr.ja,rr(),Ir.unshift(Wr.ka),Ur--,Ur==0&&Yr&&(Vt=Yr,Yr=null,Vt()),Wr}var Pt={a:Oy};if(Ur++,h.instantiateWasm)try{return h.instantiateWasm(Pt,wt)}catch(Vt){It(`Module.instantiateWasm callback failed with error: ${Vt}`),ot(Vt)}return k0(Pt,function(Vt){wt(Vt.instance)}).catch(ot),{}}(),vy=wt=>(vy=Wr.la)(wt);h._OrtInit=(wt,Pt)=>(h._OrtInit=Wr.ma)(wt,Pt),h._OrtGetLastError=(wt,Pt)=>(h._OrtGetLastError=Wr.na)(wt,Pt),h._OrtCreateSessionOptions=(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr)=>(h._OrtCreateSessionOptions=Wr.oa)(wt,Pt,Vt,Qt,gn,En,or,yr,Cr,Tr),h._OrtAppendExecutionProvider=(wt,Pt)=>(h._OrtAppendExecutionProvider=Wr.pa)(wt,Pt),h._OrtAddFreeDimensionOverride=(wt,Pt,Vt)=>(h._OrtAddFreeDimensionOverride=Wr.qa)(wt,Pt,Vt),h._OrtAddSessionConfigEntry=(wt,Pt,Vt)=>(h._OrtAddSessionConfigEntry=Wr.ra)(wt,Pt,Vt),h._OrtReleaseSessionOptions=wt=>(h._OrtReleaseSessionOptions=Wr.sa)(wt),h._OrtCreateSession=(wt,Pt,Vt)=>(h._OrtCreateSession=Wr.ta)(wt,Pt,Vt),h._OrtReleaseSession=wt=>(h._OrtReleaseSession=Wr.ua)(wt),h._OrtGetInputOutputCount=(wt,Pt,Vt)=>(h._OrtGetInputOutputCount=Wr.va)(wt,Pt,Vt),h._OrtGetInputName=(wt,Pt)=>(h._OrtGetInputName=Wr.wa)(wt,Pt),h._OrtGetOutputName=(wt,Pt)=>(h._OrtGetOutputName=Wr.xa)(wt,Pt),h._OrtFree=wt=>(h._OrtFree=Wr.ya)(wt),h._OrtCreateTensor=(wt,Pt,Vt,Qt,gn,En)=>(h._OrtCreateTensor=Wr.za)(wt,Pt,Vt,Qt,gn,En),h._OrtGetTensorData=(wt,Pt,Vt,Qt,gn)=>(h._OrtGetTensorData=Wr.Aa)(wt,Pt,Vt,Qt,gn),h._OrtReleaseTensor=wt=>(h._OrtReleaseTensor=Wr.Ba)(wt),h._OrtCreateRunOptions=(wt,Pt,Vt,Qt)=>(h._OrtCreateRunOptions=Wr.Ca)(wt,Pt,Vt,Qt),h._OrtAddRunConfigEntry=(wt,Pt,Vt)=>(h._OrtAddRunConfigEntry=Wr.Da)(wt,Pt,Vt),h._OrtReleaseRunOptions=wt=>(h._OrtReleaseRunOptions=Wr.Ea)(wt),h._OrtCreateBinding=wt=>(h._OrtCreateBinding=Wr.Fa)(wt),h._OrtBindInput=(wt,Pt,Vt)=>(h._OrtBindInput=Wr.Ga)(wt,Pt,Vt),h._OrtBindOutput=(wt,Pt,Vt,Qt)=>(h._OrtBindOutput=Wr.Ha)(wt,Pt,Vt,Qt),h._OrtClearBoundOutputs=wt=>(h._OrtClearBoundOutputs=Wr.Ia)(wt),h._OrtReleaseBinding=wt=>(h._OrtReleaseBinding=Wr.Ja)(wt),h._OrtRunWithBinding=(wt,Pt,Vt,Qt,gn)=>(h._OrtRunWithBinding=Wr.Ka)(wt,Pt,Vt,Qt,gn),h._OrtRun=(wt,Pt,Vt,Qt,gn,En,or,yr)=>(h._OrtRun=Wr.La)(wt,Pt,Vt,Qt,gn,En,or,yr),h._OrtEndProfiling=wt=>(h._OrtEndProfiling=Wr.Ma)(wt),h._JsepOutput=(wt,Pt,Vt)=>(h._JsepOutput=Wr.Na)(wt,Pt,Vt),h._JsepGetNodeName=wt=>(h._JsepGetNodeName=Wr.Oa)(wt);var ny=h._malloc=wt=>(ny=h._malloc=Wr.Pa)(wt),S0=h._free=wt=>(S0=h._free=Wr.Qa)(wt),gy=wt=>(gy=Wr.Sa)(wt),yy=wt=>(yy=Wr.Ta)(wt),_y=()=>(_y=Wr.Ua)(),cy=wt=>(cy=Wr.Wa)(wt),Wo=()=>(Wo=Wr.Xa)(),F0=wt=>(F0=Wr.Ya)(wt),Gr=()=>(Gr=Wr.Za)();h.___start_em_js=837968,h.___stop_em_js=838129;function Zr(){var wt=Wr;wt=Object.assign({},wt);var Pt=Vt=>Qt=>Vt(Qt)>>>0;return wt.la=Pt(wt.la),wt.Pa=Pt(wt.Pa),wt.Ta=Pt(wt.Ta),wt.Ua=(Vt=>()=>Vt()>>>0)(wt.Ua),wt}h.stackSave=()=>_y(),h.stackRestore=wt=>gy(wt),h.stackAlloc=wt=>yy(wt),h.UTF8ToString=e0,h.stringToUTF8=(wt,Pt,Vt)=>qr(wt,mn,Pt,Vt),h.lengthBytesUTF8=C0;var V0;Yr=function wt(){V0||dy(),V0||(Yr=wt)};function dy(){if(!(0<Ur)){if(h.preRun)for(typeof h.preRun=="function"&&(h.preRun=[h.preRun]);h.preRun.length;){var wt=h.preRun.shift();vr.unshift(wt)}for(;0<vr.length;)vr.shift()(h);if(!(0<Ur||V0||(V0=!0,h.calledRun=!0,jt))){for(;0<Ir.length;)Ir.shift()(h);for(et(h);0<$r.length;)$r.shift()(h)}}}return dy(),it}})();typeof i=="object"&&typeof e=="object"?e.exports=o:typeof define=="function"&&define.amd&&define([],()=>o)}),Bo=Er(()=>{}),Do=Er(()=>{}),Mo={};kr(Mo,{cpus:()=>fc});var fc,Uo=j(()=>{fc=void 0}),Vo=Er((i,e)=>{var o=(()=>{var d;var a=typeof document<"u"?(d=document.currentScript)==null?void 0:d.src:void 0;return typeof __filename<"u"&&(a||(a=__filename)),function(g={}){function h(){return hn.buffer!=$r.buffer&&s0(),$r}function et(){return hn.buffer!=$r.buffer&&s0(),Ur}function ot(){return hn.buffer!=$r.buffer&&s0(),Yr}function it(){return hn.buffer!=$r.buffer&&s0(),r0}function $(){return hn.buffer!=$r.buffer&&s0(),b0}function c(){return hn.buffer!=$r.buffer&&s0(),t0}function s(){return hn.buffer!=$r.buffer&&s0(),l0}function _(){return hn.buffer!=$r.buffer&&s0(),vm}var b=g,st,dt,ct=new Promise((ht,vt)=>{st=ht,dt=vt});b.mountExternalData=(ht,vt)=>{(b.Db||(b.Db=new Map)).set(ht,vt)},b.unmountExternalData=()=>{delete b.Db};let pt=()=>{let ht=(Ft,Gt,pn)=>(...wn)=>{let nr=Gr,ar=Gt==null?void 0:Gt();wn=Ft(...wn);let Mr=Gt==null?void 0:Gt();return ar!==Mr&&(Ft=Mr,pn(ar),Gt=pn=null),Gr!=nr?gn():wn},vt=Ft=>async(...Gt)=>{var pn;try{if(b.Cb)throw Error("Session already started");let wn=b.Cb={ec:Gt[0],errors:[]},nr=await Ft(...Gt);if(b.Cb!==wn)throw Error("Session mismatch");(pn=b.Kb)==null||pn.flush();let ar=wn.errors;if(0<ar.length){let Mr=await Promise.all(ar);if(Mr=Mr.filter(Ar=>Ar),0<Mr.length)throw Error(Mr.join(`
`))}return nr}finally{b.Cb=null}};b._OrtCreateSession=ht(b._OrtCreateSession,()=>b._OrtCreateSession,Ft=>b._OrtCreateSession=Ft),b._OrtRun=vt(ht(b._OrtRun,()=>b._OrtRun,Ft=>b._OrtRun=Ft)),b._OrtRunWithBinding=vt(ht(b._OrtRunWithBinding,()=>b._OrtRunWithBinding,Ft=>b._OrtRunWithBinding=Ft)),b._OrtBindInput=ht(b._OrtBindInput,()=>b._OrtBindInput,Ft=>b._OrtBindInput=Ft),pt=void 0};b.jsepInit=(ht,vt)=>{if(pt==null||pt(),ht==="webgpu"){[b.Kb,b.Wb,b.$b,b.Lb,b.Zb,b.ob,b.ac,b.cc,b.Xb,b.Yb,b.bc]=vt;let Ft=b.Kb;b.jsepRegisterBuffer=(Gt,pn,wn,nr)=>Ft.registerBuffer(Gt,pn,wn,nr),b.jsepGetBuffer=Gt=>Ft.getBuffer(Gt),b.jsepCreateDownloader=(Gt,pn,wn)=>Ft.createDownloader(Gt,pn,wn),b.jsepOnReleaseSession=Gt=>{Ft.onReleaseSession(Gt)},b.jsepOnRunStart=Gt=>Ft.onRunStart(Gt)}};var ft=Object.assign({},b),mt="./this.program",bt=(ht,vt)=>{throw vt},$t=typeof window=="object",Ct=typeof importScripts=="function",It=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",Tt=b.ENVIRONMENT_IS_PTHREAD||!1,jt="";function dn(ht){return b.locateFile?b.locateFile(ht,jt):jt+ht}var yn,mn,fn;if(It){var un=(Mi(),sr(Di)),Wt=(Wi(),sr(Ui));jt=Ct?Wt.dirname(jt)+"/":__dirname+"/",yn=(ht,vt)=>(ht=qr(ht)?new URL(ht):Wt.normalize(ht),un.readFileSync(ht,vt?void 0:"utf8")),fn=ht=>(ht=yn(ht,!0),ht.buffer||(ht=new Uint8Array(ht)),ht),mn=(ht,vt,Ft,Gt=!0)=>{ht=qr(ht)?new URL(ht):Wt.normalize(ht),un.readFile(ht,Gt?void 0:"utf8",(pn,wn)=>{pn?Ft(pn):vt(Gt?wn.buffer:wn)})},!b.thisProgram&&1<process.argv.length&&(mt=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),bt=(ht,vt)=>{throw process.exitCode=ht,vt},global.Worker=Bo().Worker}else($t||Ct)&&(Ct?jt=self.location.href:typeof document<"u"&&document.currentScript&&(jt=document.currentScript.src),typeof a<"u"&&a&&(jt=a),jt.startsWith("blob:")?jt="":jt=jt.substr(0,jt.replace(/[?#].*/,"").lastIndexOf("/")+1),It||(yn=ht=>{var vt=new XMLHttpRequest;return vt.open("GET",ht,!1),vt.send(null),vt.responseText},Ct&&(fn=ht=>{var vt=new XMLHttpRequest;return vt.open("GET",ht,!1),vt.responseType="arraybuffer",vt.send(null),new Uint8Array(vt.response)}),mn=(ht,vt,Ft)=>{var Gt=new XMLHttpRequest;Gt.open("GET",ht,!0),Gt.responseType="arraybuffer",Gt.onload=()=>{Gt.status==200||Gt.status==0&&Gt.response?vt(Gt.response):Ft()},Gt.onerror=Ft,Gt.send(null)}));It&&typeof performance>"u"&&(global.performance=Do().performance);var Jt=console.log.bind(console),_n=console.error.bind(console);It&&(Jt=(...ht)=>un.writeSync(1,ht.join(" ")+`
`),_n=(...ht)=>un.writeSync(2,ht.join(" ")+`
`));var vn=Jt,Sn=_n;Object.assign(b,ft),ft=null;var hn,rr,vr=!1,Ir,$r,Ur,Yr,r0,b0,t0,l0,_i,Po,vm;function s0(){var ht=hn.buffer;b.HEAP8=$r=new Int8Array(ht),b.HEAP16=Yr=new Int16Array(ht),b.HEAPU8=Ur=new Uint8Array(ht),b.HEAPU16=r0=new Uint16Array(ht),b.HEAP32=b0=new Int32Array(ht),b.HEAPU32=t0=new Uint32Array(ht),b.HEAPF32=l0=new Float32Array(ht),b.HEAPF64=vm=new Float64Array(ht),b.HEAP64=_i=new BigInt64Array(ht),b.HEAPU64=Po=new BigUint64Array(ht)}var k0=16777216;if(Tt)hn=b.wasmMemory;else if(b.wasmMemory)hn=b.wasmMemory;else if(hn=new WebAssembly.Memory({initial:k0/65536,maximum:65536,shared:!0}),!(hn.buffer instanceof SharedArrayBuffer))throw Sn("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),It&&Sn("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");s0(),k0=hn.buffer.byteLength;var E0=[],O0=[],U0=[],w0=0,v0=null;function a0(){if(w0--,w0==0&&v0){var ht=v0;v0=null,ht()}}function e0(ht){throw ht="Aborted("+ht+")",Sn(ht),vr=!0,Ir=1,ht=new WebAssembly.RuntimeError(ht+". Build with -sASSERTIONS for more info."),dt(ht),ht}var C0=ht=>ht.startsWith("data:application/octet-stream;base64,"),qr=ht=>ht.startsWith("file://"),L0;L0="ort-wasm-simd-threaded.wasm",C0(L0)||(L0=dn(L0));function $0(ht){if(fn)return fn(ht);throw"both async and sync fetching of the wasm failed"}function ry(ht){if($t||Ct){if(typeof fetch=="function"&&!qr(ht))return fetch(ht,{credentials:"same-origin"}).then(vt=>{if(!vt.ok)throw`failed to load wasm binary file at '${ht}'`;return vt.arrayBuffer()}).catch(()=>$0(ht));if(mn)return new Promise((vt,Ft)=>{mn(ht,Gt=>vt(new Uint8Array(Gt)),Ft)})}return Promise.resolve().then(()=>$0(ht))}function D0(ht,vt,Ft){return ry(ht).then(Gt=>WebAssembly.instantiate(Gt,vt)).then(Ft,Gt=>{Sn(`failed to asynchronously prepare wasm: ${Gt}`),e0(Gt)})}function P0(ht,vt){var Ft=L0;return typeof WebAssembly.instantiateStreaming!="function"||C0(Ft)||qr(Ft)||It||typeof fetch!="function"?D0(Ft,ht,vt):fetch(Ft,{credentials:"same-origin"}).then(Gt=>WebAssembly.instantiateStreaming(Gt,ht).then(vt,function(pn){return Sn(`wasm streaming compile failed: ${pn}`),Sn("falling back to ArrayBuffer instantiation"),D0(Ft,ht,vt)}))}var G0={826468:(ht,vt,Ft,Gt)=>{if(typeof b>"u"||!b.Db)return 1;if(ht=f0(ht>>>0),ht.startsWith("./")&&(ht=ht.substring(2)),ht=b.Db.get(ht),!ht)return 2;if(vt>>>=0,Ft>>>=0,Gt>>>=0,vt+Ft>ht.byteLength)return 3;try{return et().set(ht.subarray(vt,vt+Ft),Gt>>>0),0}catch{return 4}},826969:()=>{b.Xb()},827e3:()=>{b.Yb()},827029:()=>{b.bc()},827054:ht=>b.Wb(ht),827087:ht=>b.$b(ht),827119:(ht,vt,Ft)=>{b.Lb(ht,vt,Ft,!0)},827158:(ht,vt,Ft)=>{b.Lb(ht,vt,Ft)},827191:ht=>{b.ob("Abs",ht,void 0)},827242:ht=>{b.ob("Neg",ht,void 0)},827293:ht=>{b.ob("Floor",ht,void 0)},827346:ht=>{b.ob("Ceil",ht,void 0)},827398:ht=>{b.ob("Reciprocal",ht,void 0)},827456:ht=>{b.ob("Sqrt",ht,void 0)},827508:ht=>{b.ob("Exp",ht,void 0)},827559:ht=>{b.ob("Erf",ht,void 0)},827610:ht=>{b.ob("Sigmoid",ht,void 0)},827665:(ht,vt,Ft)=>{b.ob("HardSigmoid",ht,{alpha:vt,beta:Ft})},827744:ht=>{b.ob("Log",ht,void 0)},827795:ht=>{b.ob("Sin",ht,void 0)},827846:ht=>{b.ob("Cos",ht,void 0)},827897:ht=>{b.ob("Tan",ht,void 0)},827948:ht=>{b.ob("Asin",ht,void 0)},828e3:ht=>{b.ob("Acos",ht,void 0)},828052:ht=>{b.ob("Atan",ht,void 0)},828104:ht=>{b.ob("Sinh",ht,void 0)},828156:ht=>{b.ob("Cosh",ht,void 0)},828208:ht=>{b.ob("Asinh",ht,void 0)},828261:ht=>{b.ob("Acosh",ht,void 0)},828314:ht=>{b.ob("Atanh",ht,void 0)},828367:ht=>{b.ob("Tanh",ht,void 0)},828419:ht=>{b.ob("Not",ht,void 0)},828470:(ht,vt,Ft)=>{b.ob("Clip",ht,{min:vt,max:Ft})},828539:ht=>{b.ob("Clip",ht,void 0)},828591:(ht,vt)=>{b.ob("Elu",ht,{alpha:vt})},828649:ht=>{b.ob("Relu",ht,void 0)},828701:(ht,vt)=>{b.ob("LeakyRelu",ht,{alpha:vt})},828765:(ht,vt)=>{b.ob("ThresholdedRelu",ht,{alpha:vt})},828835:(ht,vt)=>{b.ob("Cast",ht,{to:vt})},828893:ht=>{b.ob("Add",ht,void 0)},828944:ht=>{b.ob("Sub",ht,void 0)},828995:ht=>{b.ob("Mul",ht,void 0)},829046:ht=>{b.ob("Div",ht,void 0)},829097:ht=>{b.ob("Pow",ht,void 0)},829148:ht=>{b.ob("Equal",ht,void 0)},829201:ht=>{b.ob("Greater",ht,void 0)},829256:ht=>{b.ob("GreaterOrEqual",ht,void 0)},829318:ht=>{b.ob("Less",ht,void 0)},829370:ht=>{b.ob("LessOrEqual",ht,void 0)},829429:(ht,vt,Ft,Gt,pn)=>{b.ob("ReduceMean",ht,{keepDims:!!vt,noopWithEmptyAxes:!!Ft,axes:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},829588:(ht,vt,Ft,Gt,pn)=>{b.ob("ReduceMax",ht,{keepDims:!!vt,noopWithEmptyAxes:!!Ft,axes:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},829746:(ht,vt,Ft,Gt,pn)=>{b.ob("ReduceMin",ht,{keepDims:!!vt,noopWithEmptyAxes:!!Ft,axes:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},829904:(ht,vt,Ft,Gt,pn)=>{b.ob("ReduceProd",ht,{keepDims:!!vt,noopWithEmptyAxes:!!Ft,axes:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},830063:(ht,vt,Ft,Gt,pn)=>{b.ob("ReduceSum",ht,{keepDims:!!vt,noopWithEmptyAxes:!!Ft,axes:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},830221:(ht,vt,Ft,Gt,pn)=>{b.ob("ReduceL1",ht,{keepDims:!!vt,noopWithEmptyAxes:!!Ft,axes:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},830378:(ht,vt,Ft,Gt,pn)=>{b.ob("ReduceL2",ht,{keepDims:!!vt,noopWithEmptyAxes:!!Ft,axes:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},830535:(ht,vt,Ft,Gt,pn)=>{b.ob("ReduceLogSum",ht,{keepDims:!!vt,noopWithEmptyAxes:!!Ft,axes:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},830696:(ht,vt,Ft,Gt,pn)=>{b.ob("ReduceSumSquare",ht,{keepDims:!!vt,noopWithEmptyAxes:!!Ft,axes:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},830860:(ht,vt,Ft,Gt,pn)=>{b.ob("ReduceLogSumExp",ht,{keepDims:!!vt,noopWithEmptyAxes:!!Ft,axes:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},831024:ht=>{b.ob("Where",ht,void 0)},831077:(ht,vt,Ft)=>{b.ob("Transpose",ht,{perm:vt?Array.from($().subarray(vt>>>0,Ft>>>0)):[]})},831185:(ht,vt,Ft,Gt)=>{b.ob("DepthToSpace",ht,{blocksize:vt,mode:f0(Ft),format:Gt?"NHWC":"NCHW"})},831318:(ht,vt,Ft,Gt)=>{b.ob("DepthToSpace",ht,{blocksize:vt,mode:f0(Ft),format:Gt?"NHWC":"NCHW"})},831451:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar,Hr,u0,d0,tr,ns)=>{b.ob("ConvTranspose",ht,{format:Mr?"NHWC":"NCHW",autoPad:vt,dilations:[Ft],group:Gt,kernelShape:[pn],pads:[wn,nr],strides:[ar],wIsConst:()=>!!h()[Ar>>>0],outputPadding:Hr?Array.from($().subarray(Hr>>>0,u0>>>0)):[],outputShape:d0?Array.from($().subarray(d0>>>0,tr>>>0)):[],activation:f0(ns)})},831852:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar,Hr,u0,d0,tr)=>{b.ob("ConvTranspose",ht,{format:ar?"NHWC":"NCHW",autoPad:vt,dilations:Array.from($().subarray(Ft>>>0,(Ft>>>0)+2>>>0)),group:Gt,kernelShape:Array.from($().subarray(pn>>>0,(pn>>>0)+2>>>0)),pads:Array.from($().subarray(wn>>>0,(wn>>>0)+4>>>0)),strides:Array.from($().subarray(nr>>>0,(nr>>>0)+2>>>0)),wIsConst:()=>!!h()[Mr>>>0],outputPadding:Ar?Array.from($().subarray(Ar>>>0,Hr>>>0)):[],outputShape:u0?Array.from($().subarray(u0>>>0,d0>>>0)):[],activation:f0(tr)})},832417:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar,Hr,u0,d0,tr,ns)=>{b.ob("ConvTranspose",ht,{format:Mr?"NHWC":"NCHW",autoPad:vt,dilations:[Ft],group:Gt,kernelShape:[pn],pads:[wn,nr],strides:[ar],wIsConst:()=>!!h()[Ar>>>0],outputPadding:Hr?Array.from($().subarray(Hr>>>0,u0>>>0)):[],outputShape:d0?Array.from($().subarray(d0>>>0,tr>>>0)):[],activation:f0(ns)})},832818:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar,Hr,u0,d0,tr)=>{b.ob("ConvTranspose",ht,{format:ar?"NHWC":"NCHW",autoPad:vt,dilations:Array.from($().subarray(Ft>>>0,(Ft>>>0)+2>>>0)),group:Gt,kernelShape:Array.from($().subarray(pn>>>0,(pn>>>0)+2>>>0)),pads:Array.from($().subarray(wn>>>0,(wn>>>0)+4>>>0)),strides:Array.from($().subarray(nr>>>0,(nr>>>0)+2>>>0)),wIsConst:()=>!!h()[Mr>>>0],outputPadding:Ar?Array.from($().subarray(Ar>>>0,Hr>>>0)):[],outputShape:u0?Array.from($().subarray(u0>>>0,d0>>>0)):[],activation:f0(tr)})},833383:(ht,vt)=>{b.ob("GlobalAveragePool",ht,{format:vt?"NHWC":"NCHW"})},833474:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar,Hr,u0,d0,tr,ns,o0)=>{b.ob("AveragePool",ht,{format:o0?"NHWC":"NCHW",auto_pad:vt,ceil_mode:Ft,count_include_pad:Gt,storage_order:pn,dilations:[wn,nr],kernel_shape:[ar,Mr],pads:[Ar,Hr,u0,d0],strides:[tr,ns]})},833758:(ht,vt)=>{b.ob("GlobalAveragePool",ht,{format:vt?"NHWC":"NCHW"})},833849:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar,Hr,u0,d0,tr,ns,o0)=>{b.ob("AveragePool",ht,{format:o0?"NHWC":"NCHW",auto_pad:vt,ceil_mode:Ft,count_include_pad:Gt,storage_order:pn,dilations:[wn,nr],kernel_shape:[ar,Mr],pads:[Ar,Hr,u0,d0],strides:[tr,ns]})},834133:(ht,vt)=>{b.ob("GlobalMaxPool",ht,{format:vt?"NHWC":"NCHW"})},834220:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar,Hr,u0,d0,tr,ns,o0)=>{b.ob("MaxPool",ht,{format:o0?"NHWC":"NCHW",auto_pad:vt,ceil_mode:Ft,count_include_pad:Gt,storage_order:pn,dilations:[wn,nr],kernel_shape:[ar,Mr],pads:[Ar,Hr,u0,d0],strides:[tr,ns]})},834500:(ht,vt)=>{b.ob("GlobalMaxPool",ht,{format:vt?"NHWC":"NCHW"})},834587:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar,Hr,u0,d0,tr,ns,o0)=>{b.ob("MaxPool",ht,{format:o0?"NHWC":"NCHW",auto_pad:vt,ceil_mode:Ft,count_include_pad:Gt,storage_order:pn,dilations:[wn,nr],kernel_shape:[ar,Mr],pads:[Ar,Hr,u0,d0],strides:[tr,ns]})},834867:(ht,vt,Ft,Gt,pn)=>{b.ob("Gemm",ht,{alpha:vt,beta:Ft,transA:Gt,transB:pn})},834971:ht=>{b.ob("MatMul",ht,void 0)},835025:(ht,vt,Ft,Gt)=>{b.ob("ArgMax",ht,{keepDims:!!vt,selectLastIndex:!!Ft,axis:Gt})},835133:(ht,vt,Ft,Gt)=>{b.ob("ArgMin",ht,{keepDims:!!vt,selectLastIndex:!!Ft,axis:Gt})},835241:(ht,vt)=>{b.ob("Softmax",ht,{axis:vt})},835304:(ht,vt)=>{b.ob("Concat",ht,{axis:vt})},835364:(ht,vt,Ft,Gt,pn)=>{b.ob("Split",ht,{axis:vt,numOutputs:Ft,splitSizes:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},835504:ht=>{b.ob("Expand",ht,void 0)},835558:(ht,vt)=>{b.ob("Gather",ht,{axis:Number(vt)})},835629:(ht,vt)=>{b.ob("GatherElements",ht,{axis:Number(vt)})},835708:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar,Hr)=>{b.ob("Resize",ht,{antialias:vt,axes:Ft?Array.from($().subarray(Ft>>>0,Gt>>>0)):[],coordinateTransformMode:f0(pn),cubicCoeffA:wn,excludeOutside:nr,extrapolationValue:ar,keepAspectRatioPolicy:f0(Mr),mode:f0(Ar),nearestMode:f0(Hr)})},836054:(ht,vt,Ft,Gt,pn,wn,nr)=>{b.ob("Slice",ht,{starts:vt?Array.from($().subarray(vt>>>0,Ft>>>0)):[],ends:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[],axes:wn?Array.from($().subarray(wn>>>0,nr>>>0)):[]})},836270:ht=>{b.ob("Tile",ht,void 0)},836322:(ht,vt,Ft,Gt)=>{b.ob("LayerNormalization",ht,{axis:vt,epsilon:Ft,simplified:!!Gt})},836433:(ht,vt,Ft)=>{b.ob("InstanceNormalization",ht,{epsilon:vt,format:Ft?"NHWC":"NCHW"})},836547:(ht,vt,Ft)=>{b.ob("InstanceNormalization",ht,{epsilon:vt,format:Ft?"NHWC":"NCHW"})},836661:ht=>{b.ob("Range",ht,void 0)},836714:(ht,vt)=>{b.ob("Einsum",ht,{equation:f0(vt)})},836795:(ht,vt,Ft,Gt,pn)=>{b.ob("Pad",ht,{mode:vt,value:Ft,pads:Gt?Array.from($().subarray(Gt>>>0,pn>>>0)):[]})},836922:(ht,vt,Ft,Gt,pn,wn)=>{b.ob("BatchNormalization",ht,{epsilon:vt,momentum:Ft,spatial:!!pn,trainingMode:!!Gt,format:wn?"NHWC":"NCHW"})},837091:(ht,vt,Ft,Gt,pn,wn)=>{b.ob("BatchNormalization",ht,{epsilon:vt,momentum:Ft,spatial:!!pn,trainingMode:!!Gt,format:wn?"NHWC":"NCHW"})},837260:(ht,vt,Ft)=>{b.ob("CumSum",ht,{exclusive:Number(vt),reverse:Number(Ft)})},837357:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr)=>{b.ob("Attention",ht,{numHeads:vt,isUnidirectional:Ft,maskFilterValue:Gt,scale:pn,doRotary:wn,qkvHiddenSizes:nr?Array.from($().subarray(Number(ar)>>>0,Number(ar)+nr>>>0)):[],pastPresentShareBuffer:!!Mr})},837629:ht=>{b.ob("BiasAdd",ht,void 0)},837684:ht=>{b.ob("BiasSplitGelu",ht,void 0)},837745:ht=>{b.ob("FastGelu",ht,void 0)},837801:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar,Hr,u0,d0)=>{b.ob("Conv",ht,{format:Mr?"NHWC":"NCHW",auto_pad:vt,dilations:[Ft],group:Gt,kernel_shape:[pn],pads:wn?Array.from($().subarray(wn>>>0,nr>>>0)):[],strides:[ar],w_is_const:()=>!!h()[Ar>>>0],activation:f0(Hr),activation_params:u0?Array.from(s().subarray(u0>>>0,d0>>>0)):[]})},838171:(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar,Hr,u0,d0,tr,ns,o0)=>{b.ob("Conv",ht,{format:u0?"NHWC":"NCHW",auto_pad:vt,dilations:[Ft,Gt],group:pn,kernel_shape:[wn,nr],pads:ar?Array.from($().subarray(ar>>>0,Mr>>>0)):[],strides:[Ar,Hr],w_is_const:()=>!!h()[d0>>>0],activation:f0(tr),activation_params:ns?Array.from(s().subarray(ns>>>0,o0>>>0)):[]})},838562:ht=>{b.ob("Gelu",ht,void 0)},838614:(ht,vt,Ft,Gt,pn,wn)=>{b.ob("MatMulNBits",ht,{k:vt,n:Ft,accuracyLevel:Gt,bits:pn,blockSize:wn})},838741:(ht,vt,Ft,Gt,pn,wn)=>{b.ob("MultiHeadAttention",ht,{numHeads:vt,isUnidirectional:Ft,maskFilterValue:Gt,scale:pn,doRotary:wn})},838900:(ht,vt,Ft,Gt,pn)=>{b.ob("RotaryEmbedding",ht,{interleaved:!!vt,numHeads:Ft,rotaryEmbeddingDim:Gt,scale:pn})},839039:(ht,vt,Ft)=>{b.ob("SkipLayerNormalization",ht,{epsilon:vt,simplified:!!Ft})},839141:(ht,vt,Ft)=>{b.ob("SkipLayerNormalization",ht,{epsilon:vt,simplified:!!Ft})},839243:(ht,vt,Ft,Gt)=>{b.ob("LayerNormalization",ht,{axis:vt,epsilon:Ft,simplified:!!Gt})},839354:ht=>{b.ac(ht)},839388:(ht,vt)=>b.cc(ht,vt,b.Cb.ec,b.Cb.errors)};function i0(ht){this.name="ExitStatus",this.message=`Program terminated with exit(${ht})`,this.status=ht}var B0=ht=>{ht.terminate(),ht.onmessage=()=>{}},jr=ht=>{_r.xb.length==0&&(oy(),_r.Mb(_r.xb[0]));var vt=_r.xb.pop();if(!vt)return 6;_r.yb.push(vt),_r.ub[ht.wb]=vt,vt.wb=ht.wb;var Ft={cmd:"run",start_routine:ht.fc,arg:ht.Rb,pthread_ptr:ht.wb};return It&&vt.unref(),vt.postMessage(Ft,ht.mc),0},p0=0,iy=ht=>{var vt=Uy();return ht=ht(),Ry(vt),ht},eo=(ht,vt,...Ft)=>iy(()=>{for(var Gt=2*Ft.length,pn=Fy(8*Gt),wn=pn>>>3,nr=0;nr<Ft.length;nr++){var ar=Ft[nr];typeof ar=="bigint"?(_i[wn+2*nr]=1n,_i[wn+2*nr+1]=ar):(_i[wn+2*nr]=0n,_()[wn+2*nr+1>>>0]=ar)}return Zy(ht,0,Gt,pn,vt)});function y0(ht){var vt;if(Tt)return eo(0,1,ht);Ir=ht,0<p0||(_r.hc(),(vt=b.onExit)==null||vt.call(b,ht),vr=!0),bt(ht,new i0(ht))}var bp=ht=>{if(Ir=ht,Tt)throw Kr(ht),"unwind";y0(ht)};function Q0(){for(var ht=b.numThreads;ht--;)oy();E0.unshift(()=>{w0++,H0(()=>a0())})}function oy(){var ht=dn("ort-wasm-simd-threaded.worker.js");ht=new Worker(ht),_r.xb.push(ht)}function H0(ht){Tt?ht():Promise.all(_r.xb.map(_r.Mb)).then(ht)}var _r={xb:[],yb:[],Qb:[],ub:{},Gb(){Tt?(_r.receiveObjectTransfer=_r.dc,_r.threadInitTLS=_r.Pb,_r.setExitStatus=_r.Ob):Q0()},Ob:ht=>Ir=ht,pc:["$terminateWorker"],hc:()=>{for(var ht of _r.yb)B0(ht);for(ht of _r.xb)B0(ht);_r.xb=[],_r.yb=[],_r.ub=[]},Nb:ht=>{var vt=ht.wb;delete _r.ub[vt],_r.xb.push(ht),_r.yb.splice(_r.yb.indexOf(ht),1),ht.wb=0,Ly(vt)},dc(){},Pb(){_r.Qb.forEach(ht=>ht())},Mb:ht=>new Promise(vt=>{ht.onmessage=wn=>{wn=wn.data;var nr=wn.cmd;if(wn.targetThread&&wn.targetThread!=Iy()){var ar=_r.ub[wn.targetThread];ar?ar.postMessage(wn,wn.transferList):Sn(`Internal error! Worker sent a message "${nr}" to target pthread ${wn.targetThread}, but that thread no longer exists!`)}else nr==="checkMailbox"?S0():nr==="spawnThread"?jr(wn):nr==="cleanupThread"?_r.Nb(_r.ub[wn.thread]):nr==="killThread"?(wn=wn.thread,nr=_r.ub[wn],delete _r.ub[wn],B0(nr),Ly(wn),_r.yb.splice(_r.yb.indexOf(nr),1),nr.wb=0):nr==="cancelThread"?_r.ub[wn.thread].postMessage({cmd:"cancel"}):nr==="loaded"?(ht.loaded=!0,It&&!ht.wb&&ht.unref(),vt(ht)):nr==="alert"?alert(`Thread ${wn.threadId}: ${wn.text}`):wn.target==="setimmediate"?ht.postMessage(wn):nr==="callHandler"?b[wn.handler](...wn.args):nr&&Sn(`worker sent an unknown command ${nr}`)},ht.onerror=wn=>{throw Sn(`worker sent an error! ${wn.filename}:${wn.lineno}: ${wn.message}`),wn},It&&(ht.on("message",wn=>ht.onmessage({data:wn})),ht.on("error",wn=>ht.onerror(wn)));var Ft=[],Gt=["onExit"],pn;for(pn of Gt)b.hasOwnProperty(pn)&&Ft.push(pn);ht.postMessage({cmd:"load",handlers:Ft,urlOrBlob:b.mainScriptUrlOrBlob||a,wasmMemory:hn,wasmModule:rr})})};b.PThread=_r;var Vr=ht=>{for(;0<ht.length;)ht.shift()(b)};b.establishStackSpace=()=>{var ht=Iy(),vt=c()[ht+52>>>2>>>0];ht=c()[ht+56>>>2>>>0],e_(vt,vt-ht),Ry(vt)};function Kr(ht){if(Tt)return eo(1,0,ht);bp(ht)}b.invokeEntryPoint=(ht,vt)=>{p0=0,ht=t_(ht,vt),0<p0?_r.Ob(ht):By(ht)};class hy{constructor(vt){this.Ib=vt-24}Gb(vt,Ft){c()[this.Ib+16>>>2>>>0]=0,c()[this.Ib+4>>>2>>>0]=vt,c()[this.Ib+8>>>2>>>0]=Ft}}var q0=0;function ay(ht,vt,Ft,Gt){return Tt?eo(2,1,ht,vt,Ft,Gt):K0(ht,vt,Ft,Gt)}function K0(ht,vt,Ft,Gt){if(ht>>>=0,vt>>>=0,Ft>>>=0,Gt>>>=0,typeof SharedArrayBuffer>"u")return Sn("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var pn=[];return Tt&&pn.length===0?ay(ht,vt,Ft,Gt):(ht={fc:Ft,wb:ht,Rb:Gt,mc:pn},Tt?(ht.oc="spawnThread",postMessage(ht,pn),0):jr(ht))}var Z0=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,j0=(ht,vt,Ft)=>{vt>>>=0;var Gt=vt+Ft;for(Ft=vt;ht[Ft]&&!(Ft>=Gt);)++Ft;if(16<Ft-vt&&ht.buffer&&Z0)return Z0.decode(ht.buffer instanceof SharedArrayBuffer?ht.slice(vt,Ft):ht.subarray(vt,Ft));for(Gt="";vt<Ft;){var pn=ht[vt++];if(pn&128){var wn=ht[vt++]&63;if((pn&224)==192)Gt+=String.fromCharCode((pn&31)<<6|wn);else{var nr=ht[vt++]&63;pn=(pn&240)==224?(pn&15)<<12|wn<<6|nr:(pn&7)<<18|wn<<12|nr<<6|ht[vt++]&63,65536>pn?Gt+=String.fromCharCode(pn):(pn-=65536,Gt+=String.fromCharCode(55296|pn>>10,56320|pn&1023))}}else Gt+=String.fromCharCode(pn)}return Gt},f0=(ht,vt)=>(ht>>>=0)?j0(et(),ht,vt):"";function sy(ht,vt,Ft){return Tt?eo(3,1,ht,vt,Ft):0}function I0(ht,vt){if(Tt)return eo(4,1,ht,vt)}var T0=ht=>{for(var vt=0,Ft=0;Ft<ht.length;++Ft){var Gt=ht.charCodeAt(Ft);127>=Gt?vt++:2047>=Gt?vt+=2:55296<=Gt&&57343>=Gt?(vt+=4,++Ft):vt+=3}return vt},J0=(ht,vt,Ft,Gt)=>{if(Ft>>>=0,!(0<Gt))return 0;var pn=Ft;Gt=Ft+Gt-1;for(var wn=0;wn<ht.length;++wn){var nr=ht.charCodeAt(wn);if(55296<=nr&&57343>=nr){var ar=ht.charCodeAt(++wn);nr=65536+((nr&1023)<<10)|ar&1023}if(127>=nr){if(Ft>=Gt)break;vt[Ft++>>>0]=nr}else{if(2047>=nr){if(Ft+1>=Gt)break;vt[Ft++>>>0]=192|nr>>6}else{if(65535>=nr){if(Ft+2>=Gt)break;vt[Ft++>>>0]=224|nr>>12}else{if(Ft+3>=Gt)break;vt[Ft++>>>0]=240|nr>>18,vt[Ft++>>>0]=128|nr>>12&63}vt[Ft++>>>0]=128|nr>>6&63}vt[Ft++>>>0]=128|nr&63}}return vt[Ft>>>0]=0,Ft-pn},M0=(ht,vt,Ft)=>J0(ht,et(),vt,Ft);function ey(ht,vt){if(Tt)return eo(5,1,ht,vt)}function ty(ht,vt,Ft){if(Tt)return eo(6,1,ht,vt,Ft)}function Ht(ht,vt,Ft){return Tt?eo(7,1,ht,vt,Ft):0}function cn(ht,vt){if(Tt)return eo(8,1,ht,vt)}function bn(ht,vt,Ft){if(Tt)return eo(9,1,ht,vt,Ft)}function $n(ht,vt,Ft,Gt){if(Tt)return eo(10,1,ht,vt,Ft,Gt)}function Tn(ht,vt,Ft,Gt){if(Tt)return eo(11,1,ht,vt,Ft,Gt)}function In(ht,vt,Ft,Gt){if(Tt)return eo(12,1,ht,vt,Ft,Gt)}function wr(ht){if(Tt)return eo(13,1,ht)}function Dr(ht,vt){if(Tt)return eo(14,1,ht,vt)}function Sr(ht,vt,Ft){if(Tt)return eo(15,1,ht,vt,Ft)}var Xr,Ro=ht=>{for(var vt="";et()[ht>>>0];)vt+=Xr[et()[ht++>>>0]];return vt},_0={},g0={},An;function _f(ht,vt,Ft={}){var Gt=vt.name;if(!ht)throw new An(`type "${Gt}" must have a positive integer typeid pointer`);if(g0.hasOwnProperty(ht)){if(Ft.Ub)return;throw new An(`Cannot register type '${Gt}' twice`)}g0[ht]=vt,_0.hasOwnProperty(ht)&&(vt=_0[ht],delete _0[ht],vt.forEach(pn=>pn()))}function No(ht,vt,Ft={}){if(!("argPackAdvance"in vt))throw new TypeError("registerType registeredInstance requires argPackAdvance");return _f(ht,vt,Ft)}var A0=(ht,vt,Ft)=>{switch(vt){case 1:return Ft?Gt=>h()[Gt>>>0]:Gt=>et()[Gt>>>0];case 2:return Ft?Gt=>ot()[Gt>>>1>>>0]:Gt=>it()[Gt>>>1>>>0];case 4:return Ft?Gt=>$()[Gt>>>2>>>0]:Gt=>c()[Gt>>>2>>>0];case 8:return Ft?Gt=>_i[Gt>>>3]:Gt=>Po[Gt>>>3];default:throw new TypeError(`invalid integer width (${vt}): ${ht}`)}},z0=[],R0=[];function uy(ht){ht>>>=0,9<ht&&--R0[ht+1]===0&&(R0[ht]=void 0,z0.push(ht))}var x0=ht=>{if(!ht)throw new An("Cannot use deleted val. handle = "+ht);return R0[ht]},c0=ht=>{switch(ht){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let vt=z0.pop()||R0.length;return R0[vt]=ht,R0[vt+1]=1,vt}};function Y0(ht){return this.fromWireType(c()[ht>>>2>>>0])}var ky={name:"emscripten::val",fromWireType:ht=>{var vt=x0(ht);return uy(ht),vt},toWireType:(ht,vt)=>c0(vt),argPackAdvance:8,readValueFromPointer:Y0,Bb:null},xy=(ht,vt)=>{switch(vt){case 4:return function(Ft){return this.fromWireType(s()[Ft>>>2>>>0])};case 8:return function(Ft){return this.fromWireType(_()[Ft>>>3>>>0])};default:throw new TypeError(`invalid float width (${vt}): ${ht}`)}},wy=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Ay=(ht,vt)=>{for(var Ft=ht>>1,Gt=Ft+vt/2;!(Ft>=Gt)&&it()[Ft>>>0];)++Ft;if(Ft<<=1,32<Ft-ht&&wy)return wy.decode(et().slice(ht,Ft));for(Ft="",Gt=0;!(Gt>=vt/2);++Gt){var pn=ot()[ht+2*Gt>>>1>>>0];if(pn==0)break;Ft+=String.fromCharCode(pn)}return Ft},Ey=(ht,vt,Ft)=>{if(Ft??(Ft=2147483647),2>Ft)return 0;Ft-=2;var Gt=vt;Ft=Ft<2*ht.length?Ft/2:ht.length;for(var pn=0;pn<Ft;++pn){var wn=ht.charCodeAt(pn);ot()[vt>>>1>>>0]=wn,vt+=2}return ot()[vt>>>1>>>0]=0,vt-Gt},my=ht=>2*ht.length,ly=(ht,vt)=>{for(var Ft=0,Gt="";!(Ft>=vt/4);){var pn=$()[ht+4*Ft>>>2>>>0];if(pn==0)break;++Ft,65536<=pn?(pn-=65536,Gt+=String.fromCharCode(55296|pn>>10,56320|pn&1023)):Gt+=String.fromCharCode(pn)}return Gt},Oy=(ht,vt,Ft)=>{if(vt>>>=0,Ft??(Ft=2147483647),4>Ft)return 0;var Gt=vt;Ft=Gt+Ft-4;for(var pn=0;pn<ht.length;++pn){var wn=ht.charCodeAt(pn);if(55296<=wn&&57343>=wn){var nr=ht.charCodeAt(++pn);wn=65536+((wn&1023)<<10)|nr&1023}if($()[vt>>>2>>>0]=wn,vt+=4,vt+4>Ft)break}return $()[vt>>>2>>>0]=0,vt-Gt},Wr=ht=>{for(var vt=0,Ft=0;Ft<ht.length;++Ft){var Gt=ht.charCodeAt(Ft);55296<=Gt&&57343>=Gt&&++Ft,vt+=4}return vt},vy=ht=>{if(!vr)try{if(ht(),!(0<p0))try{Tt?By(Ir):bp(Ir)}catch(vt){vt instanceof i0||vt=="unwind"||bt(1,vt)}}catch(vt){vt instanceof i0||vt=="unwind"||bt(1,vt)}};function ny(ht){ht>>>=0,typeof Atomics.nc=="function"&&(Atomics.nc($(),ht>>>2,ht).value.then(S0),ht+=128,Atomics.store($(),ht>>>2,1))}b.__emscripten_thread_mailbox_await=ny;var S0=()=>{var ht=Iy();ht&&(ny(ht),vy(Jy))};b.checkMailbox=S0;var gy=[],yy=(ht,vt)=>{var Ft=g0[ht];if(Ft===void 0)throw ht=Xy(ht),Ft=Ro(ht),py(ht),new An(`${vt} has unknown type ${Ft}`);return Ft},_y=(ht,vt,Ft)=>{var Gt=[];return ht=ht.toWireType(Gt,Ft),Gt.length&&(c()[vt>>>2>>>0]=c0(Gt)),ht},cy=ht=>{try{ht()}catch(vt){e0(vt)}};function Wo(){var ht=Lr,vt={};for(let[Ft,Gt]of Object.entries(ht))vt[Ft]=typeof Gt=="function"?(...pn)=>{V0.push(Ft);try{return Gt(...pn)}finally{vr||(V0.pop(),Gr&&F0===1&&V0.length===0&&(F0=0,p0+=1,cy(r_),typeof Fibers<"u"&&Fibers.rc()))}}:Gt;return vt}var F0=0,Gr=null,Zr=0,V0=[],dy={},wt={},Pt=0,Vt=null,Qt=[];function gn(){return new Promise((ht,vt)=>{Vt={resolve:ht,reject:vt}})}function En(){var ht=My(65548),vt=ht+12;c()[ht>>>2>>>0]=vt,c()[ht+4>>>2>>>0]=vt+65536,vt=V0[0];var Ft=dy[vt];return Ft===void 0&&(Ft=Pt++,dy[vt]=Ft,wt[Ft]=vt),vt=Ft,$()[ht+8>>>2>>>0]=vt,ht}function or(){var ht=$()[Gr+8>>>2>>>0];return ht=Lr[wt[ht]],--p0,ht()}function yr(ht){if(!vr){if(F0===0){var vt=!1,Ft=!1;ht((Gt=0)=>{if(!vr&&(Zr=Gt,vt=!0,Ft)){F0=2,cy(()=>i_(Gr)),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.resume(),Gt=!1;try{var pn=or()}catch(ar){pn=ar,Gt=!0}var wn=!1;if(!Gr){var nr=Vt;nr&&(Vt=null,(Gt?nr.reject:nr.resolve)(pn),wn=!0)}if(Gt&&!wn)throw pn}}),Ft=!0,vt||(F0=1,Gr=En(),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.pause(),cy(()=>n_(Gr)))}else F0===2?(F0=0,cy(o_),py(Gr),Gr=null,Qt.forEach(vy)):e0(`invalid state: ${F0}`);return Zr}}function Cr(ht){return yr(vt=>{ht().then(vt)})}var Tr=[],Fr={},n0=ht=>{var vt=Fr[ht];return vt===void 0?Ro(ht):vt},Nt=()=>typeof globalThis=="object"?globalThis:Function("return this")(),Lt=ht=>{var vt=Tr.length;return Tr.push(ht),vt},qt=(ht,vt)=>{for(var Ft=Array(ht),Gt=0;Gt<ht;++Gt)Ft[Gt]=yy(c()[vt+4*Gt>>>2>>>0],"parameter "+Gt);return Ft},ln=(ht,vt)=>Object.defineProperty(vt,"name",{value:ht});function xn(ht){var vt=Function;if(!(vt instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof vt} which is not a function`);var Ft=ln(vt.name||"unknownFunctionName",function(){});return Ft.prototype=vt.prototype,Ft=new Ft,ht=vt.apply(Ft,ht),ht instanceof Object?ht:Ft}var Cn=ht=>ht%4===0&&(ht%100!==0||ht%400===0),xr=[0,31,60,91,121,152,182,213,244,274,305,335],Nr=[0,31,59,90,120,151,181,212,243,273,304,334];function xu(ht,vt,Ft,Gt,pn,wn,nr){return Tt?eo(16,1,ht,vt,Ft,Gt,pn,wn,nr):-52}function _h(ht,vt,Ft,Gt,pn,wn){if(Tt)return eo(17,1,ht,vt,Ft,Gt,pn,wn)}var h0=[],W0=(ht,vt)=>{h0.length=0;for(var Ft;Ft=et()[ht++>>>0];){var Gt=Ft!=105;Gt&=Ft!=112,vt+=Gt&&vt%8?4:0,h0.push(Ft==112?c()[vt>>>2>>>0]:Ft==106?_i[vt>>>3]:Ft==105?$()[vt>>>2>>>0]:_()[vt>>>3>>>0]),vt+=Gt?8:4}return h0},N0={},er=()=>{if(!_g){var ht={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:mt||"./this.program"},vt;for(vt in N0)N0[vt]===void 0?delete ht[vt]:ht[vt]=N0[vt];var Ft=[];for(vt in ht)Ft.push(`${vt}=${ht[vt]}`);_g=Ft}return _g},_g;function m0(ht,vt){if(Tt)return eo(18,1,ht,vt);ht>>>=0,vt>>>=0;var Ft=0;return er().forEach((Gt,pn)=>{var wn=vt+Ft;for(pn=c()[ht+4*pn>>>2>>>0]=wn,wn=0;wn<Gt.length;++wn)h()[pn++>>>0]=Gt.charCodeAt(wn);h()[pn>>>0]=0,Ft+=Gt.length+1}),0}function X0(ht,vt){if(Tt)return eo(19,1,ht,vt);ht>>>=0,vt>>>=0;var Ft=er();c()[ht>>>2>>>0]=Ft.length;var Gt=0;return Ft.forEach(pn=>Gt+=pn.length+1),c()[vt>>>2>>>0]=Gt,0}function by(ht){return Tt?eo(20,1,ht):52}function Vy(ht,vt,Ft,Gt){return Tt?eo(21,1,ht,vt,Ft,Gt):52}function Wy(ht,vt,Ft,Gt){return Tt?eo(22,1,ht,vt,Ft,Gt):70}var g_=[null,[],[]];function Gy(ht,vt,Ft,Gt){if(Tt)return eo(23,1,ht,vt,Ft,Gt);vt>>>=0,Ft>>>=0,Gt>>>=0;for(var pn=0,wn=0;wn<Ft;wn++){var nr=c()[vt>>>2>>>0],ar=c()[vt+4>>>2>>>0];vt+=8;for(var Mr=0;Mr<ar;Mr++){var Ar=et()[nr+Mr>>>0],Hr=g_[ht];Ar===0||Ar===10?((ht===1?vn:Sn)(j0(Hr,0)),Hr.length=0):Hr.push(Ar)}pn+=ar}return c()[Gt>>>2>>>0]=pn,0}var Hy=[31,29,31,30,31,30,31,31,30,31,30,31],qy=[31,28,31,30,31,30,31,31,30,31,30,31];function y_(ht){var vt=Array(T0(ht)+1);return J0(ht,vt,0,vt.length),vt}var __=(ht,vt)=>{h().set(ht,vt>>>0)};function Ky(ht,vt,Ft,Gt){function pn(tr,ns,o0){for(tr=typeof tr=="number"?tr.toString():tr||"";tr.length<ns;)tr=o0[0]+tr;return tr}function wn(tr,ns){return pn(tr,ns,"0")}function nr(tr,ns){function o0(s_){return 0>s_?-1:0<s_?1:0}var $y;return($y=o0(tr.getFullYear()-ns.getFullYear()))===0&&($y=o0(tr.getMonth()-ns.getMonth()))===0&&($y=o0(tr.getDate()-ns.getDate())),$y}function ar(tr){switch(tr.getDay()){case 0:return new Date(tr.getFullYear()-1,11,29);case 1:return tr;case 2:return new Date(tr.getFullYear(),0,3);case 3:return new Date(tr.getFullYear(),0,2);case 4:return new Date(tr.getFullYear(),0,1);case 5:return new Date(tr.getFullYear()-1,11,31);case 6:return new Date(tr.getFullYear()-1,11,30)}}function Mr(tr){var ns=tr.zb;for(tr=new Date(new Date(tr.Ab+1900,0,1).getTime());0<ns;){var o0=tr.getMonth(),$y=(Cn(tr.getFullYear())?Hy:qy)[o0];if(ns>$y-tr.getDate())ns-=$y-tr.getDate()+1,tr.setDate(1),11>o0?tr.setMonth(o0+1):(tr.setMonth(0),tr.setFullYear(tr.getFullYear()+1));else{tr.setDate(tr.getDate()+ns);break}}return o0=new Date(tr.getFullYear()+1,0,4),ns=ar(new Date(tr.getFullYear(),0,4)),o0=ar(o0),0>=nr(ns,tr)?0>=nr(o0,tr)?tr.getFullYear()+1:tr.getFullYear():tr.getFullYear()-1}ht>>>=0,vt>>>=0,Ft>>>=0,Gt>>>=0;var Ar=c()[Gt+40>>>2>>>0];Gt={kc:$()[Gt>>>2>>>0],jc:$()[Gt+4>>>2>>>0],Eb:$()[Gt+8>>>2>>>0],Jb:$()[Gt+12>>>2>>>0],Fb:$()[Gt+16>>>2>>>0],Ab:$()[Gt+20>>>2>>>0],vb:$()[Gt+24>>>2>>>0],zb:$()[Gt+28>>>2>>>0],qc:$()[Gt+32>>>2>>>0],ic:$()[Gt+36>>>2>>>0],lc:Ar?f0(Ar):""},Ft=f0(Ft),Ar={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Hr in Ar)Ft=Ft.replace(new RegExp(Hr,"g"),Ar[Hr]);var u0="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d0="January February March April May June July August September October November December".split(" ");Ar={"%a":tr=>u0[tr.vb].substring(0,3),"%A":tr=>u0[tr.vb],"%b":tr=>d0[tr.Fb].substring(0,3),"%B":tr=>d0[tr.Fb],"%C":tr=>wn((tr.Ab+1900)/100|0,2),"%d":tr=>wn(tr.Jb,2),"%e":tr=>pn(tr.Jb,2," "),"%g":tr=>Mr(tr).toString().substring(2),"%G":Mr,"%H":tr=>wn(tr.Eb,2),"%I":tr=>(tr=tr.Eb,tr==0?tr=12:12<tr&&(tr-=12),wn(tr,2)),"%j":tr=>{for(var ns=0,o0=0;o0<=tr.Fb-1;ns+=(Cn(tr.Ab+1900)?Hy:qy)[o0++]);return wn(tr.Jb+ns,3)},"%m":tr=>wn(tr.Fb+1,2),"%M":tr=>wn(tr.jc,2),"%n":()=>`
`,"%p":tr=>0<=tr.Eb&&12>tr.Eb?"AM":"PM","%S":tr=>wn(tr.kc,2),"%t":()=>"	","%u":tr=>tr.vb||7,"%U":tr=>wn(Math.floor((tr.zb+7-tr.vb)/7),2),"%V":tr=>{var ns=Math.floor((tr.zb+7-(tr.vb+6)%7)/7);if(2>=(tr.vb+371-tr.zb-2)%7&&ns++,ns)ns==53&&(o0=(tr.vb+371-tr.zb)%7,o0==4||o0==3&&Cn(tr.Ab)||(ns=1));else{ns=52;var o0=(tr.vb+7-tr.zb-1)%7;(o0==4||o0==5&&Cn(tr.Ab%400-1))&&ns++}return wn(ns,2)},"%w":tr=>tr.vb,"%W":tr=>wn(Math.floor((tr.zb+7-(tr.vb+6)%7)/7),2),"%y":tr=>(tr.Ab+1900).toString().substring(2),"%Y":tr=>tr.Ab+1900,"%z":tr=>{tr=tr.ic;var ns=0<=tr;return tr=Math.abs(tr)/60,(ns?"+":"-")+("0000"+(tr/60*100+tr%60)).slice(-4)},"%Z":tr=>tr.lc,"%%":()=>"%"},Ft=Ft.replace(/%%/g,"\0\0");for(Hr in Ar)Ft.includes(Hr)&&(Ft=Ft.replace(new RegExp(Hr,"g"),Ar[Hr](Gt)));return Ft=Ft.replace(/\0\0/g,"%"),Hr=y_(Ft),Hr.length>vt?0:(__(Hr,ht),Hr.length-1)}_r.Gb();for(var Yy=Array(256),Py=0;256>Py;++Py)Yy[Py]=String.fromCharCode(Py);Xr=Yy,An=b.BindingError=class extends Error{constructor(ht){super(ht),this.name="BindingError"}},b.InternalError=class extends Error{constructor(ht){super(ht),this.name="InternalError"}},R0.push(0,1,void 0,1,null,1,!0,1,!1,1),b.count_emval_handles=()=>R0.length/2-5-z0.length;var b_=[y0,Kr,ay,sy,I0,ey,ty,Ht,cn,bn,$n,Tn,In,wr,Dr,Sr,xu,_h,m0,X0,by,Vy,Wy,Gy],w_={ua:function(ht,vt,Ft){return Cr(async()=>{await b.Zb(ht,vt,Ft)})},b:function(ht,vt,Ft){throw ht>>>=0,new hy(ht).Gb(vt>>>0,Ft>>>0),q0=ht,q0},ia:function(ht){Qy(ht>>>0,!Ct,1,!$t,131072,!1),_r.Pb()},G:function(ht){ht>>>=0,Tt?postMessage({cmd:"cleanupThread",thread:ht}):_r.Nb(_r.ub[ht])},_:K0,B:sy,pa:I0,W:ey,Y:ty,qa:Ht,na:cn,fa:bn,ma:$n,K:Tn,X:In,U:wr,oa:Dr,V:Sr,E:function(ht,vt,Ft){ht>>>=0,Ft>>>=0,vt=Ro(vt>>>0),No(ht,{name:vt,fromWireType:Gt=>Gt,toWireType:function(Gt,pn){if(typeof pn!="bigint"&&typeof pn!="number")throw pn===null?pn="null":(Gt=typeof pn,pn=Gt==="object"||Gt==="array"||Gt==="function"?pn.toString():""+pn),new TypeError(`Cannot convert "${pn}" to ${this.name}`);return typeof pn=="number"&&(pn=BigInt(pn)),pn},argPackAdvance:8,readValueFromPointer:A0(vt,Ft,vt.indexOf("u")==-1),Bb:null})},O:function(ht,vt,Ft,Gt){ht>>>=0,vt=Ro(vt>>>0),No(ht,{name:vt,fromWireType:function(pn){return!!pn},toWireType:function(pn,wn){return wn?Ft:Gt},argPackAdvance:8,readValueFromPointer:function(pn){return this.fromWireType(et()[pn>>>0])},Bb:null})},N:function(ht){return No(ht>>>0,ky)},D:function(ht,vt,Ft){ht>>>=0,Ft>>>=0,vt=Ro(vt>>>0),No(ht,{name:vt,fromWireType:Gt=>Gt,toWireType:(Gt,pn)=>pn,argPackAdvance:8,readValueFromPointer:xy(vt,Ft),Bb:null})},t:function(ht,vt,Ft,Gt,pn){if(ht>>>=0,Ft>>>=0,vt=Ro(vt>>>0),pn===-1&&(pn=4294967295),pn=ar=>ar,Gt===0){var wn=32-8*Ft;pn=ar=>ar<<wn>>>wn}var nr=vt.includes("unsigned")?function(ar,Mr){return Mr>>>0}:function(ar,Mr){return Mr};No(ht,{name:vt,fromWireType:pn,toWireType:nr,argPackAdvance:8,readValueFromPointer:A0(vt,Ft,Gt!==0),Bb:null})},p:function(ht,vt,Ft){function Gt(wn){var nr=c()[wn>>>2>>>0];return wn=c()[wn+4>>>2>>>0],new pn(h().buffer,wn,nr)}ht>>>=0;var pn=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][vt];Ft=Ro(Ft>>>0),No(ht,{name:Ft,fromWireType:Gt,argPackAdvance:8,readValueFromPointer:Gt},{Ub:!0})},F:function(ht,vt){ht>>>=0,vt=Ro(vt>>>0);var Ft=vt==="std::string";No(ht,{name:vt,fromWireType:function(Gt){var pn=c()[Gt>>>2>>>0],wn=Gt+4;if(Ft)for(var nr=wn,ar=0;ar<=pn;++ar){var Mr=wn+ar;if(ar==pn||et()[Mr>>>0]==0){if(nr=f0(nr,Mr-nr),Ar===void 0)var Ar=nr;else Ar+="\0",Ar+=nr;nr=Mr+1}}else{for(Ar=Array(pn),ar=0;ar<pn;++ar)Ar[ar]=String.fromCharCode(et()[wn+ar>>>0]);Ar=Ar.join("")}return py(Gt),Ar},toWireType:function(Gt,pn){pn instanceof ArrayBuffer&&(pn=new Uint8Array(pn));var wn=typeof pn=="string";if(!(wn||pn instanceof Uint8Array||pn instanceof Uint8ClampedArray||pn instanceof Int8Array))throw new An("Cannot pass non-string to std::string");var nr=Ft&&wn?T0(pn):pn.length,ar=My(4+nr+1),Mr=ar+4;if(c()[ar>>>2>>>0]=nr,Ft&&wn)M0(pn,Mr,nr+1);else if(wn)for(wn=0;wn<nr;++wn){var Ar=pn.charCodeAt(wn);if(255<Ar)throw py(Mr),new An("String has UTF-16 code units that do not fit in 8 bits");et()[Mr+wn>>>0]=Ar}else for(wn=0;wn<nr;++wn)et()[Mr+wn>>>0]=pn[wn];return Gt!==null&&Gt.push(py,ar),ar},argPackAdvance:8,readValueFromPointer:Y0,Bb(Gt){py(Gt)}})},A:function(ht,vt,Ft){if(ht>>>=0,vt>>>=0,Ft>>>=0,Ft=Ro(Ft),vt===2)var Gt=Ay,pn=Ey,wn=my,nr=ar=>it()[ar>>>1>>>0];else vt===4&&(Gt=ly,pn=Oy,wn=Wr,nr=ar=>c()[ar>>>2>>>0]);No(ht,{name:Ft,fromWireType:ar=>{for(var Mr=c()[ar>>>2>>>0],Ar,Hr=ar+4,u0=0;u0<=Mr;++u0){var d0=ar+4+u0*vt;(u0==Mr||nr(d0)==0)&&(Hr=Gt(Hr,d0-Hr),Ar===void 0?Ar=Hr:(Ar+="\0",Ar+=Hr),Hr=d0+vt)}return py(ar),Ar},toWireType:(ar,Mr)=>{if(typeof Mr!="string")throw new An(`Cannot pass non-string to C++ string type ${Ft}`);var Ar=wn(Mr),Hr=My(4+Ar+vt);return c()[Hr>>>2>>>0]=Ar/vt,pn(Mr,Hr+4,Ar+vt),ar!==null&&ar.push(py,Hr),Hr},argPackAdvance:8,readValueFromPointer:Y0,Bb(ar){py(ar)}})},P:function(ht,vt){ht>>>=0,vt=Ro(vt>>>0),No(ht,{Vb:!0,name:vt,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ta:()=>1,S:function(ht,vt){ht>>>=0,ht==vt>>>0?setTimeout(S0):Tt?postMessage({targetThread:ht,cmd:"checkMailbox"}):(ht=_r.ub[ht])&&ht.postMessage({cmd:"checkMailbox"})},$:function(ht,vt,Ft,Gt,pn){vt>>>=0,Ft>>>=0,Gt/=2,gy.length=Gt,pn=pn>>>0>>>3;for(var wn=0;wn<Gt;wn++)gy[wn]=_i[pn+2*wn]?_i[pn+2*wn+1]:_()[pn+2*wn+1>>>0];return ht=vt?G0[vt]:b_[ht],_r.Sb=Ft,Ft=ht(...gy),_r.Sb=0,Ft},ha:ny,sa:function(ht){It&&_r.ub[ht>>>0].ref()},w:function(ht,vt,Ft){return vt>>>=0,Ft>>>=0,ht=x0(ht>>>0),vt=yy(vt,"emval::as"),_y(vt,Ft,ht)},z:function(ht){return ht>>>=0,Cr(()=>(ht=x0(ht),ht.then(c0)))},o:function(ht,vt,Ft,Gt){return Ft>>>=0,Gt>>>=0,ht=Tr[ht>>>0],vt=x0(vt>>>0),ht(null,vt,Ft,Gt)},k:function(ht,vt,Ft,Gt,pn){return Ft>>>=0,Gt>>>=0,pn>>>=0,ht=Tr[ht>>>0],vt=x0(vt>>>0),Ft=n0(Ft),ht(vt,vt[Ft],Gt,pn)},c:uy,y:function(ht,vt){return vt>>>=0,ht=x0(ht>>>0),vt=x0(vt),ht==vt},n:function(ht){return ht>>>=0,ht===0?c0(Nt()):(ht=n0(ht),c0(Nt()[ht]))},j:function(ht,vt,Ft){vt=qt(ht,vt>>>0);var Gt=vt.shift();ht--;var pn=`return function (obj, func, destructorsRef, args) {
`,wn=0,nr=[];Ft===0&&nr.push("obj");for(var ar=["retType"],Mr=[Gt],Ar=0;Ar<ht;++Ar)nr.push("arg"+Ar),ar.push("argType"+Ar),Mr.push(vt[Ar]),pn+=`  var arg${Ar} = argType${Ar}.readValueFromPointer(args${wn?"+"+wn:""});
`,wn+=vt[Ar].argPackAdvance;return pn+=`  var rv = ${Ft===1?"new func":"func.call"}(${nr.join(", ")});
`,Gt.Vb||(ar.push("emval_returnValue"),Mr.push(_y),pn+=`  return emval_returnValue(retType, destructorsRef, rv);
`),ar.push(pn+`};
`),ht=xn(ar)(...Mr),Ft=`methodCaller<(${vt.map(Hr=>Hr.name).join(", ")}) => ${Gt.name}>`,Lt(ln(Ft,ht))},s:function(ht,vt){return vt>>>=0,ht=x0(ht>>>0),vt=x0(vt),c0(ht[vt])},d:function(ht){ht>>>=0,9<ht&&(R0[ht+1]+=1)},v:function(){return c0([])},m:function(ht){ht=x0(ht>>>0);for(var vt=Array(ht.length),Ft=0;Ft<ht.length;Ft++)vt[Ft]=ht[Ft];return c0(vt)},g:function(ht){return c0(n0(ht>>>0))},l:function(){return c0({})},i:function(ht){ht>>>=0;for(var vt=x0(ht);vt.length;){var Ft=vt.pop();vt.pop()(Ft)}uy(ht)},h:function(ht,vt,Ft){vt>>>=0,Ft>>>=0,ht=x0(ht>>>0),vt=x0(vt),Ft=x0(Ft),ht[vt]=Ft},e:function(ht,vt){return vt>>>=0,ht=yy(ht>>>0,"_emval_take_value"),ht=ht.readValueFromPointer(vt),c0(ht)},ca:function(ht,vt){ht=-9007199254740992>ht||9007199254740992<ht?NaN:Number(ht),vt>>>=0,ht=new Date(1e3*ht),$()[vt>>>2>>>0]=ht.getUTCSeconds(),$()[vt+4>>>2>>>0]=ht.getUTCMinutes(),$()[vt+8>>>2>>>0]=ht.getUTCHours(),$()[vt+12>>>2>>>0]=ht.getUTCDate(),$()[vt+16>>>2>>>0]=ht.getUTCMonth(),$()[vt+20>>>2>>>0]=ht.getUTCFullYear()-1900,$()[vt+24>>>2>>>0]=ht.getUTCDay(),ht=(ht.getTime()-Date.UTC(ht.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,$()[vt+28>>>2>>>0]=ht},da:function(ht,vt){ht=-9007199254740992>ht||9007199254740992<ht?NaN:Number(ht),vt>>>=0,ht=new Date(1e3*ht),$()[vt>>>2>>>0]=ht.getSeconds(),$()[vt+4>>>2>>>0]=ht.getMinutes(),$()[vt+8>>>2>>>0]=ht.getHours(),$()[vt+12>>>2>>>0]=ht.getDate(),$()[vt+16>>>2>>>0]=ht.getMonth(),$()[vt+20>>>2>>>0]=ht.getFullYear()-1900,$()[vt+24>>>2>>>0]=ht.getDay();var Ft=(Cn(ht.getFullYear())?xr:Nr)[ht.getMonth()]+ht.getDate()-1|0;$()[vt+28>>>2>>>0]=Ft,$()[vt+36>>>2>>>0]=-(60*ht.getTimezoneOffset()),Ft=new Date(ht.getFullYear(),6,1).getTimezoneOffset();var Gt=new Date(ht.getFullYear(),0,1).getTimezoneOffset();ht=(Ft!=Gt&&ht.getTimezoneOffset()==Math.min(Gt,Ft))|0,$()[vt+32>>>2>>>0]=ht},ea:function(ht){ht>>>=0;var vt=new Date($()[ht+20>>>2>>>0]+1900,$()[ht+16>>>2>>>0],$()[ht+12>>>2>>>0],$()[ht+8>>>2>>>0],$()[ht+4>>>2>>>0],$()[ht>>>2>>>0],0),Ft=$()[ht+32>>>2>>>0],Gt=vt.getTimezoneOffset(),pn=new Date(vt.getFullYear(),6,1).getTimezoneOffset(),wn=new Date(vt.getFullYear(),0,1).getTimezoneOffset(),nr=Math.min(wn,pn);return 0>Ft?$()[ht+32>>>2>>>0]=+(pn!=wn&&nr==Gt):0<Ft!=(nr==Gt)&&(pn=Math.max(wn,pn),vt.setTime(vt.getTime()+6e4*((0<Ft?nr:pn)-Gt))),$()[ht+24>>>2>>>0]=vt.getDay(),Ft=(Cn(vt.getFullYear())?xr:Nr)[vt.getMonth()]+vt.getDate()-1|0,$()[ht+28>>>2>>>0]=Ft,$()[ht>>>2>>>0]=vt.getSeconds(),$()[ht+4>>>2>>>0]=vt.getMinutes(),$()[ht+8>>>2>>>0]=vt.getHours(),$()[ht+12>>>2>>>0]=vt.getDate(),$()[ht+16>>>2>>>0]=vt.getMonth(),$()[ht+20>>>2>>>0]=vt.getYear(),ht=vt.getTime(),BigInt(isNaN(ht)?-1:ht/1e3)},aa:xu,ba:_h,R:function(ht,vt,Ft,Gt){ht>>>=0,vt>>>=0,Ft>>>=0,Gt>>>=0;var pn=new Date().getFullYear(),wn=new Date(pn,0,1),nr=new Date(pn,6,1);pn=wn.getTimezoneOffset();var ar=nr.getTimezoneOffset(),Mr=Math.max(pn,ar);c()[ht>>>2>>>0]=60*Mr,$()[vt>>>2>>>0]=+(pn!=ar),ht=Ar=>Ar.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],wn=ht(wn),nr=ht(nr),ar<pn?(M0(wn,Ft,17),M0(nr,Gt,17)):(M0(wn,Gt,17),M0(nr,Ft,17))},q:()=>{e0("")},f:function(ht,vt,Ft){return ht>>>=0,vt=W0(vt>>>0,Ft>>>0),G0[ht](...vt)},M:function(ht,vt,Ft){return ht>>>=0,vt=W0(vt>>>0,Ft>>>0),G0[ht](...vt)},H:()=>{},L:()=>Date.now(),ra:()=>{throw p0+=1,"unwind"},T:function(){return 4294901760},u:()=>performance.timeOrigin+performance.now(),x:()=>It?(Uo(),sr(Mo)).cpus().length:navigator.hardwareConcurrency,Q:function(ht){ht>>>=0;var vt=et().length;if(ht<=vt||4294901760<ht)return!1;for(var Ft=1;4>=Ft;Ft*=2){var Gt=vt*(1+.2/Ft);Gt=Math.min(Gt,ht+100663296);var pn=Math;Gt=Math.max(ht,Gt);e:{pn=(pn.min.call(pn,4294901760,Gt+(65536-Gt%65536)%65536)-hn.buffer.byteLength+65535)/65536;try{hn.grow(pn),s0();var wn=1;break e}catch{}wn=void 0}if(wn)return!0}return!1},ja:m0,la:X0,Z:bp,C:by,J:Vy,ga:Wy,I:Gy,a:hn||b.wasmMemory,ka:Ky,r:function(ht,vt,Ft,Gt){return Ky(ht>>>0,vt>>>0,Ft>>>0,Gt>>>0)}},Lr=function(){function ht(Ft,Gt){return Lr=Ft.exports,Lr=Wo(),Lr=v_(),_r.Qb.push(Lr.cb),O0.unshift(Lr.va),rr=Gt,a0(),Lr}var vt={a:w_};if(w0++,b.instantiateWasm)try{return b.instantiateWasm(vt,ht)}catch(Ft){Sn(`Module.instantiateWasm callback failed with error: ${Ft}`),dt(Ft)}return P0(vt,function(Ft){ht(Ft.instance,Ft.module)}).catch(dt),{}}(),Xy=ht=>(Xy=Lr.wa)(ht);b.__embind_initialize_bindings=()=>(b.__embind_initialize_bindings=Lr.xa)(),b._OrtInit=(ht,vt)=>(b._OrtInit=Lr.ya)(ht,vt),b._OrtGetLastError=(ht,vt)=>(b._OrtGetLastError=Lr.za)(ht,vt),b._OrtCreateSessionOptions=(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar)=>(b._OrtCreateSessionOptions=Lr.Aa)(ht,vt,Ft,Gt,pn,wn,nr,ar,Mr,Ar),b._OrtAppendExecutionProvider=(ht,vt)=>(b._OrtAppendExecutionProvider=Lr.Ba)(ht,vt),b._OrtAddFreeDimensionOverride=(ht,vt,Ft)=>(b._OrtAddFreeDimensionOverride=Lr.Ca)(ht,vt,Ft),b._OrtAddSessionConfigEntry=(ht,vt,Ft)=>(b._OrtAddSessionConfigEntry=Lr.Da)(ht,vt,Ft),b._OrtReleaseSessionOptions=ht=>(b._OrtReleaseSessionOptions=Lr.Ea)(ht),b._OrtCreateSession=(ht,vt,Ft)=>(b._OrtCreateSession=Lr.Fa)(ht,vt,Ft),b._OrtReleaseSession=ht=>(b._OrtReleaseSession=Lr.Ga)(ht),b._OrtGetInputOutputCount=(ht,vt,Ft)=>(b._OrtGetInputOutputCount=Lr.Ha)(ht,vt,Ft),b._OrtGetInputName=(ht,vt)=>(b._OrtGetInputName=Lr.Ia)(ht,vt),b._OrtGetOutputName=(ht,vt)=>(b._OrtGetOutputName=Lr.Ja)(ht,vt),b._OrtFree=ht=>(b._OrtFree=Lr.Ka)(ht),b._OrtCreateTensor=(ht,vt,Ft,Gt,pn,wn)=>(b._OrtCreateTensor=Lr.La)(ht,vt,Ft,Gt,pn,wn),b._OrtGetTensorData=(ht,vt,Ft,Gt,pn)=>(b._OrtGetTensorData=Lr.Ma)(ht,vt,Ft,Gt,pn),b._OrtReleaseTensor=ht=>(b._OrtReleaseTensor=Lr.Na)(ht),b._OrtCreateRunOptions=(ht,vt,Ft,Gt)=>(b._OrtCreateRunOptions=Lr.Oa)(ht,vt,Ft,Gt),b._OrtAddRunConfigEntry=(ht,vt,Ft)=>(b._OrtAddRunConfigEntry=Lr.Pa)(ht,vt,Ft),b._OrtReleaseRunOptions=ht=>(b._OrtReleaseRunOptions=Lr.Qa)(ht),b._OrtCreateBinding=ht=>(b._OrtCreateBinding=Lr.Ra)(ht),b._OrtBindInput=(ht,vt,Ft)=>(b._OrtBindInput=Lr.Sa)(ht,vt,Ft),b._OrtBindOutput=(ht,vt,Ft,Gt)=>(b._OrtBindOutput=Lr.Ta)(ht,vt,Ft,Gt),b._OrtClearBoundOutputs=ht=>(b._OrtClearBoundOutputs=Lr.Ua)(ht),b._OrtReleaseBinding=ht=>(b._OrtReleaseBinding=Lr.Va)(ht),b._OrtRunWithBinding=(ht,vt,Ft,Gt,pn)=>(b._OrtRunWithBinding=Lr.Wa)(ht,vt,Ft,Gt,pn),b._OrtRun=(ht,vt,Ft,Gt,pn,wn,nr,ar)=>(b._OrtRun=Lr.Xa)(ht,vt,Ft,Gt,pn,wn,nr,ar),b._OrtEndProfiling=ht=>(b._OrtEndProfiling=Lr.Ya)(ht),b._JsepOutput=(ht,vt,Ft)=>(b._JsepOutput=Lr.Za)(ht,vt,Ft),b._JsepGetNodeName=ht=>(b._JsepGetNodeName=Lr._a)(ht);var Iy=b._pthread_self=()=>(Iy=b._pthread_self=Lr.$a)(),My=b._malloc=ht=>(My=b._malloc=Lr.ab)(ht),py=b._free=ht=>(py=b._free=Lr.bb)(ht);b.__emscripten_tls_init=()=>(b.__emscripten_tls_init=Lr.cb)();var Qy=b.__emscripten_thread_init=(ht,vt,Ft,Gt,pn,wn)=>(Qy=b.__emscripten_thread_init=Lr.eb)(ht,vt,Ft,Gt,pn,wn);b.__emscripten_thread_crashed=()=>(b.__emscripten_thread_crashed=Lr.fb)();var Zy=(ht,vt,Ft,Gt,pn)=>(Zy=Lr.gb)(ht,vt,Ft,Gt,pn),Ly=ht=>(Ly=Lr.hb)(ht),By=b.__emscripten_thread_exit=ht=>(By=b.__emscripten_thread_exit=Lr.ib)(ht),Jy=()=>(Jy=Lr.jb)(),e_=(ht,vt)=>(e_=Lr.kb)(ht,vt),Ry=ht=>(Ry=Lr.lb)(ht),Fy=ht=>(Fy=Lr.mb)(ht),Uy=()=>(Uy=Lr.nb)(),t_=b.dynCall_ii=(ht,vt)=>(t_=b.dynCall_ii=Lr.pb)(ht,vt),n_=ht=>(n_=Lr.qb)(ht),r_=()=>(r_=Lr.rb)(),i_=ht=>(i_=Lr.sb)(ht),o_=()=>(o_=Lr.tb)();b.___start_em_js=839500,b.___stop_em_js=839661;function v_(){var ht=Lr;ht=Object.assign({},ht);var vt=Gt=>pn=>Gt(pn)>>>0,Ft=Gt=>()=>Gt()>>>0;return ht.wa=vt(ht.wa),ht.$a=Ft(ht.$a),ht.ab=vt(ht.ab),ht.emscripten_main_runtime_thread_id=Ft(ht.emscripten_main_runtime_thread_id),ht.mb=vt(ht.mb),ht.nb=Ft(ht.nb),ht}b.wasmMemory=hn,b.stackSave=()=>Uy(),b.stackRestore=ht=>Ry(ht),b.stackAlloc=ht=>Fy(ht),b.keepRuntimeAlive=()=>0<p0,b.UTF8ToString=f0,b.stringToUTF8=M0,b.lengthBytesUTF8=T0,b.ExitStatus=i0,b.PThread=_r;var Dy;v0=function ht(){Dy||a_(),Dy||(v0=ht)};function a_(){if(!(0<w0))if(Tt)st(b),Tt||Vr(O0),startWorker(b);else{if(b.preRun)for(typeof b.preRun=="function"&&(b.preRun=[b.preRun]);b.preRun.length;)E0.unshift(b.preRun.shift());Vr(E0),0<w0||Dy||(Dy=!0,b.calledRun=!0,vr||(Tt||Vr(O0),st(b),Tt||Vr(U0)))}}return a_(),ct}})();typeof i=="object"&&typeof e=="object"?e.exports=o:typeof define=="function"&&define.amd&&define([],()=>o)}),Ho=Er((i,e)=>{e.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(...e){var a=e.join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,a+`\n`);return}console.error(a)}function threadAlert(...e){var a=e.join(" ");postMessage({cmd:"alert",text:a,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,a)=>{var r=Module.wasmModule;Module.wasmModule=null;var t=new WebAssembly.Instance(r,e);return a(t)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let r=[];self.onmessage=t=>r.push(t),self.startWorker=t=>{Module=t,postMessage({cmd:"loaded"});for(let s of r)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const t of e.data.handlers)Module[t]=(...s)=>{postMessage({cmd:"callHandler",handler:t,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var a=URL.createObjectURL(e.data.urlOrBlob);importScripts(a),URL.revokeObjectURL(a)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(r){if(r!="unwind")throw r}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(r){throw Module.__emscripten_thread_crashed?.(),r}}self.onmessage=handleMessage;\n'}),Lo,gc,Hi,Gi,Un,Go,yc,bc,vc,Fo,Fe,Or=j(()=>{Lo=zo(),gc=Vo(),Gi=!1,Un=!1,Go=!1,yc=i=>{if(i===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+i+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+i+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},bc=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},vc=(i,e)=>i?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":e?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Fo=async i=>{if(Gi)return Promise.resolve();if(Un)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Go)throw new Error("previous call to 'initializeWebAssembly()' failed.");Un=!0;let e=i.initTimeout,o=i.numThreads,a=i.simd,d=yc(o),g=a&&bc(),h=i.wasmPaths,et=typeof h=="string"?h:void 0,ot=vc(g,d),it=typeof h=="object"?h[ot]:void 0,$=!1,c=[];if(e>0&&c.push(new Promise(s=>{setTimeout(()=>{$=!0,s()},e)})),c.push(new Promise((s,_)=>{let b=d?gc:Lo,st={locateFile:(dt,ct)=>{if(d&&dt.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Ho()],{type:"text/javascript"}));if(dt.endsWith(".wasm")){if(it)return it;let pt=et??ct;return ot==="ort-wasm-simd.wasm"?pt+"ort-wasm-simd.jsep.wasm":ot==="ort-wasm-simd-threaded.wasm"?pt+"ort-wasm-simd-threaded.jsep.wasm":pt+ot}return ct+dt}};if(d)if(st.numThreads=o,typeof Blob>"u")st.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let dt=`var ortWasmThreaded=${b.toString()};`;st.mainScriptUrlOrBlob=new Blob([dt],{type:"text/javascript"})}b(st).then(dt=>{Un=!1,Gi=!0,Hi=dt,s()},dt=>{Un=!1,Go=!0,_(dt)})})),await Promise.race(c),$)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},Fe=()=>{if(Gi&&Hi)return Hi;throw new Error("WebAssembly is not initialized yet.")}}),qe,Jr,We,Wn=j(()=>{Or(),qe=(i,e)=>{let o=Fe(),a=o.lengthBytesUTF8(i)+1,d=o._malloc(a);return o.stringToUTF8(i,d,a),e.push(d),d},Jr=(i,e,o,a)=>{if(typeof i=="object"&&i!==null){if(o.has(i))throw new Error("Circular reference in options");o.add(i)}Object.entries(i).forEach(([d,g])=>{let h=e?e+d:d;if(typeof g=="object")Jr(g,h+".",o,a);else if(typeof g=="string"||typeof g=="number")a(h,g.toString());else if(typeof g=="boolean")a(h,g?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof g}`)})},We=i=>{let e=Fe(),o=e.stackSave();try{let a=e.stackAlloc(8);e._OrtGetLastError(a,a+4);let d=e.HEAP32[a/4],g=e.HEAPU32[a/4+1],h=g?e.UTF8ToString(g):"";throw new Error(`${i} ERROR_CODE: ${d}, ERROR_MESSAGE: ${h}`)}finally{e.stackRestore(o)}}}),qo,jo=j(()=>{Or(),Wn(),qo=i=>{let e=Fe(),o=0,a=[],d=i||{};try{if((i==null?void 0:i.logSeverityLevel)===void 0)d.logSeverityLevel=2;else if(typeof i.logSeverityLevel!="number"||!Number.isInteger(i.logSeverityLevel)||i.logSeverityLevel<0||i.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${i.logSeverityLevel}`);if((i==null?void 0:i.logVerbosityLevel)===void 0)d.logVerbosityLevel=0;else if(typeof i.logVerbosityLevel!="number"||!Number.isInteger(i.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${i.logVerbosityLevel}`);(i==null?void 0:i.terminate)===void 0&&(d.terminate=!1);let g=0;return(i==null?void 0:i.tag)!==void 0&&(g=qe(i.tag,a)),o=e._OrtCreateRunOptions(d.logSeverityLevel,d.logVerbosityLevel,!!d.terminate,g),o===0&&We("Can't create run options."),(i==null?void 0:i.extra)!==void 0&&Jr(i.extra,"",new WeakSet,(h,et)=>{let ot=qe(h,a),it=qe(et,a);e._OrtAddRunConfigEntry(o,ot,it)!==0&&We(`Can't set a run config entry: ${h} - ${et}.`)}),[o,a]}catch(g){throw o!==0&&e._OrtReleaseRunOptions(o),a.forEach(h=>e._free(h)),g}}}),wc,$c,_c,xc,Ko,Yo=j(()=>{Or(),Wn(),wc=i=>{switch(i){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${i}`)}},$c=i=>{switch(i){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${i}`)}},_c=i=>{i.extra||(i.extra={}),i.extra.session||(i.extra.session={});let e=i.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),i.executionProviders&&i.executionProviders.some(o=>(typeof o=="string"?o:o.name)==="webgpu")&&(i.enableMemPattern=!1)},xc=(i,e,o)=>{for(let a of e){let d=typeof a=="string"?a:a.name;switch(d){case"webnn":if(d="WEBNN",typeof a!="string"){let h=a;if(h!=null&&h.deviceType){let et=qe("deviceType",o),ot=qe(h.deviceType,o);Fe()._OrtAddSessionConfigEntry(i,et,ot)!==0&&We(`Can't set a session config entry: 'deviceType' - ${h.deviceType}.`)}if(h!=null&&h.numThreads){let et=h.numThreads;(typeof et!="number"||!Number.isInteger(et)||et<0)&&(et=0);let ot=qe("numThreads",o),it=qe(et.toString(),o);Fe()._OrtAddSessionConfigEntry(i,ot,it)!==0&&We(`Can't set a session config entry: 'numThreads' - ${h.numThreads}.`)}if(h!=null&&h.powerPreference){let et=qe("powerPreference",o),ot=qe(h.powerPreference,o);Fe()._OrtAddSessionConfigEntry(i,et,ot)!==0&&We(`Can't set a session config entry: 'powerPreference' - ${h.powerPreference}.`)}}break;case"webgpu":if(d="JS",typeof a!="string"){let h=a;if(h!=null&&h.preferredLayout){if(h.preferredLayout!=="NCHW"&&h.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${h.preferredLayout}`);let et=qe("preferredLayout",o),ot=qe(h.preferredLayout,o);Fe()._OrtAddSessionConfigEntry(i,et,ot)!==0&&We(`Can't set a session config entry: 'preferredLayout' - ${h.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${d}`)}let g=qe(d,o);Fe()._OrtAppendExecutionProvider(i,g)!==0&&We(`Can't append execution provider: ${d}.`)}},Ko=i=>{let e=Fe(),o=0,a=[],d=i||{};_c(d);try{let g=wc(d.graphOptimizationLevel??"all"),h=$c(d.executionMode??"sequential"),et=typeof d.logId=="string"?qe(d.logId,a):0,ot=d.logSeverityLevel??2;if(!Number.isInteger(ot)||ot<0||ot>4)throw new Error(`log serverity level is not valid: ${ot}`);let it=d.logVerbosityLevel??0;if(!Number.isInteger(it)||it<0||it>4)throw new Error(`log verbosity level is not valid: ${it}`);let $=typeof d.optimizedModelFilePath=="string"?qe(d.optimizedModelFilePath,a):0;if(o=e._OrtCreateSessionOptions(g,!!d.enableCpuMemArena,!!d.enableMemPattern,h,!!d.enableProfiling,0,et,ot,it,$),o===0&&We("Can't create session options."),d.executionProviders&&xc(o,d.executionProviders,a),d.enableGraphCapture!==void 0){if(typeof d.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${d.enableGraphCapture}`);let c=qe("enableGraphCapture",a),s=qe(d.enableGraphCapture.toString(),a);e._OrtAddSessionConfigEntry(o,c,s)!==0&&We(`Can't set a session config entry: 'enableGraphCapture' - ${d.enableGraphCapture}.`)}if(d.freeDimensionOverrides)for(let[c,s]of Object.entries(d.freeDimensionOverrides)){if(typeof c!="string")throw new Error(`free dimension override name must be a string: ${c}`);if(typeof s!="number"||!Number.isInteger(s)||s<0)throw new Error(`free dimension override value must be a non-negative integer: ${s}`);let _=qe(c,a);e._OrtAddFreeDimensionOverride(o,_,s)!==0&&We(`Can't set a free dimension override: ${c} - ${s}.`)}return d.extra!==void 0&&Jr(d.extra,"",new WeakSet,(c,s)=>{let _=qe(c,a),b=qe(s,a);e._OrtAddSessionConfigEntry(o,_,b)!==0&&We(`Can't set a session config entry: ${c} - ${s}.`)}),[o,a]}catch(g){throw o!==0&&e._OrtReleaseSessionOptions(o),a.forEach(h=>e._free(h)),g}}}),Li,Kt,cr,Nn,en,Vn,Fi,ye=j(()=>{Li=i=>{switch(i){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${i}`)}},Kt=i=>{switch(i){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${i}`)}},cr=i=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][i],Nn=i=>{switch(i){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${i}`)}},en=i=>{switch(i){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${i}`)}},Vn=i=>i==="float32"||i==="float16"||i==="int32"||i==="int64"||i==="uint32"||i==="uint8"||i==="bool",Fi=i=>{switch(i){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${i}`)}}}),tn,qi=j(()=>{tn=async i=>{if(typeof i=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(i))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let o=(void 0)(i),a=[];for await(let d of o)a.push(d);return new Uint8Array(Buffer.concat(a))}throw e}else{let e=await fetch(i);if(!e.ok)throw new Error(`failed to load external data file: ${i}`);let o=e.headers.get("Content-Length"),a=o?parseInt(o,10):0;if(a<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${i}, no response body.`);let d=e.body.getReader(),g;try{g=new ArrayBuffer(a)}catch(et){if(et instanceof RangeError){let ot=Math.ceil(a/65536);g=new WebAssembly.Memory({initial:ot,maximum:ot}).buffer}else throw et}let h=0;for(;;){let{done:et,value:ot}=await d.read();if(et)break;let it=ot.byteLength;new Uint8Array(g,h,it).set(ot),h+=it}return new Uint8Array(g,0,a)}}else return i instanceof Blob?new Uint8Array(await i.arrayBuffer()):i instanceof Uint8Array?i:new Uint8Array(i)}}),Sc,Cc,Xo,Zo,Qo,Ic,Ne,Yt=j(()=>{ye(),Sc=["V","I","W","E","F"],Cc=(i,e)=>{console.log(`[${Sc[i]},${new Date().toISOString()}]${e}`)},Qo=(i,e)=>{Xo=i,Zo=e},Ic=(i,e)=>{let o=en(i),a=en(Xo);o>=a&&Cc(o,typeof e=="function"?e():e)},Ne=(...i)=>{Zo&&Ic(...i)}}),Jo,es=j(()=>{ye(),Jo=(i,e)=>new(Nn(e))(i)}),Hn=j(()=>{}),ts,ji,Ki,Tc,Ac,rs,Xi,Yi,is,as=j(()=>{Yt(),Hn(),ts=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),ji=[],Ki=i=>Math.ceil(i/16)*16,Tc=i=>{for(let e=0;e<ji.length;e++){let o=ji[e];if(i<=o)return o}return Math.ceil(i/16)*16},Ac=1,rs=()=>Ac++,Xi=async(i,e,o,a)=>{let d=Ki(o),g=i.device.createBuffer({size:d,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let h=i.getCommandEncoder();i.endComputePass(),h.copyBufferToBuffer(e,0,g,0,d),i.flush(),await g.mapAsync(GPUMapMode.READ);let et=g.getMappedRange();if(a){let ot=a();return ot.set(new Uint8Array(et,0,o)),ot}else return new Uint8Array(et.slice(0,o))}finally{g.destroy()}},Yi=class{constructor(i){this.backend=i,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map,this.capturedPendingBuffers=new Map;for(let[e]of ts)ji.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[])}upload(i,e){let o=e.buffer,a=e.byteOffset,d=e.byteLength,g=Ki(d),h=this.storageCache.get(i);if(!h)throw new Error("gpu data for uploading does not exist");if(h.originalSize!==d)throw new Error(`inconsistent data size. gpu data size=${h.originalSize}, data size=${d}`);let et=this.backend.device.createBuffer({mappedAtCreation:!0,size:g,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),ot=et.getMappedRange();new Uint8Array(ot).set(new Uint8Array(o,a,d)),et.unmap();let it=this.backend.getCommandEncoder();this.backend.endComputePass(),it.copyBufferToBuffer(et,0,h.gpuData.buffer,0,g),Ne("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${i})`),this.buffersForUploadingPending.push(et)}memcpy(i,e){let o=this.storageCache.get(i);if(!o)throw new Error("source gpu data for memcpy does not exist");let a=this.storageCache.get(e);if(!a)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==a.originalSize)throw new Error("inconsistent source and destination gpu data size");let d=Ki(o.originalSize),g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(o.gpuData.buffer,0,a.gpuData.buffer,0,d)}registerExternalBuffer(i,e,o){let a;if(o){if(a=this.externalBuffers.get(o),a===void 0)throw new Error("previous buffer is not registered");if(i===o)return Ne("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${a}, buffer is the same, skip.`),a;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);this.externalBuffers.delete(o)}else a=rs();return this.storageCache.set(a,{gpuData:{id:a,type:0,buffer:i},originalSize:e}),this.externalBuffers.set(i,a),Ne("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${a}, registered.`),a}unregisterExternalBuffer(i){let e=this.externalBuffers.get(i);e!==void 0&&(this.storageCache.delete(e),this.externalBuffers.delete(i),Ne("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(i,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Tc(i),a,d=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,g=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(d||g){let et=(d?this.freeBuffers:this.freeUniformBuffers).get(o);et?et.length>0?a=et.pop():a=this.backend.device.createBuffer({size:o,usage:e}):a=this.backend.device.createBuffer({size:o,usage:e})}else a=this.backend.device.createBuffer({size:o,usage:e});let h={id:rs(),type:0,buffer:a};return this.storageCache.set(h.id,{gpuData:h,originalSize:i}),Ne("verbose",()=>`[WebGPU] GpuDataManager.create(size=${i}) => id=${h.id}`),h}get(i){var e;return(e=this.storageCache.get(i))==null?void 0:e.gpuData}release(i){let e=this.storageCache.get(i);if(!e)throw new Error("releasing data does not exist");return Ne("verbose",()=>`[WebGPU] GpuDataManager.release(id=${i}), gpuDataId=${e.gpuData.id}`),this.storageCache.delete(i),this.buffersPending.push(e.gpuData.buffer),e.originalSize}async download(i,e){let o=this.storageCache.get(i);if(!o)throw new Error("data does not exist");await Xi(this.backend,o.gpuData.buffer,o.originalSize,e)}refreshPendingBuffers(){for(let i of this.buffersForUploadingPending)i.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let i of this.buffersPending){let e=ts.get(i.size);if((i.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let o=this.freeBuffers.get(i.size)||[];e===void 0||o.length>=e?i.destroy():o.push(i)}else if((i.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let o=this.freeUniformBuffers.get(i.size)||[];e===void 0||o.length>=e?i.destroy():o.push(i)}else i.destroy()}this.buffersPending=[]}else{let i=this.capturedPendingBuffers.get(this.backend.currentSessionId);i||(i=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,i));for(let e of this.buffersPending)i.push(e);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(i=>{i.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(i=>{i.forEach(e=>{e.destroy()})}),this.storageCache.forEach(i=>{i.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(i=>{i.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(i){let e=this.capturedPendingBuffers.get(i);e&&(e.forEach(o=>{o.destroy()}),this.capturedPendingBuffers.delete(i))}},is=(...i)=>new Yi(...i)}),Zi,we,Ze=j(()=>{Zi=class{constructor(i){Object.assign(this,i)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(i=>`${this[i]}`).join(";")),this.key}},we=i=>new Zi(i)}),Qi,Rt,M,pr,Gn,Ln,Fn,xe=j(()=>{Qi=class{static calcMatMulShape(i,e){return i[1]!==e[0]?void 0:[i[0],e[1]]}},Rt=class{static calcShape(i,e,o=!1){let a=i.length,d=e.length;if(a===0)return e;if(d===0)return i;let g=Math.max(i.length,e.length),h=new Array(g);if(o){if(a<2||d<2)return;let et=Qi.calcMatMulShape([i[a-2],i[a-1]],[e[d-2],e[d-1]]);if(et===void 0)return;[h[g-2],h[g-1]]=et}for(let et=o?3:1;et<=g;et++){let ot=a-et<0?1:i[a-et],it=d-et<0?1:e[d-et];if(ot!==it&&ot>1&&it>1)return;let $=Math.max(ot,it);if(ot&&it)h[g-et]=Math.max(ot,it);else{if($>1)return;h[g-et]=0}}return h}static isValidBroadcast(i,e){let o=i.length,a=e.length;if(o>a)return!1;for(let d=1;d<=o;d++)if(i[o-d]!==1&&i[o-d]!==e[a-d])return!1;return!0}},M=class Ny{static size(e){return Ny.getSizeFromDimensionRange(e,0,e.length)}static convertShape(e,o=4){let a=e.length;if(a===0)return[];let d=new Array(a),g=a-1;for(;g>=0;){if(e[g]%o===0){d[g]=e[g]/o;break}if(o%e[g]!==0)throw new Error("cannot convert shape");d[g]=1,o/=e[g],g--}for(g--;g>=0;g--)d[g]=e[g];return d}static sizeFromDimension(e,o){if(o<0||o>e.length)throw new Error(`invalid dimension of ${o} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return Ny.getSizeFromDimensionRange(e,o,e.length)}static sizeToDimension(e,o){if(o<0||o>e.length)throw new Error(`invalid dimension of ${o} for sizeToDimension as Tensor has ${e.length} dimensions.`);return Ny.getSizeFromDimensionRange(e,0,o)}static getSizeFromDimensionRange(e,o,a){let d=1;for(let g=o;g<a;g++){if(e[g]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");d*=e[g]}return d}static computeStrides(e){let o=e.length;if(o===0)return[];if(o===1)return[1];let a=new Array(o);a[o-1]=1,a[o-2]=e[o-1];for(let d=o-3;d>=0;--d)a[d]=a[d+1]*e[d+1];return a}static normalizeAxis(e,o){if(e<-o&&e>=o)throw new Error("unsupported axis for this operation.");return e<0?e+o:e}static normalizeAxes(e,o){return e.map(a=>this.normalizeAxis(a,o??e.length))}static sortBasedOnPerm(e,o){return o?o.map(a=>e[a]):e.slice().reverse()}static padShape(e,o){let a=e.length;return e.map((d,g)=>d+o[g]+o[g+a])}static areEqual(e,o){return e.length!==o.length?!1:e.every((a,d)=>a===o[d])}},pr=class Cy{static adjustPoolAttributes(e,o,a,d,g,h){if(!e&&a.length!==o.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let et=0;et<o.length-2;et++)et>=a.length?a.push(o[et+2]):a[et]=o[et+2];for(let et=0;et<a.length;et++)if(et<d.length){if(d[et]<0)throw new Error("strides should be greater than or equal to 1")}else d.push(1);for(let et=0;et<a.length;et++)if(et<g.length){if(g[et]<0)throw new Error("dilations should be greater than or equal to 1")}else g.push(1);for(let et=0;et<a.length*2;et++)if(et<h.length){if(h[et]<0)throw new Error("pad should be greater than or equal to 1")}else h.push(0);for(let et=0;et<a.length;et++){if(a[et]<=0)throw new Error("kernel shapes need to be greater than 0");if(h[et]>=a[et]||h[et+a.length]>=a[et])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,o,a,d,g,h,et){if(et){if(g.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(o.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(d.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let ot=0;ot<e.length-2;ot++)Cy.adjustPadAndReturnShape(e[ot+(h?1:2)],o[ot],a[ot],d[ot],g,ot,ot+e.length-2,et)}}static computePoolOutputShape(e,o,a,d,g,h,et){if(o.length<=0)throw new Error("input shape must be of size greater than 0");let ot=[o[0],o[1]];return Cy.computeShapeHelper(e,o,ot,a,d,g,h,et),ot}static computeConvOutputShape(e,o,a,d,g,h,et){if(e.length<=0||o.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let ot=[e[0],o[0]];return Cy.computeShapeHelper(!1,e,ot,a,d,g,h,et),ot}static computeShapeHelper(e,o,a,d,g,h,et,ot){if(e)for(let it=0;it<o.length-2;it++)a.push(1);else for(let it=0;it<o.length-2;it++)a.push(Cy.adjustPadAndReturnShape(o[it+2],d[it],g[it],h[it],et,it,it+o.length-2,ot))}static adjustPadAndReturnShape(e,o,a,d,g,h,et,ot){let it=a*(d-1)+1;if(ot&&ot!=="NOTSET")switch(ot){case"VALID":return g[h]=0,g[et]=0,Math.floor((e-it)/o+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let $=((e+o-1)/o-1)*o+d-e;return g[h]=Math.floor(ot==="SAME_LOWER"?($+1)/2:$/2),g[et]=$-g[h],Math.floor((e+$-d)/o+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+g[h]+g[et]-it)/o+1)}},Gn=class{static getShapeOfGemmResult(i,e,o,a,d){if(i.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let g,h,et;e?(g=i[1],h=i[0]):(g=i[0],h=i[1]);let ot=-1;if(a?(et=o[0],ot=1):(et=o[1],ot=0),o[ot]!==h)throw new Error("dimension mismatch");if(g<=0||et<=0||h<=0)throw new Error("invalid shape specified");if(d&&!Rt.isValidBroadcast(d,[g,et]))throw new Error("gemm: invalid bias shape for broadcast");return[g,et,h]}},Ln=-34028234663852886e22,Fn=34028234663852886e22}),mr,ea,Be,rt,X,Ue,Xt,fr,At,fe,ta,U,K,qn,Ji,os,Pr,_e=j(()=>{ye(),xe(),mr=64,ea=(i,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(i){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${i}`)}},Be=(i,e=1)=>{let o=ea(i,e);return typeof o=="string"?o:o[0]},rt=(i,e=1)=>{let o=ea(i,e);return typeof o=="string"?o:o[1]},X=(...i)=>{let e=[];return i.forEach(o=>{o.length!==0&&e.push({type:12,data:o},{type:12,data:M.computeStrides(o)})}),e},Ue=i=>i%4===0?4:i%2===0?2:1,Xt=(i="f32",e,o="0")=>!e||e===1?`${i}(${o})`:`vec${e}<${i}>(${o})`,fr=(i,e,o)=>i==="f32"?o:e===1?`f32(${o})`:`vec${e}<f32>(${o})`,At=(i,e)=>e===4?`(${i}.x + ${i}.y + ${i}.z + ${i}.w)`:e===2?`(${i}.x + ${i}.y)`:e===3?`(${i}.x + ${i}.y + ${i}.z)`:i,fe=(i,e,o,a)=>i.startsWith("uniforms.")&&o>4?typeof e=="string"?a==="f16"?`${i}[(${e}) / 8][(${e}) % 8 / 4][(${e}) % 8 % 4]`:`${i}[(${e}) / 4][(${e}) % 4]`:a==="f16"?`${i}[${Math.floor(e/8)}][${Math.floor(e%8/4)}][${e%8%4}]`:`${i}[${Math.floor(e/4)}][${e%4}]`:o>1?`${i}[${e}]`:i,ta=(i,e,o,a,d)=>{let g=typeof o=="number",h=g?o:o.length,et=[...new Array(h).keys()],ot=h<2?"u32":h<=4?`vec${h}<u32>`:`array<u32, ${h}>`,it=ea(e,d),$=typeof it=="string"?it:it[1],c=typeof it=="string"?it:it[0],s={indices:ot,value:$,storage:c,tensor:e},_=hn=>typeof hn=="string"?hn:`${hn}u`,b={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},st=g?"uniforms.":"",dt=`${st}${i}_shape`,ct=`${st}${i}_strides`,pt="";for(let hn=0;hn<h-1;hn++)pt+=`
    let dim${hn} = current / ${fe(ct,hn,h)};
    let rest${hn} = current % ${fe(ct,hn,h)};
    indices[${hn}] = dim${hn};
    current = rest${hn};
    `;pt+=`indices[${h-1}] = current;`;let ft=h<2?"":`
  fn o2i_${i}(offset: u32) -> ${s.indices} {
    var indices: ${s.indices};
    var current = offset;
    ${pt}
    return indices;
  }`,mt=hn=>(b.offsetToIndices=!0,h<2?hn:`o2i_${i}(${hn})`),bt=[];if(h>=2)for(let hn=h-1;hn>=0;hn--)bt.push(`${fe(ct,hn,h)} * (indices[${hn}])`);let $t=h<2?"":`
  fn i2o_${i}(indices: ${s.indices}) -> u32 {
    return ${bt.join("+")};
  }`,Ct=hn=>(b.indicesToOffset=!0,h<2?hn:`i2o_${i}(${hn})`),It=(...hn)=>h===0?"0u":`${s.indices}(${hn.map(_).join(",")})`,Tt=(hn,rr)=>h<2?`${hn}`:`${fe(hn,rr,h)}`,jt=(hn,rr,vr)=>h<2?`${hn}=${vr};`:`${fe(hn,rr,h)}=${vr};`,dn={},yn=(hn,rr)=>{b.broadcastedIndicesToOffset=!0;let vr=`${rr.name}broadcastedIndicesTo${i}Offset`;if(vr in dn)return`${vr}(${hn})`;let Ir=[];for(let $r=h-1;$r>=0;$r--){let Ur=rr.indicesGet("outputIndices",$r+rr.rank-h);Ir.push(`${Tt(ct,$r)} * (${Ur} % ${Tt(dt,$r)})`)}return dn[vr]=`fn ${vr}(outputIndices: ${rr.type.indices}) -> u32 {
             return ${Ir.length>0?Ir.join("+"):"0u"};
           }`,`${vr}(${hn})`},mn=(hn,rr)=>(()=>{if(s.storage===s.value)return`${i}[${hn}]=${rr};`;if(s.storage==="vec2<u32>"&&s.value==="i32")return`${i}[${hn}]=vec2<u32>(u32(${rr}), select(0u, 0xFFFFFFFFu, ${rr} < 0));`;if(s.storage==="vec2<u32>"&&s.value==="u32")return`${i}[${hn}]=vec2<u32>(u32(${rr}), 0u);`;if(s.storage==="u32"&&s.value==="vec4<bool>")return`${i}[${hn}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${rr}));`;throw new Error(`not supported combination of storage type ${s.storage} and value type ${s.value} yet`)})(),fn=hn=>(()=>{if(s.storage===s.value)return`${i}[${hn}]`;if(s.storage==="vec2<u32>"&&s.value==="i32")return`i32(${i}[${hn}].x)`;if(s.storage==="vec2<u32>"&&s.value==="u32")return`u32(${i}[${hn}].x)`;if(s.storage==="u32"&&s.value==="vec4<bool>")return`vec4<bool>(bool(${i}[${hn}] & 0xFFu), bool(${i}[${hn}] & 0xFF00u), bool(${i}[${hn}] & 0xFF0000u), bool(${i}[${hn}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${s.storage} and value type ${s.value} yet`)})(),un=h<2?"":`
  fn get_${i}ByIndices(indices: ${s.indices}) -> ${$} {
    return ${fn(`i2o_${i}(indices)`)};
  }`,Wt=h<2?"":(()=>{let hn=et.map(vr=>`d${vr}: u32`).join(", "),rr=et.map(vr=>`d${vr}`).join(", ");return`
  fn get_${i}(${hn}) -> ${$} {
    return get_${i}ByIndices(${It(rr)});
  }`})(),Jt=(...hn)=>{if(hn.length!==h)throw new Error(`indices length must be ${h}`);let rr=hn.map(_).join(",");return h===0?fn("0u"):h===1?fn(rr[0]):(b.get=!0,b.getByIndices=!0,b.indicesToOffset=!0,`get_${i}(${rr})`)},_n=hn=>h<2?fn(hn):(b.getByIndices=!0,b.indicesToOffset=!0,`get_${i}ByIndices(${hn})`),vn=h<2?"":`
  fn set_${i}ByIndices(indices: ${s.indices}, value: ${$}) {
    ${mn(`i2o_${i}(indices)`,"value")}
  }`,Sn=h<2?"":(()=>{let hn=et.map(vr=>`d${vr}: u32`).join(", "),rr=et.map(vr=>`d${vr}`).join(", ");return`
  fn set_${i}(${hn}, value: ${$}) {
    set_${i}ByIndices(${It(rr)}, value);
  }`})();return{impl:()=>{let hn=[],rr=!1;return b.offsetToIndices&&(hn.push(ft),rr=!0),b.indicesToOffset&&(hn.push($t),rr=!0),b.broadcastedIndicesToOffset&&(Object.values(dn).forEach(vr=>hn.push(vr)),rr=!0),b.set&&(hn.push(Sn),rr=!0),b.setByIndices&&(hn.push(vn),rr=!0),b.get&&(hn.push(Wt),rr=!0),b.getByIndices&&(hn.push(un),rr=!0),!g&&rr&&hn.unshift(`const ${dt} = ${s.indices}(${o.join(",")});`,`const ${ct} = ${s.indices}(${M.computeStrides(o).join(",")});`),hn.join(`
`)},type:s,offsetToIndices:mt,indicesToOffset:Ct,broadcastedIndicesToOffset:yn,indices:It,indicesGet:Tt,indicesSet:jt,set:(...hn)=>{if(hn.length!==h+1)throw new Error(`indices length must be ${h}`);let rr=hn[h];if(typeof rr!="string")throw new Error("value must be string");let vr=hn.slice(0,h).map(_).join(",");return h===0?mn("0u",rr):h===1?mn(vr[0],rr):(b.set=!0,b.setByIndices=!0,b.indicesToOffset=!0,`set_${i}(${vr}, ${rr})`)},setByOffset:mn,setByIndices:(hn,rr)=>h<2?mn(hn,rr):(b.setByIndices=!0,b.indicesToOffset=!0,`set_${i}ByIndices(${hn}, ${rr});`),get:Jt,getByOffset:fn,getByIndices:_n,usage:a,name:i,strides:ct,shape:dt,rank:h}},U=(i,e,o,a=1)=>ta(i,e,o,"input",a),K=(i,e,o,a=1)=>ta(i,e,o,"output",a),qn=(i,e,o,a=1)=>ta(i,e,o,"internal",a),Ji=class{constructor(i,e){this.normalizedDispatchGroup=i,this.limits=e,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(i){return`if (global_idx >= ${typeof i=="number"?`${i}u`:i}) { return; }`}mainStart(i=mr){let e=typeof i=="number"?i:i[0],o=typeof i=="number"?1:i[1],a=typeof i=="number"?1:i[2];if(e>this.limits.maxComputeWorkgroupSizeX||o>this.limits.maxComputeWorkgroupSizeY||a>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${e}, ${o}, ${a}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(e*o*a>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${e}, ${o}, ${a}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let d=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,g=d?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,h=d?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${e*o*a}u + local_idx;`;return`@compute @workgroup_size(${e}, ${o}, ${a})
  fn main(${g}) {
    ${h}
  `}appendVariableUniforms(i){i.rank!==0&&(i.shape.startsWith("uniforms.")&&this.uniforms.push({name:i.shape.replace("uniforms.",""),type:"u32",length:i.rank}),i.strides.startsWith("uniforms.")&&this.uniforms.push({name:i.strides.replace("uniforms.",""),type:"u32",length:i.rank}))}declareVariable(i,e){if(i.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(i),this.appendVariableUniforms(i);let o=i.usage==="input"?"read":"read_write",a=i.type.storage;return`@group(0) @binding(${e}) var<storage, ${o}> ${i.name}: array<${a}>;`}declareVariables(...i){return i.map(e=>this.declareVariable(e,this.variableIndex++)).join(`
`)}registerInternalVariable(i){if(i.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(i),this.appendVariableUniforms(i)}registerInternalVariables(...i){return i.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(i,e,o=1){return this.uniforms.push({name:i,type:e,length:o}),this}registerUniforms(i){return this.uniforms=this.uniforms.concat(i),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let i=[];for(let{name:e,type:o,length:a}of this.uniforms)if(a&&a>4)o==="f16"?i.push(`@align(16) ${e}:array<mat2x4<${o}>, ${Math.ceil(a/8)}>`):i.push(`${e}:array<vec4<${o}>, ${Math.ceil(a/4)}>`);else{let d=a==null||a===1?o:`vec${a}<${o}>`;i.push(`${e}:${d}`)}return`
      struct Uniforms { ${i.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(i=>i.impl()).join(`
`)+this.internalVariables.map(i=>i.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let i=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map(e=>[i(e.type),e.length??1])}},os=(i,e)=>new Ji(i,e),Pr=(i,e)=>{let o=i.length,a=[];for(let d=0;d<o;d++){let g=o-1-d,h=i[g]||1;(e[e.length-1-d]||1)>1&&h===1&&a.unshift(g)}return a}}),Ec,ss,kc,Oc,xt,us,ls,Rr=j(()=>{ye(),xe(),Ze(),_e(),Ec=i=>{if(!i||i.length!==1)throw new Error("Transpose requires 1 input.")},ss=(i,e)=>e&&e.length!==i?[...new Array(i).keys()].reverse():e,kc=(i,e)=>M.sortBasedOnPerm(i,ss(i.length,e)),Oc=(i,e,o,a)=>{let d=[];d.push(`fn perm(i: ${a.type.indices}) -> ${o.type.indices} {
    var a: ${o.type.indices};`);for(let g=0;g<e;++g)d.push(o.indicesSet("a",i[g],`i[${g}]`));return d.push("return a;}"),d.join(`
`)},xt=(i,e)=>{let o=i.dataType,a=i.dims.length,d=ss(a,e),g=kc(i.dims,d),h=K("output",o,g.length),et=U("a",o,a),ot=it=>`
  ${it.registerUniform("output_size","u32").declareVariables(et,h)}

  ${Oc(d,a,et,h)}

  ${it.mainStart()}
    ${it.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${h.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${h.setByOffset("global_idx",et.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:it=>{let $=M.size(g);return{outputs:[{dims:g,dataType:it[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:[{type:12,data:$},...X(it[0].dims,g)]}},getShaderSource:ot}},us=(i,e)=>{Ec(i.inputs),i.compute(xt(i.inputs[0],e.perm))},ls=i=>we({perm:i.perm})}),Pc,Rc,zc,Bc,Dc,Mc,Uc,Wc,Nc,Vc,zt,ds,cs,ps,ms,fs,hs,gs,ys,bs,vs,ws=j(()=>{ye(),xe(),_e(),jn(),Rr(),Pc={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Rc={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},zc={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Bc={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Dc=(i,e)=>{let o=[];for(let a=e-i;a<e;++a)o.push(a);return o},Mc=(i,e)=>{let o=[],a=i.length;for(let g=0;g<a;g++)e.indexOf(g)===-1&&o.push(i[g]);let d=e.map(g=>i[g]);return[o,d]},Uc=(i,e)=>{let o=i.length+e.length,a=[],d=0;for(let g=0;g<o;g++)e.indexOf(g)===-1?a.push(i[d++]):a.push(1);return a},Wc=(i,e)=>{for(let o=0;o<i.length;++o)if(i[i.length-o-1]!==e-1-o)return!1;return!0},Nc=(i,e)=>{let o=[];if(!Wc(i,e)){for(let a=0;a<e;++a)i.indexOf(a)===-1&&o.push(a);i.forEach(a=>o.push(a))}return o},Vc=(i,e,o,a,d,g,h)=>{let et=o[0].dims,ot=M.size(g),it=M.size(h),$=U("_A",o[0].dataType,et),c=K("output",d,g),s=32,_=`
          var<workgroup> aBestValues : array<f32, ${s}>;
       `;return{name:i,shaderCache:e,getShaderSource:b=>`
        ${b.registerUniform("reduceSize","u32").declareVariables($,c)}
        ${_}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${b.mainStart(s)}

          let outputIndex = global_idx / ${s};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${zc[a]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${s}) {
           let candidate = f32(${$.getByOffset("offset + k")});
           bestValue = ${Pc[a]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Rc[a]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${c.setByOffset("outputIndex",`${a==="mean"?`${c.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${c.type.storage}(${Bc[a]})`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:g,dataType:d}],dispatchGroup:{x:ot},programUniforms:[{type:12,data:it}]})}},zt=(i,e,o,a)=>{let d=i.inputs.length===1?o:ra(i.inputs,o),g=d.axes;g.length===0&&!d.noopWithEmptyAxes&&(g=i.inputs[0].dims.map((_,b)=>b));let h=M.normalizeAxes(g,i.inputs[0].dims.length),et=h,ot=i.inputs[0],it=Nc(et,i.inputs[0].dims.length);it.length>0&&(ot=i.compute(xt(i.inputs[0],it),{inputs:[0],outputs:[-1]})[0],et=Dc(et.length,ot.dims.length));let[$,c]=Mc(ot.dims,et),s=$;d.keepDims&&(s=Uc($,h)),i.compute(Vc(e,{hint:d.cacheKey,inputDependencies:["type"]},[ot],a,i.inputs[0].dataType,s,c),{inputs:[ot]})},ds=(i,e)=>{zt(i,"ReduceMeanShared",e,"mean")},cs=(i,e)=>{zt(i,"ReduceL1Shared",e,"l1")},ps=(i,e)=>{zt(i,"ReduceL2Shared",e,"l2")},ms=(i,e)=>{zt(i,"ReduceLogSumExpShared",e,"logSumExp")},fs=(i,e)=>{zt(i,"ReduceMaxShared",e,"max")},hs=(i,e)=>{zt(i,"ReduceMinShared",e,"min")},gs=(i,e)=>{zt(i,"ReduceProdShared",e,"prod")},ys=(i,e)=>{zt(i,"ReduceSumShared",e,"sum")},bs=(i,e)=>{zt(i,"ReduceSumSquareShared",e,"sumSquare")},vs=(i,e)=>{zt(i,"ReduceLogSumShared",e,"logSum")}}),Bt,Hc,Kn,ra,Dt,Gc,Lc,Fc,qc,jc,Kc,Yc,Xc,Zc,Qc,Mt,$s,_s,xs,Ss,Cs,Is,Ts,As,Es,ks,jn=j(()=>{ye(),xe(),Ze(),_e(),ws(),Bt=i=>{if(!i||i.length===0||i.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(i.length===2&&i[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Hc=i=>["","",`var value = ${i.getByIndices("input_indices")};`,""],Kn=(i,e,o,a,d,g,h=!1,et=!1)=>{let ot=[],it=o[0].dims,$=it.length,c=M.normalizeAxes(d,$),s=!et&&c.length===0;it.forEach((st,dt)=>{s||c.indexOf(dt)>=0?h&&ot.push(1):ot.push(st)});let _=ot.length,b=M.size(ot);return{name:i,shaderCache:e,getShaderSource:st=>{let dt=[],ct=U("_A",o[0].dataType,$),pt=K("output",g,_),ft=a(ct,pt,c),mt=ft[2];for(let bt=0,$t=0;bt<$;bt++)s||c.indexOf(bt)>=0?(h&&$t++,mt=`for(var j${bt}: u32 = 0; j${bt} < ${it[bt]}; j${bt}++) {
                  ${ft[2].includes("last_index")?`let last_index = j${bt};`:""}
                  ${ct.indicesSet("input_indices",bt,`j${bt}`)}
                  ${mt}
                }`):(dt.push(`${ct.indicesSet("input_indices",bt,pt.indicesGet("output_indices",$t))};`),$t++);return`

        ${st.registerUniform("output_size","u32").declareVariables(ct,pt)}

        ${st.mainStart()}
          ${st.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${ct.type.indices};
          let output_indices = ${pt.offsetToIndices("global_idx")};

          ${dt.join(`
`)}
          ${ft[0]}       // init ops for reduce max/min
          ${ft[1]}
          ${mt}
          ${ft[3]}
          ${ft.length===4?pt.setByOffset("global_idx","value"):ft.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:ot,dataType:g}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:[{type:12,data:b},...X(it,ot)]})}},ra=(i,e)=>{let o=[];return i[1].dims[0]>0&&i[1].getBigInt64Array().forEach(a=>o.push(Number(a))),we({axes:o,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},Dt=(i,e,o,a)=>{let d=i.inputs,g=d.length===1?o:ra(d,o);i.compute(Kn(e,{hint:g.cacheKey,inputDependencies:["rank"]},[d[0]],g.noopWithEmptyAxes&&g.axes.length===0?Hc:a,g.axes,d[0].dataType,g.keepDims,g.noopWithEmptyAxes),{inputs:[0]})},Gc=(i,e)=>{Bt(i.inputs),Dt(i,"ReduceLogSum",e,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,"value = log(value);"])},Lc=(i,e)=>{Bt(i.inputs),Dt(i,"ReduceL1",e,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += abs(${o.getByIndices("input_indices")});`,""])},Fc=(i,e)=>{Bt(i.inputs),Dt(i,"ReduceL2",e,(o,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},qc=(i,e)=>{Bt(i.inputs),Dt(i,"ReduceLogSumExp",e,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += exp(${o.getByIndices("input_indices")});`,"value = log(value);"])},jc=(i,e)=>{Bt(i.inputs),Dt(i,"ReduceMax",e,(o,a,d)=>{let g=[];for(let h=0;h<o.rank;h++)(d.indexOf(h)>=0||d.length===0)&&g.push(o.indicesSet("input_indices",h,0));return[`${g.join(`
`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = max(value, ${o.getByIndices("input_indices")});`,""]})},Kc=(i,e)=>{Bt(i.inputs),Dt(i,"ReduceMean",e,(o,a,d)=>{let g=1;for(let h=0;h<o.rank;h++)(d.indexOf(h)>=0||d.length===0)&&(g*=i.inputs[0].dims[h]);return["var sum = f32(0);","",`sum += f32(${o.getByIndices("input_indices")});`,`let value = ${a.type.value}(sum / ${g});`]})},Yc=(i,e)=>{Bt(i.inputs),Dt(i,"ReduceMin",e,(o,a,d)=>{let g=[];for(let h=0;h<o.rank;h++)(d.indexOf(h)>=0||d.length===0)&&g.push(`input_indices[${h}] = 0;`);return[`${g.join(`
`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = min(value, ${o.getByIndices("input_indices")});`,""]})},Xc=(i,e)=>{Bt(i.inputs),Dt(i,"ReduceProd",e,(o,a)=>[`var value = ${a.type.storage}(1);`,"",`value *= ${o.getByIndices("input_indices")};`,""])},Zc=(i,e)=>{Bt(i.inputs),Dt(i,"ReduceSum",e,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,""])},Qc=(i,e)=>{Bt(i.inputs),Dt(i,"ReduceSumSquare",e,(o,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += t * t;`,""])},Mt=(i,e,o)=>{if(e.length===0)return o;let a=1,d=1;for(let g=0;g<e.length;g++)e.indexOf(g)===-1?a*=i[g]:d*=i[g];return d<32&&a>1024},$s=(i,e)=>{Mt(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Kc(i,e):ds(i,e)},_s=(i,e)=>{Mt(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Lc(i,e):cs(i,e)},xs=(i,e)=>{Mt(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Fc(i,e):ps(i,e)},Ss=(i,e)=>{Mt(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?qc(i,e):ms(i,e)},Cs=(i,e)=>{Mt(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?jc(i,e):fs(i,e)},Is=(i,e)=>{Mt(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Yc(i,e):hs(i,e)},Ts=(i,e)=>{Mt(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Xc(i,e):gs(i,e)},As=(i,e)=>{Mt(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Zc(i,e):ys(i,e)},Es=(i,e)=>{Mt(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Qc(i,e):bs(i,e)},ks=(i,e)=>{Mt(i.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Gc(i,e):vs(i,e)}}),Os,Ps,Rs,na,zs=j(()=>{ye(),Ze(),jn(),Os=i=>{if(!i||i.length===0||i.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(i[0].dataType!==1)throw new Error("Invalid input type.")},Ps=(i,e)=>{Os(i.inputs);let o=(a,d,g)=>{let h=[];for(let et=0;et<a.rank;et++)(g.indexOf(et)>=0||g.length===0)&&h.push(`input_indices[${et}] = 0;`);return[`${h.join(`
`)}`,`var value = ${a.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${a.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${a.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",d.setByOffset("global_idx","best_index")]};i.compute(Kn("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[i.inputs[0]],o,[e.axis],7,e.keepDims),{inputs:[0]})},Rs=(i,e)=>{Os(i.inputs);let o=(a,d,g)=>{let h=[];for(let et=0;et<a.rank;et++)(g.indexOf(et)>=0||g.length===0)&&h.push(`input_indices[${et}] = 0;`);return[`${h.join(`
`)}`,`var value = ${a.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${a.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${a.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",d.setByOffset("global_idx","best_index")]};i.compute(Kn("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[i.inputs[0]],o,[e.axis],7,e.keepDims),{inputs:[0]})},na=i=>we(i)}),Jc,ep,tp,Yn,Bs,Ds,ia=j(()=>{ye(),xe(),Ze(),_e(),Jc=(i,e)=>{if(!i||i.length<1)throw new Error("too few inputs");let o=0,a=i[o],d=a.dataType,g=a.dims.length;i.forEach((h,et)=>{if(et!==o){if(h.dataType!==d)throw new Error("input tensors should be one type");if(h.dims.length!==g)throw new Error("input tensors should have the same shape");h.dims.forEach((ot,it)=>{if(it!==e&&ot!==a.dims[it])throw new Error("non concat dimensions must match")})}})},ep=(i,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${i}u>(${e});
    for (var i: u32 = 0u; i < ${i}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${i}u;
  }`,tp=(i,e)=>{let o=i.length,a=[];for(let d=0;d<o;++d){let g=e.setByOffset("global_idx",i[d].getByIndices("indices"));o===1?a.push(g):d===0?a.push(`if (inputIndex == ${d}u) { ${g} }`):d===o-1?a.push(`else { ${g} }`):a.push(`else if (inputIndex == ${d}) { ${g} }`)}return a.join(`
`)},Yn=(i,e,o,a)=>{let d=M.size(o),g=new Array(i.length),h=new Array(i.length),et=0,ot=[],it=[],$=[{type:12,data:d}];for(let st=0;st<i.length;++st)et+=i[st].dims[e],g[st]=et,it.push(i[st].dims.length),h[st]=U(`input${st}`,a,it[st]),ot.push("rank"),$.push({type:12,data:g[st]});for(let st=0;st<i.length;++st)$.push(...X(i[st].dims));$.push(...X(o));let c=K("output",a,o.length),s=c.indicesGet("indices",e),_=Array.from(Array(g.length).keys()).map(st=>`uniforms.sizeInConcatAxis${st}`).join(","),b=st=>`

  ${(()=>{st.registerUniform("outputSize","u32");for(let dt=0;dt<i.length;dt++)st.registerUniform(`sizeInConcatAxis${dt}`,"u32");return st.declareVariables(...h,c)})()}

  ${ep(g.length,_)}

  ${st.mainStart()}
    ${st.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${c.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${s});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${g.length}u>(${_});
      ${s} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${tp(h,c)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:ot},getRunData:()=>({outputs:[{dims:o,dataType:a}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:$}),getShaderSource:b}},Bs=(i,e)=>{let o=i.inputs,a=o[0].dims,d=M.normalizeAxis(e.axis,a.length);Jc(o,d);let g=a.slice();g[d]=o.reduce((et,ot)=>et+(ot.dims.length>d?ot.dims[d]:0),0);let h=o.filter(et=>M.size(et.dims)>0);i.compute(Yn(h,d,g,o[0].dataType),{inputs:h})},Ds=i=>we({axis:i.axis})}),rp,np,ip,ap,Xn,op,Ms,aa=j(()=>{ye(),Hn(),_e(),ia(),rp=(i,e)=>{let o=i[0],a=i[1],d=i[2],g=i[3],h=i[4],et=i[5];if(h&&et)throw new Error("Attention cannot have both past and relative_position_bias");if(o.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let ot=o.dims[0],it=o.dims[1],$=o.dims[2];if(d.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(a.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(a.dims[0]!==$)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(d.dims[0]!==a.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let c=d.dims[0]/3,s=c,_=s;if(e.qkvHiddenSizes.length>0){if(e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let ft of e.qkvHiddenSizes)if(ft%e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");c=e.qkvHiddenSizes[0],s=e.qkvHiddenSizes[1],_=e.qkvHiddenSizes[2]}let b=it;if(c!==s)throw new Error("qkv_hidden_sizes first element should be same as the second");if(d.dims[0]!==c+s+_)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let st=0;if(h){if(s!==_)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(h.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(h.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(h.dims[1]!==ot)throw new Error('Input "past" second dimension must be batch_size');if(h.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(h.dims[4]!==s/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(st=h.dims[3])}let dt=b+st,ct=-1,pt=0;if(g)throw new Error("Mask not supported");if(h)throw new Error("past is not supported");return{batchSize:ot,sequenceLength:it,pastSequenceLength:st,kvSequenceLength:b,totalSequenceLength:dt,maxSequenceLength:ct,inputHiddenSize:$,hiddenSize:c,vHiddenSize:_,headSize:Math.floor(c/e.numHeads),vHeadSize:Math.floor(_/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:pt,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},np=(i,e,o,a)=>{let d=Ue(a),g=64,h=a/d;h<g?g=1:h/8<64&&(g=Math.ceil(h/8));let et=Math.ceil(a/d/g),ot=[{type:e.dataType,data:1/a},{type:12,data:h},{type:12,data:et}],it=Be(e.dataType,d),$=rt(1,d),c=s=>{let _=K("x",e.dataType,e.dims,d),b=[{name:"d_inv",type:rt(e.dataType)},{name:"d_comp",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${g}>;
  var<workgroup> thread_sum: array<f32, ${g}>;
  ${s.registerUniforms(b).declareVariables(_)}
  ${s.mainStart([g,1,1])}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = workgroup_id.x * uniforms.d_comp + local_offset;

    var thread_max_vector = ${$}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      thread_max_vector = max(${$}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(d){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${d}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${g}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${$}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      sum_vector += exp(${$}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(d){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${d}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${g}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        x[offset + i] = ${_.type.value}(uniforms.d_inv);
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        var f32input = ${$}(x[offset + i]);
        x[offset + i] = ${_.type.value}(exp(f32input - max_value) / sum);
      }
    }
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${g};${it};${d}`},getShaderSource:c,getRunData:()=>({outputs:[],dispatchGroup:{x:o},programUniforms:ot})}},ip=(i,e,o,a,d,g,h)=>{let et=h+d.kvSequenceLength,ot=[d.batchSize,d.numHeads,d.sequenceLength,et],it=g.scale===0?1/Math.sqrt(d.headSize):g.scale,$=Ue(d.headSize),c=d.headSize/$,s=12,_={x:Math.ceil(et/s),y:Math.ceil(d.sequenceLength/s),z:d.batchSize*d.numHeads},b=[{type:12,data:d.sequenceLength},{type:12,data:c},{type:12,data:et},{type:12,data:d.numHeads},{type:1,data:it}],st=a?["type","type","type"]:["type","type"],dt=ct=>{let pt=U("q",e.dataType,e.dims,$),ft=U("key",o.dataType,o.dims,$),mt=[pt,ft];a&&mt.push(U("relative_position_bias",a.dataType,a.dims));let bt=K("output",e.dataType,ot),$t=rt(1,$),Ct=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"alpha",type:"f32"}];return`
  const TILE_SIZE = ${s}u;

  var<workgroup> tileQ: array<${pt.type.storage}, ${s*s}>;
  var<workgroup> tileK: array<${pt.type.storage}, ${s*s}>;
  ${ct.registerUniforms(Ct).declareVariables(...mt,bt)}
  ${ct.mainStart([s,s,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;

    var value = ${$t}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
        value += ${$t}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch($){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${$}`)}})()};
        output[outputIdx] = ${bt.type.value} (sum * uniforms.alpha) + ${a?"relative_position_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${$}`,inputDependencies:st},getRunData:()=>({outputs:[{dims:ot,dataType:e.dataType,gpuDataType:0}],dispatchGroup:_,programUniforms:b}),getShaderSource:dt}},ap=(i,e,o,a,d)=>{let g=d+a.kvSequenceLength,h=[a.batchSize,a.sequenceLength,a.vHiddenSize],et=12,ot={x:Math.ceil(a.vHeadSize/et),y:Math.ceil(a.sequenceLength/et),z:a.batchSize*a.numHeads},it=[{type:12,data:a.sequenceLength},{type:12,data:g},{type:12,data:a.vHeadSize},{type:12,data:a.numHeads},{type:12,data:a.vHiddenSize}];return{name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:h,dataType:e.dataType,gpuDataType:0}],dispatchGroup:ot,programUniforms:it}),getShaderSource:$=>{let c=U("probs",e.dataType,e.dims),s=U("v",o.dataType,o.dims),_=K("output",e.dataType,h),b=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}];return`
  const TILE_SIZE = ${et}u;
  var<workgroup> tileQ: array<${c.type.value}, ${et*et}>;
  var<workgroup> tileK: array<${c.type.value}, ${et*et}>;
  ${$.registerUniforms(b).declareVariables(c,s,_)}
  ${$.mainStart([et,et,1])}
   let headIdx = workgroup_id.z;
   let m = global_id.y;
   let n = global_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;

   var value = ${c.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
     if (m < uniforms.M && w + local_id.x < uniforms.K) {
       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
     }
     if (n < uniforms.N && w + local_id.y < uniforms.K) {
       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];
     }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`}}},Xn=(i,e,o,a,d,g,h,et,ot,it,$)=>{let c=i.outputCount>1,s=i.outputCount>2,_=c&&s?it.pastSequenceLength:0,b=_+it.kvSequenceLength,st=[it.batchSize,it.numHeads,b,it.headSize],dt=h?[h,o]:[o],ct=c?i.compute(Yn(dt,2,st,o.dataType),{inputs:dt,outputs:[1]})[0]:o,pt=[it.batchSize,it.numHeads,b,it.headSize],ft=et?[et,a]:[a],mt=s?i.compute(Yn(ft,2,pt,a.dataType),{inputs:ft,outputs:[2]})[0]:a,bt=[e,ct];ot&&bt.push(ot);let $t=i.compute(ip(i,e,ct,ot,it,$,_),{inputs:bt,outputs:[-1]})[0];i.compute(np(i,$t,it.batchSize*it.numHeads*it.sequenceLength,b),{inputs:[$t],outputs:[]});let Ct=[$t,mt];i.compute(ap(i,$t,mt,it,_),{inputs:Ct,outputs:[0]})},op=(i,e)=>{let o=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],a=e.sequenceLength,d=e.inputHiddenSize,g=e.headSize,h=12,et={x:Math.ceil(e.headSize/h),y:Math.ceil(e.sequenceLength/h),z:e.batchSize*e.numHeads},ot=[i.inputs[0],i.inputs[1],i.inputs[2]],it=[{type:12,data:a},{type:12,data:d},{type:12,data:g},{type:12,data:e.numHeads},{type:12,data:e.headSize},{type:12,data:e.hiddenSize},{type:12,data:e.hiddenSize+e.hiddenSize+e.vHiddenSize}],$=c=>{let s=K("output_q",ot[0].dataType,o),_=K("output_k",ot[0].dataType,o),b=K("output_v",ot[0].dataType,o),st=U("input",ot[0].dataType,ot[0].dims),dt=U("weight",ot[1].dataType,ot[1].dims),ct=U("bias",ot[2].dataType,ot[2].dims),pt=st.type.storage,ft=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${h}u;
  var<workgroup> tileInput: array<${pt}, ${h*h}>;
  var<workgroup> tileWeightQ: array<${pt}, ${h*h}>;
  var<workgroup> tileWeightK: array<${pt}, ${h*h}>;
  var<workgroup> tileWeightV: array<${pt}, ${h*h}>;
  ${c.registerUniforms(ft).declareVariables(st,dt,ct,s,_,b)}
  ${c.mainStart([h,h,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${pt}(0);
    var valueK = ${pt}(0);
    var valueV = ${pt}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return i.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:i.inputs[0].dataType,gpuDataType:0},{dims:o,dataType:i.inputs[0].dataType,gpuDataType:0},{dims:o,dataType:i.inputs[0].dataType,gpuDataType:0}],dispatchGroup:et,programUniforms:it}),getShaderSource:$},{inputs:ot,outputs:[-1,-1,-1]})},Ms=(i,e)=>{let o=rp(i.inputs,e),[a,d,g]=op(i,o);return Xn(i,a,d,g,i.inputs[4],void 0,void 0,void 0,i.inputs[5],o,e)}}),sp,up,lp,Us,Ws=j(()=>{_t(),ye(),xe(),Ze(),_e(),sp=(i,e)=>{if(!i||i.length!==5)throw new Error("BatchNormalization requires 5 inputs");let o=(a,d,g)=>{let h=d.length;if(h!==a.length)throw new Error(`${g}: num dimensions != ${h}`);d.forEach((et,ot)=>{if(et!==a[ot])throw new Error(`${g}: dim[${ot}] do not match`)})};if(i[0].dims.length>1){let a=e.format==="NHWC"?e.spatial?i[0].dims.slice(-1):i[0].dims.slice(-1).concat(i[0].dims.slice(1,i[0].dims.length-1)):i[0].dims.slice(1,e.spatial?2:void 0);o(i[1].dims,a,"Invalid input scale"),o(i[2].dims,a,"Invalid input B"),o(i[3].dims,a,"Invalid input mean"),o(i[4].dims,a,"Invalid input var")}else o(i[1].dims,[1],"Invalid input scale"),o(i[2].dims,[1],"Invalid input B"),o(i[3].dims,[1],"Invalid input mean"),o(i[4].dims,[1],"Invalid input var")},up=(i,e)=>{let{epsilon:o,spatial:a,format:d}=e,g=i[0].dims,h=a?Ue(g[g.length-1]):1,et=d==="NHWC"&&g.length>1?h:1,ot=M.size(g)/h,it=a,$=it?g.length:g,c=U("x",i[0].dataType,i[0].dims,h),s=U("scale",i[1].dataType,i[1].dims,et),_=U("bias",i[2].dataType,i[2].dims,et),b=U("inputMean",i[3].dataType,i[3].dims,et),st=U("inputVar",i[4].dataType,i[4].dims,et),dt=K("y",i[0].dataType,$,h),ct=()=>{let ft="";if(a)ft=`let cOffset = ${g.length===1?"0u":d==="NHWC"?`outputIndices[${g.length-1}] / ${h}`:"outputIndices[1]"};`;else if(d==="NCHW")ft=`
            ${dt.indicesSet("outputIndices","0","0")}
            let cOffset = ${dt.indicesToOffset("outputIndices")};`;else{ft=`var cIndices = ${s.type.indices}(0);
                       cIndices[0] = outputIndices[${g.length-1}];`;for(let mt=1;mt<s.rank;mt++)ft+=`cIndices[${mt}] = outputIndices[${mt}];`;ft+=`let cOffset = ${s.indicesToOffset("cIndices")};`}return ft},pt=ft=>`
  const epsilon = ${o};
  ${ft.registerUniform("outputSize","u32").declareVariables(c,s,_,b,st,dt)}
  ${ft.mainStart()}
  ${ft.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${dt.offsetToIndices(`global_idx * ${h}`)};
    ${ct()}
    let scale = ${s.getByOffset("cOffset")};
    let bias = ${_.getByOffset("cOffset")};
    let inputMean = ${b.getByOffset("cOffset")};
    let inputVar = ${st.getByOffset("cOffset")};
    let x = ${c.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${dt.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${a}_${h}`,inputDependencies:it?["rank","type","type","type","type"]:void 0},getShaderSource:pt,getRunData:()=>({outputs:[{dims:i[0].dims,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(ot/64)},programUniforms:it?[{type:12,data:ot},...X(g)]:[{type:12,data:ot}]})}},lp=i=>we(i),Us=(i,e)=>{let{inputs:o,outputCount:a}=i,d=lp({...e,outputCount:a});if(ke.webgpu.validateInputContent&&sp(o,d),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");i.compute(up(o,d))}}),dp,cp,Ns,Vs=j(()=>{xe(),_e(),dp=i=>{if(i[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(i[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(i[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(i[0].dims[2]!==i[1].dims[0])throw new Error("last dimension of input and bias are not the same")},cp=i=>{let e=i[0].dims,o=i[0].dims[2],a=M.size(e)/4,d=i[0].dataType,g=U("input",d,e,4),h=U("bias",d,[o],4),et=U("residual",d,e,4),ot=K("output",d,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:it=>`
  const channels = ${o}u / 4;
  ${it.declareVariables(g,h,et,ot)}

  ${it.mainStart()}
    ${it.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let value = ${g.getByOffset("global_idx")}
      + ${h.getByOffset("global_idx % channels")} + ${et.getByOffset("global_idx")};
    ${ot.setByOffset("global_idx","value")}
  }`}},Ns=i=>{dp(i.inputs),i.compute(cp(i.inputs))}}),pp,Pe,Hs,Gs,Ls,Fs,qs,js,Ks,Ys,Xs,mp,Zs,Qs,Js,eu,Zn,tu,Qn,ru,nu,iu,au,ou,su,uu,lu,du,cu,pu,mu,fu,hu,gu,yu,bu,vu,oa,sa,wu,$u,_u,Jn=j(()=>{ye(),xe(),Ze(),_e(),pp=(i,e,o,a,d,g)=>{let h=Math.ceil(e/4),et="";typeof d=="string"?et=`${d}(a)`:et=d("a");let ot=U("inputData",o,[h],4),it=K("outputData",a,[h],4);return`
      ${i.registerUniform("vec_size","u32").declareVariables(ot,it)}

  ${g??""}

  ${i.mainStart()}
    ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${ot.getByOffset("global_idx")};
    ${it.setByOffset("global_idx",et)}
  }`},Pe=(i,e,o,a,d,g=i.dataType)=>({name:e,shaderCache:{hint:d,inputDependencies:["type"]},getShaderSource:h=>pp(h,M.size(i.dims),i.dataType,g,o,a),getRunData:h=>({outputs:[{dims:i.dims,dataType:g}],dispatchGroup:{x:Math.ceil(M.size(h[0].dims)/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(i.dims)/4)}]})}),Hs=i=>{i.compute(Pe(i.inputs[0],"Abs","abs"))},Gs=i=>{i.compute(Pe(i.inputs[0],"Acos","acos"))},Ls=i=>{i.compute(Pe(i.inputs[0],"Acosh","acosh"))},Fs=i=>{i.compute(Pe(i.inputs[0],"Asin","asin"))},qs=i=>{i.compute(Pe(i.inputs[0],"Asinh","asinh"))},js=i=>{i.compute(Pe(i.inputs[0],"Atan","atan"))},Ks=i=>{i.compute(Pe(i.inputs[0],"Atanh","atanh"))},Ys=i=>we(i),Xs=(i,e)=>{let o;switch(e.to){case 10:o="vec4<f16>";break;case 1:o="vec4<f32>";break;case 12:o="vec4<u32>";break;case 6:o="vec4<i32>";break;case 9:o="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}i.compute(Pe(i.inputs[0],"Cast",o,void 0,e.cacheKey,e.to))},mp=i=>{let e=i.length>=2&&i[1].data!==0?i[1].getFloat32Array()[0]:Ln,o=i.length>=3&&i[2].data!==0?i[2].getFloat32Array()[0]:Fn;return we({min:e,max:o})},Zs=(i,e)=>{let o=i.inputs.length===1?e:mp(i.inputs),a=rt(i.inputs[0].dataType);i.compute(Pe(i.inputs[0],"Clip",d=>`clamp(${d}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${a}> = vec4(${a}(${o.min}));
    const clip_max_: vec4<${a}> = vec4(${a}(${o.max}));
`,o.cacheKey),{inputs:[0]})},Qs=i=>{i.compute(Pe(i.inputs[0],"Ceil","ceil"))},Js=i=>{i.compute(Pe(i.inputs[0],"Cos","cos"))},eu=i=>{i.compute(Pe(i.inputs[0],"Cosh","cosh"))},Zn=i=>we(i),tu=(i,e)=>{let o=rt(i.inputs[0].dataType);i.compute(Pe(i.inputs[0],"Elu",a=>`elu_vf32(${a})`,`
  const elu_alpha_ = ${o}(${e.alpha});

  fn elu_f32(a: ${o}) -> ${o} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${o}>) -> vec4<${o}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},Qn=(i="f32")=>`
const r0: ${i} = 0.3275911;
const r1: ${i} = 0.254829592;
const r2: ${i} = -0.284496736;
const r3: ${i} = 1.421413741;
const r4: ${i} = -1.453152027;
const r5: ${i} = 1.061405429;

fn erf_vf32(v: vec4<${i}>) -> vec4<${i}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,ru=i=>{let e=rt(i.inputs[0].dataType);i.compute(Pe(i.inputs[0],"Erf",o=>`erf_vf32(${o})`,Qn(e)))},nu=i=>{i.compute(Pe(i.inputs[0],"Exp","exp"))},iu=i=>{i.compute(Pe(i.inputs[0],"Floor","floor"))},au=i=>{let e=rt(i.inputs[0].dataType);i.compute(Pe(i.inputs[0],"Gelu",o=>`0.5 * ${o} * (1.0 + erf_vf32(${o} * 0.7071067811865475))`,Qn(e)))},ou=(i,e)=>{let o=rt(i.inputs[0].dataType);i.compute(Pe(i.inputs[0],"LeakyRelu",a=>`select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${o}>(0.0))`,`const leaky_relu_alpha_ = ${o}(${e.alpha});`,e.cacheKey))},su=i=>{i.compute(Pe(i.inputs[0],"Not",e=>`!${e}`))},uu=i=>{i.compute(Pe(i.inputs[0],"Neg",e=>`-${e}`))},lu=i=>{i.compute(Pe(i.inputs[0],"Reciprocal",e=>`1.0/${e}`))},du=i=>{let e=rt(i.inputs[0].dataType);i.compute(Pe(i.inputs[0],"Relu",o=>`select(vec4<${e}>(0.0), ${o}, ${o} > vec4<${e}>(0.0))`))},cu=i=>{i.compute(Pe(i.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},pu=i=>we(i),mu=(i,e)=>{let o=rt(i.inputs[0].dataType);i.compute(Pe(i.inputs[0],"HardSigmoid",a=>`max(vec4<${o}>(0.0), min(vec4<${o}>(1.0), ${e.alpha} * ${a} + vec4<${o}>(${e.beta})))`,void 0,e.cacheKey))},fu=i=>{i.compute(Pe(i.inputs[0],"Sin","sin"))},hu=i=>{i.compute(Pe(i.inputs[0],"Sinh","sinh"))},gu=i=>{i.compute(Pe(i.inputs[0],"Sqrt","sqrt"))},yu=i=>{i.compute(Pe(i.inputs[0],"Tan","tan"))},bu=i=>`sign(${i}) * (1 - exp(-2 * abs(${i}))) / (1 + exp(-2 * abs(${i})))`,vu=i=>{i.compute(Pe(i.inputs[0],"Tanh",bu))},oa=(i="f32")=>`
const fast_gelu_a: ${i} = 0.5;
const fast_gelu_b: ${i} = 0.7978845608028654;
const fast_gelu_c: ${i} = 0.035677408136300125;

fn tanh_v(v: vec4<${i}>) -> vec4<${i}> {
  return ${bu("v")};
}
`,sa=i=>`(fast_gelu_a + fast_gelu_a * tanh_v(${i} * (fast_gelu_c * ${i} * ${i} + fast_gelu_b))) * ${i}`,wu=i=>{let e=rt(i.inputs[0].dataType);i.compute(Pe(i.inputs[0],"FastGelu",sa,oa(e),void 0,i.inputs[0].dataType))},$u=(i,e)=>{let o=rt(i.inputs[0].dataType);return i.compute(Pe(i.inputs[0],"ThresholdedRelu",a=>`select(vec4<${o}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${o}>(${e.alpha});`,e.cacheKey)),0},_u=i=>{i.compute(Pe(i.inputs[0],"Log","log"))}}),fp,hp,Su,Cu=j(()=>{xe(),_e(),Jn(),fp=i=>{if(i[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(i[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(i[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(i[0].dims[2]!==i[1].dims[0])throw new Error("last dimension of input and bias are not the same")},hp=i=>{let e=i[0].dims.slice();e[2]=e[2]/2;let o=U("input",i[0].dataType,i[0].dims,4),a=U("bias",i[0].dataType,[i[0].dims[2]],4),d=K("output",i[0].dataType,e,4),g=M.size(e)/4,h=Be(i[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)}}),getShaderSource:et=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${i[0].dims[2]/4/2}u;

  ${et.declareVariables(o,a,d)}

  ${Qn(h)}

  ${et.mainStart()}
    ${et.guardAgainstOutOfBoundsWorkgroupSizes(g)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${d.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Su=i=>{fp(i.inputs),i.compute(hp(i.inputs))}}),gp,yp,Ut,Iu,Tu,Au,Eu,ku,Ou,Pu,Ru,zu,Bu,Du=j(()=>{ye(),xe(),_e(),gp=(i,e,o,a,d,g,h,et,ot,it,$,c)=>{let s,_;typeof et=="string"?s=_=(pt,ft)=>`${et}((${pt}),(${ft}))`:typeof et=="function"?s=_=et:(s=et.scalar,_=et.vector);let b=K("outputData",$,a.length,4),st=U("aData",ot,e.length,4),dt=U("bData",it,o.length,4),ct;if(d)if(g){let pt=M.size(e)===1,ft=M.size(o)===1,mt=e.length>0&&e[e.length-1]%4===0,bt=o.length>0&&o[o.length-1]%4===0;pt||ft?ct=b.setByOffset("global_idx",_(pt?`${st.type.value}(${st.getByOffset("0")}.x)`:st.getByOffset("global_idx"),ft?`${dt.type.value}(${dt.getByOffset("0")}.x)`:dt.getByOffset("global_idx"))):ct=`
            let outputIndices = ${b.offsetToIndices("global_idx * 4u")};
            let offsetA = ${st.broadcastedIndicesToOffset("outputIndices",b)};
            let offsetB = ${dt.broadcastedIndicesToOffset("outputIndices",b)};
            ${b.setByOffset("global_idx",_(h||mt?st.getByOffset("offsetA / 4u"):`${st.type.value}(${st.getByOffset("offsetA / 4u")}[offsetA % 4u])`,h||bt?dt.getByOffset("offsetB / 4u"):`${dt.type.value}(${dt.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else ct=b.setByOffset("global_idx",_(st.getByOffset("global_idx"),dt.getByOffset("global_idx")));else{if(!g)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let pt=(ft,mt,bt="")=>{let $t=`aData[indexA${mt}][componentA${mt}]`,Ct=`bData[indexB${mt}][componentB${mt}]`;return`
            let outputIndices${mt} = ${b.offsetToIndices(`global_idx * 4u + ${mt}u`)};
            let offsetA${mt} = ${st.broadcastedIndicesToOffset(`outputIndices${mt}`,b)};
            let offsetB${mt} = ${dt.broadcastedIndicesToOffset(`outputIndices${mt}`,b)};
            let indexA${mt} = offsetA${mt} / 4u;
            let indexB${mt} = offsetB${mt} / 4u;
            let componentA${mt} = offsetA${mt} % 4u;
            let componentB${mt} = offsetB${mt} % 4u;
            ${ft}[${mt}] = ${bt}(${s($t,Ct)});
          `};$===9?ct=`
            var data = vec4<u32>(0);
            ${pt("data",0,"u32")}
            ${pt("data",1,"u32")}
            ${pt("data",2,"u32")}
            ${pt("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:ct=`
            ${pt("outputData[global_idx]",0)}
            ${pt("outputData[global_idx]",1)}
            ${pt("outputData[global_idx]",2)}
            ${pt("outputData[global_idx]",3)}
          `}return`
        ${i.registerUniform("vec_size","u32").declareVariables(st,dt,b)}

        ${c??""}

        ${i.mainStart()}
        ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${ct}
      }`},yp=(i,e,o,a,d,g,h=o.dataType)=>{let et=!M.areEqual(o.dims,a.dims),ot=o.dims,it=M.size(o.dims),$=!1,c=!1,s=[et];if(et){let _=Rt.calcShape(o.dims,a.dims,!1);if(!_)throw new Error("Can't perform binary op on the given tensors");ot=_,it=M.size(ot);let b=M.size(o.dims)===1,st=M.size(a.dims)===1,dt=o.dims.length>0&&o.dims[o.dims.length-1]%4===0,ct=a.dims.length>0&&a.dims[a.dims.length-1]%4===0;s.push(b),s.push(st),s.push(dt),s.push(ct);let pt=1;for(let ft=1;ft<ot.length;ft++){let mt=o.dims[o.dims.length-ft]??1,bt=a.dims[a.dims.length-ft]??1;if(mt===bt)pt*=mt;else break}pt%4===0?(c=!0,$=!0):(b||st||dt||ct)&&($=!0)}else $=!0;return s.push($),{name:i,shaderCache:{hint:e+s.map(_=>_.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:_=>gp(_,o.dims,a.dims,ot,$,et,c,d,o.dataType,a.dataType,h,g),getRunData:()=>({outputs:[{dims:ot,dataType:h}],dispatchGroup:{x:Math.ceil(it/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(ot)/4)},...X(o.dims,a.dims,ot)]})}},Ut=(i,e,o,a,d,g)=>{i.compute(yp(e,d??"",i.inputs[0],i.inputs[1],o,a,g))},Iu=i=>{Ut(i,"Add",(e,o)=>`${e}+${o}`)},Tu=i=>{Ut(i,"Div",(e,o)=>`${e}/${o}`)},Au=i=>{Ut(i,"Equal",{scalar:(e,o)=>`u32(${e}==${o})`,vector:(e,o)=>`vec4<u32>(${e}==${o})`},void 0,void 0,9)},Eu=i=>{Ut(i,"Mul",(e,o)=>`${e}*${o}`)},ku=i=>{let e=U("input",i.inputs[0].dataType,i.inputs[0].dims).type.value;Ut(i,"Pow",{scalar:(o,a)=>`pow_custom(${o},${a})`,vector:(o,a)=>`pow_vector_custom(${o},${a})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Ou=i=>{Ut(i,"Sub",(e,o)=>`${e}-${o}`)},Pu=i=>{Ut(i,"Greater",{scalar:(e,o)=>`u32(${e}>${o})`,vector:(e,o)=>`vec4<u32>(${e}>${o})`},void 0,void 0,9)},Ru=i=>{Ut(i,"Less",{scalar:(e,o)=>`u32(${e}<${o})`,vector:(e,o)=>`vec4<u32>(${e}<${o})`},void 0,void 0,9)},zu=i=>{Ut(i,"GreaterOrEqual",{scalar:(e,o)=>`u32(${e}>=${o})`,vector:(e,o)=>`vec4<u32>(${e}>=${o})`},void 0,void 0,9)},Bu=i=>{Ut(i,"LessOrEqual",{scalar:(e,o)=>`u32(${e}<=${o})`,vector:(e,o)=>`vec4<u32>(${e}<=${o})`},void 0,void 0,9)}}),Et,kt,Ot,ei,Zt=j(()=>{ye(),xe(),Et=(i,e,o="f32")=>{switch(i.activation){case"Relu":return`value = max(value, ${e}(0.0));`;case"Sigmoid":return`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${e}(${o}(uniforms.clip_min)), ${e}(${o}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${e}(0.0), min(${e}(1.0), ${o}(uniforms.alpha) * value + ${o}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${o}(uniforms.alpha) * value, value, value >= ${e}(0.0));`;case"":return"";default:throw new Error(`Unsupported activation ${i.activation}`)}},kt=(i,e)=>{i.activation==="Clip"?e.push({type:1,data:i.clipMax},{type:1,data:i.clipMin}):i.activation==="HardSigmoid"?e.push({type:1,data:i.alpha},{type:1,data:i.beta}):i.activation==="LeakyRelu"&&e.push({type:1,data:i.alpha})},Ot=(i,e)=>{i.activation==="Clip"?e.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):i.activation==="HardSigmoid"?e.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):i.activation==="LeakyRelu"&&e.push({name:"alpha",type:"f32"})},ei=i=>{let e=(i==null?void 0:i.activation)||"";if(e==="HardSigmoid"){let[o,a]=(i==null?void 0:i.activation_params)||[.2,.5];return{activation:e,alpha:o,beta:a}}else if(e==="Clip"){let[o,a]=(i==null?void 0:i.activation_params)||[Ln,Fn];return{activation:e,clipMax:a,clipMin:o}}else if(e==="LeakyRelu"){let[o]=(i==null?void 0:i.activation_params)||[.01];return{activation:e,alpha:o}}return{activation:e}}}),nt,ti,ri=j(()=>{nt=(i,e)=>{switch(i){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${i}-component is not supported.`)}},ti=i=>`
      ${i?"value = value + getBiasByOutputCoords(coords);":""}
      `}),ni,ua=j(()=>{ni=i=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${i}.x), i32(${i}.y), i32(${i}.z), 1));
}
`}),vp,wp,rn,Mu,$p,nn,_p,ii,an=j(()=>{ye(),xe(),_e(),Zt(),ri(),vp=(i,e)=>i?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,wp=(i,e)=>i?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,rn=(i,e,o="f32",a,d=!1,g=32,h=!1,et=32)=>{let ot=e[1]*i[1],it=e[0]*i[0],$=d?ot:g,c=d?g:ot,s=$/e[0],_=g/e[1];if(!((d&&s===4&&i[1]===4||!d&&(s===3||s===4))&&$%e[0]===0&&g%e[1]===0&&i[0]===4))throw new Error(`If transposeA ${d} is true, innerElementSize ${s} and workPerThread[1] ${i[1]} must be 4.
      Otherwise, innerElementSize ${s} must be 3 or 4.
  tileAWidth ${$} must be divisible by workgroupSize[0]${e[0]}. tileInner ${g} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${i[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${s}<${o}>, ${$/s}>, ${c}>;
var<workgroup> mm_Bsub: array<array<vec4<${o}>, ${it/i[0]}>, ${g}>;

const rowPerThread = ${i[1]};
const colPerThread = ${i[0]};
const innerElementSize = ${s};
const tileInner = ${g};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${h?"0":"i32(globalId.z)"};
  ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${ot};

  let num_tiles = ${h?`${Math.ceil(et/g)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${h?`i32(globalId.z) * ${et}`:"0"};

  var acc: array<vec4<${o}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${_};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${vp(d,a)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${a?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${s===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${wp(d,s)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Mu=(i,e)=>i?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,$p=i=>i?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",nn=(i,e,o="f32",a,d=!1,g=32,h=!1,et=32,ot=!1)=>{let it=i[1]*e[1],$=i[0]*e[0],c=d?it:g,s=d?g:it;if(!(s%e[1]===0&&c%e[0]===0&&g%e[1]===0))throw new Error(`tileAHight ${s} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}, tileInner ${g} must be divisible by workgroupSize[1]${e[1]}`);let _=s/e[1],b=c/e[0],st=g/e[1],dt=ot?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${it};
    let globalColStart = i32(workgroupId.x) * ${$};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
          ${Mu(d,a)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${g}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${$}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${a?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${o}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${d?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${it};

let tileRowA = i32(localId.y) * ${_};
let tileColA = i32(localId.x) * ${b};
let tileRowB = i32(localId.y) * ${st};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${b}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Mu(d,a)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${st}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${a?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${o}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${$p(d)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${o}, ${c}>, ${s}>;
  var<workgroup> mm_Bsub : array<array<${o}, ${$}>, ${g}>;
  const rowPerThread = ${i[1]};
  const colPerThread = ${i[0]};
  const tileInner = ${g};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${h?"0":"i32(globalId.z)"};
    ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${h?`${Math.ceil(et/g)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${h?`i32(globalId.z) * ${et}`:"0"};

    var acc : array<array<${o}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${dt}
  }
`},_p=(i,e,o,a,d,g=!1)=>{let[h,et,ot]=d,[it,$,c,s]=a,_=Pr(h,ot),b=Pr(et,ot),st=Be(a[0].type.tensor),dt=()=>{let pt=$.rank,ft=it.rank,mt=`var aIndices: ${$.type.indices};`;for(let bt=pt-2-1,$t=ft-1;bt>=0;bt--,$t--)mt+=`
aIndices[${bt}] = ${ft>1?`batchIndices[${$t}]`:"batchIndices"};`;return _.forEach(bt=>{mt+=`
aIndices[${bt}] = 0;`}),mt+=`
aIndices[${pt-2}] = u32(row);
                   aIndices[${pt-1}] = u32(colIn);`,mt},ct=()=>{let pt=c.rank,ft=it.rank,mt=`var bIndices: ${c.type.indices};`;for(let bt=pt-2-1,$t=ft-1;bt>=0;bt--,$t--)mt+=`
bIndices[${bt}] = ${ft>1?`batchIndices[${$t}]`:"batchIndices"};`;return b.forEach(bt=>{mt+=`
bIndices[${bt}] = 0;`}),mt+=`
bIndices[${pt-2}] = u32(row);
                   bIndices[${pt-1}] = u32(colIn);`,mt};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${it.type.indices}) -> ${nt(i,st)} {
      var value = ${nt(i,st)}(0.0);
      let col = colIn * ${i};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${dt()}
        value = ${$.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${it.type.indices}) -> ${nt(i,st)} {
      var value = ${nt(i,st)}(0.0);
      let col = colIn * ${i};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${ct()}
        value = ${c.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${nt(i,st)}) {
      let col = colIn * ${i};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${g?"bias[colIn]":`${nt(i,st)}(bias[row])`};`:""}
        ${o}
        ${s.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},ii=(i,e,o,a,d=!1)=>{let g=i[0].dims,h=i[1].dims,et=g.slice(0,-2),ot=h.slice(0,-2),it=a?a.slice(0,-2):o.slice(0,-2),$=M.size(it),c=g[g.length-2],s=g[g.length-1],_=h[h.length-1],b=s%4===0&&_%4===0,st=c<=8?[4,1,1]:[4,4,1],dt=[8,8,1],ct=[Math.ceil(_/dt[0]/st[0]),Math.ceil(c/dt[1]/st[1]),Math.ceil($/dt[2]/st[2])],pt=b?4:1,ft=[...et,c,s/pt],mt=ft.length,bt=[...ot,s,_/pt],$t=bt.length,Ct=[$,c,_/pt],It=[{type:6,data:c},{type:6,data:_},{type:6,data:s}];kt(e,It),It.push(...X(it,ft,bt));let Tt=["rank","rank"],jt=i.length>2;jt&&(It.push(...X(i[2].dims)),Tt.push("rank")),It.push(...X(Ct));let dn=yn=>{let mn=it.length,fn=qn("batchDims",i[0].dataType,mn,1),un=Be(i[0].dataType),Wt=U("a",i[0].dataType,mt,pt),Jt=U("b",i[1].dataType,$t,pt),_n=K("result",i[0].dataType,Ct.length,pt),vn=[Wt,Jt];if(jt){let Ir=d?pt:1;vn.push(U("bias",i[2].dataType,i[2].dims.length,Ir))}let Sn=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Ot(e,Sn);let hn=Be(_n.type.tensor),rr=Et(e,_n.type.value,hn),vr=_p(pt,jt,rr,[fn,Wt,Jt,_n],[et,ot,it],d);return`
  ${yn.registerUniforms(Sn).registerInternalVariables(fn).declareVariables(...vn,_n)}
  ${vr}
  ${b?rn(st,dt,un,fn):nn(st,dt,un,fn)}
                   `};return{name:"MatMul",shaderCache:{hint:`${st};${e.activation};${b};${d}`,inputDependencies:Tt},getRunData:()=>({outputs:[{dims:o,dataType:i[0].dataType}],dispatchGroup:{x:ct[0],y:ct[1],z:ct[2]},programUniforms:It}),getShaderSource:dn}}}),xp,Uu,Wu=j(()=>{ye(),Yt(),_e(),Zt(),ri(),ua(),an(),xp=(i,e,o,a,d=!1,g,h=4,et=4,ot=4,it="f32")=>{let $=Tt=>{switch(Tt){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${it}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Tt} is not supported.`)}},c=Tt=>{switch(Tt){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${Tt} is not supported.`)}},s=i?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,_=i?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,b=i?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",st=i?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",dt=i?"row":"col",ct=i?"col":"row",pt=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${i?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${dt} / outWidth;
    let outCol = ${dt} % outWidth;

    let WRow = ${ct} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${ct} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${ct} % inChannels;
    var resData = ${nt(h,it)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${b} && xCol >= 0 && xCol < ${st}) {
      ${s}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${$(h)}
    }
    return resData;`,ft=i?e&&a?`
    let col = colIn * ${h};
    ${pt}`:`
    let col = colIn * ${h};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${pt}
    }
    return ${nt(h,it)}(0.0);`:a&&o?`
    let col = colIn * ${h};
    ${pt}`:`
    let col = colIn * ${h};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${pt}
    }
    return ${nt(h,it)}(0.0);`,mt=`${c(et)}`,bt=nt(ot,it),$t=nt(i?h:et,it),Ct=nt(i?et:h,it),It=Et(g,bt,it);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${$t} {
      ${i?ft:mt}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Ct} {
      ${i?mt:ft}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${bt}) {
      let col = colIn * ${ot};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${i?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${_}
      ${ti(d)}
      ${It}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Uu=(i,e,o,a,d,g,h,et)=>{let ot=e.format==="NHWC",it=ot?i[0].dims[3]:i[0].dims[1],$=o[0],c=ot?o[2]:o[3],s=ot?o[1]:o[2],_=ot?o[3]:o[1],b=ot&&(it%4===0||it%3===0)&&_%4===0,st=ot?_:c*s,dt=ot?c*s:_,ct=[8,8,1],pt=a<=8?[4,1,1]:[4,4,1],ft=[Math.ceil(st/ct[0]/pt[0]),Math.ceil(dt/ct[1]/pt[1]),Math.ceil($/ct[2]/pt[2])];Ne("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${ft}`);let mt=b?ot&&it%4!==0?3:4:1,bt=ct[1]*pt[1],$t=ct[0]*pt[0],Ct=Math.max(ct[0]*mt,ct[1]),It=a%bt===0,Tt=d%$t===0,jt=g%Ct===0,dn=b?[mt,4,4]:[1,1,1],yn=[{type:6,data:a},{type:6,data:d},{type:6,data:g},{type:6,data:[e.pads[0],e.pads[1]]},{type:6,data:e.strides},{type:6,data:e.dilations}];kt(e,yn),yn.push(...X(i[0].dims,i[1].dims));let mn=["rank","rank"];h&&(yn.push(...X(i[2].dims)),mn.push("rank")),yn.push(...X(o));let fn=un=>{let Wt=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Ot(e,Wt);let Jt=b?4:1,_n=Be(i[0].dataType),vn=`
      fn setOutputAtIndex(flatIndex : i32, value : ${b?`vec4<${_n}>`:_n}) {
        result[flatIndex] = ${b?`vec4<${_n}>`:_n}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${b?`vec4<${_n}>`:_n}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${b?"/ 4":""}, value);
      }`,Sn=U("x",i[0].dataType,i[0].dims.length,mt===3?1:mt),hn=U("w",i[1].dataType,i[1].dims.length,Jt),rr=[Sn,hn],vr=K("result",i[0].dataType,o.length,Jt);if(h){let Ir=U("bias",i[2].dataType,i[2].dims.length,Jt);rr.push(Ir),vn+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${b?`vec4<${_n}>`:_n} {
          return bias[coords.${ot?"w":"y"}${b?"/ 4":""}];
        }`}return`
        ${ni("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${un.registerUniforms(Wt).declareVariables(...rr,vr)}
        ${vn}
        ${xp(ot,It,Tt,jt,h,e,dn[0],dn[1],dn[2],_n)}
        ${b?rn(pt,ct,_n,void 0,!ot,Ct):nn(pt,ct,_n,void 0,!ot,Ct,!1,void 0,et)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${e.cacheKey};${mt};${b};${It};${Tt};${jt};${bt};${$t};${Ct}`,inputDependencies:mn},getRunData:()=>({outputs:[{dims:o,dataType:i[0].dataType}],dispatchGroup:{x:ft[0],y:ft[1],z:ft[2]},programUniforms:yn}),getShaderSource:fn}}}),la,Nu,Vu=j(()=>{ye(),xe(),_e(),da(),Zt(),la=(i,e,o)=>{let a=i.length>2,d=a?"value += b[output_channel];":"",g=i[0].dims,h=i[1].dims,et=h[0]/e.group,ot=e.format==="NHWC",it=ai(g,h,e.dilations,e.pads,e.strides,ot),$=M.size(it),c=[{type:12,data:$},{type:12,data:e.dilations},{type:12,data:[e.strides[0],e.strides[1]]},{type:12,data:[e.pads[0],e.pads[1]]},{type:12,data:et}];kt(e,c),c.push(...X(g,h));let s=["rank","rank"];a&&(c.push(...X(i[2].dims)),s.push("rank")),c.push(...X(it));let _=b=>{let st=K("output",i[0].dataType,it.length),dt=Be(st.type.tensor),ct=Et(e,st.type.value,dt),pt=U("x",i[0].dataType,g.length),ft=U("w",i[1].dataType,h.length),mt=[pt,ft];a&&mt.push(U("b",i[2].dataType,i[2].dims.length));let bt=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:e.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];return Ot(e,bt),`
  ${b.registerUniforms(bt).declareVariables(...mt,st)}

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${st.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${ot?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${ot?1:2}], outputIndices[${ot?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel / uniforms.output_channels_per_group;

    var value: ${st.type.value} = ${st.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[${ot?1:2}]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[${ot?2:3}]) {
            continue;
          }

          let xVal = ${ot?pt.get("batch","xHeight","xWidth","input_channel"):pt.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${ft.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${d}
    ${ct}
    ${st.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:e.cacheKey,inputDependencies:s},getRunData:()=>({outputs:[{dims:o?o(it):it,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:c}),getShaderSource:_}},Nu=(i,e,o)=>{let a=i.length>2,d=Ue(o[3]),g=Ue(o[2]),h=M.size(o)/d/g,et=[i[0].dims[0],i[0].dims[1],i[0].dims[2],i[0].dims[3]/d],ot=[i[1].dims[0],i[1].dims[1],i[1].dims[2],i[1].dims[3]/d],it=[o[0],o[1],o[2],o[3]/d],$=[{type:12,data:h},{type:6,data:[e.strides[0],e.strides[1]]},{type:6,data:[e.pads[0],e.pads[1]]}];kt(e,$),$.push(...X(et,ot,it));let c=(g-1)*e.strides[1]+ot[1],s=_=>{let b=K("output",i[0].dataType,it.length,d),st=Be(b.type.tensor),dt=Et(e,b.type.value,st),ct=U("x",i[0].dataType,et.length,d),pt=U("w",i[1].dataType,ot.length,d),ft=[ct,pt];a&&ft.push(U("b",i[2].dataType,i[2].dims,d));let mt=a?"value += b[output_channel];":"",bt=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Ot(e,bt),`
  ${_.registerUniforms(bt).declareVariables(...ft,b)}
  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${g}u;
    let col = (index1 % width1) * ${g}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${ct.type.value}, ${c}>;
    var values: array<${b.type.value}, ${g}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${ot[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${c}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${ct.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${ct.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${ot[1]}; w_width++) {
          let w_val = ${pt.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${g}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${g}u; i++) {
      var value = values[i];
      ${mt}
      ${dt}
      ${b.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${e.cacheKey};${d};${g};${c};${ot[0]};${ot[1]}`,inputDependencies:a?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:o,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:$}),getShaderSource:s}}}),ca,Sp,Hu,pa=j(()=>{ye(),xe(),an(),_e(),Zt(),ca=(i,e,o,a,d=!1)=>{let g=i[0].dims,h=i[1].dims,et=g[g.length-2],ot=h[h.length-1],it=g[g.length-1],$=Ue(ot),c=Ue(it),s=Ue(et),_=M.size(o)/$/s,b=i.length>2,st=a?a.slice(0,-2):o.slice(0,-2),dt=[M.size(st),et,ot],ct=[{type:12,data:_},{type:12,data:et},{type:12,data:ot},{type:12,data:it}];kt(e,ct),ct.push(...X(st,g,h)),b&&ct.push(...X(i[2].dims)),ct.push(...X(dt));let pt=ft=>{let mt=qn("batch_dims",i[0].dataType,st.length),bt=U("a",i[0].dataType,g.length,c),$t=U("b",i[1].dataType,h.length,$),Ct=K("output",i[0].dataType,dt.length,$),It=Be(Ct.type.tensor),Tt=Et(e,Ct.type.value,It),jt=[bt,$t],dn="";if(b){let vn=d?$:1;jt.push(U("bias",i[2].dataType,i[2].dims.length,vn)),dn=`${d?`value += bias[col / ${vn}];`:`value += ${Ct.type.value}(bias[row + i]);`}`}let yn=g.slice(0,-2),mn=h.slice(0,-2),fn=Pr(yn,st),un=Pr(mn,st),Wt=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Ot(e,Wt);let Jt=(vn,Sn)=>{let hn=vn.rank,rr=vn.name;if(hn===2)return`var ${rr}_indices = ${vn.type.indices}(0u, 0u);`;let vr=mt.rank,Ir=`var ${rr}_indices: ${vn.type.indices};`;for(let $r=hn-2-1,Ur=vr-1;$r>=0;$r--,Ur--)Ir+=`
${rr}_indices[${$r}] = ${vr>1?`batch_indices[${Ur}]`:"batch_indices"};`;return Sn.forEach($r=>{Ir+=`
${rr}_indices[${$r}] = 0;`}),Ir+=`${rr}_indices[${hn-2}] = 0u;
                     ${rr}_indices[${hn-1}] = 0u;`,Ir},_n=()=>{let vn=`var a_data: ${bt.type.value};`;for(let Sn=0;Sn<c;Sn++)vn+=`
              let b_data${Sn} = b[(b_offset + (k + ${Sn}) * uniforms.N + col) / ${$}];`;for(let Sn=0;Sn<s;Sn++){vn+=`a_data = a[(a_offset + (row + ${Sn}) * uniforms.K + k) / ${c}];`;for(let hn=0;hn<c;hn++)vn+=`
            values[${Sn}] = fma(${$t.type.value}(a_data${c===1?"":`[${hn}]`}), b_data${hn}, values[${Sn}]);
`}return vn};return`
  ${ft.registerUniforms(Wt).registerInternalVariables(mt).declareVariables(...jt,Ct)}
  ${ft.mainStart()}
    ${ft.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${$})) * ${$};
    var index1 = global_idx / (uniforms.N / ${$});
    let stride1 = uniforms.M / ${s};
    let row = (index1 % stride1) * ${s};
    let batch = index1 / stride1;

    ${o.length===2?"":`let batch_indices = ${mt.offsetToIndices("batch")};`}
    ${Jt(bt,fn)}
    let a_offset = ${bt.indicesToOffset("a_indices")};
    ${Jt($t,un)}
    let b_offset = ${$t.indicesToOffset("b_indices")};
    var values: array<${Ct.type.value}, ${s}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${c}) {
      ${_n()}
    }
    for (var i = 0u; i < ${s}u; i++) {
      var value = values[i];
      ${dn}
      ${Tt}
      let cur_indices = ${Ct.type.indices}(batch, row + i, col);
      let offset = ${Ct.indicesToOffset("cur_indices")};
      ${Ct.setByOffset(`offset / ${$}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${e.activation};${$};${c};${s};${d}`,inputDependencies:b?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:o,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:ct}),getShaderSource:pt}},Sp=i=>{if(!i||i.length!==2)throw new Error("MatMul requires 2 inputs.");if(i[0].dims[i[0].dims.length-1]!==i[1].dims[i[1].dims.length-2])throw new Error("shared dimension does not match.")},Hu=i=>{Sp(i.inputs);let e=Rt.calcShape(i.inputs[0].dims,i.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");let o=e[e.length-1],a=i.inputs[0].dims[i.inputs[0].dims.length-1];o<8&&a<8?i.compute(ca(i.inputs,{activation:""},e)):i.compute(ii(i.inputs,{activation:""},e))}}),ai,ma,Cp,Gu,fa,Ip,Tp,ha,da=j(()=>{xe(),Wu(),an(),Vu(),Zt(),pa(),Rr(),ai=(i,e,o,a,d,g)=>{let h=i[0],et=i.slice(g?1:2,g?3:4),ot=et.length,it=e[0],$=e.slice(2).map((s,_)=>s+(s-1)*(o[_]-1)),c=et.map((s,_)=>s+a[_]+a[_+ot]).map((s,_)=>Math.floor((s-$[_]+d[_])/d[_]));return c.splice(0,0,h),c.splice(g?3:1,0,it),c},ma=[2,3,1,0],Cp=(i,e)=>{if(!i||i.length!==2&&i.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(i[0].dims.length!==4&&i[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(i[0].dims.length!==i[1].dims.length)throw new Error("filter does not have same dimension as input");let o=i[0].dims[e.format==="NHWC"?i[0].dims.length-1:1],a=i[1].dims[1]*e.group;if(o!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(i.length===3&&(i[2].dims.length!==1||i[1].dims[0]!==i[2].dims[0]))throw new Error("invalid bias");let d=i[0].dims.length-2;if(e.dilations.length!==d)throw new Error(`dilations should be ${d}D`);if(e.strides.length!==d)throw new Error(`strides should be ${d}D`);if(e.pads.length!==d*2)throw new Error(`pads should be ${d*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==i[1].dims.length-2)throw new Error("invalid kernel shape")},Gu=(i,e)=>{let o=i.kernelShape.slice();for(let g=2;g<e[1].dims.length;++g)o[g-2]===0&&(o[g-2]=e[1].dims[g]);let a=i.pads.slice();pr.adjustPadsBasedOnAutoPad(e[0].dims,i.strides,i.dilations,o,a,i.format==="NHWC",i.autoPad);let d=Object.assign({},i);return Object.assign(d,{kernelShape:o,pads:a}),d},fa=i=>{let e=ei(i),o=i.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][i.auto_pad],d=i.dilations,g=i.group,h=i.kernel_shape,et=i.pads,ot=i.strides,it=i.w_is_const();return{autoPad:a,format:o,dilations:d,group:g,kernelShape:h,pads:et,strides:ot,wIsConst:it,...e,cacheKey:`${i.format};${e.activation};`}},Ip=(i,e,o)=>{let a=Gu(o,e),d=o.format==="NHWC";if(o.group!==1){if(!i.adapterInfo.isArchitecture("ampere")&&d&&e[1].dims[0]===o.group&&e[1].dims[1]===1&&o.dilations[0]===1&&o.dilations[1]===1){let $t=ai(e[0].dims,e[1].dims,o.dilations,a.pads,o.strides,d),Ct=i.kernelCustomData.wT??i.compute(xt(e[1],ma),{inputs:[1],outputs:[o.wIsConst?-2:-1]})[0];o.wIsConst&&!i.kernelCustomData.wT&&(i.kernelCustomData.wT=Ct);let It=[e[0],Ct];e.length===3&&It.push(e[2]),i.compute(Nu(It,a,$t),{inputs:It})}else i.compute(la(e,a));return}let g=e.length===3,h=e[0].dims[d?1:2],et=e[0].dims[d?2:3],ot=e[0].dims[d?3:1],it=e[1].dims[2],$=e[1].dims[3],c=ai(e[0].dims,e[1].dims,o.dilations,a.pads,o.strides,d),s=c[d?1:2],_=c[d?2:3],b=c[d?3:1],st=d&&it===h&&$===et&&o.pads[0]===0&&o.pads[1]===0;if(st||it===1&&$===1&&o.dilations[0]===1&&o.dilations[1]===1&&o.strides[0]===1&&o.strides[1]===1&&o.pads[0]===0&&o.pads[1]===0){let $t=c[0],Ct,It,Tt,jt=[];if(d){let mn=i.kernelCustomData.wT??i.compute(xt(e[1],ma),{inputs:[1],outputs:[o.wIsConst?-2:-1]})[0];if(o.wIsConst&&!i.kernelCustomData.wT&&(i.kernelCustomData.wT=mn),st){let fn=h*et*ot;Ct=e[0].reshape([1,$t,fn]),It=mn.reshape([1,fn,b]),Tt=[1,$t,b]}else Ct=e[0].reshape([$t,h*et,ot]),It=mn.reshape([1,ot,b]),Tt=[$t,s*_,b];jt.push(Ct),jt.push(It)}else Ct=e[0].reshape([$t,ot,h*et]),It=e[1].reshape([1,b,ot]),Tt=[$t,b,s*_],jt.push(It),jt.push(Ct);g&&jt.push(e[2]);let dn=Tt[2],yn=jt[0].dims[jt[0].dims.length-1];dn<8&&yn<8?i.compute(ca(jt,a,c,Tt,d),{inputs:jt}):i.compute(ii(jt,a,c,Tt,d),{inputs:jt});return}let dt=!0,ct=i.kernelCustomData.wT??i.compute(xt(e[1],ma),{inputs:[1],outputs:[o.wIsConst?-2:-1]})[0];o.wIsConst&&!i.kernelCustomData.wT&&(i.kernelCustomData.wT=ct);let pt=[e[0],ct];g&&pt.push(e[2]);let ft=d?s*_:b,mt=d?b:s*_,bt=it*$*ot;i.compute(Uu(pt,a,c,ft,mt,bt,g,dt),{inputs:pt})},Tp=(i,e)=>{let o=e.format==="NHWC",a=[i.inputs[0].reshape(o?[i.inputs[0].dims[0],1,i.inputs[0].dims[1],i.inputs[0].dims[2]]:[i.inputs[0].dims[0],i.inputs[0].dims[1],1,i.inputs[0].dims[2]]),i.inputs[1].reshape([i.inputs[1].dims[0],i.inputs[1].dims[1],1,i.inputs[1].dims[2]])];i.inputs.length===3&&a.push(i.inputs[2]);let d=[0,e.pads[0],0,e.pads[1]],g=[1].concat(e.strides),h=[1].concat(e.dilations),et=[1].concat(e.kernelShape),ot=Gu({...e,pads:d,strides:g,dilations:h,kernelShape:et},a);i.compute(la(a,ot,it=>o?[it[0],it[2],it[3]]:[]))},ha=(i,e)=>{Cp(i.inputs,e),i.inputs[0].dims.length===3?Tp(i,e):Ip(i,i.inputs,e)}}),Ap,Lu,Fu=j(()=>{ye(),Yt(),_e(),Zt(),ri(),ua(),an(),Ap=(i,e=!1,o,a,d=4)=>{let g=dt=>{switch(dt){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${a}(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${dt} is not supported.`)}},h=i?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,et=i?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,ot=i?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",it=i?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",$=i?"row":"col",c=i?"col":"row",s=`
      let inChannels = ${i?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let outWidth = ${i?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${$} / outWidth;
      let outCol = ${$} % outWidth;

      let WRow = ${c} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${c} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${ot}) || fract(xR) > 0.0) {
        return ${a}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${it}) || fract(xC) > 0.0) {
        return ${a}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${c} % inChannels;
      ${h}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${d}];`,_=i?`
      let col = colIn * ${d};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${s}
      }
      return ${a}(0.0);`:`
      let col = colIn * ${d};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${s}
      }
      return ${a}(0.0);`,b=`
      let col = colIn * ${d};
      let inChannels = ${i?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${i?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${g(d)}
      }
      return ${a}(0.0);
      `,st=Et(o,a);return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${a} {
    ${i?_:b}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${a} {
    ${i?b:_}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${a}) {
    let col = colIn * ${d};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${i?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${et}
      ${ti(e)}
      ${st}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${d}] = value;
    }
  }`},Lu=(i,e,o,a,d,g,h,et)=>{let ot=e.format==="NHWC",it=ot?i[0].dims[3]:i[0].dims[1],$=o[0],c=ot?o[2]:o[3],s=ot?o[1]:o[2],_=ot?o[3]:o[1],b=ot&&it%4===0&&it%3&&_%4===0,st=ot?_:c*s,dt=ot?c*s:_,ct=[8,8,1],pt=a<=8?[4,1,1]:[4,4,1],ft=[Math.ceil(st/ct[0]/pt[0]),Math.ceil(dt/ct[1]/pt[1]),Math.ceil($/ct[2]/pt[2])];Ne("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${ft}`);let mt=b?4:1,bt=Math.max(ct[0]*mt,ct[1]),$t=b?4:1,Ct=[e.kernelShape[ot?1:2],e.kernelShape[ot?2:3]],It=[Ct[0]+(e.dilations[0]<=1?0:(Ct[0]-1)*(e.dilations[0]-1)),Ct[1]+(e.dilations[1]<=1?0:(Ct[1]-1)*(e.dilations[1]-1))],Tt=[It[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),It[1]-1-Math.floor((e.pads[1]+e.pads[3])/2)],jt=[{type:6,data:a},{type:6,data:d},{type:6,data:g},{type:6,data:e.strides},{type:6,data:e.dilations},{type:6,data:Ct},{type:6,data:Tt}];kt(e,jt),jt.push(...X(i[0].dims,i[1].dims));let dn=["rank","rank"];h&&(jt.push(...X(i[2].dims)),dn.push("rank")),jt.push(...X(o));let yn=mn=>{let fn=U("x",i[0].dataType,i[0].dims.length,$t),un=U("w",i[1].dataType,i[1].dims.length,1),Wt=K("result",i[0].dataType,o.length,$t),Jt=[fn,un],_n="";if(h){let hn=U("bias",i[2].dataType,i[2].dims.length,$t);Jt.push(hn),_n+=`
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${hn.type.value} {
            return bias[coords.${ot?"w":"y"}${b?"/ 4":""}];
          }`}let vn=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:Ct.length},{name:"pads",type:"i32",length:Tt.length}];Ot(e,vn);let Sn=Be(i[0].dataType,1);if(Sn!=="f16"&&Sn!=="f32")throw new Error(`elemType ${Sn} is not supported.`);return`
        ${ni("uniforms.result_strides")}
        ${mn.registerUniforms(vn).declareVariables(...Jt,Wt)};
        ${_n}
        ${Ap(ot,h,e,fn.type.value,mt)}
        ${b?rn(pt,ct,Sn,void 0,!ot,bt):nn(pt,ct,Sn,void 0,!ot,bt,!1,void 0,et)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${e.cacheKey};${pt};${ct};${b}`,inputDependencies:dn},getRunData:()=>({outputs:[{dims:o,dataType:i[0].dataType}],dispatchGroup:{x:ft[0],y:ft[1],z:ft[2]},programUniforms:jt}),getShaderSource:yn}}}),Ep,ga,qu=j(()=>{ye(),Yt(),xe(),_e(),Ep=(i,e,o,a,d,g=!1,h,et,ot=!1)=>{let it=ot?1:2,$=ot?2:3,c=ot?3:1,s=g?2:1,_=`
  fn setOutputAtIndex(flatIndex : u32, value : ${g?`vec4<${h}>`:h}) {
    result[flatIndex] = ${g?`vec4<${h}>`:h}(value);
  }`;a&&(_+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${g?`vec4<${h}>`:h} {
      return bias[coords.${ot?"w":"y"}${g?"/ 4":""}];
    }`);let b=g?4:1,st=U("W",e[1].dataType,e[1].dims.length,b),dt=U("Dy",e[0].dataType,e[0].dims.length,b),ct=[dt,st];a&&ct.push(U("bias",e[2].dataType,[o[c]].length,b));let pt=K("result",e[0].dataType,o.length,b),ft=`{
        let batch: u32 = ${d?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${d?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${d?"global_id.y":"workgroup_id.y"} * ${s};
        let d1: u32 = ${d?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${h}>, ${s}>;
        for (var i = 0; i < ${s}; i++) {
          dotProd[i] = vec4<${h}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${h}(dyCorner.x) + ${h}(wR)) / ${h}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${h}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${h}(dyCorner.y) + ${h}(wC)) / ${h}(uniforms.strides.y);
            let dyC2 = (${h}(dyCorner.y) + 1.0 + ${h}(wC)) / ${h}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${h}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${h}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${dt.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${h}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${dt.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${h}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${c}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${dt.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${h}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${st.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${dt.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${h}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${s}; i = i + 1) {
          let value = dotProd[i] + ${a?"bias[c+i]":`vec4<${h}>(0.0)`};
          ${pt.set("batch","r","c + i","d1","value")};
        }
      }`,mt=`
          let outputIndices = ${pt.offsetToIndices("global_idx")};
          let batch = ${pt.indicesGet("outputIndices",0)};
          let d1 = ${pt.indicesGet("outputIndices",c)};
          let r = ${pt.indicesGet("outputIndices",it)};
          let c = ${pt.indicesGet("outputIndices",$)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${h}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${h}(dyRCorner) + ${h}(wR)) / ${h}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${h}(uniforms.Dy_shape[${it}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${h}(dyCCorner) + ${h}(wC)) / ${h}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${h}(uniforms.Dy_shape[${$}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${ot?dt.get("batch","idyR","idyC","inputChannel"):dt.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${st.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${a?"bias[d1]":`${h}(0.0)`};
          ${pt.setByOffset("global_idx","value")};
        `;return`
  ${i.registerUniforms(et).declareVariables(...ct,pt)}
  ${_}

    ${i.mainStart()}
    ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${g?ft:mt}}`},ga=(i,e,o)=>{let a=i.length>2,d=e.outputShape,g=M.size(d),h=[Math.ceil(g/64),1,1];Ne("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${h}`);let et=e.format==="NHWC",ot=["rank","rank"],it=[e.strides[0],e.strides[1]],$=[e.kernelShape[et?1:2],e.kernelShape[et?2:3]],c=[e.dilations[0],e.dilations[1]],s=[$[0]+(e.dilations[0]<=1?0:(e.kernelShape[et?1:2]-1)*(e.dilations[0]-1)),$[1]+(e.dilations[1]<=1?0:(e.kernelShape[et?2:3]-1)*(e.dilations[1]-1))],_=[s[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),s[1]-1-Math.floor(e.pads[1]+e.pads[3])/2],b=!1,st=e.group,dt=i[1].dims,ct=dt[0]/st,pt=dt[1],ft=[{type:12,data:g},{type:12,data:it},{type:12,data:$},{type:12,data:c},{type:12,data:s},{type:6,data:_},{type:12,data:ct},{type:12,data:pt},...X(i[0].dims,i[1].dims)];a&&(ft.push(...X(i[2].dims)),ot.push("rank")),ft.push(...X(d));let mt=h[1]===1&&h[2]===1,bt=$t=>{let Ct=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:it.length},{name:"filter_dims",type:"u32",length:$.length},{name:"dilations",type:"u32",length:$.length},{name:"effective_filter_dims",type:"u32",length:s.length},{name:"pads",type:"i32",length:_.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],It=Be(i[0].dataType);return`${Ep($t,i,d,a,mt,b,It,Ct,et)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${e.cacheKey};`,inputDependencies:ot},getRunData:()=>({dispatchGroup:{x:h[0],y:h[1],z:h[2]},outputs:[{dims:o?o(d):d,dataType:i[0].dataType}],programUniforms:ft}),getShaderSource:bt}}}),kp,Op,Pp,ju,Ku,Rp,zp,Bp,Dp,Yu,Xu=j(()=>{Fu(),qu(),Zt(),Rr(),kp=(i,e,o,a,d,g)=>(i-1)*e+o+(a-1)*d+1-g,Op=(i,e,o,a,d)=>{let g=Math.floor(i/2);e==="SAME_UPPER"?(o[a]=g,o[d]=i-g):e==="SAME_LOWER"&&(o[a]=i-g,o[d]=g)},Pp=(i,e,o,a,d,g,h,et,ot,it)=>{let $=i.length-2,c=it.length===0;if(ot.length===0)for(let b=0;b<$;++b)ot.push(0);let s=i[0],_=e[et?3:1]*d;for(let b=0,st=i.length-$-(et?1:0);b<$;++b,++st){let dt=i[st],ct=c?dt*h[b]:it[b],pt=kp(dt,h[b],g[b],e[st],o[b],ct);Op(pt,a,g,b,b+$),c&&it.push(h[b]*(dt-1)+ot[b]+(e[st]-1)*o[b]+1-g[b]-g[b+$])}it.splice(0,0,s),it.splice(et?3:1,0,_)},ju=(i,e)=>{let o=i.kernelShape.slice();if(i.kernelShape.length===0||i.kernelShape.reduce((c,s)=>c*s,1)===0){o.length=0;for(let c=2;c<e[1].dims.length;++c)o.push(e[1].dims[c])}let a=i.format==="NHWC";o.splice(0,0,e[1].dims[0]),o.splice(a?3:1,0,e[1].dims[1]);let d=i.pads.slice(),g=i.outputShape.slice(),h=i.outputPadding.slice(),et=e[0].dims,ot=i.dilations.slice();if(ot.reduce((c,s)=>c+s,0)===0){let c=e[0].dims.length-2;ot=new Array(c).fill(1)}let it=i.strides.slice();if(it.reduce((c,s)=>c+s,0)===0){let c=e[0].dims.length-2;it=new Array(c).fill(1)}Pp(et,o,ot,i.autoPad,i.group,d,it,a,h,g);let $=Object.assign({},i);return Object.assign($,{kernelShape:o,pads:d,outputPadding:h,outputShape:g,dilations:ot,strides:it}),$},Ku=i=>{let e=ei(i),o=i.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof i.autoPad>"u"?0:i.autoPad],d=i.dilations,g=i.group,h=i.kernelShape,et=i.pads,ot=i.strides,it=i.wIsConst(),$=i.outputPadding,c=i.outputShape;return{autoPad:a,format:o,dilations:d,group:g,kernelShape:h,outputPadding:$,outputShape:c,pads:et,strides:ot,wIsConst:it,...e,cacheKey:`${i.format};${e.activation};`}},Rp=(i,e)=>{if(!i||i.length!==2&&i.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(i[0].dims.length!==4&&i[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(i[0].dims.length!==i[1].dims.length)throw new Error("filter does not have same dimension as input");let o=i[0].dims[e.format==="NHWC"?i[0].dims.length-1:1],a=i[1].dims[0];if(o!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let d=i[1].dims[1]*e.group;if(i.length===3&&(i[2].dims.length!==1||i[2].dims[0]!==d))throw new Error("invalid bias");let g=i[0].dims.length-2;if(e.dilations.reduce((h,et)=>h+et,0)>0&&e.dilations.length!==g)throw new Error(`dilations should be ${g}D`);if(e.strides.reduce((h,et)=>h+et,0)>0&&e.strides.length!==g)throw new Error(`strides should be ${g}D`);if(e.pads.reduce((h,et)=>h+et,0)>0&&e.pads.length!==g*2)throw new Error(`pads should be ${g*2}D`);if(e.outputPadding.length!==g&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${g}D`);if(e.kernelShape.reduce((h,et)=>h+et,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==i[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==i[0].dims.length-2)throw new Error("invalid output shape")},zp=[2,3,1,0],Bp=(i,e,o)=>{let a=ju(o,e),d=o.format==="NHWC",g=a.outputShape,h=g[d?3:1],et=e[0].dims[d?3:1];if(a.group!==1||h===1&&et===1){i.compute(ga(e,a));return}let ot=g[d?1:2],it=g[d?2:3],$=e[1].dims[2],c=e[1].dims[3],s=d?ot*it:h,_=d?h:ot*it,b=$*c*et,st=!0,dt=i.kernelCustomData.wT??i.compute(xt(e[1],zp),{inputs:[1],outputs:[o.wIsConst?-2:-1]})[0];o.wIsConst&&!i.kernelCustomData.wT&&(i.kernelCustomData.wT=dt);let ct=[e[0],dt],pt=e.length===3;pt&&(!d&&e[2].dims.length===1?ct.push(e[2].reshape([e[2].dims[0],1,1])):ct.push(e[2])),i.compute(Lu(ct,a,g,s,_,b,pt,st),{inputs:ct})},Dp=(i,e)=>{let o=e.format==="NHWC",a=[i.inputs[0].reshape(o?[i.inputs[0].dims[0],1,i.inputs[0].dims[1],i.inputs[0].dims[2]]:[i.inputs[0].dims[0],i.inputs[0].dims[1],1,i.inputs[0].dims[2]]),i.inputs[1].reshape([i.inputs[1].dims[0],i.inputs[1].dims[1],1,i.inputs[1].dims[2]])];i.inputs.length===3&&a.push(i.inputs[2]);let d=e.kernelShape;(d.length===0||d[0]===0)&&(d=[i.inputs[1].dims[2]]);let g=e.dilations;(g.length===0||g[0]===0)&&(g=[1]);let h=e.strides;(h.length===0||h[0]===0)&&(h=[1]);let et=e.pads;et.length===0&&(et=[0,0]),et=[0,et[0],0,et[1]],h=[1].concat(h),g=[1].concat(g),d=[1].concat(d);let ot=ju({...e,pads:et,strides:h,dilations:g,kernelShape:d},a);i.compute(ga(a,ot,it=>o?[it[0],it[2],it[3]]:[it[0],it[1],it[3]]))},Yu=(i,e)=>{Rp(i.inputs,e),i.inputs[0].dims.length===3?Dp(i,e):Bp(i,i.inputs,e)}}),Mp,Zu,Qu,Ju=j(()=>{ye(),xe(),Ze(),_e(),Mp=(i,e,o,a)=>{let d=M.size(e),g=e.length,h=U("input",i,g),et=K("output",i,g),ot=o.dataType===6?o.getInt32Array()[0]:Number(o.getBigInt64Array()[0]),it=M.normalizeAxis(ot,g),$=c=>{let s=` i32(${h.indicesGet("inputIndices","uniforms.axis")}) `,_=fe("uniforms.input_shape","uniforms.axis",g),b=a.reverse?s+(a.exclusive?" + 1":""):"0",st=a.reverse?_:s+(a.exclusive?"":" + 1");return`
                ${c.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(h,et)}
                ${c.mainStart()}
                  ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${et.offsetToIndices("global_idx")};
                  var sum = ${et.type.value}(0);
                  let first : i32 = ${b};
                  let last : i32 = ${st};
                  for (var i : i32 = first; i < last; i++) {
                    ${h.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${h.getByIndices("inputIndices")};
                  }
                  ${et.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:a.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:i}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},{type:12,data:it},...X(e,e)]}),getShaderSource:$}},Zu=(i,e)=>{let o=i.inputs[0].dims,a=i.inputs[0].dataType,d=i.inputs[1];i.compute(Mp(a,o,d,e),{inputs:[0]})},Qu=i=>{let e=i.exclusive===1,o=i.reverse===1;return we({exclusive:e,reverse:o})}}),Up,Wp,Np,el,tl,rl=j(()=>{ye(),xe(),Ze(),_e(),Up=i=>{if(!i||i.length!==1)throw new Error("DepthToSpace requires 1 input.");if(i[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},Wp=(i,e,o,a)=>{let d=[];d.push(`fn perm(i: ${a.type.indices}) -> ${o.type.indices} {
    var a: ${o.type.indices};`);for(let g=0;g<e;++g)d.push(o.indicesSet("a",i[g],`i[${g}]`));return d.push("return a;}"),d.join(`
`)},Np=(i,e)=>{let o,a,d,g,h,et,ot=e.format==="NHWC",it=e.blocksize,$=e.mode==="DCR";ot?([o,a,d,g]=i.dims,h=$?[o,a,d,it,it,g/it**2]:[o,a,d,g/it**2,it,it],et=$?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([o,a,d,g]=[i.dims[0],i.dims[2],i.dims[3],i.dims[1]],h=$?[o,it,it,g/it**2,a,d]:[o,g/it**2,it,it,a,d],et=$?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let c=i.reshape(h),s=c.dims.length,_=i.dataType,b=U("a",_,s),st=K("output",_,s),dt=ct=>`
  ${ct.registerUniform("output_size","u32").declareVariables(b,st)}

  ${Wp(et,s,b,st)}

  ${ct.mainStart()}
    ${ct.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${st.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${st.setByOffset("global_idx",b.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${i.dims};${e.blocksize};${e.mode}`,inputDependencies:["rank"]},getRunData:ct=>{let pt=ot?[o,a*it,d*it,g/it**2]:[o,g/it**2,a*it,d*it],ft=M.size(pt),mt=c.dims,bt=M.sortBasedOnPerm(mt,et);return{outputs:[{dims:pt,dataType:ct[0].dataType}],dispatchGroup:{x:Math.ceil(ft/64)},programUniforms:[{type:12,data:ft},...X(mt,bt)]}},getShaderSource:dt}},el=(i,e)=>{Up(i.inputs),i.compute(Np(i.inputs[0],e))},tl=i=>we({blocksize:i.blocksize,mode:i.mode,format:i.format})}),ya,oi,nl,Vp,Hp,ba,va,il,Gp,al,ol,sl=j(()=>{ye(),xe(),Ze(),_e(),ya="[a-zA-Z]|\\.\\.\\.",oi="("+ya+")+",nl="^"+oi+"$",Vp="("+oi+",)*"+oi,Hp="^"+Vp+"$",ba=class{constructor(i=-1){this.symbolToIndices=new Map,this.inputIndex=i}addSymbol(i,e){let o=this.symbolToIndices.get(i);o===void 0?o=[e]:o.push(e),this.symbolToIndices.set(i,o)}},va=class{constructor(i,e){var d;this.equation=e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,a]=e.includes("->")?e.split("->",2):[e,""];if(!o.match(RegExp(Hp)))throw new Error("Invalid LHS term");if(o.split(",").forEach((g,h)=>{let et=i[h].dims.slice();if(!g.match(RegExp(nl)))throw new Error("Invalid LHS term");let ot=this.processTerm(g,!0,et,h);this.lhs.push(ot)}),a==="")a+=[...this.symbolToInfo.entries()].filter(([g,h])=>h.count===1||g==="...").map(([g])=>g).join("");else if(!a.match(RegExp(oi)))throw new Error("Invalid RHS");(d=a.match(RegExp(ya,"g")))==null||d.forEach(g=>{if(g==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let h=this.symbolToInfo.get(g);if(h===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(h.dimValue)}}),this.rhs=this.processTerm(a,!1,this.outputDims)}addSymbol(i,e,o){let a=this.symbolToInfo.get(i);if(a!==void 0){if(a.dimValue!==e&&a.count!==1)throw new Error("Dimension mismatch");a.count++,a.inputIndices.push(o)}else a={count:1,dimValue:e,inputIndices:[o]};this.symbolToInfo.set(i,a)}processTerm(i,e,o,a=-1){let d=o.length,g=!1,h=[],et=0;if(!i.match(RegExp(nl))&&!e&&i!=="")throw new Error("Invalid LHS term");let ot=i.match(RegExp(ya,"g")),it=new ba(a);return ot==null||ot.forEach(($,c)=>{if($==="..."){if(g)throw new Error("Only one ellipsis is allowed per input term");g=!0;let s=d-ot.length+1;if(s<0)throw new Error("Ellipsis out of bounds");if(h=o.slice(et,et+s),this.hasEllipsis){if(this.ellipsisDims.length!==h.length||this.ellipsisDims.toString()!==h.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=h;else throw new Error("Ellipsis must be specified in the LHS");for(let _=0;_<h.length;_++){let b=String.fromCharCode(48+_);it.addSymbol(b,c+_),this.addSymbol(b,o[et++],a)}}else it.addSymbol($,c+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol($,o[et++],a)}),it}},il=i=>i+"_max",Gp=(i,e,o,a)=>{let d=i.map(it=>it.length).map((it,$)=>U(`input${$}`,e,it)),g=M.size(a),h=K("output",e,a.length),et=[...o.symbolToInfo.keys()].filter(it=>!o.rhs.symbolToIndices.has(it)),ot=it=>{let $=[],c="var prod = 1.0;",s="var sum = 0.0;",_="sum += prod;",b=[],st=[],dt=[],ct=[],pt=o.symbolToInfo.size===o.rhs.symbolToIndices.size;o.symbolToInfo.forEach((mt,bt)=>{var $t;if(o.rhs.symbolToIndices.has(bt)){let Ct=($t=o.rhs.symbolToIndices.get(bt))==null?void 0:$t[0];Ct!==void 0&&o.lhs.forEach((It,Tt)=>{if(mt.inputIndices.includes(Tt)){let jt=It.symbolToIndices.get(bt);if(jt===void 0)throw new Error("Invalid symbol error");jt.forEach(dn=>{$.push(`${d[Tt].indicesSet(`input${Tt}Indices`,dn,h.indicesGet("outputIndices",Ct))}`)})}})}else o.lhs.forEach((Ct,It)=>{if(mt.inputIndices.includes(It)){let Tt=Ct.symbolToIndices.get(bt);if(Tt===void 0)throw new Error("Invalid symbol error");Tt.forEach(jt=>{b.push(`${d[It].indicesSet(`input${It}Indices`,jt,`${bt}`)}`)}),ct.push(`prod *= ${d[It].getByIndices(`input${It}Indices`)};`)}}),st.push(`for(var ${bt}: u32 = 0; ${bt} < uniforms.${il(bt)}; ${bt}++) {`),dt.push("}")});let ft=pt?[...$,`let sum = ${d.map((mt,bt)=>mt.getByIndices(`input${bt}Indices`)).join(" * ")};`]:[...$,s,...st,...b,c,...ct,_,...dt];return`
            ${it.registerUniforms(et.map(mt=>({name:`${il(mt)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...d,h)}

            ${it.mainStart()}
            ${it.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${h.offsetToIndices("global_idx")};
            ${d.map((mt,bt)=>`var input${bt}Indices: ${d[bt].type.indices};`).join(`
`)}
            ${ft.join(`
`)};
            ${h.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:o.equation,inputDependencies:i.map(()=>"rank")},getRunData:()=>{let it=et.filter(c=>o.symbolToInfo.has(c)).map(c=>{var s;return{type:12,data:((s=o.symbolToInfo.get(c))==null?void 0:s.dimValue)||0}});it.push({type:12,data:g});let $=i.map((c,s)=>[...X(c)]).reduce((c,s)=>c.concat(s),it);return $.push(...X(a)),{outputs:[{dims:a,dataType:e}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:$}},getShaderSource:ot}},al=(i,e)=>{let o=new va(i.inputs,e.equation),a=o.outputDims,d=i.inputs.map((g,h)=>g.dims);i.compute(Gp(d,i.inputs[0].dataType,o,a))},ol=i=>{let e=i.equation.replace(/\s+/g,"");return we({equation:e})}}),Lp,ul,Fp,qp,ll,dl=j(()=>{ye(),xe(),_e(),Lp=i=>{if(!i||i.length!==2)throw new Error("Expand requires 2 input.");let e=i[0].dims,o=Array.from(i[1].getBigInt64Array(),Number),a=o.length<e.length?0:o.length-e.length,d=e.length<o.length?0:e.length-o.length;for(;a<o.length&&d<e.length;++a,++d)if(o[a]!==e[d]&&o[a]!==1&&e[d]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ul=(i,e)=>{let o=i.length-e.length,a=[];for(let d=0;d<o;++d)a.push(i[d]);for(let d=0;d<e.length;++d)a.push(e[d]===1?i[d+o]:e[d]);return a},Fp=(i,e)=>i.length>e.length?ul(i,e):ul(e,i),qp=i=>{let e=i[0].dims,o=Array.from(i[1].getBigInt64Array(),Number),a=Fp(e,o),d=i[0].dataType,g=d===9?4:1,h=Math.ceil(M.size(a)/g),et=it=>{let $=U("input",d,e.length,g),c=K("output",d,a.length,g),s;if(d===9){let _=(b,st,dt="")=>`
          let outputIndices${st} = ${c.offsetToIndices(`outputOffset + ${st}u`)};
          let offset${st} = ${$.broadcastedIndicesToOffset(`outputIndices${st}`,c)};
          let index${st} = offset${st} / 4u;
          let component${st} = offset${st} % 4u;
          ${b}[${st}] = ${dt}(${$.getByOffset(`index${st}`)}[component${st}]);
        `;s=`
        let outputOffset = global_idx * ${g};
        var data = vec4<u32>(0);
        ${_("data",0,"u32")}
        ${_("data",1,"u32")}
        ${_("data",2,"u32")}
        ${_("data",3,"u32")}
        ${c.setByOffset("global_idx","data")}
      }`}else s=`
        let outputIndices = ${c.offsetToIndices("global_idx")};
        let inputOffset = ${$.broadcastedIndicesToOffset("outputIndices",c)};
        ${c.setByOffset("global_idx",$.getByOffset("inputOffset"))}
      }`;return`
    ${it.registerUniform("vec_size","u32").declareVariables($,c)}
    ${it.mainStart()}
    ${it.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${s}`},ot=[{type:12,data:h},...X(e,a)];return{name:"Expand",shaderCache:{hint:`${a.length}`,inputDependencies:["rank"]},getShaderSource:et,getRunData:()=>({outputs:[{dims:a,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:ot})}},ll=i=>{Lp(i.inputs),i.compute(qp(i.inputs),{inputs:[0]})}}),jp,cl,pl=j(()=>{ye(),xe(),_e(),Jn(),jp=i=>{let e=i[0].dataType,o=M.size(i[0].dims),a=M.size(i[1].dims),d=a%4===0,g=h=>{let et=U("x",e,[1],4),ot=U("bias",e,[1],4),it=K("y",e,[1],4),$=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],c=_=>`
      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;
      let bias${_} = ${ot.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,s=d?`
      let bias = ${ot.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${c(0)}${c(1)}${c(2)}${c(3)}
      let bias = ${et.type.value}(bias0, bias1, bias2, bias3);`;return`${h.registerUniforms($).declareVariables(et,ot,it)}

    ${oa(rt(e))}

    ${h.mainStart(mr)}
      ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${et.getByOffset("global_idx")};
      ${s}
      let x_in = x + bias;
      ${it.setByOffset("global_idx",sa("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${d}`,inputDependencies:["type","type"]},getShaderSource:g,getRunData:h=>({outputs:[{dims:h[0].dims,dataType:h[0].dataType}],programUniforms:[{type:12,data:Math.ceil(o/4)},{type:12,data:a}],dispatchGroup:{x:Math.ceil(o/mr/4)}})}},cl=i=>{i.inputs.length<2||M.size(i.inputs[1].dims)===0?wu(i):i.compute(jp(i.inputs))}}),Kp,Yp,ml,fl,hl=j(()=>{ye(),xe(),Ze(),_e(),Kp=i=>{if(!i||i.length!==2)throw new Error("Gather requires 2 inputs.")},Yp=(i,e)=>{let o=i[0].dims,a=i[1].dims,d=o.length,g=M.normalizeAxis(e.axis,d),h=o.slice(0);h.splice(g,1,...a);let et=o[g],ot=i[0].dataType===9?4:1,it=Math.ceil(M.size(h)/ot),$=[{type:12,data:it},{type:6,data:et},{type:12,data:g},...X(i[0].dims,i[1].dims,h)],c=s=>{let _=U("data",i[0].dataType,i[0].dims.length,ot),b=U("inputIndices",i[1].dataType,i[1].dims.length),st=K("output",i[0].dataType,h.length,ot),dt=pt=>{let ft=a.length,mt=`var indicesIndices${pt}  = ${b.type.indices}(0);`;for(let bt=0;bt<ft;bt++)mt+=`${ft>1?`indicesIndices${pt}[${bt}]`:`indicesIndices${pt}`} = ${h.length>1?`outputIndices${pt}[uniforms.axis + ${bt}]`:`outputIndices${pt}`};`;mt+=`
          var idx${pt} = ${b.getByIndices(`indicesIndices${pt}`)};
          if (idx${pt} < 0) {
            idx${pt} = idx${pt} + uniforms.axisDimLimit;
          }
          var dataIndices${pt} : ${_.type.indices};
        `;for(let bt=0,$t=0;bt<d;bt++)bt===g?(mt+=`${d>1?`dataIndices${pt}[${bt}]`:`dataIndices${pt}`} = u32(idx${pt});`,$t+=ft):(mt+=`${d>1?`dataIndices${pt}[${bt}]`:`dataIndices${pt}`} = ${h.length>1?`outputIndices${pt}[${$t}]`:`outputIndices${pt}`};`,$t++);return mt},ct;if(i[0].dataType===9){let pt=(ft,mt,bt="")=>`
          let outputIndices${mt} = ${st.offsetToIndices(`outputOffset + ${mt}u`)};
          ${dt(mt)};
          let offset${mt} = ${_.indicesToOffset(`dataIndices${mt}`)};
          let index${mt} = offset${mt} / 4u;
          let component${mt} = offset${mt} % 4u;
          ${ft}[${mt}] = ${bt}(${_.getByOffset(`index${mt}`)}[component${mt}]);
        `;ct=`
        let outputOffset = global_idx * ${ot};
        var value = vec4<u32>(0);
        ${pt("value",0,"u32")}
        ${pt("value",1,"u32")}
        ${pt("value",2,"u32")}
        ${pt("value",3,"u32")}
        ${st.setByOffset("global_idx","value")}
      `}else ct=`
      let outputIndices = ${st.offsetToIndices("global_idx")};
      ${dt("")};
      let value = ${_.getByIndices("dataIndices")};
      ${st.setByOffset("global_idx","value")};
      `;return`
      ${s.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(_,b,st)}
      ${s.mainStart()}
        ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${ct}
      }`};return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:h,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(it/64)},programUniforms:$}),getShaderSource:c}},ml=i=>we({axis:i.axis}),fl=(i,e)=>{let o=i.inputs;Kp(o),i.compute(Yp(i.inputs,e))}}),Xp,Zp,gl,yl,bl=j(()=>{ye(),xe(),Ze(),_e(),Xp=i=>{if(!i||i.length!==2)throw new Error("GatherElements requires 2 inputs.");if(i[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(i[0].dims.length!==i[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Zp=(i,e)=>{let o=i[0].dims,a=i[0].dataType,d=o.length,g=i[1].dims,h=i[1].dataType,et=M.normalizeAxis(e.axis,d),ot=o[et],it=g.slice(0),$=M.size(it),c=U("input",a,d),s=U("indicesInput",h,g.length),_=K("output",a,it.length),b=[{type:12,data:$},{type:6,data:ot},{type:12,data:et}];return b.push(...X(o,g,it)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:it,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:b}),getShaderSource:st=>`
      ${st.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(c,s,_)}
      ${st.mainStart()}
      ${st.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${_.offsetToIndices("global_idx")};

      var idx = ${s.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${c.type.indices}(outputIndices);
      ${c.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${c.getByIndices("inputIndices")};

      ${_.setByOffset("global_idx","value")};
  }`}},gl=i=>we({axis:i.axis}),yl=(i,e)=>{let o=i.inputs;Xp(o),i.compute(Zp(i.inputs,e))}}),Qp,Jp,vl,wl,$l=j(()=>{ye(),xe(),_e(),Qp=i=>{if(!i)throw new Error("Input is missing");if(i.length<2||i.length>3)throw new Error("Invaid input number.");if(i.length===3&&i[2].dims.length>2)throw new Error("Invalid input shape of C");if(i[0].dataType!==i[1].dataType||i.length===3&&i[0].dataType!==i[2].dataType)throw new Error("Input types are mismatched")},Jp=(i,e)=>{let o=i[0].dims.slice(),a=i[1].dims.slice(),[d,g,h]=Gn.getShapeOfGemmResult(o,e.transA,a,e.transB,i.length===3?i[2].dims:void 0),et=[d,g];if(!et)throw new Error("Can't use gemm on the given tensors");let ot=M.size(et),it=[{type:12,data:ot},{type:12,data:d},{type:12,data:g},{type:12,data:h},{type:1,data:e.alpha},{type:1,data:e.beta}],$=["type","type"];i.length===3&&(it.push(...X(i[2].dims)),$.push("rank")),it.push(...X(et));let c=s=>{let _="";e.transA&&e.transB?_="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":e.transA&&!e.transB?_="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!e.transA&&e.transB?_="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!e.transA&&!e.transB&&(_="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let b=e.alpha===1?"":"value *= uniforms.alpha;",st=U("a",i[0].dataType,i[0].dims),dt=U("b",i[1].dataType,i[1].dims),ct=st.type.value,pt=null,ft=[st,dt];i.length===3&&(pt=U("c",i[2].dataType,i[2].dims.length),ft.push(pt));let mt=K("output",i[0].dataType,et.length);ft.push(mt);let bt=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${s.registerUniforms(bt).declareVariables(...ft)}

  ${s.mainStart()}
    ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${ct}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${_}
    }

    ${b}
    ${pt!=null?`let cOffset = ${pt.broadcastedIndicesToOffset("vec2(m, n)",mt)}; value += ${ct}(uniforms.beta) * ${pt.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`};return{name:"Gemm",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:$},getRunData:()=>({outputs:[{dims:et,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(ot/64)},programUniforms:it}),getShaderSource:c}},vl=i=>{let e=i.transA,o=i.transB,a=i.alpha,d=i.beta;return{transA:e,transB:o,alpha:a,beta:d,cacheKey:`${i.transA};${i.transB};${i.alpha===1}`}},wl=(i,e)=>{Qp(i.inputs),i.compute(Jp(i.inputs,e))}}),em,tm,rm,_l,xl=j(()=>{ye(),xe(),_e(),em=(i,e)=>{let o=i[0].dims,a=o,d=2,g=M.sizeToDimension(o,d),h=M.sizeFromDimension(o,d),et=Ue(h),ot=h/et,it=[o[0],o[1],ot],$=["rank","type","type"],c=[{type:12,data:h},{type:12,data:ot}];c.push(...X(it,it));let s=_=>{let b=U("x",i[0].dataType,it.length,et),st=U("scale",i[1].dataType,i[1].dims),dt=U("bias",i[2].dataType,i[2].dims),ct=K("output",i[0].dataType,it.length,et),pt=[b,st,dt,ct],ft=b.type.value,mt=et===1?"f32":`vec${et}<f32>`,bt=64,$t=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${mt}, ${bt}>;
  const workgroupSize = ${bt}u;
  ${_.registerUniforms($t).declareVariables(...pt)}
  ${_.mainStart(bt)}
    let norm = global_idx / workgroupSize;
    let batch = norm / uniforms.x_shape[1];
    let channel = norm % uniforms.x_shape[1];
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${mt}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      initial = initial + ${mt}(${b.get("batch","channel","h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${At("workgroupShared[0]",et)} / f32(uniforms.normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${mt}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let deviation =  ${mt}(${b.get("batch","channel","h")}) - ${mt}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${At("workgroupShared[0]",et)};
    }
    workgroupBarrier();

    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${e.epsilon}));
    let channelScale = invStdDev * f32(${st.getByOffset("channel")});
    let channelShift = f32(${dt.getByOffset("channel")}) - meanShared * channelScale;
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let value = ${b.get("batch","channel","h")} * ${ft}(${mt}(channelScale)) + ${ft}(${mt}(channelShift));
      ${ct.set("batch","channel","h","value")};
    }
  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${e.epsilon};${et}`,inputDependencies:$},getRunData:()=>({outputs:[{dims:a,dataType:i[0].dataType}],dispatchGroup:{x:g},programUniforms:c}),getShaderSource:s}},tm=(i,e,o,a,d,g,h,et)=>{let ot=Ue(h),it=64,$=ot===1?"vec2f":`mat2x${ot}f`,c=ot===1?"f32":`vec${ot}f`,s=($t,Ct)=>`${$}(${$t}, ${Ct})`,_=d*h/ot,b=Math.ceil(g/it),st=["type"],dt=[{type:12,data:b},{type:12,data:g},{type:12,data:Math.floor(h/ot)},{type:12,data:Math.floor(g*h/ot)}],ct=$t=>{let Ct=U("input",e.dataType,e.dims,ot);return`
  ${$t.declareVariables(Ct)}
  @group(0) @binding(1) var<storage, read_write> output : array<${$}>;
  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};
  @group(0) @binding(2) var<uniform> uniforms: Uniforms;

  ${$t.mainStart(it)}
    let currentImageNumber = global_idx / ${it} / uniforms.C;
    let currentChannelNumber = (global_idx / ${it}) % uniforms.C;
    let wgOffset = local_id.x * uniforms.wg_size;
    if (wgOffset >= uniforms.H) {
        return;
    }
    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);

    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;
    var sum = ${Xt("f32",ot)};
    var squaredSum = ${Xt("f32",ot)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${c}(input[offset + i * uniforms.C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${s("sum","squaredSum")};
  }`},pt=i.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${ot}`,inputDependencies:st},getRunData:()=>({outputs:[{dims:[d,h,it,2],dataType:1}],dispatchGroup:{x:d*h/ot},programUniforms:dt}),getShaderSource:ct},{inputs:[e],outputs:[-1]})[0],ft=[{type:12,data:_},{type:12,data:g},{type:12,data:Math.floor(h/ot)},{type:12,data:Math.floor(it*h/ot)}],mt=["type","type","type"],bt=$t=>{let Ct=U("scale",o.dataType,o.dims,ot),It=U("bias",a.dataType,a.dims,ot);return`
  @group(0) @binding(0) var<storage, read> input : array<${$}>;
  @group(0) @binding(1) var<storage, read> scale : array<${Ct.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${It.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${$}>;
  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};
  @group(0) @binding(4) var<uniform> uniforms: Uniforms;

  ${$t.mainStart()}
    ${$t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}
    let currentImageNumber = global_idx / uniforms.C;
    let currentChannelNumber = global_idx % uniforms.C;

    let offset = currentImageNumber * uniforms.image_size;
    var sum = ${Xt("f32",ot)};
    var squaredSum = ${Xt("f32",ot)};
    for (var i: u32 = 0; i < min(${it}, uniforms.H); i++) {
        let value = input[offset + i + currentChannelNumber * ${it}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(uniforms.H);
    squaredSum = squaredSum / f32(uniforms.H);
    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${et}));
    let channelScale = invStdDev * ${c}(scale[currentChannelNumber]);
    let channelShift = ${c}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${s("channelScale","channelShift")};
  }`};return i.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${ot};${et}`,inputDependencies:mt},getRunData:()=>({outputs:[{dims:[d,h,2],dataType:1}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:ft}),getShaderSource:bt},{inputs:[pt,o,a],outputs:[-1]})[0]},rm=(i,e,o)=>{let a=e[0].dims,d=a,g=a[0],h=a[a.length-1],et=M.sizeFromDimension(a,1)/h,ot=Ue(h),it=M.size(d)/ot,$=[{type:12,data:et},{type:12,data:Math.floor(h/ot)}],c=["type","type"],s=tm(i,e[0],e[1],e[2],g,et,h,o.epsilon),_=b=>{let st=Be(e[0].dataType),dt=ot===1?"vec2f":`mat2x${ot}f`,ct=ot===1?st:`vec${ot}<${st}>`,pt=U("input",e[0].dataType,e[0].dims,ot),ft=K("output",e[0].dataType,d,ot);return`
  @group(0) @binding(0) var<storage, read> input : array<${pt.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${dt}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${ft.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${b.mainStart()}
    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);
    let currentChannelNumber = global_idx % uniforms.C;

    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${ct}(scale[0]), ${ct}(scale[1]));
  }`};i.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${ot}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(it/64)},programUniforms:$}),getShaderSource:_},{inputs:[e[0],s]})},_l=(i,e)=>{e.format==="NHWC"?rm(i,i.inputs,e):i.compute(em(i.inputs,e))}}),nm,im,Sl,Cl=j(()=>{ye(),xe(),_e(),nm=i=>{if(!i||i.length<2)throw new Error("layerNorm requires at least 2 inputs.")},im=(i,e,o)=>{let a=e.simplified,d=i[0].dims,g=i[1],h=!a&&i[2],et=d,ot=M.normalizeAxis(e.axis,d.length),it=M.sizeToDimension(d,ot),$=M.sizeFromDimension(d,ot),c=M.size(g.dims),s=h?M.size(h.dims):0;if(c!==$||h&&s!==$)throw new Error(`Size of X.shape()[axis:] == ${$}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${c} and bias size of ${s}`);let _=[];for(let bt=0;bt<d.length;++bt)bt<ot?_.push(d[bt]):_.push(1);let b=Ue($),st=["type","type"],dt=[{type:12,data:it},{type:1,data:$},{type:12,data:Math.floor($/b)},{type:1,data:e.epsilon}];h&&st.push("type");let ct=o>1,pt=o>2,ft=bt=>{let $t=Be(i[0].dataType),Ct=[U("x",i[0].dataType,i[0].dims,b),U("scale",g.dataType,g.dims,b)];h&&Ct.push(U("bias",h.dataType,h.dims,b)),Ct.push(K("output",i[0].dataType,et,b)),ct&&Ct.push(K("mean_data_output",1,_)),pt&&Ct.push(K("inv_std_output",1,_));let It=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${bt.registerUniforms(It).declareVariables(...Ct)}
  ${bt.mainStart()}
    ${bt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Xt("f32",b)};
    var mean_square_vector = ${Xt("f32",b)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${fr($t,b,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${At("mean_vector",b)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${At("mean_square_vector",b)} / uniforms.norm_size ${a?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${fr($t,b,"x[j + offset]")};
      let f32scale = ${fr($t,b,"scale[j]")};
      output[j + offset] = ${Ct[0].type.value}((f32input ${a?"":"- mean"}) * inv_std_dev * f32scale
        ${h?`+ ${fr($t,b,"bias[j]")}`:""}
      );
    }

    ${ct?"mean_data_output[global_idx] = mean":""};
    ${pt?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},mt=[{dims:et,dataType:i[0].dataType}];return ct&&mt.push({dims:_,dataType:1}),pt&&mt.push({dims:_,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${b};${o};${a}`,inputDependencies:st},getRunData:()=>({outputs:mt,dispatchGroup:{x:Math.ceil(it/64)},programUniforms:dt}),getShaderSource:ft}},Sl=(i,e)=>{nm(i.inputs),i.compute(im(i.inputs,e,i.outputCount))}}),am,om,Il,Tl,Al=j(()=>{ye(),xe(),Ze(),_e(),am=(i,e)=>{if(i.length<3||i.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let o=i[0],a=o.dims.length;if(o.dims[a-1]!==e.k)throw new Error("The last dim of input shape does not match the k value");let d=Math.floor((e.k+e.blockSize-1)/e.blockSize),g=e.blockSize/8*e.bits,h=i[1];if(!M.areEqual(h.dims,[e.n,d,g]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let et=i[2].dims;if(M.size(et)!==e.n*d)throw new Error("scales input size error.");if(i.length===4){let ot=i[3].dims,it=e.bits>4?e.n*d:e.n*Math.floor((d+1)/2);if(M.size(ot)!==it)throw new Error("zeroPoints input size error.")}},om=(i,e,o,a)=>{let d=i[0].dims,g=d.length,h=Math.floor((e.k+e.blockSize-1)/e.blockSize),et=d[g-2],ot=e.k,it=e.n,$=d.slice(0,g-2),c=M.size($),s=e.blockSize/8*e.bits/4,_=i[0].dataType,b=Ue(et),st=Ue(e.k),dt=Ue(s),ct=cr(_),pt=et*h*ct,ft=Math.floor(a/pt),mt=h<=o[0]&&ft>0,bt=!mt||ft>=4?Ue(it):ft>=2&&Ue(it)>=2?2:1,$t=$.concat([et,it]),Ct=M.size($t)/bt/b,It=mt?[]:[{type:12,data:Ct},{type:12,data:e.blockSize}],Tt=[c,et,ot/st],jt=M.convertShape(i[1].dims).slice();jt.splice(-1,1,s/dt),It.push(...X(Tt)),It.push(...X(jt)),It.push(...X(i[2].dims)),i.length===4&&It.push(...X(M.convertShape(i[3].dims)));let dn=[c,et,it/bt];It.push(...X(dn));let yn=mn=>{let fn=Tt.length,un=U("a",i[0].dataType,fn,st),Wt=U("b",12,jt.length,dt),Jt=U("scales",i[2].dataType,i[2].dims.length),_n=[un,Wt,Jt],vn=i.length===4?U("zero_points",12,i[3].dims.length):void 0;vn&&_n.push(vn);let Sn=dn.length,hn=K("output",i[0].dataType,Sn,bt),rr=[{name:"output_size",type:"u32"},{name:"block_size",type:"u32"}],vr=Be(i[0].dataType),Ir=(()=>{switch(st){case 1:return`array<${vr}, 8>`;case 2:return`mat4x2<${vr}>`;case 4:return`mat2x4<${vr}>`;default:throw new Error(`${st}-component is not supported.`)}})(),$r=`
        for (var word: u32 = 0; word < ${s}; word += ${dt}) {
          ${Wt.indicesSet("b_indices","2","word")};
          let b_data = ${Wt.getByIndices("b_indices")};
          for (var i: u32 = 0; i < ${dt}; i++) {
            let b_value: u32 = ${dt===1?"b_data":"b_data[word + i]"};
            let b_mask: u32 = 0x0F0F0F0Fu;
            let b_value_lower: vec4<u32> = unpack4xU8(b_value & b_mask);
            let b_value_upper: vec4<u32> = unpack4xU8((b_value >> 4) & b_mask);
            let b_quantized_values = ${Ir}(${Array.from({length:4},(Yr,r0)=>`${vr}(b_value_lower[${r0}]), ${vr}(b_value_upper[${r0}])`).join(", ")});
            let b_dequantized_values = ${st===1?`${Ir}(${Array.from({length:8},(Yr,r0)=>`(b_quantized_values[${r0}] - zero_point) * scale`).join(", ")});`:`(b_quantized_values - ${Ir}(${Array(8).fill("zero_point").join(",")})) * scale;`};
            // Number of B elements per 32-bit word is 32/bits = 32/4 = 8
            for (var m: u32 = 0; m < ${mt?et:b}u; m++) {
              ${un.indicesSet("a_indices",fn-2,mt?"m":`row * ${b} + m`)};
              ${un.indicesSet("a_indices",fn-1,"word_offset")};
              var input_offset = ${un.indicesToOffset("a_indices")};
              var a_data: ${Ir};
              for (var j: u32 = 0; j < ${8/st}; j++) {
                a_data[j] = ${un.getByOffset("input_offset")};
                input_offset++;
              }
              ${mt?"workgroup_shared[workgroup_shared_offset + m]":"output_values[m]"}${bt>1?"[c]":""} += ${Array.from({length:8/st},(Yr,r0)=>`${st===1?`a_data[${r0}] * b_dequantized_values[${r0}]`:`dot(a_data[${r0}], b_dequantized_values[${r0}])`}`).join(" + ")};
            }
            word_offset += ${8/st};
          }
        }`,Ur=vn?`
          zero_point_offset += 4;
          if (zero_point_offset == 32) {
            zero_point_offset = 0;
            zero_point_index++;
            zero_point_word = ${vn.getByOffset("zero_point_index")};
          }`:"";return mt?`
        var<workgroup> workgroup_shared: array<${hn.type.value}, ${et*h}>;
        ${mn.declareVariables(..._n,hn)}
        ${mn.mainStart([h,1,1])}
          var a_indices: ${un.type.indices};
          var block = local_id.x;
          var col = workgroup_id.y;
          var batch = workgroup_id.z;
          ${un.indicesSet("a_indices","0","batch")};
          // Two zero points are packed into one byte when uniforms.bits is 4.
          for (var c: u32 = 0; c < ${bt}; c++) {
            let col_times_components_plus_c = col * ${bt} + c;
              ${vn?`
            var zero_point_bytes_per_col: u32 = (${h} + 1) / 2;
            var zero_point_byte_count: u32 = col_times_components_plus_c * zero_point_bytes_per_col + (block >> 0x1u);
            var zero_point_word_index: u32 = zero_point_byte_count >> 0x2u;
            var zero_point_byte_offset: u32 = zero_point_byte_count & 0x3u;
            var zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32 = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            var zero_point_word: u32 = ${vn.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;`:""}
            var b_indices: ${Wt.type.indices};
            ${Wt.indicesSet("b_indices","0","col_times_components_plus_c")};
            // The scale and zero points are computed per block.
            var scales_index = col_times_components_plus_c * ${h} + block;
            let scale = ${Jt.getByOffset("scales_index")};
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${vr}(${vn?"(zero_point_word) & 0xFu":8});
            ${Wt.indicesSet("b_indices","1","block")};
            var word_offset: u32 = block * ${e.blockSize/st};
            var workgroup_shared_offset: u32 = block * ${et};
            ${$r}
          }
          workgroupBarrier();
          var output_indices: ${hn.type.indices};
          var elements_per_thread: u32 = ${Math.ceil(et/h)};
          ${hn.indicesSet("output_indices","0","batch")};
          ${hn.indicesSet("output_indices",Sn-1,"col")};
          ${hn.indicesSet("output_indices",Sn-2,"local_id.x * elements_per_thread")};
          var output_offset = ${hn.indicesToOffset("output_indices")};
          for (var m: u32 = 0u; m < elements_per_thread; m++) {
            var row = m + local_id.x * elements_per_thread;
            if (row < ${et}) {
              var output_value: ${hn.type.value} = ${hn.type.value}(0);
              var workgroup_shared_offset: u32 = row;
              for (var b: u32 = 0u; b < ${h}u; b++) {
                output_value += workgroup_shared[workgroup_shared_offset];
                workgroup_shared_offset += ${et};
              }
              ${hn.setByOffset("output_offset","output_value")};
              output_offset += ${it/bt};
            }
          }
        }`:`
        ${mn.registerUniforms(rr).declareVariables(..._n,hn)}
        ${mn.mainStart()}
          ${mn.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var output_values: array<${hn.type.value}, ${b}>;
          var output_indices = ${hn.offsetToIndices("global_idx")};
          var col = ${hn.indicesGet("output_indices",Sn-1)};
          var row = ${hn.indicesGet("output_indices",Sn-2)};
          var a_indices: ${un.type.indices} = output_indices;
          // Two zero points are packed into one byte because uniforms.bits <= 4.
          // zero_point_offset is either 0 or 4. It is bit offset within one byte.
          // TODO support zero_point_offset for bits > 4
          ${vn?`
          var zero_point_abs_offset = col * ${bt} * ((${h} + 1) / 2);
          var zero_point_index: u32 = zero_point_abs_offset / 4;
          var zero_point_word: u32 = ${vn.getByOffset("zero_point_index")};
          var zero_point_offset: u32 = (zero_point_abs_offset % 4) * 8;`:""}
          var scale_index = col * ${h*bt};
          var b_indices: ${Wt.type.indices};
          for (var c: u32 = 0; c < ${bt}; c++) {
            ${Wt.indicesSet("b_indices","0",`col * ${bt} + c`)};
            var block_offset: u32 = 0;
            for (var block: u32 = 0; block < ${h}; block++) {
              // The scale and zero points are computed per block.
              let scale = ${Jt.getByOffset("scale_index")};
              // The default zero point is 8 for unsigned 4-bit quantization.
              let zero_point = ${vr}(${vn?"extractBits(zero_point_word, zero_point_offset, 4)":8});
              ${Wt.indicesSet("b_indices","1","block")};
              var word_offset: u32 = block_offset;
              ${$r}
              scale_index++;
              ${Ur}
              block_offset += uniforms.block_size / ${st};
            }
            // Drop the trailing 4 bits if the zero_poit_offset is not a byte boundary to align with the next byte.
            ${vn?`if (zero_point_offset % 8 > 0) {
                ${Ur}
              }`:""}
            }
            for (var k: u32 = 0u; k < ${b}u; k++) {
              ${hn.indicesSet("output_indices",Sn-2,`${b} * row + k`)};
              ${hn.setByIndices("output_indices","output_values[k]")}
            }
        }`};return{name:mt?"BlockwiseMatMulNBits":"MatMulNBits",shaderCache:{hint:`${e.cacheKey};${et};${_};${i.length}`,inputDependencies:Array(i.length).fill("rank")},getRunData:()=>({outputs:[{dims:$t,dataType:_}],name:mt?"BlockwiseMatMulNBits":"MatMulNBits",dispatchGroup:mt?{x:1,y:Math.ceil(it/bt),z:c}:{x:Math.ceil(Ct/64)},programUniforms:It}),getShaderSource:yn}},Il=(i,e)=>{am(i.inputs,e);let o=i.getMaxComputeWorkgroupSizes(),a=i.getMaxComputeWorkgroupStoragesize();i.compute(om(i.inputs,e,o,a))},Tl=i=>we(i)}),lt,sm,kl,El,um,wa,Ol,Pl=j(()=>{ye(),xe(),Ze(),Hn(),aa(),_e(),Rr(),lt=(i,e)=>i.length>e&&i[e].dims.length>0&&M.size(i[e].dims)>0?i[e]:void 0,sm=(i,e)=>{let o=i[0],a=lt(i,1),d=lt(i,2),g=lt(i,3),h=lt(i,4),et=lt(i,5),ot=lt(i,6),it=lt(i,7);if(o.dims.length!==3&&o.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let $=!1,c=o.dims[0],s=o.dims[1],_=o.dims.length===3?$?o.dims[2]/3:o.dims[2]:e.numHeads*o.dims[4],b=s,st=0,dt=0,ct=Math.floor(_/e.numHeads);if(ot&&it){if(ot.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(ot.dims[0]!==c||ot.dims[1]!==e.numHeads||ot.dims[3]!==ct)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(it.dims[0]!==c||it.dims[1]!==e.numHeads||it.dims[3]!==ct)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(ot.dims[2]!==it.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(it.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');st=ot.dims[2],dt=ot.dims[2]}else if(ot||it)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let pt;if(a){if(o.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(a.dims.length<3||a.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(o.dims[0]!==a.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(a.dims.length===3){if(a.dims[2]!==o.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');pt=2,b=a.dims[1]}else if(a.dims.length===5){if(a.dims[2]!==e.numHeads||a.dims[3]!==2||a.dims[4]!==ct)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(d)throw new Error('Expect "value" be none when "key" has packed kv format.');pt=5,b=a.dims[1]}else{if(a.dims[1]!==e.numHeads||a.dims[3]!==ct)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');pt=0,b=a.dims[2]}}else{if(o.dims.length!==3&&o.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(o.dims.length===5&&(o.dims[2]!==e.numHeads||o.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');pt=3}if(g){if(g.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(d&&o.dims.length===5&&o.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let ft=0;if(h){ft=8;let It=h.dims;throw It.length===1?It[0]===c?ft=1:It[0]===3*c+2&&(ft=3):It.length===2&&It[0]===c&&It[1]===b&&(ft=5),ft===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)'):new Error("Mask not supported")}let mt=!1,bt=_;if(d){if(d.dims.length!==3&&d.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(o.dims[0]!==d.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(d.dims.length===3){if(b!==d.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');bt=d.dims[2]}else{if(b!==d.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');bt=d.dims[1]*d.dims[3],mt=!0}}let $t=st+b,Ct=!1;if(h)throw new Error("Key padding mask is not supported");if(et){if(et.dims.length!==4)throw new Error('Input "relative_position_bias" is expected to have 4 dimensions');if(et.dims[0]!==c&&et.dims[0]!==1||et.dims[1]!==e.numHeads||et.dims[2]!==s||et.dims[3]!==$t)throw new Error('Input "relative_position_bias" shape (batch_size, 1, sequence_length, kv_sequence_length)')}return{batchSize:c,sequenceLength:s,pastSequenceLength:st,kvSequenceLength:b,totalSequenceLength:$t,maxSequenceLength:dt,inputHiddenSize:0,hiddenSize:_,vHiddenSize:bt,headSize:ct,vHeadSize:Math.floor(bt/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:ft,scale:e.scale,broadcastResPosBias:Ct,passPastInKv:mt,qkvFormat:pt}},kl=i=>we({...i}),El=we({perm:[0,2,1,3]}),um=(i,e,o,a,d,g,h)=>{let et=[a,d,g],ot=M.size(et),it=[{type:12,data:ot},{type:12,data:h},{type:12,data:g}],$=c=>{let s=K("qkv_with_bias",e.dataType,et),_=U("qkv",e.dataType,et),b=U("bias",o.dataType,et),st=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${c.registerUniforms(st).declareVariables(_,b,s)}
  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return i.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:et,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(ot/64)},programUniforms:it}),getShaderSource:$},{inputs:[e,o],outputs:[-1]})[0]},wa=(i,e,o,a,d,g,h,et)=>{let ot=g;if(h){if(a===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return ot=um(i,g,h,e,a,o*d,et),ot=ot.reshape([e,a,o,d]),i.compute(xt(ot,El.perm),{inputs:[ot],outputs:[-1]})[0]}else return g.dims.length===3&&(ot=g.reshape([e,a,o,d])),i.compute(xt(ot,El.perm),{inputs:[ot],outputs:[-1]})[0]},Ol=(i,e)=>{let o=sm(i.inputs,e),a=i.inputs[0],d=lt(i.inputs,1),g=lt(i.inputs,2),h=lt(i.inputs,3),et=lt(i.inputs,4),ot=lt(i.inputs,5),it=lt(i.inputs,6),$=lt(i.inputs,7);if(a.dims.length===5)throw new Error("Packed QKV is not implemented");if((d==null?void 0:d.dims.length)===5)throw new Error("Packed KV is not implemented");let c=d&&g&&d.dims.length===4&&g.dims.length===4,s=wa(i,o.batchSize,o.numHeads,o.sequenceLength,o.headSize,a,h,0);if(c)return Xn(i,s,d,g,et,void 0,it,$,ot,o,e);if(!d||!g)throw new Error("key and value must be provided");let _=wa(i,o.batchSize,o.numHeads,o.kvSequenceLength,o.headSize,d,h,o.hiddenSize),b=wa(i,o.batchSize,o.numHeads,o.kvSequenceLength,o.vHeadSize,g,h,2*o.hiddenSize);Xn(i,s,_,b,et,void 0,it,$,ot,o,e)}}),lm,dm,cm,pm,mm,fm,hm,gm,Rl,zl=j(()=>{ye(),xe(),_e(),lm=i=>{if(!i||i.length<1)throw new Error("Too few inputs");if(i[0].dataType!==1&&i[0].dataType!==10)throw new Error("Input type must be float or float16.");if(i.length>=2){let e=i[0].dims.length*2===i[1].dims[0];if(i.length===4&&(e=i[3].dims[0]*2===i[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},dm=(i,e,o)=>{let a="";for(let d=e-1;d>=0;--d)a+=`
            k = i32(${i.indicesGet("indices",d)}) - ${fe("uniforms.pads",d,o)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${fe("uniforms.x_shape",d,e)})) {
              break;
            }
            offset += k * i32(${fe("uniforms.x_strides",d,e)});
        `;return`
          value = ${i.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${a}
            value = x[offset];
          }
      `},cm=(i,e,o)=>{let a="";for(let d=e-1;d>=0;--d)a+=`
                k = i32(${i.indicesGet("indices",d)}) - ${fe("uniforms.pads",d,o)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${fe("uniforms.x_shape",d,e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${fe("uniforms.x_shape",d,e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${fe("uniforms.x_strides",d,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${a}
              value = x[offset];
          `},pm=(i,e,o)=>{let a="";for(let d=e-1;d>=0;--d)a+=`
                k = i32(${i.indicesGet("indices",d)}) - ${fe("uniforms.pads",d,o)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${fe("uniforms.x_shape",d,e)})) {
                  k = i32(${fe("uniforms.x_shape",d,e)}) - 1;
                }
                offset += k * i32(${fe("uniforms.x_strides",d,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${a}
              value = x[offset];
          `},mm=(i,e,o)=>{let a="";for(let d=e-1;d>=0;--d)a+=`
                k = i32(${i.indicesGet("indices",d)}) - ${fe("uniforms.pads",d,o)};
                if (k < 0)  {
                  k += i32(${fe("uniforms.x_shape",d,e)}]);
                }
                if (k >= i32(${fe("uniforms.x_shape",d,e)})) {
                  k -= i32(${fe("uniforms.x_shape",d,e)});
                }
                offset += k * i32(${fe("uniforms.x_strides",d,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${a}
              value = x[offset];
          `},fm=(i,e,o)=>{switch(o.mode){case 0:return dm(i,e,o.pads.length);case 1:return cm(i,e,o.pads.length);case 2:return pm(i,e,o.pads.length);case 3:return mm(i,e,o.pads.length);default:throw new Error("Invalid mode")}},hm=(i,e)=>{let o=M.padShape(i[0].dims.slice(),e.pads),a=i[0].dims,d=M.size(o),g=[{type:12,data:d},{type:6,data:e.pads}];e.mode===0&&g.push({type:i[0].dataType,data:e.value}),g.push(...X(i[0].dims,o));let h=["rank"],et=ot=>{let it=K("output",i[0].dataType,o.length),$=U("x",i[0].dataType,a.length),c=$.type.value,s=fm(it,a.length,e),_=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:e.pads.length}];return e.mode===0&&_.push({name:"constant_value",type:c}),`
            ${ot.registerUniforms(_).declareVariables($,it)}
            ${ot.mainStart()}
            ${ot.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${it.offsetToIndices("global_idx")};

            var value = ${c}(0);
            ${s}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${e.mode}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:o,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(o)/64)},programUniforms:g}),getShaderSource:et}},gm=(i,e)=>{if(i.length>1){let o=i[1].getBigInt64Array(),a=i.length>=3&&i[2].data?i[2].getFloat32Array()[0]:0,d=i[0].dims.length,g=new Int32Array(2*d).fill(0);if(i.length>=4){let et=i[3].getBigInt64Array();for(let ot=0;ot<et.length;ot++)g[Number(et[ot])]=Number(o[ot]),g[Number(et[ot])+d]=Number(o[ot+et.length])}else o.forEach((et,ot)=>g[Number(ot)]=Number(et));let h=[];return g.forEach(et=>h.push(et)),{mode:e.mode,value:a,pads:h}}else return e},Rl=(i,e)=>{lm(i.inputs);let o=gm(i.inputs,e);i.compute(hm(i.inputs,o),{inputs:[0]})}}),si,Bl,Dl,Ml,Ul,ym,bm,Wl,Nl,Vl,Hl,Gl,Ll,Fl,ql,jl,Kl,Yl,Xl,Zl=j(()=>{_t(),ye(),xe(),_e(),si=i=>{if(ke.webgpu.validateInputContent&&(!i||i.length!==1))throw new Error("Pool ops requires 1 input.")},Bl=(i,e,o)=>{let a=e.format==="NHWC",d=i.dims.slice();a&&d.splice(1,0,d.pop());let g=Object.hasOwnProperty.call(e,"dilations"),h=e.kernelShape.slice(),et=e.strides.slice(),ot=g?e.dilations.slice():[],it=e.pads.slice();pr.adjustPoolAttributes(o,d,h,et,ot,it);let $=pr.computePoolOutputShape(o,d,et,ot,h,it,e.autoPad),c=Object.assign({},e);g?Object.assign(c,{kernelShape:h,strides:et,pads:it,dilations:ot,cacheKey:e.cacheKey}):Object.assign(c,{kernelShape:h,strides:et,pads:it,cacheKey:e.cacheKey});let s=$.slice();return s.push(s.splice(1,1)[0]),[c,a?s:$]},Dl=(i,e)=>{let o=e.format==="NHWC",a=M.size(i),d=M.size(e.kernelShape),g=[{type:12,data:a},{type:12,data:d}],h=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){let et=e.kernelShape[e.kernelShape.length-1],ot=e.strides[e.strides.length-1],it=e.pads[e.pads.length/2-1],$=e.pads[e.pads.length-1],c=!!(it+$);g.push({type:12,data:et},{type:12,data:ot},{type:12,data:it},{type:12,data:$}),h.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let s=!1;if(e.kernelShape.length===2){let _=e.kernelShape[e.kernelShape.length-2],b=e.strides[e.strides.length-2],st=e.pads[e.pads.length/2-2],dt=e.pads[e.pads.length-2];s=!!(st+dt),g.push({type:12,data:_},{type:12,data:b},{type:12,data:st},{type:12,data:dt}),h.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[g,h,!0,c,s]}else{if(o)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let et=M.computeStrides(e.kernelShape);g.push({type:12,data:et},{type:12,data:e.pads},{type:12,data:e.strides}),h.push({name:"kernelStrides",type:"u32",length:et.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});let ot=e.pads.reduce((it,$)=>it+$);return[g,h,!!ot,!1,!1]}},Ml=(i,e,o,a,d,g,h,et,ot,it,$,c)=>{let s=d.format==="NHWC",_=e.type.value,b=K("output",e.type.tensor,a);if(d.kernelShape.length<=2){let st="",dt="",ct="",pt=o-(s?2:1);if($?st=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${pt}] = indices[${pt}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${pt}] < 0 || xIndices[${pt}]
                      >= uniforms.x_shape[${pt}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${g}
                }`:st=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${pt}] = indices[${pt}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${g}
                }`,d.kernelShape.length===2){let ft=o-(s?3:2);c?dt=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${ft}] = indices[${ft}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${ft}] < 0 || xIndices[${ft}] >= uniforms.x_shape[${ft}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:dt=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${ft}] = indices[${ft}] * uniforms.sh - uniforms.phStart + j;
                `,ct=`
              }
            `}return`
            ${i.registerUniforms(ot).declareVariables(e,b)}

            ${i.mainStart()}
              ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${b.offsetToIndices("global_idx")};
              var xIndices = ${b.offsetToIndices("global_idx")};

              var value = ${_}(${et});
              var pad = 0;
              ${dt}
              ${st}
              ${ct}
              ${h}

              output[global_idx] = value;
            }`}else{if(s)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let st=d.kernelShape.length,dt=d.pads.length,ct="";return it?ct=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${g}
              }`:ct=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${g}
            `,`
            ${i.registerUniforms(ot).declareVariables(e,b)}

            ${i.mainStart()}
              ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${b.offsetToIndices("global_idx")};
              var xIndices = ${b.offsetToIndices("global_idx")};

              var offsets: array<u32, ${st}>;

              var value = ${_}(${et});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${st-1}u; j++) {
                  offsets[j] = offset / ${fe("uniforms.kernelStrides","j",st)};
                  offset -= offsets[j] * ${fe("uniforms.kernelStrides","j",st)};
                }
                offsets[${st-1}] = offset;

                isPad = false;
                for (var j = ${o-st}u; j < ${o}u; j++) {
                  xIndices[j] = indices[j] * ${fe("uniforms.strides",`j - ${o-st}u`,st)}
                    + offsets[j - ${o-st}u] - ${fe("uniforms.pads","j - 2u",dt)};
                  ${ct}
              }
              ${h}

              output[global_idx] = value;
            }`}},Ul=i=>`${i.format};${i.ceilMode};${i.autoPad};${i.kernelShape.length}`,ym=i=>`${Ul(i)};${i.countIncludePad}`,bm=i=>`${Ul(i)};${i.storageOrder};${i.dilations}`,Wl=i=>({format:i.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][i.auto_pad],ceilMode:i.ceil_mode,kernelShape:i.kernel_shape,strides:i.strides,pads:i.pads}),Nl=(i,e,o,a)=>{let[d,g]=Bl(e,a,o),h=U("x",e.dataType,e.dims.length),et=h.type.value,ot="value += x_val;",it="";d.countIncludePad?it+=`value /= ${et}(uniforms.kernelSize);`:it+=`value /= ${et}(i32(uniforms.kernelSize) - pad);`;let[$,c,s,_,b]=Dl(g,d);$.push(...X(e.dims,g));let st=["rank"];return{name:i,shaderCache:{hint:`${a.cacheKey};${s};${_};${b}`,inputDependencies:st},getRunData:()=>({outputs:[{dims:g,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(M.size(g)/64)},programUniforms:$}),getShaderSource:dt=>Ml(dt,h,e.dims.length,g.length,d,ot,it,0,c,s,_,b)}},Vl=i=>{let e=i.count_include_pad!==0,o=Wl(i);if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let a={countIncludePad:e,...o,cacheKey:""};return{...a,cacheKey:ym(a)}},Hl=(i,e)=>{si(i.inputs),i.compute(Nl("AveragePool",i.inputs[0],!1,e))},Gl={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Ll=i=>{let e=i.format;return{format:e,...Gl,cacheKey:e}},Fl=(i,e)=>{si(i.inputs),i.compute(Nl("GlobalAveragePool",i.inputs[0],!0,e))},ql=(i,e,o,a)=>{let[d,g]=Bl(e,a,o),h=`
      value = max(x_val, value);
    `,et="",ot=U("x",e.dataType,e.dims.length),it=["rank"],[$,c,s,_,b]=Dl(g,d);return $.push(...X(e.dims,g)),{name:i,shaderCache:{hint:`${a.cacheKey};${s};${_};${b}`,inputDependencies:it},getRunData:()=>({outputs:[{dims:g,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(M.size(g)/64)},programUniforms:$}),getShaderSource:st=>Ml(st,ot,e.dims.length,g.length,d,h,et,e.dataType===10?-65504:-1e5,c,s,_,b)}},jl=(i,e)=>{si(i.inputs),i.compute(ql("MaxPool",i.inputs[0],!1,e))},Kl=i=>{let e=i.storage_order,o=i.dilations,a=Wl(i);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(a.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let d={storageOrder:e,dilations:o,...a,cacheKey:""};return{...d,cacheKey:bm(d)}},Yl=i=>{let e=i.format;return{format:e,...Gl,cacheKey:e}},Xl=(i,e)=>{si(i.inputs),i.compute(ql("GlobalMaxPool",i.inputs[0],!0,e))}}),wm,$m,Ql,Jl=j(()=>{_t(),ye(),_e(),wm=(i,e,o)=>{let a=i===e,d=i<e&&o<0,g=i>e&&o>0;if(a||d||g)throw new Error("Range these inputs' contents are invalid.")},$m=(i,e,o,a)=>{let d=Math.abs(Math.ceil((e-i)/o)),g=[d],h=d,et=[{type:12,data:h},{type:a,data:i},{type:a,data:o},...X(g)],ot=it=>{let $=K("output",a,g.length),c=$.type.value,s=[{name:"outputSize",type:"u32"},{name:"start",type:c},{name:"delta",type:c}];return`
        ${it.registerUniforms(s).declareVariables($)}
        ${it.mainStart()}
        ${it.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${c}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${a}`},getShaderSource:ot,getRunData:()=>({outputs:[{dims:g,dataType:a}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:et})}},Ql=i=>{let e=0,o=0,a=0;i.inputs[0].dataType===6?(e=i.inputs[0].getInt32Array()[0],o=i.inputs[1].getInt32Array()[0],a=i.inputs[2].getInt32Array()[0]):i.inputs[0].dataType===1&&(e=i.inputs[0].getFloat32Array()[0],o=i.inputs[1].getFloat32Array()[0],a=i.inputs[2].getFloat32Array()[0]),ke.webgpu.validateInputContent&&wm(e,o,a),i.compute($m(e,o,a,i.inputs[0].dataType),{inputs:[]})}}),_m,xm,Sm,Cm,Im,Tm,Am,Em,km,Om,Pm,ed,Rm,zm,Bm,Dm,Mm,td,rd,nd=j(()=>{ye(),xe(),Ze(),_e(),_m=(i,e)=>{if(i.every(o=>o>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),i.length>0){if(e.mode==="linear"){if(!(i.length===2||i.length===3||i.length===4&&i[0]===1&&i[1]===1||i.length===4&&i[0]===1&&i[3]===1||i.length===5&&i[0]===1&&i[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(e.mode==="cubic"&&!(i.length===2||i.length===4&&i[0]===1&&i[1]===1||i.length===4&&i[0]===1&&i[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},xm=(i,e,o)=>{e.every(d=>d>=0&&d<o||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let a=new Array(o).fill(1);return e.forEach((d,g)=>a[d]=i[g]),a},Sm=(i,e,o,a,d,g)=>{let[h,et,ot]=o>10?[1,2,3]:[-1,i.length>1?1:-1,-1],it=i[0].dims.length;if(h>0&&i.length>h&&i[h].dims.length>0)i[h].getFloat32Array().forEach($=>g.push($));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(et>0&&i.length>et&&i[et].dims.length>0){if(i[et].getFloat32Array().forEach($=>a.push($)),a.length!==0&&a.length!==it&&o>=18&&a.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");_m(a,e),e.axes.length>0&&xm(a,e.axes,it).forEach(($,c)=>a[c]=$)}if(ot>0&&i.length>ot&&(i[ot].getBigInt64Array().forEach($=>d.push(Number($))),d.length!==it||o>=18&&d.length===e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(a.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(d.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof a<"u"&&typeof d<"u"&&a.length>0&&d.length>it)throw new Error("Resize requires only of scales or sizes to be specified")},Cm=(i,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { `+(()=>{switch(i){case"asymmetric":return`return ${e}(xResized) / ${e}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${e}(xResized) + 0.5) / ${e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${e}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${e}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${e}(lengthResized - 1);
                    return whole + fract;
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${i} is not supported`)}})()+"}",Im=(i,e,o)=>`fn getNearestPixelFromOriginal(xOriginal: ${o}, isDownSample: bool) -> ${o} {`+(()=>{switch(i){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${i} is not supported`)}})()+"}",Tm=(i,e,o)=>{let a=new Array(o).fill(0).concat(new Array(o).fill(1)),d=i.length===0?a:i.slice();return e.length>0?(e.forEach((g,h)=>{a[g]=d[h],a[h+o]=d[e.length+h]}),a):d},Am=(i,e,o,a)=>{let d=[];if(o.length>0)if(a.length>0){if(i.forEach(g=>d.push(g)),Math.max(...a)>i.length)throw new Error("axes is out of bound");a.forEach((g,h)=>d[g]=o[h])}else o.forEach(g=>d.push(g));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");d=i.map((g,h)=>Math.round(g*e[h]))}return d},Em=(i,e,o)=>{let a=(()=>{switch(o.keepAspectRatioPolicy){case"not_larger":return o.axes.length>0?Math.min(...o.axes.map(g=>e[g]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return o.axes.length>0?Math.max(...o.axes.map(g=>e[g]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${o.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let d=i.slice();return o.axes.length>0?(o.axes.forEach(g=>e[g]=a),o.axes.forEach(g=>d[g]=Math.round(i[g]*e[g]))):(e.fill(a,0,e.length),d.forEach((g,h)=>d[h]=Math.round(g*e[h]))),d},km=(i,e,o,a,d)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${i.type.indices}) -> array<${i.type.value}, ${o.length}> {
      var original_indices: array<${i.type.value}, ${o.length}>;
      for (var i:u32 = 0; i < ${o.length}; i++) {
        var output_index = ${i.indicesGet("output_indices","i")};
        var scale = ${fe("uniforms.scales","i",a)};
        var roi_low = ${fe("uniforms.roi","i",d)};
        var roi_hi = ${fe("uniforms.roi",`i + ${e.length}`,d)};
        if (scale == 1.0) {
          original_indices[i] = ${i.type.value}(output_index);
        } else {
          var input_shape_i = ${fe("uniforms.input_shape","i",e.length)};
          var output_shape_i = ${fe("uniforms.output_shape","i",o.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,Om=(i,e,o,a,d,g,h)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${i.type.indices} {
      var input_indices: ${i.type.indices};
      for (var i:u32 = 0; i < ${a.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${fe("uniforms.scales","i",d)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${fe("uniforms.roi","i",g)};
          var roi_hi = ${fe("uniforms.roi",`i + ${o.length}`,g)};
          var input_shape_i = ${fe("uniforms.input_shape","i",o.length)};
          var output_shape_i = ${fe("uniforms.output_shape","i",a.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${h} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${i.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,Pm=(i,e)=>`
    fn checkInputIndices(input_indices: ${i.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${i.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${fe("uniforms.input_shape","i",e.length)}) {
          return false;
        }
      }
      return true;
    }`,ed=(i,e,o,a)=>i.rank>a?`
    ${i.indicesSet("input_indices",e,"channel")};
    ${i.indicesSet("input_indices",o,"batch")};
`:"",Rm=(i,e,o,a,d)=>{let[g,h,et,ot]=o.length===2?[-1,0,1,-1]:[0,2,3,1],it=i.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${it} {
      var input_indices: ${i.type.indices};
      ${i.indicesSet("input_indices",h,`max(0, min(row, ${o[h]} - 1))`)};
      ${i.indicesSet("input_indices",et,`max(0, min(col, ${o[et]} - 1))`)};
      ${ed(i,ot,g,2)}
      return ${i.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${it} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${it} = originalIndices[${h}];
      var col:${it} = originalIndices[${et}];
      ${a?`if (row < 0 || row > (${o[h]} - 1) || col < 0 || col > (${o[et]} - 1)) {
        return ${d};
      }`:""};
      row = max(0, min(row, ${o[h]} - 1));
      col = max(0, min(col, ${o[et]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${o.length>2?`u32(originalIndices[${ot}])`:"0"};
      var batch: u32 =  ${o.length>2?`u32(originalIndices[${g}])`:"0"};
      var x11: ${it} = getInputValue(batch, channel, row1, col1);
      var x12: ${it} = getInputValue(batch, channel, row1, col2);
      var x21: ${it} = getInputValue(batch, channel, row2, col1);
      var x22: ${it} = getInputValue(batch, channel, row2, col2);
      var dx1: ${it} = abs(row - ${it}(row1));
      var dx2: ${it} = abs(${it}(row2) - row);
      var dy1: ${it} = abs(col - ${it}(col1));
      var dy2: ${it} = abs(${it}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},zm=(i,e,o,a,d,g,h,et,ot,it)=>{let $=o.length===2,[c,s]=$?[0,1]:[2,3],_=i.type.value,b=st=>{let dt=st===c?"row":"col";return`
      fn ${dt}CubicInterpolation(input_indices: ${i.type.indices}, output_indices: ${e.type.indices}) -> ${_} {
        var output_index = ${e.indicesGet("output_indices",st)};
        var originalIdx: ${_} = getOriginalCoordinateFromResizedCoordinate(output_index, ${d[st]},
        ${a[st]}, ${o[st]}, ${g[st]}, ${g[st]} + ${o.length});
        var fractOriginalIdx: ${_} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${et} && (originalIdx < 0 || originalIdx > (${o[st]} - 1))) {
          return ${ot};
        }
        var data: array<${_}, 4> = array<${_}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${dt}: ${_} = originalIdx + ${_}(i);
          if (${dt} < 0 || ${dt} >= ${o[st]}) {
            ${it?`coefs[i + 1] = 0.0;
                        continue;`:et?`return ${ot};`:`${dt} = max(0, min(${dt}, ${o[st]} - 1));`};
          }
        var input_indices_copy: ${i.type.indices} = input_indices;
          ${i.indicesSet("input_indices_copy",st,`u32(${dt})`)};
          data[i + 1] = ${st===c?i.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${b(c)};
    ${b(s)};
  fn getCubicInterpolationCoefs(s: ${_}) -> array<${_}, 4> {
    var absS = abs(s);
    var coeffs: array<${_}, 4> = array<${_}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${_} = 1.0 - absS;
    var twoMinusAbsS: ${_} = 2.0 - absS;
    var onePlusAbsS: ${_} = 1.0 + absS;
    coeffs[0] = ((${h} * onePlusAbsS - 5 * ${h}) * onePlusAbsS + 8 * ${h}) * onePlusAbsS - 4 * ${h};
    coeffs[1] = ((${h} + 2) * absS - (${h} + 3)) * absS * absS + 1;
    coeffs[2] = ((${h} + 2) * oneMinusAbsS - (${h} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${h} * twoMinusAbsS - 5 * ${h}) * twoMinusAbsS + 8 * ${h}) * twoMinusAbsS - 4 * ${h};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${_}, 4>, coefs: array<${_}, 4>) -> ${_} {
    var coefsSum: ${_} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${_} {
    var input_indices: ${i.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},Bm=(i,e,o,a,d)=>{let[g,h,et,ot,it]=o.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],$=i.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${$} {
      var input_indices: ${i.type.indices};
      ${i.indicesSet("input_indices",h,`max(0, min(depth, ${o[h]} - 1))`)};
      ${i.indicesSet("input_indices",et,`max(0, min(height, ${o[et]} - 1))`)};
      ${i.indicesSet("input_indices",ot,`max(0, min(width, ${o[ot]} - 1))`)};
      ${ed(i,it,g,3)}
      return ${i.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${$} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${$} = originalIndices[${h}];
      var height:${$} = originalIndices[${et}];
      var width:${$} = originalIndices[${ot}];
      ${a?`if (depth < 0 || depth > (${o[h]} - 1) || height < 0 || height > (${o[et]} - 1) || width < 0 || (width > ${o[ot]} - 1)) {
      return ${d};
        }`:""};

    depth = max(0, min(depth, ${o[h]} - 1));
      height = max(0, min(height, ${o[et]} - 1));
      width = max(0, min(width, ${o[ot]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${o.length>3?`u32(originalIndices[${it}])`:"0"};
      var batch: u32 =  ${o.length>3?`u32(originalIndices[${g}])`:"0"};

      var x111: ${$} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${$} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${$} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${$} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${$} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${$} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${$} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${$} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${$} = abs(depth - ${$}(depth1));
      var dx2: ${$} = abs(${$}(depth2) - depth);
      var dy1: ${$} = abs(height - ${$}(height1));
      var dy2: ${$} = abs(${$}(height2) - height);
      var dz1: ${$} = abs(width - ${$}(width1));
      var dz2: ${$} = abs(${$}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},Dm=(i,e,o,a,d,g)=>{let h=i.dims,et=Tm(g,e.axes,h.length),ot=Am(h,a,d,e.axes),it=a.slice();a.length===0&&(it=h.map((pt,ft)=>pt===0?1:ot[ft]/pt),e.keepAspectRatioPolicy!=="stretch"&&(ot=Em(h,it,e)));let $=K("output",i.dataType,ot.length),c=U("input",i.dataType,h.length),s=M.size(ot),_=h.length===ot.length&&h.every((pt,ft)=>pt===ot[ft]),b=e.coordinateTransformMode==="tf_crop_and_resize",st=e.extrapolationValue,dt=c.type.value,ct=pt=>`
      ${_?"":`
      ${Cm(e.coordinateTransformMode,dt)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${Pm(c,h)};
              ${Im(e.nearestMode,o,dt)};
              ${Om(c,$,h,ot,it.length,et.length,b)};
              `;case"linear":return`
              ${km($,h,ot,it.length,et.length)};
              ${(()=>{if(h.length===2||h.length===4)return`${Rm(c,$,h,b,st)}`;if(h.length===3||h.length===5)return`${Bm(c,$,h,b,st)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(h.length===2||h.length===4)return`${zm(c,$,h,ot,it,et,e.cubicCoeffA,b,e.extrapolationValue,e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${pt.registerUniform("output_size","u32").registerUniform("scales","f32",it.length).registerUniform("roi","f32",et.length).declareVariables(c,$)}
      ${pt.mainStart()}
        ${pt.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${_?"output[global_idx] = input[global_idx];":`
        let output_indices = ${$.offsetToIndices("global_idx")};
        var input_indices: ${c.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${c.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${h.length===2||h.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${o}|${it.length>0?it:""}|${d.length>0?d:""}|${et.length>0?et:""}|${_}|${h}`,inputDependencies:["rank"]},getShaderSource:ct,getRunData:()=>({outputs:[{dims:ot,dataType:i.dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},{type:1,data:it},{type:1,data:et},...X(h,ot)]})}},Mm=i=>{let e=i.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},td=(i,e)=>{let o=[],a=[],d=[],g=Mm(i);if(e.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");Sm(i.inputs,e,g,o,a,d),i.compute(Dm(i.inputs[0],e,g,o,a,d),{inputs:[0]})},rd=i=>{let e=i.antialias,o=i.axes,a=i.coordinateTransformMode,d=i.cubicCoeffA,g=i.excludeOutside!==0,h=i.extrapolationValue,et=i.keepAspectRatioPolicy,ot=i.mode,it=i.nearestMode===""?"simple":i.nearestMode;return we({antialias:e,axes:o,coordinateTransformMode:a,cubicCoeffA:d,excludeOutside:g,extrapolationValue:h,keepAspectRatioPolicy:et,mode:ot,nearestMode:it})}}),Um,Wm,id,ad=j(()=>{ye(),xe(),Ze(),_e(),Um=(i,e)=>{let[o,a,d,g]=i,{numHeads:h,rotaryEmbeddingDim:et}=e;if(o.dims.length!==3&&o.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${o.dims.length}`);if(!M.areEqual(a.dims,[])&&!M.areEqual(a.dims,[1])&&a.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${a.dims.length}`);if(d.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${d.dims.length}`);if(g.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${g.dims.length}`);if(!M.areEqual(d.dims,g.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(et>0&&h===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let ot=o.dims[0],it=o.dims[o.dims.length-2],$=d.dims[0],c=M.sizeFromDimension(o.dims,1)/it,s=et===0?d.dims[1]*2:c/h;if(et>s)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(a.dims.length===2){if(ot!==a.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${a.dims[0]}`);if(it!==a.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${a.dims[1]}`)}if(s/2!==d.dims[1]&&et/2!==d.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${d.dims[1]}`);if(it>$)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},Wm=(i,e)=>{let{interleaved:o,numHeads:a,rotaryEmbeddingDim:d,scale:g}=e,h=i[0].dims[0],et=M.sizeFromDimension(i[0].dims,1),ot=i[0].dims[i[0].dims.length-2],it=et/ot,$=i[2].dims[1],c=d===0?$*2:it/a,s=new Array(h,ot,it/c,c-$),_=M.computeStrides(s),b=[{type:1,data:g},{type:12,data:s},{type:12,data:_},...i[0].dims.length===3?new Array({type:12,data:[et,it,c,1]}):[],...i[0].dims.length===4?new Array({type:12,data:[et,c,ot*c,1]}):[],...X(i[0].dims,i[1].dims,i[2].dims,i[3].dims,i[0].dims)],st=dt=>{let ct=U("input",i[0].dataType,i[0].dims.length),pt=U("position_ids",i[1].dataType,i[1].dims.length),ft=U("cos_cache",i[2].dataType,i[2].dims.length),mt=U("sin_cache",i[3].dataType,i[3].dims.length),bt=K("output",i[0].dataType,i[0].dims.length);return dt.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:s.length},{name:"global_strides",type:"u32",length:_.length},{name:"input_output_strides",type:"u32",length:_.length}]),`
        ${dt.declareVariables(ct,pt,ft,mt,bt)}

        ${dt.mainStart(mr)}
          let half_rotary_emb_dim = uniforms.${ft.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${dt.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${pt.broadcastedIndicesToOffset("bsnh.xy",K("",pt.type.tensor,2))};
            let position_id =
                u32(${pt.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${o});
            let j = i + select(half_rotary_emb_dim, 1, ${o});
            let re = ${ct.getByOffset("i")} * ${ft.get("position_id","bsnh[3]")} -
                ${ct.getByOffset("j")} * ${mt.get("position_id","bsnh[3]")};
            ${bt.setByOffset("i","re")}
            let im = ${ct.getByOffset("i")} * ${mt.get("position_id","bsnh[3]")} +
                ${ct.getByOffset("j")} * ${ft.get("position_id","bsnh[3]")};
            ${bt.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${bt.setByOffset("k",ct.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:we({interleaved:o}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:st,getRunData:()=>({outputs:[{dims:i[0].dims,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(s)/mr)},programUniforms:b})}},id=(i,e)=>{Um(i.inputs,e),i.compute(Wm(i.inputs,e))}}),Nm,Vm,od,sd=j(()=>{ye(),xe(),_e(),Nm=i=>{if(!i||i.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=i[0],o=i[1],a=i[2];if(e.dataType!==o.dataType||e.dataType!==a.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(o.dims.length!==3&&o.dims.length!==2)throw new Error("Skip must be 2D or 3D");let d=e.dims[e.dims.length-1],g=e.dims[e.dims.length-2];if(o.dims[o.dims.length-1]!==d)throw new Error("Skip must have the same hidden size as input");if(o.dims[o.dims.length-2]!==g)throw new Error("Skip must have the same sequence length as input");if(a.dims.length!==1)throw new Error("Gamma must be 1D");if(a.dims[a.dims.length-1]!==d)throw new Error("Gamma must have the same hidden size as input");if(i.length>3){let h=i[3];if(h.dims.length!==1)throw new Error("Beta must be 1D");if(h.dims[h.dims.length-1]!==d)throw new Error("Beta must have the same hidden size as input")}if(i.length>4){let h=i[4];if(h.dims.length!==1)throw new Error("Bias must be 1D");if(h.dims[h.dims.length-1]!==d)throw new Error("Bias must have the same hidden size as input")}},Vm=(i,e,o,a)=>{let d=e.simplified,g=i[0].dims,h=M.size(g),et=g,ot=h,it=g.slice(-1)[0],$=a?g.slice(0,-1).concat(1):[],c=!d&&i.length>3,s=i.length>4,_=a&&o>1,b=a&&o>2,st=o>3,dt=64,ct=Ue(it),pt=[{type:12,data:ot},{type:12,data:ct},{type:12,data:it},{type:1,data:e.epsilon}],ft=bt=>{let $t=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],Ct=[U("x",i[0].dataType,i[0].dims,ct),U("skip",i[1].dataType,i[1].dims,ct),U("gamma",i[2].dataType,i[2].dims,ct)];c&&Ct.push(U("beta",i[3].dataType,i[3].dims,ct)),s&&Ct.push(U("bias",i[4].dataType,i[4].dims,ct)),Ct.push(K("output",i[0].dataType,et,ct)),_&&Ct.push(K("mean_output",1,$)),b&&Ct.push(K("inv_std_output",1,$)),st&&Ct.push(K("input_skip_bias_sum",i[0].dataType,et,ct));let It=Be(i[0].dataType),Tt=Be(1,ct);return`

      ${bt.registerUniforms($t).declareVariables(...Ct)}
      var<workgroup> sum_shared : array<${Tt}, ${dt}>;
      var<workgroup> sum_squared_shared : array<${Tt}, ${dt}>;

      ${bt.mainStart([dt,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${dt};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${dt};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${dt-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${s?"bias[offset1d + i]":It+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${st?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${fr(It,ct,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${dt};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${At("sum",ct)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${At("square_sum",ct)} / f32(uniforms.hidden_size) ${d?"":"- mean * mean"} + uniforms.epsilon);
        ${_?"mean_output[global_idx] = mean;":""}
        ${b?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${d?"":`- ${It}(mean)`}) *
            ${It}(inv_std_dev) * gamma[offset1d + i]
            ${c?"+ beta[offset1d + i]":""};
        }
      }`},mt=[{dims:et,dataType:i[0].dataType}];return o>1&&mt.push({dims:$,dataType:1}),o>2&&mt.push({dims:$,dataType:1}),o>3&&mt.push({dims:g,dataType:i[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${ct};${_};${b};${st}`,inputDependencies:i.map((bt,$t)=>"type")},getShaderSource:ft,getRunData:()=>({outputs:mt,dispatchGroup:{x:Math.ceil(ot/it)},programUniforms:pt})}},od=(i,e)=>{Nm(i.inputs);let o=[0];i.outputCount>1&&o.push(-3),i.outputCount>2&&o.push(-3),i.outputCount>3&&o.push(3),i.compute(Vm(i.inputs,e,i.outputCount,!1),{outputs:o})}}),Hm,ui,Gm,ud,Lm,Fm,ld,dd,cd=j(()=>{ye(),xe(),Ze(),_e(),Hm=(i,e)=>{if(!i||i.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");i.slice(1).forEach((o,a)=>{if(i[a+1].dataType!==6&&i[a+1].dataType!==7)throw new Error(`Input ${a} must be an array of int32 or int64`)})},ui=(i,e)=>{let o=[];if(i.length>e)if(i[e].dataType===7)i[e].getBigInt64Array().forEach(a=>o.push(Number(a)));else if(i[e].dataType===6)i[e].getInt32Array().forEach(a=>o.push(Number(a)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return o},Gm=(i,e)=>{if(i.length>1){let o=ui(i,1),a=ui(i,2),d=ui(i,3);return d.length===0&&(d=[...Array(i[0].dims.length).keys()]),we({starts:o,ends:a,axes:d})}else return e},ud=(i,e,o,a,d)=>{let g=i;return i<0&&(g+=o[a[e]]),d[e]<0?Math.max(0,Math.min(g,o[a[e]]-1)):Math.max(0,Math.min(g,o[a[e]]))},Lm=(i,e,o)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${i.type.indices} {
          var input_indices: ${i.type.indices};
          var carry = 0u;
          for (var i = ${o.length}; i >= 0; i--) {
            let input_shape_i = ${fe("uniforms.input_shape","i",o.length)};
            let steps_i = ${fe("uniforms.steps","i",o.length)};
            let signs_i = ${fe("uniforms.signs","i",o.length)};
            let starts_i = ${fe("uniforms.starts","i",o.length)};
            var output_index = ${e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${i.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,Fm=(i,e)=>{let o=i[0].dims,a=M.size(o),d=e.axes.length>0?M.normalizeAxes(e.axes,o.length):[...Array(o.length).keys()],g=ui(i,4);g.forEach(ct=>ct!==0||(()=>{throw new Error("step cannot be 0")})),g.length===0&&(g=Array(d.length).fill(1));let h=e.starts.map((ct,pt)=>ud(ct,pt,o,d,g)),et=e.ends.map((ct,pt)=>ud(ct,pt,o,d,g));if(d.length!==h.length||d.length!==et.length)throw new Error("start, ends and axes should have the same number of elements");if(d.length!==o.length)for(let ct=0;ct<o.length;++ct)d.includes(ct)||(h.splice(ct,0,0),et.splice(ct,0,o[ct]),g.splice(ct,0,1));let ot=g.map(ct=>Math.sign(ct));g.forEach((ct,pt,ft)=>{if(ct<0){let mt=(et[pt]-h[pt])/ct,bt=h[pt],$t=bt+mt*g[pt];h[pt]=$t,et[pt]=bt,ft[pt]=-ct}});let it=o.slice(0);d.forEach((ct,pt)=>{it[ct]=Math.ceil((et[ct]-h[ct])/g[ct])});let $={dims:it,dataType:i[0].dataType},c=K("output",i[0].dataType,it.length),s=U("input",i[0].dataType,i[0].dims.length),_=M.size(it),b=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:h.length},{name:"signs",type:"i32",length:ot.length},{name:"steps",type:"u32",length:g.length}],st=[{type:12,data:_},{type:12,data:h},{type:6,data:ot},{type:12,data:g},...X(i[0].dims,it)],dt=ct=>`
      ${ct.registerUniforms(b).declareVariables(s,c)}
        ${Lm(s,c,o)}
        ${ct.mainStart()}
          ${ct.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${c.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${c.setByOffset("global_idx",s.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${ot.length}_${h.length}_${g.length}`,inputDependencies:["rank"]},getShaderSource:dt,getRunData:()=>({outputs:[$],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:st})}},ld=(i,e)=>{Hm(i.inputs,e);let o=Gm(i.inputs,e);i.compute(Fm(i.inputs,o),{inputs:[0]})},dd=i=>{let e=i.starts,o=i.ends,a=i.axes;return we({starts:e,ends:o,axes:a})}}),qm,jm,pd,md,fd=j(()=>{ye(),xe(),Ze(),_e(),qm=i=>{if(!i||i.length!==1)throw new Error("Softmax op requires 1 input.")},jm=(i,e)=>{let o=i.dims,a=M.size(o),d=64,g=e.axis;if(g<0&&(g=o.length+g),g<o.length-1)throw new Error("softmax only supports last axis for now.");let h=o[g],et=a/h,ot=Ue(h),it=h/ot,$=(dt,ct)=>ct===4?`max(max(${dt}.x, ${dt}.y), max(${dt}.z, ${dt}.w))`:ct===2?`max(${dt}.x, ${dt}.y)`:ct===3?`max(max(${dt}.x, ${dt}.y), ${dt}.z)`:dt,c=U("x",i.dataType,i.dims,ot),s=K("result",i.dataType,i.dims,ot),_=c.type.value,b=Be(i.dataType)==="f32"?`var threadMax = ${_}(-3.402823e+38f);`:`var threadMax = ${_}(-65504.0h);`,st=dt=>`
      var<workgroup> rowMaxShared : ${_};
      var<workgroup> rowSumShared : ${_};
      var<workgroup> threadShared : array<${_}, ${d}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${_} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${_}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${dt.registerUniform("packedCols","i32").declareVariables(c,s)}
      ${dt.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${d};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${b}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${_}(${$("threadShared[0]",ot)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${_}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${_}(${At("threadShared[0]",ot)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${ot}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:o,dataType:i.dataType}],dispatchGroup:{x:et},programUniforms:[{type:6,data:it}]}),getShaderSource:st}},pd=(i,e)=>{qm(i.inputs),i.compute(jm(i.inputs[0],e))},md=i=>we({axis:i.axis})}),Km,Ym,Xm,Zm,Qm,hd,gd,yd=j(()=>{ye(),xe(),Ze(),_e(),Km=i=>{if(!i||i.length<1)throw new Error("too few inputs")},Ym=(i,e)=>{let o=[],a=e.numOutputs;return i[1].dims[0]>0&&(i[1].getBigInt64Array().forEach(d=>o.push(Number(d))),a=o.length),we({numOutputs:a,axis:e.axis,splitSizes:o})},Xm=i=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${i}u; i += 1u ) {
    if (index < ${fe("uniforms.size_in_split_axis","i",i)}) {
        return i;
    }
    }
    return ${i}u;
}`,Zm=i=>{let e=i.length,o=[];for(let a=0;a<e;++a){let d=i[a].setByIndices("indices","input[global_idx]");e===1?o.push(d):a===0?o.push(`if (output_number == ${a}u) { ${d} }`):a===e-1?o.push(`else { ${d} }`):o.push(`else if (output_number == ${a}) { ${d} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${i[0].type.indices}, global_idx: u32) {
        ${o.join(`
`)}
      }`},Qm=(i,e)=>{let o=i[0].dims,a=M.size(o),d=i[0].dataType,g=M.normalizeAxis(e.axis,o.length),h=new Array(e.numOutputs),et=U("input",d,o.length),ot=new Array(e.numOutputs),it=[],$=[],c=0,s=[{type:12,data:a}];for(let b=0;b<e.numOutputs;b++){c+=e.splitSizes[b],ot[b]=c;let st=o.slice();st[e.axis]=e.splitSizes[b],$.push(st),h[b]=K(`output${b}`,d,st.length),it.push({dims:$[b],dataType:i[0].dataType})}s.push({type:12,data:ot},...X(o,...$));let _=b=>`
  ${b.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",ot.length).declareVariables(et,...h)}
  ${Xm(ot.length)}
  ${Zm(h)}

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${et.offsetToIndices("global_idx")};
    var index = ${et.indicesGet("indices",g)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${fe("uniforms.size_in_split_axis","output_number - 1u",ot.length)};
      ${et.indicesSet("indices",g,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:_,getRunData:()=>({outputs:it,dispatchGroup:{x:Math.ceil(a/64)},programUniforms:s})}},hd=(i,e)=>{Km(i.inputs);let o=i.inputs.length===1?e:Ym(i.inputs,e);i.compute(Qm(i.inputs,o),{inputs:[0]})},gd=i=>{let e=i.axis,o=i.splitSizes,a=i.numOutputs<0?o.length:i.numOutputs;if(a!==o.length)throw new Error("numOutputs and splitSizes lengh must be equal");return we({axis:e,numOutputs:a,splitSizes:o})}}),bd,Jm,ef,tf,vd,wd=j(()=>{ye(),xe(),_e(),bd=i=>Array.from(i.getBigInt64Array(),Number),Jm=i=>{if(!i||i.length!==2)throw new Error("Tile requires 2 inputs.");if(i[0].dataType!==1&&i[0].dataType!==6&&i[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(i[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(i[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(bd(i[1]).length!==i[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ef=(i,e)=>{let o=[];for(let a=0;a<i.length;++a)o.push(i[a]*e[a]);return o},tf=i=>{let e=i[0].dims,o=bd(i[1]),a=ef(e,o),d=M.size(a),g=i[0].dataType,h=U("input",g,e.length),et=K("output",g,a.length),ot=it=>`
      const inputShape = ${h.indices(...e)};
      ${it.registerUniform("output_size","u32").declareVariables(h,et)}
      ${it.mainStart()}
      ${it.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${et.offsetToIndices("global_idx")};
      var input_indices: ${h.type.indices};
      for (var i = 0; i < ${e.length}; i++) {
        let input_dim_i = ${h.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${et.indicesGet("output_indices","i")}  % input_dim_i;

        ${h.indicesSet("input_indices","i","input_dim_value")}
      }
      ${et.setByOffset("global_idx",h.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${o}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:i[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},...X(i[0].dims,a)]}),getShaderSource:ot}},vd=i=>{Jm(i.inputs),i.compute(tf(i.inputs),{inputs:[0]})}}),rf,nf,$d,_d=j(()=>{ye(),xe(),_e(),rf=(i,e,o,a,d)=>{let g=K("output_data",d,o.length,4),h=U("a_data",e[1].dataType,e[1].dims.length,4),et=U("b_data",e[2].dataType,e[2].dims.length,4),ot=U("c_data",e[0].dataType,e[0].dims.length,4),it,$=(c,s,_)=>`select(${s}, ${c}, ${_})`;if(!a)it=g.setByOffset("global_idx",$(h.getByOffset("global_idx"),et.getByOffset("global_idx"),ot.getByOffset("global_idx")));else{let c=(s,_,b="")=>{let st=`a_data[index_a${_}][component_a${_}]`,dt=`b_data[index_b${_}][component_b${_}]`,ct=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`
            let output_indices${_} = ${g.offsetToIndices(`global_idx * 4u + ${_}u`)};
            let offset_a${_} = ${h.broadcastedIndicesToOffset(`output_indices${_}`,g)};
            let offset_b${_} = ${et.broadcastedIndicesToOffset(`output_indices${_}`,g)};
            let offset_c${_} = ${ot.broadcastedIndicesToOffset(`output_indices${_}`,g)};
            let index_a${_} = offset_a${_} / 4u;
            let index_b${_} = offset_b${_} / 4u;
            let index_c${_} = offset_c${_} / 4u;
            let component_a${_} = offset_a${_} % 4u;
            let component_b${_} = offset_b${_} % 4u;
            let component_c${_} = offset_c${_} % 4u;
            ${s}[${_}] = ${b}(${$(st,dt,ct)});
          `};d===9?it=`
            var data = vec4<u32>(0);
            ${c("data",0,"u32")}
            ${c("data",1,"u32")}
            ${c("data",2,"u32")}
            ${c("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:it=`
            ${c("output_data[global_idx]",0)}
            ${c("output_data[global_idx]",1)}
            ${c("output_data[global_idx]",2)}
            ${c("output_data[global_idx]",3)}
          `}return`
        ${i.registerUniform("vec_size","u32").declareVariables(ot,h,et,g)}
        ${i.mainStart()}
        ${i.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${it}
      }`},nf=i=>{let e=i[1].dims,o=i[2].dims,a=i[0].dims,d=i[1].dataType,g=!(M.areEqual(e,o)&&M.areEqual(o,a)),h=e,et=M.size(e);if(g){let it=Rt.calcShape(Rt.calcShape(e,o,!1),a,!1);if(!it)throw new Error("Can't perform where op on the given tensors");h=it,et=M.size(h)}let ot=Math.ceil(et/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:it=>rf(it,i,h,g,d),getRunData:()=>({outputs:[{dims:h,dataType:d}],dispatchGroup:{x:Math.ceil(et/64/4)},programUniforms:[{type:12,data:ot},...X(a,e,o,h)]})}},$d=i=>{i.compute(nf(i.inputs))}}),xd,Sd=j(()=>{zs(),aa(),Ws(),Vs(),Cu(),Du(),ia(),da(),Xu(),Ju(),rl(),sl(),dl(),pl(),hl(),bl(),$l(),xl(),Cl(),pa(),Al(),Pl(),zl(),Zl(),Jl(),jn(),nd(),ad(),sd(),cd(),fd(),yd(),wd(),Rr(),Jn(),_d(),xd=new Map([["Abs",[Hs]],["Acos",[Gs]],["Acosh",[Ls]],["Add",[Iu]],["ArgMax",[Rs,na]],["ArgMin",[Ps,na]],["Asin",[Fs]],["Asinh",[qs]],["Atan",[js]],["Atanh",[Ks]],["Attention",[Ms]],["AveragePool",[Hl,Vl]],["BatchNormalization",[Us]],["BiasAdd",[Ns]],["BiasSplitGelu",[Su]],["Cast",[Xs,Ys]],["Ceil",[Qs]],["Clip",[Zs]],["Concat",[Bs,Ds]],["Conv",[ha,fa]],["ConvTranspose",[Yu,Ku]],["Cos",[Js]],["Cosh",[eu]],["CumSum",[Zu,Qu]],["DepthToSpace",[el,tl]],["Div",[Tu]],["Einsum",[al,ol]],["Elu",[tu,Zn]],["Equal",[Au]],["Erf",[ru]],["Exp",[nu]],["Expand",[ll]],["FastGelu",[cl]],["Floor",[iu]],["FusedConv",[ha,fa]],["Gather",[fl,ml]],["GatherElements",[yl,gl]],["Gelu",[au]],["Gemm",[wl,vl]],["GlobalAveragePool",[Fl,Ll]],["GlobalMaxPool",[Xl,Yl]],["Greater",[Pu]],["GreaterOrEqual",[zu]],["HardSigmoid",[mu,pu]],["InstanceNormalization",[_l]],["LayerNormalization",[Sl]],["LeakyRelu",[ou,Zn]],["Less",[Ru]],["LessOrEqual",[Bu]],["Log",[_u]],["MatMul",[Hu]],["MatMulNBits",[Il,Tl]],["MaxPool",[jl,Kl]],["Mul",[Eu]],["MultiHeadAttention",[Ol,kl]],["Neg",[uu]],["Not",[su]],["Pad",[Rl]],["Pow",[ku]],["Range",[Ql]],["Reciprocal",[lu]],["ReduceMin",[Is]],["ReduceMean",[$s]],["ReduceMax",[Cs]],["ReduceSum",[As]],["ReduceProd",[Ts]],["ReduceL1",[_s]],["ReduceL2",[xs]],["ReduceLogSum",[ks]],["ReduceLogSumExp",[Ss]],["ReduceSumSquare",[Es]],["Relu",[du]],["Resize",[td,rd]],["RotaryEmbedding",[id]],["Sigmoid",[cu]],["Sin",[fu]],["Sinh",[hu]],["Slice",[ld,dd]],["SkipLayerNormalization",[od]],["Split",[hd,gd]],["Sqrt",[gu]],["Softmax",[pd,md]],["Sub",[Ou]],["Tan",[yu]],["Tanh",[vu]],["ThresholdedRelu",[$u,Zn]],["Tile",[vd]],["Transpose",[us,ls]],["Where",[$d]]])}),li,Cd=j(()=>{_t(),Yt(),_e(),li=class{constructor(i){this.backend=i,this.repo=new Map,this.attributesBound=!1}getArtifact(i){return this.repo.get(i)}setArtifact(i,e){this.repo.set(i,e)}run(i,e,o,a,d){yt(i.programInfo.name);let g=this.backend.device,h=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let et=[];for(let it of e)et.push({binding:et.length,resource:{buffer:it.buffer}});for(let it of o)et.push({binding:et.length,resource:{buffer:it.buffer}});d&&et.push({binding:et.length,resource:d});let ot=g.createBindGroup({layout:i.computePipeline.getBindGroupLayout(0),entries:et,label:i.programInfo.name});if(this.backend.sessionStatus==="capturing"){let it={kernelId:this.backend.currentKernelId,computePipeline:i.computePipeline,bindGroup:ot,dispatchGroup:a};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(it)}h.setPipeline(i.computePipeline),h.setBindGroup(0,ot),h.dispatchWorkgroups(...a),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),ut(i.programInfo.name)}dispose(){}build(i,e){yt(i.name);let o=this.backend.device,a=[];o.features.has("shader-f16")&&a.push("enable f16;");let d=os(e,this.backend.device.limits),g=i.getShaderSource(d),h=`${a.join(`
`)}
${d.additionalImplementations}
${g}`,et=o.createShaderModule({code:h,label:i.name});Ne("verbose",()=>`[WebGPU] ${i.name} shader code: ${h}`);let ot=o.createComputePipeline({compute:{module:et,entryPoint:"main"},layout:"auto",label:i.name});return ut(i.name),{programInfo:i,computePipeline:ot,uniformVariablesInfo:d.variablesInfo}}normalizeDispatchGroupSize(i){let e=typeof i=="number"?i:i.x,o=typeof i=="number"?1:i.y||1,a=typeof i=="number"?1:i.z||1,d=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=d&&o<=d&&a<=d)return[e,o,a];let g=e*o*a,h=Math.ceil(Math.sqrt(g));if(h>d){if(h=Math.ceil(Math.cbrt(g)),h>d)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[h,h,h]}else return[h,h,1]}}}),af,of,$a,di,Id=j(()=>{_t(),ye(),Yt(),es(),as(),Sd(),Cd(),af=(i,e)=>{if(e.length!==i.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${i.length}.`);let o=[];for(let a=0;a<i.length;++a){let d=i[a].dataType;switch(e[a]){case"none":{o.push("");break}case"type":{o.push(`${d}`);break}case"rank":{let g=i[a].dims.length;o.push(`${d};${g}`);break}case"dims":{let g=i[a].dims.join(",");o.push(`${d};${g}`);break}default:throw new Error(`unsupported input dependency: ${e[a]}`)}}return o.join("|")},of=(i,e,o)=>{var d,g;let a=i.name;return(d=i.shaderCache)!=null&&d.hint&&(a+="["+i.shaderCache.hint+"]"),a+=":"+o+`:${af(e,((g=i.shaderCache)==null?void 0:g.inputDependencies)??new Array(e.length).fill("dims"))}`,a},$a=class{constructor(i){i&&(this.architecture=i.architecture,this.vendor=i.vendor)}isArchitecture(i){return this.architecture===i}isVendor(i){return this.vendor===i}},di=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let i=this.kernelCustomData.get(this.currentKernelId);return i||(i={},this.kernelCustomData.set(this.currentKernelId,i)),i}async initialize(i,e){this.env=i;let o=[],a={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};e.features.has("chromium-experimental-timestamp-query-inside-passes")?o.push("chromium-experimental-timestamp-query-inside-passes"):e.features.has("timestamp-query")&&o.push("timestamp-query"),e.features.has("shader-f16")&&o.push("shader-f16"),this.device=await e.requestDevice(a),this.adapterInfo=new $a(await e.requestAdapterInfo()),this.gpuDataManager=is(this),this.programManager=new li(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Qo(i.logLevel,!!i.debug),this.device.onuncapturederror=d=>{d.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${d.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:e,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let i=this.getCommandEncoder(),e={};this.queryType==="at-passes"&&(e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=i.beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;yt(),this.endComputePass();let i;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),i=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(i,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,i,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&i.mapAsync(GPUMapMode.READ).then(()=>{var a;let e=new BigUint64Array(i.getMappedRange()),o=this.pendingQueries.get(i);for(let d=0;d<e.length/2;d++){let g=o[d],h=g.kernelId,et=this.kernels.get(h),ot=et.kernelType,it=et.kernelName,$=g.programName,c=g.inputTensorViews,s=g.outputTensorViews,_=e[d*2],b=e[d*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=_);let st=Number(_-this.queryTimeBase),dt=Number(b-this.queryTimeBase);if(!Number.isSafeInteger(st)||!Number.isSafeInteger(dt))throw new RangeError("incorrect timestamp range");if((a=this.env.webgpu.profiling)!=null&&a.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:c.map(ct=>({dims:ct.dims,dataType:Kt(ct.dataType)})),outputsMetadata:s.map(ct=>({dims:ct.dims,dataType:Kt(ct.dataType)})),kernelId:h,kernelType:ot,kernelName:it,programName:$,startTime:st,endTime:dt});else{let ct="";c.forEach((ft,mt)=>{ct+=`input[${mt}]: [${ft.dims}] | ${Kt(ft.dataType)}, `});let pt="";s.forEach((ft,mt)=>{pt+=`output[${mt}]: [${ft.dims}] | ${Kt(ft.dataType)}, `}),console.log(`[profiling] kernel "${h}|${ot}|${it}|${$}" ${ct}${pt}execution time: ${dt-st} ns`)}Bn("GPU",`${$}::${_}::${b}`)}i.unmap(),this.pendingQueries.delete(i)}),ut()}run(i,e,o,a,d,g){yt(i.name);let h=[];for(let pt=0;pt<e.length;++pt){let ft=e[pt].data;if(ft===0)continue;let mt=this.gpuDataManager.get(ft);if(!mt)throw new Error(`no GPU data for input: ${ft}`);h.push(mt)}let{outputs:et,dispatchGroup:ot,programUniforms:it}=i.getRunData(e),$=o.length===0?et.map((pt,ft)=>ft):o;if($.length!==et.length)throw new Error(`Output size ${$.length} must be equal to ${et.length}.`);let c=[],s=[];for(let pt=0;pt<et.length;++pt){if(!Number.isInteger($[pt])||$[pt]<-3||$[pt]>=g)throw new Error(`Invalid output index: ${$[pt]}`);if($[pt]===-3)continue;let ft=$[pt]===-1,mt=$[pt]===-2,bt=ft||mt?d(et[pt].dataType,et[pt].dims):a($[pt],et[pt].dataType,et[pt].dims);if(c.push(bt),bt.data===0)continue;let $t=this.gpuDataManager.get(bt.data);if(!$t)throw new Error(`no GPU data for output: ${bt.data}`);if(ft&&this.temporaryData.push($t),mt){let Ct=this.kernelPersistentData.get(this.currentKernelId);Ct||(Ct=[],this.kernelPersistentData.set(this.currentKernelId,Ct)),Ct.push($t)}s.push($t)}if(h.length!==e.length||s.length!==c.length){if(s.length===0)return ut(i.name),c;throw new Error(`Program ${i.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let _;if(it){let pt=0,ft=[];it.forEach(Ct=>{let It=typeof Ct.data=="number"?[Ct.data]:Ct.data;if(It.length===0)return;let Tt=Ct.type===10?2:4,jt,dn;Ct.type===10?(dn=It.length>4?16:It.length>2?8:It.length*Tt,jt=It.length>4?16:Tt*It.length):(dn=It.length<=2?It.length*Tt:16,jt=16),pt=Math.ceil(pt/dn)*dn,ft.push(pt);let yn=Ct.type===10?8:4;pt+=It.length>4?Math.ceil(It.length/yn)*jt:It.length*Tt});let mt=16;pt=Math.ceil(pt/mt)*mt;let bt=new ArrayBuffer(pt);it.forEach((Ct,It)=>{let Tt=ft[It],jt=typeof Ct.data=="number"?[Ct.data]:Ct.data;if(Ct.type===6)new Int32Array(bt,Tt,jt.length).set(jt);else if(Ct.type===12)new Uint32Array(bt,Tt,jt.length).set(jt);else if(Ct.type===10)new Uint16Array(bt,Tt,jt.length).set(jt);else if(Ct.type===1)new Float32Array(bt,Tt,jt.length).set(jt);else throw new Error(`Unsupported uniform type: ${Kt(Ct.type)}`)});let $t=this.gpuDataManager.create(pt,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer($t.buffer,0,bt,0,pt),this.gpuDataManager.release($t.id),_={offset:0,size:pt,buffer:$t.buffer}}let b=this.programManager.normalizeDispatchGroupSize(ot),st=b[1]===1&&b[2]===1,dt=of(i,e,st),ct=this.programManager.getArtifact(dt);if(ct||(ct=this.programManager.build(i,b),this.programManager.setArtifact(dt,ct),Ne("info",()=>`[artifact] key: ${dt}, programName: ${i.name}`)),it&&ct.uniformVariablesInfo){if(it.length!==ct.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${ct.uniformVariablesInfo.length}, got ${it.length} in program "${ct.programInfo.name}".`);for(let pt=0;pt<it.length;pt++){let ft=it[pt],mt=ft.type,bt=typeof ft.data=="number"?1:ft.data.length,[$t,Ct]=ct.uniformVariablesInfo[pt];if(mt!==$t||bt!==Ct)throw new Error(`Uniform variable ${pt} mismatch: expect type ${$t} with size ${Ct}, got type ${mt} with size ${bt} in program "${ct.programInfo.name}".`)}}if(Ne("info",()=>`[ProgramManager] run "${i.name}" (key=${dt}) with ${b[0]}x${b[1]}x${b[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let pt={kernelId:this.currentKernelId,programName:ct.programInfo.name,inputTensorViews:e,outputTensorViews:c};this.pendingKernels.push(pt),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(pt)}return this.programManager.run(ct,h,s,b,_),ut(i.name),c}upload(i,e){this.gpuDataManager.upload(i,e)}memcpy(i,e){this.gpuDataManager.memcpy(i,e)}async download(i,e){await this.gpuDataManager.download(i,e)}alloc(i){return this.gpuDataManager.create(i).id}free(i){return this.gpuDataManager.release(i)}createKernel(i,e,o,a){let d=xd.get(i);if(!d)throw new Error(`kernel not implemented: ${i}`);let g={kernelType:i,kernelName:a,kernelEntry:d[0],attributes:[d[1],o]};this.kernels.set(e,g)}releaseKernel(i){let e=this.kernelPersistentData.get(i);if(e){for(let o of e)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(i)}this.kernelCustomData.delete(i),this.kernels.delete(i)}computeKernel(i,e,o){let a=this.kernels.get(i);if(!a)throw new Error(`kernel not created: ${i}`);let d=a.kernelType,g=a.kernelName,h=a.kernelEntry,et=a.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${d}] ${g}" is not allowed to be called recursively`);this.currentKernelId=i,et[0]&&(et[1]=et[0](et[1]),et[0]=void 0),Ne("info",()=>`[WebGPU] Start to run kernel "[${d}] ${g}"...`);let ot=this.env.debug;this.temporaryData=[];try{return ot&&this.device.pushErrorScope("validation"),h(e,et[1]),0}catch(it){return o.push(Promise.resolve(`[WebGPU] Kernel "[${d}] ${g}" failed. ${it}`)),1}finally{ot&&o.push(this.device.popErrorScope().then(it=>it?`GPU validation error for kernel "[${d}] ${g}": ${it.message}`:null));for(let it of this.temporaryData)this.gpuDataManager.release(it.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(i,e,o,a){let d=this.sessionExternalDataMapping.get(i);d||(d=new Map,this.sessionExternalDataMapping.set(i,d));let g=d.get(e),h=this.gpuDataManager.registerExternalBuffer(o,a,g==null?void 0:g[1]);return d.set(e,[h,o]),h}unregisterBuffers(i){let e=this.sessionExternalDataMapping.get(i);e&&(e.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(i))}getBuffer(i){let e=this.gpuDataManager.get(i);if(!e)throw new Error(`no GPU data for buffer: ${i}`);return e.buffer}createDownloader(i,e,o){return async()=>{let a=await Xi(this,i,e);return Jo(a.buffer,o)}}writeTimestamp(i){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,i)}setQueryType(){var i;this.queryType="none",(((i=this.env.webgpu.profiling)==null?void 0:i.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Ne("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Ne("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Ne("info","replay"),this.sessionStatus="replaying";let i=this.capturedCommandList.get(this.currentSessionId),e=this.capturedPendingKernels.get(this.currentSessionId),o=i.length;this.pendingKernels=[];for(let a=0;a<o;a++){let d=this.getComputePassEncoder(),g=i[a];this.writeTimestamp(this.pendingDispatchNumber*2),d.setPipeline(g.computePipeline),d.setBindGroup(0,g.bindGroup),d.dispatchWorkgroups(...g.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(e[a]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(i){this.unregisterBuffers(i),this.capturedCommandList.has(i)&&this.capturedCommandList.delete(i),this.capturedPendingKernels.has(i)&&this.capturedPendingKernels.delete(i),this.gpuDataManager.onReleaseSession(i)}onRunStart(i){this.currentSessionId=i,this.setQueryType()}}}),Td={};kr(Td,{init:()=>sf});var on,_a,sf,Ad=j(()=>{ye(),Id(),Yt(),xe(),on=class m_{constructor(e,o,a,d){this.module=e,this.dataType=o,this.data=a,this.dims=d}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=M.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=M.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=M.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(M.size(e)!==M.size(this.dims))throw new Error("Invalid new shape");return new m_(this.module,this.dataType,this.data,e)}},_a=class{constructor(i,e,o){this.module=i,this.backend=e,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=e.adapterInfo;let a=i.HEAPU32,d=o>>>2;this.opKernelContext=a[d++];let g=a[d++];this.outputCount=a[d++],this.customDataOffset=a[d++],this.customDataSize=a[d++];let h=[];for(let et=0;et<g;et++){let ot=a[d++],it=a[d++],$=a[d++],c=[];for(let s=0;s<$;s++)c.push(a[d++]);h.push(new on(i,ot,it,c))}this.inputs=h}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(i,e){var h;let o=((h=e==null?void 0:e.inputs)==null?void 0:h.map(et=>typeof et=="number"?this.inputs[et]:et))??this.inputs,a=(e==null?void 0:e.outputs)??[],d=(et,ot,it)=>new on(this.module,ot,this.output(et,it),it),g=(et,ot)=>{let it=cr(et);if(!it)throw new Error(`Unsupported data type: ${et}`);let $=it*M.size(ot),c=$>0?this.backend.gpuDataManager.create($).id:0;return new on(this.module,et,c,ot)};return this.backend.run(i,o,a,d,g,this.outputCount)}output(i,e){let o=this.module.stackSave();try{let a=this.module.stackAlloc((1+e.length)*4),d=a>>2;this.module.HEAPU32[d++]=e.length;for(let g=0;g<e.length;g++)this.module.HEAPU32[d++]=e[g];return this.module._JsepOutput(this.opKernelContext,i,a)}catch(a){throw new Error(`Failed to generate kernel's output[${i}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${a}`)}finally{this.module.stackRestore(o)}}},sf=async(i,e,o,a)=>{let d=e.jsepInit;if(!d)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(i==="webgpu"){let g=new di;await g.initialize(o,a),d("webgpu",[g,h=>g.alloc(h),h=>g.free(h),(h,et,ot,it=!1)=>{if(it)Ne("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${h}, dst=${et}, size=${ot}`),g.memcpy(h,et);else{Ne("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${h}, gpuDataId=${et}, size=${ot}`);let $=e.HEAPU8.subarray(h>>>0,(h>>>0)+ot);g.upload(et,$)}},async(h,et,ot)=>{Ne("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${h}, dataOffset=${et}, size=${ot}`),await g.download(h,()=>e.HEAPU8.subarray(et>>>0,(et>>>0)+ot))},(h,et,ot)=>g.createKernel(h,et,ot,e.UTF8ToString(e._JsepGetNodeName(et))),h=>g.releaseKernel(h),(h,et,ot,it)=>{Ne("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${ot}, kernel=${h}, contextDataOffset=${et}`);let $=new _a(e,g,et);return g.computeKernel(h,$,it)},()=>g.captureBegin(),()=>g.captureEnd(),()=>g.replay()])}else d("webnn")}}),uf,kd,Od,hr,lf,xa,Pd,Rd,Ed,zd,Bd,Dd,Md=j(()=>{jo(),Yo(),ye(),Or(),Wn(),qi(),uf=(i,e)=>{Fe()._OrtInit(i,e)!==0&&We("Can't initialize onnxruntime.")},kd=async i=>{uf(i.wasm.numThreads,en(i.logLevel))},Od=async(i,e)=>{{let o=(Ad(),sr(Td)).init;if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let a=i.webgpu.adapter;if(a){if(typeof a.limits!="object"||typeof a.features!="object"||typeof a.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let d=i.webgpu.powerPreference;if(d!==void 0&&d!=="low-power"&&d!=="high-performance")throw new Error(`Invalid powerPreference setting: "${d}"`);let g=i.webgpu.forceFallbackAdapter;if(g!==void 0&&typeof g!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${g}"`);if(a=await navigator.gpu.requestAdapter({powerPreference:d,forceFallbackAdapter:g}),!a)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}if(!i.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");await o("webgpu",Fe(),i,a)}if(e==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await o("webnn",Fe(),i)}}},hr=new Map,lf=i=>{let e=Fe(),o=e.stackSave();try{let a=e.stackAlloc(8);return e._OrtGetInputOutputCount(i,a,a+4)!==0&&We("Can't get session input/output count."),[e.HEAP32[a/4],e.HEAP32[a/4+1]]}finally{e.stackRestore(o)}},xa=i=>{let e=Fe(),o=e._malloc(i.byteLength);if(o===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${i.byteLength}.`);return e.HEAPU8.set(i,o),[o,i.byteLength]},Pd=async(i,e)=>{var c,s;let o,a,d=Fe();Array.isArray(i)?[o,a]=i:i.buffer===d.HEAPU8.buffer?[o,a]=[i.byteOffset,i.byteLength]:[o,a]=xa(i);let g=0,h=0,et=0,ot=[],it=[],$=[];try{if([h,ot]=Ko(e),(e==null?void 0:e.externalData)&&d.mountExternalData){let mt=[];for(let bt of e.externalData){let $t=typeof bt=="string"?bt:bt.path;mt.push(tn(typeof bt=="string"?bt:bt.data).then(Ct=>{d.mountExternalData($t,Ct)}))}await Promise.all(mt)}g=await d._OrtCreateSession(o,a,h),g===0&&We("Can't create a session.");let[_,b]=lf(g),st=!!(e!=null&&e.enableGraphCapture),dt=[],ct=[],pt=[];for(let mt=0;mt<_;mt++){let bt=d._OrtGetInputName(g,mt);bt===0&&We("Can't get an input name."),it.push(bt),dt.push(d.UTF8ToString(bt))}for(let mt=0;mt<b;mt++){let bt=d._OrtGetOutputName(g,mt);bt===0&&We("Can't get an output name."),$.push(bt);let $t=d.UTF8ToString(bt);ct.push($t);{if(st&&(e==null?void 0:e.preferredOutputLocation)===void 0){pt.push("gpu-buffer");continue}let Ct=typeof(e==null?void 0:e.preferredOutputLocation)=="string"?e.preferredOutputLocation:((c=e==null?void 0:e.preferredOutputLocation)==null?void 0:c[$t])??"cpu";if(Ct!=="cpu"&&Ct!=="cpu-pinned"&&Ct!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${Ct}.`);if(st&&Ct!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${Ct}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);pt.push(Ct)}}let ft=null;return pt.some(mt=>mt==="gpu-buffer")&&(et=d._OrtCreateBinding(g),et===0&&We("Can't create IO binding."),ft={handle:et,outputPreferredLocations:pt,outputPreferredLocationsEncoded:pt.map(mt=>Fi(mt))}),hr.set(g,[g,it,$,ft,st,!1]),[g,dt,ct]}catch(_){throw it.forEach(b=>d._OrtFree(b)),$.forEach(b=>d._OrtFree(b)),et!==0&&d._OrtReleaseBinding(et),g!==0&&d._OrtReleaseSession(g),_}finally{d._free(o),h!==0&&d._OrtReleaseSessionOptions(h),ot.forEach(_=>d._free(_)),(s=d.unmountExternalData)==null||s.call(d)}},Rd=i=>{var ot;let e=Fe(),o=hr.get(i);if(!o)throw new Error(`cannot release session. invalid session id: ${i}`);let[a,d,g,h,et]=o;h&&(et&&e._OrtClearBoundOutputs(h.handle),e._OrtReleaseBinding(h.handle)),(ot=e.jsepOnReleaseSession)==null||ot.call(e,i),d.forEach(it=>e._OrtFree(it)),g.forEach(it=>e._OrtFree(it)),e._OrtReleaseSession(a),hr.delete(i)},Ed=(i,e,o,a,d,g=!1)=>{if(!i){e.push(0);return}let h=Fe(),et=i[0],ot=i[1],it=i[3],$,c;if(et==="string"&&it==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(g&&it!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${d} when enableGraphCapture is true.`);if(it==="gpu-buffer"){let b=i[2].gpuBuffer,st=cr(Li(et));c=ot.reduce((ct,pt)=>ct*pt,1)*st;let dt=h.jsepRegisterBuffer;if(!dt)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');$=dt(a,d,b,c)}else{let b=i[2];if(Array.isArray(b)){c=4*b.length,$=h._malloc(c),o.push($);let st=$/4;for(let dt=0;dt<b.length;dt++){if(typeof b[dt]!="string")throw new TypeError(`tensor data at index ${dt} is not a string`);h.HEAPU32[st++]=qe(b[dt],o)}}else c=b.byteLength,$=h._malloc(c),o.push($),h.HEAPU8.set(new Uint8Array(b.buffer,b.byteOffset,c),$)}let s=h.stackSave(),_=h.stackAlloc(4*ot.length);try{let b=_/4;ot.forEach(dt=>h.HEAP32[b++]=dt);let st=h._OrtCreateTensor(Li(et),$,c,_,ot.length,Fi(it));st===0&&We(`Can't create tensor for input/output. session=${a}, index=${d}.`),e.push(st)}finally{h.stackRestore(s)}},zd=async(i,e,o,a,d,g)=>{var jt,dn;let h=Fe(),et=hr.get(i);if(!et)throw new Error(`cannot run inference. invalid session id: ${i}`);let ot=et[0],it=et[1],$=et[2],c=et[3],s=et[4],_=et[5],b=e.length,st=a.length,dt=0,ct=[],pt=[],ft=[],mt=[],bt=h.stackSave(),$t=h.stackAlloc(b*4),Ct=h.stackAlloc(b*4),It=h.stackAlloc(st*4),Tt=h.stackAlloc(st*4);try{[dt,ct]=qo(g);for(let _n=0;_n<b;_n++)Ed(o[_n],pt,mt,i,e[_n],s);for(let _n=0;_n<st;_n++)Ed(d[_n],ft,mt,i,b+a[_n],s);let yn=$t/4,mn=Ct/4,fn=It/4,un=Tt/4;for(let _n=0;_n<b;_n++)h.HEAPU32[yn++]=pt[_n],h.HEAPU32[mn++]=it[e[_n]];for(let _n=0;_n<st;_n++)h.HEAPU32[fn++]=ft[_n],h.HEAPU32[un++]=$[a[_n]];if(c&&!_){let{handle:_n,outputPreferredLocations:vn,outputPreferredLocationsEncoded:Sn}=c;if(it.length!==b)throw new Error(`input count from feeds (${b}) is expected to be always equal to model's input count (${it.length}).`);for(let hn=0;hn<b;hn++){let rr=e[hn];await h._OrtBindInput(_n,it[rr],pt[hn])!==0&&We(`Can't bind input[${hn}] for session=${i}.`)}for(let hn=0;hn<st;hn++){let rr=a[hn];(jt=d[hn])!=null&&jt[3]?h._OrtBindOutput(_n,$[rr],ft[hn],0)!==0&&We(`Can't bind pre-allocated output[${hn}] for session=${i}.`):h._OrtBindOutput(_n,$[rr],0,Sn[rr])!==0&&We(`Can't bind output[${hn}] to ${vn[hn]} for session=${i}.`)}hr.set(i,[ot,it,$,c,s,!0])}(dn=h.jsepOnRunStart)==null||dn.call(h,ot);let Wt;c?Wt=await h._OrtRunWithBinding(ot,c.handle,st,It,dt):Wt=await h._OrtRun(ot,Ct,$t,b,Tt,st,It,dt),Wt!==0&&We("failed to call OrtRun().");let Jt=[];for(let _n=0;_n<st;_n++){let vn=h.HEAPU32[It/4+_n];if(vn===ft[_n]){Jt.push(d[_n]);continue}let Sn=h.stackSave(),hn=h.stackAlloc(4*4),rr=!1,vr,Ir=0;try{h._OrtGetTensorData(vn,hn,hn+4,hn+8,hn+12)!==0&&We(`Can't access output tensor data on index ${_n}.`);let $r=hn/4,Ur=h.HEAPU32[$r++];Ir=h.HEAPU32[$r++];let Yr=h.HEAPU32[$r++],r0=h.HEAPU32[$r++],b0=[];for(let _i=0;_i<r0;_i++)b0.push(h.HEAPU32[Yr/4+_i]);h._OrtFree(Yr);let t0=b0.reduce((_i,Po)=>_i*Po,1);vr=Kt(Ur);let l0=c==null?void 0:c.outputPreferredLocations[a[_n]];if(vr==="string"){if(l0==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let _i=[],Po=Ir/4;for(let vm=0;vm<t0;vm++){let s0=h.HEAPU32[Po++],k0=vm===t0-1?void 0:h.HEAPU32[Po]-s0;_i.push(h.UTF8ToString(s0,k0))}Jt.push([vr,b0,_i,"cpu"])}else if(l0==="gpu-buffer"&&t0>0){let _i=h.jsepGetBuffer;if(!_i)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Po=_i(Ir),vm=cr(Ur);if(vm===void 0||!Vn(vr))throw new Error(`Unsupported data type: ${vr}`);rr=!0,Jt.push([vr,b0,{gpuBuffer:Po,download:h.jsepCreateDownloader(Po,t0*vm,vr),dispose:()=>{h._OrtReleaseTensor(vn)}},"gpu-buffer"])}else{let _i=Nn(vr),Po=new _i(t0);new Uint8Array(Po.buffer,Po.byteOffset,Po.byteLength).set(h.HEAPU8.subarray(Ir,Ir+Po.byteLength)),Jt.push([vr,b0,Po,"cpu"])}}finally{h.stackRestore(Sn),vr==="string"&&Ir&&h._free(Ir),rr||h._OrtReleaseTensor(vn)}}return c&&!s&&(h._OrtClearBoundOutputs(c.handle),hr.set(i,[ot,it,$,c,s,!1])),Jt}finally{h.stackRestore(bt),pt.forEach(yn=>h._OrtReleaseTensor(yn)),ft.forEach(yn=>h._OrtReleaseTensor(yn)),mt.forEach(yn=>h._free(yn)),dt!==0&&h._OrtReleaseRunOptions(dt),ct.forEach(yn=>h._free(yn))}},Bd=i=>{let e=Fe(),o=hr.get(i);if(!o)throw new Error("invalid session id");let a=o[0],d=e._OrtEndProfiling(a);d===0&&We("Can't get an profile file name."),e._OrtFree(d)},Dd=i=>{let e=[];for(let o of i){let a=o[2];!Array.isArray(a)&&"buffer"in a&&e.push(a.buffer)}return e}}),Ud=Er((i,e)=>{e.exports='/*!\n * ONNX Runtime Web v1.19.0-dev.20240509-69cfcba38a\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var ao=Object.defineProperty;var nl=Object.getOwnPropertyDescriptor;var ol=Object.getOwnPropertyNames;var il=Object.prototype.hasOwnProperty;var Y=(e,t)=>()=>(e&&(t=e(e=0)),t);var Wr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),gn=(e,t)=>{for(var r in t)ao(e,r,{get:t[r],enumerable:!0})},al=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of ol(t))!il.call(e,i)&&i!==r&&ao(e,i,{get:()=>t[i],enumerable:!(o=nl(t,i))||o.enumerable});return e};var wr=e=>al(ao({},"__esModule",{value:!0}),e);var so={};gn(so,{createReadStream:()=>Ai,readFile:()=>sl,readFileSync:()=>ul});var sl,ul,Ai,uo=Y(()=>{sl=void 0,ul=void 0,Ai=void 0});var lo={};gn(lo,{join:()=>dl});var dl,co=Y(()=>{dl=void 0});var Ei=Wr((Ti,po)=>{"use strict";var Ii=(()=>{var e=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(e||=__filename),function(t={}){var r=t,o,i,u=new Promise((s,m)=>{o=s,i=m});r.mountExternalData=(s,m)=>{(r.eb||(r.eb=new Map)).set(s,m)},r.unmountExternalData=()=>{delete r.eb};let a=()=>{let s=(g,$,T)=>(...B)=>{let L=dt,q=$?.();B=g(...B);let te=$?.();return q!==te&&(g=te,T(q),$=T=null),dt!=L?tn():B},m=g=>async(...$)=>{try{if(r.cb)throw Error("Session already started");let T=r.cb={xb:$[0],errors:[]},B=await g(...$);if(r.cb!==T)throw Error("Session mismatch");r.kb?.flush();let L=T.errors;if(0<L.length){let q=await Promise.all(L);if(q=q.filter(te=>te),0<q.length)throw Error(q.join(`\n`))}return B}finally{r.cb=null}};r._OrtCreateSession=s(r._OrtCreateSession,()=>r._OrtCreateSession,g=>r._OrtCreateSession=g),r._OrtRun=m(s(r._OrtRun,()=>r._OrtRun,g=>r._OrtRun=g)),r._OrtRunWithBinding=m(s(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,g=>r._OrtRunWithBinding=g)),r._OrtBindInput=s(r._OrtBindInput,()=>r._OrtBindInput,g=>r._OrtBindInput=g),a=void 0};r.jsepInit=(s,m)=>{if(a?.(),s==="webgpu"){[r.kb,r.pb,r.tb,r.lb,r.sb,r.Ra,r.ub,r.wb,r.qb,r.rb,r.vb]=m;let g=r.kb;r.jsepRegisterBuffer=($,T,B,L)=>g.registerBuffer($,T,B,L),r.jsepGetBuffer=$=>g.getBuffer($),r.jsepCreateDownloader=($,T,B)=>g.createDownloader($,T,B),r.jsepOnReleaseSession=$=>{g.onReleaseSession($)},r.jsepOnRunStart=$=>g.onRunStart($)}};var c=Object.assign({},r),p="./this.program",h=(s,m)=>{throw m},d=typeof window=="object",y=typeof importScripts=="function",w=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",_="",v,S,I;if(w){var A=(uo(),wr(so)),x=(co(),wr(lo));_=y?x.dirname(_)+"/":__dirname+"/",v=(s,m)=>(s=Ke(s)?new URL(s):x.normalize(s),A.readFileSync(s,m?void 0:"utf8")),I=s=>(s=v(s,!0),s.buffer||(s=new Uint8Array(s)),s),S=(s,m,g,$=!0)=>{s=Ke(s)?new URL(s):x.normalize(s),A.readFile(s,$?void 0:"utf8",(T,B)=>{T?g(T):m($?B.buffer:B)})},!r.thisProgram&&1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),h=(s,m)=>{throw process.exitCode=s,m}}else(d||y)&&(y?_=self.location.href:typeof document<"u"&&document.currentScript&&(_=document.currentScript.src),e&&(_=e),_.startsWith("blob:")?_="":_=_.substr(0,_.replace(/[?#].*/,"").lastIndexOf("/")+1),v=s=>{var m=new XMLHttpRequest;return m.open("GET",s,!1),m.send(null),m.responseText},y&&(I=s=>{var m=new XMLHttpRequest;return m.open("GET",s,!1),m.responseType="arraybuffer",m.send(null),new Uint8Array(m.response)}),S=(s,m,g)=>{var $=new XMLHttpRequest;$.open("GET",s,!0),$.responseType="arraybuffer",$.onload=()=>{$.status==200||$.status==0&&$.response?m($.response):g()},$.onerror=g,$.send(null)});var E=console.log.bind(console),P=console.error.bind(console);Object.assign(r,c),c=null;var O,R=!1,H,N,K,Q,he,W,se,Ce,We,ee,ae;function Ae(){var s=O.buffer;r.HEAP8=N=new Int8Array(s),r.HEAP16=Q=new Int16Array(s),r.HEAPU8=K=new Uint8Array(s),r.HEAPU16=he=new Uint16Array(s),r.HEAP32=W=new Int32Array(s),r.HEAPU32=se=new Uint32Array(s),r.HEAPF32=Ce=new Float32Array(s),r.HEAPF64=ae=new Float64Array(s),r.HEAP64=We=new BigInt64Array(s),r.HEAPU64=ee=new BigUint64Array(s)}var me=[],ie=[],ue=[],le=0,qe=null,G=null;function ne(s){throw s="Aborted("+s+")",P(s),R=!0,H=1,s=new WebAssembly.RuntimeError(s+". Build with -sASSERTIONS for more info."),i(s),s}var xe=s=>s.startsWith("data:application/octet-stream;base64,"),Ke=s=>s.startsWith("file://"),De;if(De="ort-wasm-simd.wasm",!xe(De)){var Ge=De;De=r.locateFile?r.locateFile(Ge,_):_+Ge}function Mt(s){if(I)return I(s);throw"both async and sync fetching of the wasm failed"}function Ne(s){if(d||y){if(typeof fetch=="function"&&!Ke(s))return fetch(s,{credentials:"same-origin"}).then(m=>{if(!m.ok)throw`failed to load wasm binary file at \'${s}\'`;return m.arrayBuffer()}).catch(()=>Mt(s));if(S)return new Promise((m,g)=>{S(s,$=>m(new Uint8Array($)),g)})}return Promise.resolve().then(()=>Mt(s))}function Ye(s,m,g){return Ne(s).then($=>WebAssembly.instantiate($,m)).then(g,$=>{P(`failed to asynchronously prepare wasm: ${$}`),ne($)})}function mt(s,m){var g=De;return typeof WebAssembly.instantiateStreaming!="function"||xe(g)||Ke(g)||w||typeof fetch!="function"?Ye(g,s,m):fetch(g,{credentials:"same-origin"}).then($=>WebAssembly.instantiateStreaming($,s).then(m,function(T){return P(`wasm streaming compile failed: ${T}`),P("falling back to ArrayBuffer instantiation"),Ye(g,s,m)}))}var Ot={824936:(s,m,g,$)=>{if(typeof r>"u"||!r.eb)return 1;if(s=je(s>>>0),s.startsWith("./")&&(s=s.substring(2)),s=r.eb.get(s),!s)return 2;if(m>>>=0,g>>>=0,m+g>s.byteLength)return 3;try{return K.set(s.subarray(m,m+g),$>>>0>>>0),0}catch{return 4}},825437:()=>{r.qb()},825468:()=>{r.rb()},825497:()=>{r.vb()},825522:s=>r.pb(s),825555:s=>r.tb(s),825587:(s,m,g)=>{r.lb(s,m,g,!0)},825626:(s,m,g)=>{r.lb(s,m,g)},825659:s=>{r.Ra("Abs",s,void 0)},825710:s=>{r.Ra("Neg",s,void 0)},825761:s=>{r.Ra("Floor",s,void 0)},825814:s=>{r.Ra("Ceil",s,void 0)},825866:s=>{r.Ra("Reciprocal",s,void 0)},825924:s=>{r.Ra("Sqrt",s,void 0)},825976:s=>{r.Ra("Exp",s,void 0)},826027:s=>{r.Ra("Erf",s,void 0)},826078:s=>{r.Ra("Sigmoid",s,void 0)},826133:(s,m,g)=>{r.Ra("HardSigmoid",s,{alpha:m,beta:g})},826212:s=>{r.Ra("Log",s,void 0)},826263:s=>{r.Ra("Sin",s,void 0)},826314:s=>{r.Ra("Cos",s,void 0)},826365:s=>{r.Ra("Tan",s,void 0)},826416:s=>{r.Ra("Asin",s,void 0)},826468:s=>{r.Ra("Acos",s,void 0)},826520:s=>{r.Ra("Atan",s,void 0)},826572:s=>{r.Ra("Sinh",s,void 0)},826624:s=>{r.Ra("Cosh",s,void 0)},826676:s=>{r.Ra("Asinh",s,void 0)},826729:s=>{r.Ra("Acosh",s,void 0)},826782:s=>{r.Ra("Atanh",s,void 0)},826835:s=>{r.Ra("Tanh",s,void 0)},826887:s=>{r.Ra("Not",s,void 0)},826938:(s,m,g)=>{r.Ra("Clip",s,{min:m,max:g})},827007:s=>{r.Ra("Clip",s,void 0)},827059:(s,m)=>{r.Ra("Elu",s,{alpha:m})},827117:s=>{r.Ra("Relu",s,void 0)},827169:(s,m)=>{r.Ra("LeakyRelu",s,{alpha:m})},827233:(s,m)=>{r.Ra("ThresholdedRelu",s,{alpha:m})},827303:(s,m)=>{r.Ra("Cast",s,{to:m})},827361:s=>{r.Ra("Add",s,void 0)},827412:s=>{r.Ra("Sub",s,void 0)},827463:s=>{r.Ra("Mul",s,void 0)},827514:s=>{r.Ra("Div",s,void 0)},827565:s=>{r.Ra("Pow",s,void 0)},827616:s=>{r.Ra("Equal",s,void 0)},827669:s=>{r.Ra("Greater",s,void 0)},827724:s=>{r.Ra("GreaterOrEqual",s,void 0)},827786:s=>{r.Ra("Less",s,void 0)},827838:s=>{r.Ra("LessOrEqual",s,void 0)},827897:(s,m,g,$,T)=>{r.Ra("ReduceMean",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828056:(s,m,g,$,T)=>{r.Ra("ReduceMax",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828214:(s,m,g,$,T)=>{r.Ra("ReduceMin",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828372:(s,m,g,$,T)=>{r.Ra("ReduceProd",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828531:(s,m,g,$,T)=>{r.Ra("ReduceSum",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828689:(s,m,g,$,T)=>{r.Ra("ReduceL1",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},828846:(s,m,g,$,T)=>{r.Ra("ReduceL2",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},829003:(s,m,g,$,T)=>{r.Ra("ReduceLogSum",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},829164:(s,m,g,$,T)=>{r.Ra("ReduceSumSquare",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},829328:(s,m,g,$,T)=>{r.Ra("ReduceLogSumExp",s,{keepDims:!!m,noopWithEmptyAxes:!!g,axes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},829492:s=>{r.Ra("Where",s,void 0)},829545:(s,m,g)=>{r.Ra("Transpose",s,{perm:m?Array.from(W.subarray(m>>>0,g>>>0)):[]})},829653:(s,m,g,$)=>{r.Ra("DepthToSpace",s,{blocksize:m,mode:je(g),format:$?"NHWC":"NCHW"})},829786:(s,m,g,$)=>{r.Ra("DepthToSpace",s,{blocksize:m,mode:je(g),format:$?"NHWC":"NCHW"})},829919:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be)=>{r.Ra("ConvTranspose",s,{format:te?"NHWC":"NCHW",autoPad:m,dilations:[g],group:$,kernelShape:[T],pads:[B,L],strides:[q],wIsConst:()=>!!N[X>>>0],outputPadding:de?Array.from(W.subarray(de>>>0,Ee>>>0)):[],outputShape:Oe?Array.from(W.subarray(Oe>>>0,D>>>0)):[],activation:je(be)})},830320:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D)=>{r.Ra("ConvTranspose",s,{format:q?"NHWC":"NCHW",autoPad:m,dilations:Array.from(W.subarray(g>>>0,(g>>>0)+2>>>0)),group:$,kernelShape:Array.from(W.subarray(T>>>0,(T>>>0)+2>>>0)),pads:Array.from(W.subarray(B>>>0,(B>>>0)+4>>>0)),strides:Array.from(W.subarray(L>>>0,(L>>>0)+2>>>0)),wIsConst:()=>!!N[te>>>0],outputPadding:X?Array.from(W.subarray(X>>>0,de>>>0)):[],outputShape:Ee?Array.from(W.subarray(Ee>>>0,Oe>>>0)):[],activation:je(D)})},830885:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be)=>{r.Ra("ConvTranspose",s,{format:te?"NHWC":"NCHW",autoPad:m,dilations:[g],group:$,kernelShape:[T],pads:[B,L],strides:[q],wIsConst:()=>!!N[X>>>0],outputPadding:de?Array.from(W.subarray(de>>>0,Ee>>>0)):[],outputShape:Oe?Array.from(W.subarray(Oe>>>0,D>>>0)):[],activation:je(be)})},831286:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D)=>{r.Ra("ConvTranspose",s,{format:q?"NHWC":"NCHW",autoPad:m,dilations:Array.from(W.subarray(g>>>0,(g>>>0)+2>>>0)),group:$,kernelShape:Array.from(W.subarray(T>>>0,(T>>>0)+2>>>0)),pads:Array.from(W.subarray(B>>>0,(B>>>0)+4>>>0)),strides:Array.from(W.subarray(L>>>0,(L>>>0)+2>>>0)),wIsConst:()=>!!N[te>>>0],outputPadding:X?Array.from(W.subarray(X>>>0,de>>>0)):[],outputShape:Ee?Array.from(W.subarray(Ee>>>0,Oe>>>0)):[],activation:je(D)})},831851:(s,m)=>{r.Ra("GlobalAveragePool",s,{format:m?"NHWC":"NCHW"})},831942:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("AveragePool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,L],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},832226:(s,m)=>{r.Ra("GlobalAveragePool",s,{format:m?"NHWC":"NCHW"})},832317:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("AveragePool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,L],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},832601:(s,m)=>{r.Ra("GlobalMaxPool",s,{format:m?"NHWC":"NCHW"})},832688:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("MaxPool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,L],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},832968:(s,m)=>{r.Ra("GlobalMaxPool",s,{format:m?"NHWC":"NCHW"})},833055:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("MaxPool",s,{format:Ie?"NHWC":"NCHW",auto_pad:m,ceil_mode:g,count_include_pad:$,storage_order:T,dilations:[B,L],kernel_shape:[q,te],pads:[X,de,Ee,Oe],strides:[D,be]})},833335:(s,m,g,$,T)=>{r.Ra("Gemm",s,{alpha:m,beta:g,transA:$,transB:T})},833439:s=>{r.Ra("MatMul",s,void 0)},833493:(s,m,g,$)=>{r.Ra("ArgMax",s,{keepDims:!!m,selectLastIndex:!!g,axis:$})},833601:(s,m,g,$)=>{r.Ra("ArgMin",s,{keepDims:!!m,selectLastIndex:!!g,axis:$})},833709:(s,m)=>{r.Ra("Softmax",s,{axis:m})},833772:(s,m)=>{r.Ra("Concat",s,{axis:m})},833832:(s,m,g,$,T)=>{r.Ra("Split",s,{axis:m,numOutputs:g,splitSizes:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},833972:s=>{r.Ra("Expand",s,void 0)},834026:(s,m)=>{r.Ra("Gather",s,{axis:Number(m)})},834097:(s,m)=>{r.Ra("GatherElements",s,{axis:Number(m)})},834176:(s,m,g,$,T,B,L,q,te,X,de)=>{r.Ra("Resize",s,{antialias:m,axes:g?Array.from(W.subarray(g>>>0,$>>>0)):[],coordinateTransformMode:je(T),cubicCoeffA:B,excludeOutside:L,extrapolationValue:q,keepAspectRatioPolicy:je(te),mode:je(X),nearestMode:je(de)})},834522:(s,m,g,$,T,B,L)=>{r.Ra("Slice",s,{starts:m?Array.from(W.subarray(m>>>0,g>>>0)):[],ends:$?Array.from(W.subarray($>>>0,T>>>0)):[],axes:B?Array.from(W.subarray(B>>>0,L>>>0)):[]})},834738:s=>{r.Ra("Tile",s,void 0)},834790:(s,m,g,$)=>{r.Ra("LayerNormalization",s,{axis:m,epsilon:g,simplified:!!$})},834901:(s,m,g)=>{r.Ra("InstanceNormalization",s,{epsilon:m,format:g?"NHWC":"NCHW"})},835015:(s,m,g)=>{r.Ra("InstanceNormalization",s,{epsilon:m,format:g?"NHWC":"NCHW"})},835129:s=>{r.Ra("Range",s,void 0)},835182:(s,m)=>{r.Ra("Einsum",s,{equation:je(m)})},835263:(s,m,g,$,T)=>{r.Ra("Pad",s,{mode:m,value:g,pads:$?Array.from(W.subarray($>>>0,T>>>0)):[]})},835390:(s,m,g,$,T,B)=>{r.Ra("BatchNormalization",s,{epsilon:m,momentum:g,spatial:!!T,trainingMode:!!$,format:B?"NHWC":"NCHW"})},835559:(s,m,g,$,T,B)=>{r.Ra("BatchNormalization",s,{epsilon:m,momentum:g,spatial:!!T,trainingMode:!!$,format:B?"NHWC":"NCHW"})},835728:(s,m,g)=>{r.Ra("CumSum",s,{exclusive:Number(m),reverse:Number(g)})},835825:(s,m,g,$,T,B,L,q,te)=>{r.Ra("Attention",s,{numHeads:m,isUnidirectional:g,maskFilterValue:$,scale:T,doRotary:B,qkvHiddenSizes:L?Array.from(W.subarray(Number(q)>>>0,Number(q)+L>>>0)):[],pastPresentShareBuffer:!!te})},836097:s=>{r.Ra("BiasAdd",s,void 0)},836152:s=>{r.Ra("BiasSplitGelu",s,void 0)},836213:s=>{r.Ra("FastGelu",s,void 0)},836269:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe)=>{r.Ra("Conv",s,{format:te?"NHWC":"NCHW",auto_pad:m,dilations:[g],group:$,kernel_shape:[T],pads:B?Array.from(W.subarray(B>>>0,L>>>0)):[],strides:[q],w_is_const:()=>!!N[X>>>0],activation:je(de),activation_params:Ee?Array.from(Ce.subarray(Ee>>>0,Oe>>>0)):[]})},836639:(s,m,g,$,T,B,L,q,te,X,de,Ee,Oe,D,be,Ie)=>{r.Ra("Conv",s,{format:Ee?"NHWC":"NCHW",auto_pad:m,dilations:[g,$],group:T,kernel_shape:[B,L],pads:q?Array.from(W.subarray(q>>>0,te>>>0)):[],strides:[X,de],w_is_const:()=>!!N[Oe>>>0],activation:je(D),activation_params:be?Array.from(Ce.subarray(be>>>0,Ie>>>0)):[]})},837030:s=>{r.Ra("Gelu",s,void 0)},837082:(s,m,g,$,T,B)=>{r.Ra("MatMulNBits",s,{k:m,n:g,accuracyLevel:$,bits:T,blockSize:B})},837209:(s,m,g,$,T,B)=>{r.Ra("MultiHeadAttention",s,{numHeads:m,isUnidirectional:g,maskFilterValue:$,scale:T,doRotary:B})},837368:(s,m,g,$,T)=>{r.Ra("RotaryEmbedding",s,{interleaved:!!m,numHeads:g,rotaryEmbeddingDim:$,scale:T})},837507:(s,m,g)=>{r.Ra("SkipLayerNormalization",s,{epsilon:m,simplified:!!g})},837609:(s,m,g)=>{r.Ra("SkipLayerNormalization",s,{epsilon:m,simplified:!!g})},837711:(s,m,g,$)=>{r.Ra("LayerNormalization",s,{axis:m,epsilon:g,simplified:!!$})},837822:s=>{r.ub(s)},837856:(s,m)=>r.wb(s,m,r.cb.xb,r.cb.errors)};function qt(s){this.name="ExitStatus",this.message=`Program terminated with exit(${s})`,this.status=s}class Ut{constructor(m){this.hb=m-24}}var sr=0,jt=0,xr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Kt=(s,m,g)=>{m>>>=0;var $=m+g;for(g=m;s[g]&&!(g>=$);)++g;if(16<g-m&&s.buffer&&xr)return xr.decode(s.subarray(m,g));for($="";m<g;){var T=s[m++];if(T&128){var B=s[m++]&63;if((T&224)==192)$+=String.fromCharCode((T&31)<<6|B);else{var L=s[m++]&63;T=(T&240)==224?(T&15)<<12|B<<6|L:(T&7)<<18|B<<12|L<<6|s[m++]&63,65536>T?$+=String.fromCharCode(T):(T-=65536,$+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else $+=String.fromCharCode(T)}return $},je=(s,m)=>(s>>>=0)?Kt(K,s,m):"",Vt=s=>{for(var m=0,g=0;g<s.length;++g){var $=s.charCodeAt(g);127>=$?m++:2047>=$?m+=2:55296<=$&&57343>=$?(m+=4,++g):m+=3}return m},at=(s,m,g,$)=>{if(g>>>=0,!(0<$))return 0;var T=g;$=g+$-1;for(var B=0;B<s.length;++B){var L=s.charCodeAt(B);if(55296<=L&&57343>=L){var q=s.charCodeAt(++B);L=65536+((L&1023)<<10)|q&1023}if(127>=L){if(g>=$)break;m[g++>>>0]=L}else{if(2047>=L){if(g+1>=$)break;m[g++>>>0]=192|L>>6}else{if(65535>=L){if(g+2>=$)break;m[g++>>>0]=224|L>>12}else{if(g+3>=$)break;m[g++>>>0]=240|L>>18,m[g++>>>0]=128|L>>12&63}m[g++>>>0]=128|L>>6&63}m[g++>>>0]=128|L&63}}return m[g>>>0]=0,g-T},Cr,ft=s=>{for(var m="";K[s>>>0];)m+=Cr[K[s++>>>0]];return m},ur={},Ar={},Ir={},st;function Tr(s,m,g={}){var $=m.name;if(!s)throw new st(`type "${$}" must have a positive integer typeid pointer`);if(Ar.hasOwnProperty(s)){if(g.nb)return;throw new st(`Cannot register type \'${$}\' twice`)}Ar[s]=m,delete Ir[s],ur.hasOwnProperty(s)&&(m=ur[s],delete ur[s],m.forEach(T=>T()))}function ht(s,m,g={}){if(!("argPackAdvance"in m))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Tr(s,m,g)}var bt=(s,m,g)=>{switch(m){case 1:return g?$=>N[$>>>0]:$=>K[$>>>0];case 2:return g?$=>Q[$>>>1>>>0]:$=>he[$>>>1>>>0];case 4:return g?$=>W[$>>>2>>>0]:$=>se[$>>>2>>>0];case 8:return g?$=>We[$>>>3]:$=>ee[$>>>3];default:throw new TypeError(`invalid integer width (${m}): ${s}`)}},Er=[],Te=[];function dr(s){s>>>=0,9<s&&--Te[s+1]===0&&(Te[s]=void 0,Er.push(s))}var Xe=s=>{if(!s)throw new st("Cannot use deleted val. handle = "+s);return Te[s]},ut=s=>{switch(s){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let m=Er.pop()||Te.length;return Te[m]=s,Te[m+1]=1,m}};function lr(s){return this.fromWireType(se[s>>>2>>>0])}var Fn={name:"emscripten::val",fromWireType:s=>{var m=Xe(s);return dr(s),m},toWireType:(s,m)=>ut(m),argPackAdvance:8,readValueFromPointer:lr,bb:null},ge=(s,m)=>{switch(m){case 4:return function(g){return this.fromWireType(Ce[g>>>2>>>0])};case 8:return function(g){return this.fromWireType(ae[g>>>3>>>0])};default:throw new TypeError(`invalid float width (${m}): ${s}`)}},Yt=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,jr=(s,m)=>{for(var g=s>>1,$=g+m/2;!(g>=$)&&he[g>>>0];)++g;if(g<<=1,32<g-s&&Yt)return Yt.decode(K.subarray(s>>>0,g>>>0));for(g="",$=0;!($>=m/2);++$){var T=Q[s+2*$>>>1>>>0];if(T==0)break;g+=String.fromCharCode(T)}return g},qn=(s,m,g)=>{if(g??=2147483647,2>g)return 0;g-=2;var $=m;g=g<2*s.length?g/2:s.length;for(var T=0;T<g;++T)Q[m>>>1>>>0]=s.charCodeAt(T),m+=2;return Q[m>>>1>>>0]=0,m-$},Kr=s=>2*s.length,jn=(s,m)=>{for(var g=0,$="";!(g>=m/4);){var T=W[s+4*g>>>2>>>0];if(T==0)break;++g,65536<=T?(T-=65536,$+=String.fromCharCode(55296|T>>10,56320|T&1023)):$+=String.fromCharCode(T)}return $},Yr=(s,m,g)=>{if(m>>>=0,g??=2147483647,4>g)return 0;var $=m;g=$+g-4;for(var T=0;T<s.length;++T){var B=s.charCodeAt(T);if(55296<=B&&57343>=B){var L=s.charCodeAt(++T);B=65536+((B&1023)<<10)|L&1023}if(W[m>>>2>>>0]=B,m+=4,m+4>g)break}return W[m>>>2>>>0]=0,m-$},Zr=s=>{for(var m=0,g=0;g<s.length;++g){var $=s.charCodeAt(g);55296<=$&&57343>=$&&++g,m+=4}return m},cr=(s,m)=>{var g=Ar[s];if(g===void 0)throw s=Mr(s),g=ft(s),rt(s),new st(`${m} has unknown type ${g}`);return g},Pr=(s,m,g)=>{var $=[];return s=s.toWireType($,g),$.length&&(se[m>>>2>>>0]=ut($)),s},He=s=>{try{s()}catch(m){ne(m)}},Xr=s=>{if(!R)try{s();try{H=H=s=H,r.onExit?.(s),R=!0,h(s,new qt(s))}catch(m){m instanceof qt||m=="unwind"||h(1,m)}}catch(m){m instanceof qt||m=="unwind"||h(1,m)}};function Qr(){var s=pe,m={};for(let[g,$]of Object.entries(s))m[g]=typeof $=="function"?(...T)=>{Zt.push(g);try{return $(...T)}finally{R||(Zt.pop(),dt&&gt===1&&Zt.length===0&&(gt=0,He(dn),typeof Fibers<"u"&&Fibers.Db()))}}:$;return m}var gt=0,dt=null,Rt=0,Zt=[],kr={},Or={},Jr=0,pr=null,en=[];function tn(){return new Promise((s,m)=>{pr={resolve:s,reject:m}})}function rn(){var s=Wt(65548),m=s+12;se[s>>>2>>>0]=m,se[s+4>>>2>>>0]=m+65536,m=Zt[0];var g=kr[m];return g===void 0&&(g=Jr++,kr[m]=g,Or[g]=m),W[s+8>>>2>>>0]=g,s}function nn(s){if(!R){if(gt===0){var m=!1,g=!1;s(($=0)=>{if(!R&&(Rt=$,m=!0,g)){gt=2,He(()=>vt(dt)),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.resume(),$=!1;try{var T=(0,pe[Or[W[dt+8>>>2>>>0]]])()}catch(q){T=q,$=!0}var B=!1;if(!dt){var L=pr;L&&(pr=null,($?L.reject:L.resolve)(T),B=!0)}if($&&!B)throw T}}),g=!0,m||(gt=1,dt=rn(),typeof Browser<"u"&&Browser.ib.mb&&Browser.ib.pause(),He(()=>Jt(dt)))}else gt===2?(gt=0,He(ct),rt(dt),dt=null,en.forEach(Xr)):ne(`invalid state: ${gt}`);return Rt}}function Rr(s){return nn(m=>{s().then(m)})}var Xt=[],on={},nt=s=>{var m=on[s];return m===void 0?ft(s):m},mr=()=>typeof globalThis=="object"?globalThis:Function("return this")(),Br=s=>{var m=Xt.length;return Xt.push(s),m},Kn=(s,m)=>{for(var g=Array(s),$=0;$<s;++$)g[$]=cr(se[m+4*$>>>2>>>0],"parameter "+$);return g},wt=(s,m)=>Object.defineProperty(m,"name",{value:s});function Yn(s){var m=Function;if(!(m instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof m} which is not a function`);var g=wt(m.name||"unknownFunctionName",function(){});return g.prototype=m.prototype,g=new g,s=m.apply(g,s),s instanceof Object?s:g}var Je=s=>s%4===0&&(s%100!==0||s%400===0),Dr=[0,31,60,91,121,152,182,213,244,274,305,335],fr=[0,31,59,90,120,151,181,212,243,273,304,334],lt=[],hr=(s,m)=>{lt.length=0;for(var g;g=K[s++>>>0];){var $=g!=105;$&=g!=112,m+=$&&m%8?4:0,lt.push(g==112?se[m>>>2>>>0]:g==106?We[m>>>3]:g==105?W[m>>>2>>>0]:ae[m>>>3>>>0]),m+=$?8:4}return lt},Qe={},ot=()=>{if(!Qt){var s={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"},m;for(m in Qe)Qe[m]===void 0?delete s[m]:s[m]=Qe[m];var g=[];for(m in s)g.push(`${m}=${s[m]}`);Qt=g}return Qt},Qt,Zn=[null,[],[]],an=[31,29,31,30,31,30,31,31,30,31,30,31],zr=[31,28,31,30,31,30,31,31,30,31,30,31];function Xn(s){var m=Array(Vt(s)+1);return at(s,m,0,m.length),m}function sn(s,m,g,$){function T(D,be,Ie){for(D=typeof D=="number"?D.toString():D||"";D.length<be;)D=Ie[0]+D;return D}function B(D,be){return T(D,be,"0")}function L(D,be){function Ie(zt){return 0>zt?-1:0<zt?1:0}var Dt;return(Dt=Ie(D.getFullYear()-be.getFullYear()))===0&&(Dt=Ie(D.getMonth()-be.getMonth()))===0&&(Dt=Ie(D.getDate()-be.getDate())),Dt}function q(D){switch(D.getDay()){case 0:return new Date(D.getFullYear()-1,11,29);case 1:return D;case 2:return new Date(D.getFullYear(),0,3);case 3:return new Date(D.getFullYear(),0,2);case 4:return new Date(D.getFullYear(),0,1);case 5:return new Date(D.getFullYear()-1,11,31);case 6:return new Date(D.getFullYear()-1,11,30)}}function te(D){var be=D.$a;for(D=new Date(new Date(D.ab+1900,0,1).getTime());0<be;){var Ie=D.getMonth(),Dt=(Je(D.getFullYear())?an:zr)[Ie];if(be>Dt-D.getDate())be-=Dt-D.getDate()+1,D.setDate(1),11>Ie?D.setMonth(Ie+1):(D.setMonth(0),D.setFullYear(D.getFullYear()+1));else{D.setDate(D.getDate()+be);break}}return Ie=new Date(D.getFullYear()+1,0,4),be=q(new Date(D.getFullYear(),0,4)),Ie=q(Ie),0>=L(be,D)?0>=L(Ie,D)?D.getFullYear()+1:D.getFullYear():D.getFullYear()-1}s>>>=0,m>>>=0,g>>>=0,$>>>=0;var X=se[$+40>>>2>>>0];$={Ab:W[$>>>2>>>0],zb:W[$+4>>>2>>>0],fb:W[$+8>>>2>>>0],jb:W[$+12>>>2>>>0],gb:W[$+16>>>2>>>0],ab:W[$+20>>>2>>>0],Va:W[$+24>>>2>>>0],$a:W[$+28>>>2>>>0],Cb:W[$+32>>>2>>>0],yb:W[$+36>>>2>>>0],Bb:X?je(X):""},g=je(g),X={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var de in X)g=g.replace(new RegExp(de,"g"),X[de]);var Ee="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Oe="January February March April May June July August September October November December".split(" ");X={"%a":D=>Ee[D.Va].substring(0,3),"%A":D=>Ee[D.Va],"%b":D=>Oe[D.gb].substring(0,3),"%B":D=>Oe[D.gb],"%C":D=>B((D.ab+1900)/100|0,2),"%d":D=>B(D.jb,2),"%e":D=>T(D.jb,2," "),"%g":D=>te(D).toString().substring(2),"%G":te,"%H":D=>B(D.fb,2),"%I":D=>(D=D.fb,D==0?D=12:12<D&&(D-=12),B(D,2)),"%j":D=>{for(var be=0,Ie=0;Ie<=D.gb-1;be+=(Je(D.ab+1900)?an:zr)[Ie++]);return B(D.jb+be,3)},"%m":D=>B(D.gb+1,2),"%M":D=>B(D.zb,2),"%n":()=>`\n`,"%p":D=>0<=D.fb&&12>D.fb?"AM":"PM","%S":D=>B(D.Ab,2),"%t":()=>"	","%u":D=>D.Va||7,"%U":D=>B(Math.floor((D.$a+7-D.Va)/7),2),"%V":D=>{var be=Math.floor((D.$a+7-(D.Va+6)%7)/7);if(2>=(D.Va+371-D.$a-2)%7&&be++,be)be==53&&(Ie=(D.Va+371-D.$a)%7,Ie==4||Ie==3&&Je(D.ab)||(be=1));else{be=52;var Ie=(D.Va+7-D.$a-1)%7;(Ie==4||Ie==5&&Je(D.ab%400-1))&&be++}return B(be,2)},"%w":D=>D.Va,"%W":D=>B(Math.floor((D.$a+7-(D.Va+6)%7)/7),2),"%y":D=>(D.ab+1900).toString().substring(2),"%Y":D=>D.ab+1900,"%z":D=>{D=D.yb;var be=0<=D;return D=Math.abs(D)/60,(be?"+":"-")+("0000"+(D/60*100+D%60)).slice(-4)},"%Z":D=>D.Bb,"%%":()=>"%"},g=g.replace(/%%/g,"\\0\\0");for(de in X)g.includes(de)&&(g=g.replace(new RegExp(de,"g"),X[de]($)));return g=g.replace(/\\0\\0/g,"%"),de=Xn(g),de.length>m?0:(N.set(de,s>>>0),de.length-1)}for(var un=Array(256),gr=0;256>gr;++gr)un[gr]=String.fromCharCode(gr);Cr=un,st=r.BindingError=class extends Error{constructor(s){super(s),this.name="BindingError"}},r.InternalError=class extends Error{constructor(s){super(s),this.name="InternalError"}},Te.push(0,1,void 0,1,null,1,!0,1,!1,1),r.count_emval_handles=()=>Te.length/2-5-Er.length;var Qn={ia:function(s,m,g){return Rr(async()=>{await r.sb(s,m,g)})},a:function(s,m,g){s>>>=0;var $=new Ut(s);throw se[$.hb+16>>>2>>>0]=0,se[$.hb+4>>>2>>>0]=m>>>0,se[$.hb+8>>>2>>>0]=g>>>0,sr=s,jt++,sr},z:function(){return 0},ea:function(){},R:function(){},T:function(){},ga:function(){return 0},ca:function(){},Z:function(){},ba:function(){},G:function(){},S:function(){},P:function(){},da:function(){},Q:function(){},C:function(s,m,g){m=ft(m>>>0),ht(s>>>0,{name:m,fromWireType:$=>$,toWireType:function($,T){if(typeof T!="bigint"&&typeof T!="number")throw T===null?T="null":($=typeof T,T=$==="object"||$==="array"||$==="function"?T.toString():""+T),new TypeError(`Cannot convert "${T}" to ${this.name}`);return typeof T=="number"&&(T=BigInt(T)),T},argPackAdvance:8,readValueFromPointer:bt(m,g>>>0,m.indexOf("u")==-1),bb:null})},K:function(s,m,g,$){m=ft(m>>>0),ht(s>>>0,{name:m,fromWireType:function(T){return!!T},toWireType:function(T,B){return B?g:$},argPackAdvance:8,readValueFromPointer:function(T){return this.fromWireType(K[T>>>0])},bb:null})},J:function(s){return ht(s>>>0,Fn)},B:function(s,m,g){m=ft(m>>>0),ht(s>>>0,{name:m,fromWireType:$=>$,toWireType:($,T)=>T,argPackAdvance:8,readValueFromPointer:ge(m,g>>>0),bb:null})},s:function(s,m,g,$,T){if(s>>>=0,g>>>=0,m=ft(m>>>0),T===-1&&(T=4294967295),T=q=>q,$===0){var B=32-8*g;T=q=>q<<B>>>B}var L=m.includes("unsigned")?function(q,te){return te>>>0}:function(q,te){return te};ht(s,{name:m,fromWireType:T,toWireType:L,argPackAdvance:8,readValueFromPointer:bt(m,g,$!==0),bb:null})},o:function(s,m,g){function $(B){return new T(N.buffer,se[B+4>>>2>>>0],se[B>>>2>>>0])}var T=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][m];g=ft(g>>>0),ht(s>>>0,{name:g,fromWireType:$,argPackAdvance:8,readValueFromPointer:$},{nb:!0})},D:function(s,m){m=ft(m>>>0);var g=m==="std::string";ht(s>>>0,{name:m,fromWireType:function($){var T=se[$>>>2>>>0],B=$+4;if(g)for(var L=B,q=0;q<=T;++q){var te=B+q;if(q==T||K[te>>>0]==0){if(L=je(L,te-L),X===void 0)var X=L;else X+=String.fromCharCode(0),X+=L;L=te+1}}else{for(X=Array(T),q=0;q<T;++q)X[q]=String.fromCharCode(K[B+q>>>0]);X=X.join("")}return rt($),X},toWireType:function($,T){T instanceof ArrayBuffer&&(T=new Uint8Array(T));var B=typeof T=="string";if(!(B||T instanceof Uint8Array||T instanceof Uint8ClampedArray||T instanceof Int8Array))throw new st("Cannot pass non-string to std::string");var L=g&&B?Vt(T):T.length,q=Wt(4+L+1),te=q+4;if(se[q>>>2>>>0]=L,g&&B)at(T,K,te,L+1);else if(B)for(B=0;B<L;++B){var X=T.charCodeAt(B);if(255<X)throw rt(te),new st("String has UTF-16 code units that do not fit in 8 bits");K[te+B>>>0]=X}else for(B=0;B<L;++B)K[te+B>>>0]=T[B];return $!==null&&$.push(rt,q),q},argPackAdvance:8,readValueFromPointer:lr,bb($){rt($)}})},y:function(s,m,g){if(m>>>=0,g>>>=0,g=ft(g),m===2)var $=jr,T=qn,B=Kr,L=q=>he[q>>>1>>>0];else m===4&&($=jn,T=Yr,B=Zr,L=q=>se[q>>>2>>>0]);ht(s>>>0,{name:g,fromWireType:q=>{for(var te=se[q>>>2>>>0],X,de=q+4,Ee=0;Ee<=te;++Ee){var Oe=q+4+Ee*m;(Ee==te||L(Oe)==0)&&(de=$(de,Oe-de),X===void 0?X=de:(X+=String.fromCharCode(0),X+=de),de=Oe+m)}return rt(q),X},toWireType:(q,te)=>{if(typeof te!="string")throw new st(`Cannot pass non-string to C++ string type ${g}`);var X=B(te),de=Wt(4+X+m);return se[de>>>2>>>0]=X/m,T(te,de+4,X+m),q!==null&&q.push(rt,de),de},argPackAdvance:8,readValueFromPointer:lr,bb(q){rt(q)}})},L:function(s,m){m=ft(m>>>0),ht(s>>>0,{ob:!0,name:m,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ha:()=>1,u:function(s,m,g){return m>>>=0,g>>>=0,s=Xe(s>>>0),m=cr(m,"emval::as"),Pr(m,g,s)},x:function(s){return s>>>=0,Rr(()=>(s=Xe(s),s.then(ut)))},n:function(s,m,g,$){return g>>>=0,$>>>=0,s=Xt[s>>>0],m=Xe(m>>>0),s(null,m,g,$)},j:function(s,m,g,$,T){return g>>>=0,$>>>=0,T>>>=0,s=Xt[s>>>0],m=Xe(m>>>0),g=nt(g),s(m,m[g],$,T)},b:dr,w:function(s,m){return m>>>=0,s=Xe(s>>>0),m=Xe(m),s==m},m:function(s){return s>>>=0,s===0?ut(mr()):(s=nt(s),ut(mr()[s]))},i:function(s,m,g){m=Kn(s,m>>>0);var $=m.shift();s--;var T=`return function (obj, func, destructorsRef, args) {\n`,B=0,L=[];g===0&&L.push("obj");for(var q=["retType"],te=[$],X=0;X<s;++X)L.push("arg"+X),q.push("argType"+X),te.push(m[X]),T+=`  var arg${X} = argType${X}.readValueFromPointer(args${B?"+"+B:""});\n`,B+=m[X].argPackAdvance;return T+=`  var rv = ${g===1?"new func":"func.call"}(${L.join(", ")});\n`,$.ob||(q.push("emval_returnValue"),te.push(Pr),T+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),q.push(T+`};\n`),s=Yn(q)(...te),g=`methodCaller<(${m.map(de=>de.name).join(", ")}) => ${$.name}>`,Br(wt(g,s))},r:function(s,m){return m>>>=0,s=Xe(s>>>0),m=Xe(m),ut(s[m])},e:function(s){s>>>=0,9<s&&(Te[s+1]+=1)},t:function(){return ut([])},l:function(s){s=Xe(s>>>0);for(var m=Array(s.length),g=0;g<s.length;g++)m[g]=s[g];return ut(m)},f:function(s){return ut(nt(s>>>0))},k:function(){return ut({})},h:function(s){s>>>=0;for(var m=Xe(s);m.length;){var g=m.pop();m.pop()(g)}dr(s)},g:function(s,m,g){m>>>=0,g>>>=0,s=Xe(s>>>0),m=Xe(m),g=Xe(g),s[m]=g},c:function(s,m){return m>>>=0,s=cr(s>>>0,"_emval_take_value"),s=s.readValueFromPointer(m),ut(s)},W:function(s,m){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),m>>>=0,s=new Date(1e3*s),W[m>>>2>>>0]=s.getUTCSeconds(),W[m+4>>>2>>>0]=s.getUTCMinutes(),W[m+8>>>2>>>0]=s.getUTCHours(),W[m+12>>>2>>>0]=s.getUTCDate(),W[m+16>>>2>>>0]=s.getUTCMonth(),W[m+20>>>2>>>0]=s.getUTCFullYear()-1900,W[m+24>>>2>>>0]=s.getUTCDay(),W[m+28>>>2>>>0]=(s.getTime()-Date.UTC(s.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},X:function(s,m){s=-9007199254740992>s||9007199254740992<s?NaN:Number(s),m>>>=0,s=new Date(1e3*s),W[m>>>2>>>0]=s.getSeconds(),W[m+4>>>2>>>0]=s.getMinutes(),W[m+8>>>2>>>0]=s.getHours(),W[m+12>>>2>>>0]=s.getDate(),W[m+16>>>2>>>0]=s.getMonth(),W[m+20>>>2>>>0]=s.getFullYear()-1900,W[m+24>>>2>>>0]=s.getDay(),W[m+28>>>2>>>0]=(Je(s.getFullYear())?Dr:fr)[s.getMonth()]+s.getDate()-1|0,W[m+36>>>2>>>0]=-(60*s.getTimezoneOffset());var g=new Date(s.getFullYear(),6,1).getTimezoneOffset(),$=new Date(s.getFullYear(),0,1).getTimezoneOffset();W[m+32>>>2>>>0]=(g!=$&&s.getTimezoneOffset()==Math.min($,g))|0},Y:function(s){s>>>=0;var m=new Date(W[s+20>>>2>>>0]+1900,W[s+16>>>2>>>0],W[s+12>>>2>>>0],W[s+8>>>2>>>0],W[s+4>>>2>>>0],W[s>>>2>>>0],0),g=W[s+32>>>2>>>0],$=m.getTimezoneOffset(),T=new Date(m.getFullYear(),6,1).getTimezoneOffset(),B=new Date(m.getFullYear(),0,1).getTimezoneOffset(),L=Math.min(B,T);return 0>g?W[s+32>>>2>>>0]=+(T!=B&&L==$):0<g!=(L==$)&&(T=Math.max(B,T),m.setTime(m.getTime()+6e4*((0<g?L:T)-$))),W[s+24>>>2>>>0]=m.getDay(),W[s+28>>>2>>>0]=(Je(m.getFullYear())?Dr:fr)[m.getMonth()]+m.getDate()-1|0,W[s>>>2>>>0]=m.getSeconds(),W[s+4>>>2>>>0]=m.getMinutes(),W[s+8>>>2>>>0]=m.getHours(),W[s+12>>>2>>>0]=m.getDate(),W[s+16>>>2>>>0]=m.getMonth(),W[s+20>>>2>>>0]=m.getYear(),s=m.getTime(),BigInt(isNaN(s)?-1:s/1e3)},U:function(){return-52},V:function(){},N:function(s,m,g,$){g>>>=0,$>>>=0;var T=new Date().getFullYear(),B=new Date(T,0,1),L=new Date(T,6,1);T=B.getTimezoneOffset();var q=L.getTimezoneOffset();se[s>>>0>>>2>>>0]=60*Math.max(T,q),W[m>>>0>>>2>>>0]=+(T!=q),s=te=>te.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],B=s(B),L=s(L),q<T?(at(B,K,g,17),at(L,K,$,17)):(at(B,K,$,17),at(L,K,g,17))},v:()=>{ne("")},d:function(s,m,g){return s>>>=0,m=hr(m>>>0,g>>>0),Ot[s](...m)},I:function(s,m,g){return s>>>=0,m=hr(m>>>0,g>>>0),Ot[s](...m)},H:()=>Date.now(),O:function(){return 4294901760},q:()=>performance.now(),M:function(s){s>>>=0;var m=K.length;if(4294901760<s)return!1;for(var g=1;4>=g;g*=2){var $=m*(1+.2/g);$=Math.min($,s+100663296);var T=Math;$=Math.max(s,$);e:{T=(T.min.call(T,4294901760,$+(65536-$%65536)%65536)-O.buffer.byteLength+65535)/65536;try{O.grow(T),Ae();var B=1;break e}catch{}B=void 0}if(B)return!0}return!1},$:function(s,m){s>>>=0,m>>>=0;var g=0;return ot().forEach(($,T)=>{var B=m+g;for(T=se[s+4*T>>>2>>>0]=B,B=0;B<$.length;++B)N[T++>>>0]=$.charCodeAt(B);N[T>>>0]=0,g+=$.length+1}),0},aa:function(s,m){s>>>=0,m>>>=0;var g=ot();se[s>>>2>>>0]=g.length;var $=0;return g.forEach(T=>$+=T.length+1),se[m>>>2>>>0]=$,0},A:()=>52,F:function(){return 52},_:function(){return 70},E:function(s,m,g,$){m>>>=0,g>>>=0,$>>>=0;for(var T=0,B=0;B<g;B++){var L=se[m>>>2>>>0],q=se[m+4>>>2>>>0];m+=8;for(var te=0;te<q;te++){var X=K[L+te>>>0],de=Zn[s];X===0||X===10?((s===1?E:P)(Kt(de,0)),de.length=0):de.push(X)}T+=q}return se[$>>>2>>>0]=T,0},fa:sn,p:function(s,m,g,$){return sn(s>>>0,m>>>0,g>>>0,$>>>0)}},pe=function(){function s(g){return pe=g.exports,pe=Qr(),pe=ln(),O=pe.ja,Ae(),ie.unshift(pe.ka),le--,le==0&&(qe!==null&&(clearInterval(qe),qe=null),G&&(g=G,G=null,g())),pe}var m={a:Qn};if(le++,r.instantiateWasm)try{return r.instantiateWasm(m,s)}catch(g){P(`Module.instantiateWasm callback failed with error: ${g}`),i(g)}return mt(m,function(g){s(g.instance)}).catch(i),{}}(),Mr=s=>(Mr=pe.la)(s);r._OrtInit=(s,m)=>(r._OrtInit=pe.ma)(s,m),r._OrtGetLastError=(s,m)=>(r._OrtGetLastError=pe.na)(s,m),r._OrtCreateSessionOptions=(s,m,g,$,T,B,L,q,te,X)=>(r._OrtCreateSessionOptions=pe.oa)(s,m,g,$,T,B,L,q,te,X),r._OrtAppendExecutionProvider=(s,m)=>(r._OrtAppendExecutionProvider=pe.pa)(s,m),r._OrtAddFreeDimensionOverride=(s,m,g)=>(r._OrtAddFreeDimensionOverride=pe.qa)(s,m,g),r._OrtAddSessionConfigEntry=(s,m,g)=>(r._OrtAddSessionConfigEntry=pe.ra)(s,m,g),r._OrtReleaseSessionOptions=s=>(r._OrtReleaseSessionOptions=pe.sa)(s),r._OrtCreateSession=(s,m,g)=>(r._OrtCreateSession=pe.ta)(s,m,g),r._OrtReleaseSession=s=>(r._OrtReleaseSession=pe.ua)(s),r._OrtGetInputOutputCount=(s,m,g)=>(r._OrtGetInputOutputCount=pe.va)(s,m,g),r._OrtGetInputName=(s,m)=>(r._OrtGetInputName=pe.wa)(s,m),r._OrtGetOutputName=(s,m)=>(r._OrtGetOutputName=pe.xa)(s,m),r._OrtFree=s=>(r._OrtFree=pe.ya)(s),r._OrtCreateTensor=(s,m,g,$,T,B)=>(r._OrtCreateTensor=pe.za)(s,m,g,$,T,B),r._OrtGetTensorData=(s,m,g,$,T)=>(r._OrtGetTensorData=pe.Aa)(s,m,g,$,T),r._OrtReleaseTensor=s=>(r._OrtReleaseTensor=pe.Ba)(s),r._OrtCreateRunOptions=(s,m,g,$)=>(r._OrtCreateRunOptions=pe.Ca)(s,m,g,$),r._OrtAddRunConfigEntry=(s,m,g)=>(r._OrtAddRunConfigEntry=pe.Da)(s,m,g),r._OrtReleaseRunOptions=s=>(r._OrtReleaseRunOptions=pe.Ea)(s),r._OrtCreateBinding=s=>(r._OrtCreateBinding=pe.Fa)(s),r._OrtBindInput=(s,m,g)=>(r._OrtBindInput=pe.Ga)(s,m,g),r._OrtBindOutput=(s,m,g,$)=>(r._OrtBindOutput=pe.Ha)(s,m,g,$),r._OrtClearBoundOutputs=s=>(r._OrtClearBoundOutputs=pe.Ia)(s),r._OrtReleaseBinding=s=>(r._OrtReleaseBinding=pe.Ja)(s),r._OrtRunWithBinding=(s,m,g,$,T)=>(r._OrtRunWithBinding=pe.Ka)(s,m,g,$,T),r._OrtRun=(s,m,g,$,T,B,L,q)=>(r._OrtRun=pe.La)(s,m,g,$,T,B,L,q),r._OrtEndProfiling=s=>(r._OrtEndProfiling=pe.Ma)(s),r._JsepOutput=(s,m,g)=>(r._JsepOutput=pe.Na)(s,m,g),r._JsepGetNodeName=s=>(r._JsepGetNodeName=pe.Oa)(s);var Wt=r._malloc=s=>(Wt=r._malloc=pe.Pa)(s),rt=r._free=s=>(rt=r._free=pe.Qa)(s),yr=s=>(yr=pe.Sa)(s),br=s=>(br=pe.Ta)(s),Ur=()=>(Ur=pe.Ua)(),Jt=s=>(Jt=pe.Wa)(s),dn=()=>(dn=pe.Xa)(),vt=s=>(vt=pe.Ya)(s),ct=()=>(ct=pe.Za)();r.___start_em_js=837968,r.___stop_em_js=838129;function ln(){var s=pe;s=Object.assign({},s);var m=g=>$=>g($)>>>0;return s.la=m(s.la),s.Pa=m(s.Pa),s.Ta=m(s.Ta),s.Ua=(g=>()=>g()>>>0)(s.Ua),s}r.stackSave=()=>Ur(),r.stackRestore=s=>yr(s),r.stackAlloc=s=>br(s),r.UTF8ToString=je,r.stringToUTF8=(s,m,g)=>at(s,K,m,g),r.lengthBytesUTF8=Vt;var Bt;G=function s(){Bt||Vr(),Bt||(G=s)};function Vr(){if(!(0<le)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;){var s=r.preRun.shift();me.unshift(s)}for(;0<me.length;)me.shift()(r);if(!(0<le||Bt||(Bt=!0,r.calledRun=!0,R))){for(;0<ie.length;)ie.shift()(r);for(o(r);0<ue.length;)ue.shift()(r)}}}return Vr(),u}})();typeof Ti=="object"&&typeof po=="object"?po.exports=Ii:typeof define=="function"&&define.amd&&define([],()=>Ii)});var Pi=Wr(()=>{});var ki=Wr(()=>{});var Oi={};gn(Oi,{cpus:()=>ll});var ll,Ri=Y(()=>{ll=void 0});var zi=Wr((Di,mo)=>{"use strict";var Bi=(()=>{var e=typeof document<"u"?document.currentScript?.src:void 0;return typeof __filename<"u"&&(e||=__filename),function(t={}){function r(){return ae.buffer!=ue.buffer&&Ne(),ue}function o(){return ae.buffer!=ue.buffer&&Ne(),le}function i(){return ae.buffer!=ue.buffer&&Ne(),qe}function u(){return ae.buffer!=ue.buffer&&Ne(),G}function a(){return ae.buffer!=ue.buffer&&Ne(),ne}function c(){return ae.buffer!=ue.buffer&&Ne(),xe}function p(){return ae.buffer!=ue.buffer&&Ne(),Ke}function h(){return ae.buffer!=ue.buffer&&Ne(),Mt}var d=t,y,w,_=new Promise((n,l)=>{y=n,w=l});d.mountExternalData=(n,l)=>{(d.Db||(d.Db=new Map)).set(n,l)},d.unmountExternalData=()=>{delete d.Db};let v=()=>{let n=(f,b,C)=>(...k)=>{let V=ct,F=b?.();k=f(...k);let re=b?.();return F!==re&&(f=re,C(F),b=C=null),ct!=V?T():k},l=f=>async(...b)=>{try{if(d.Cb)throw Error("Session already started");let C=d.Cb={ec:b[0],errors:[]},k=await f(...b);if(d.Cb!==C)throw Error("Session mismatch");d.Kb?.flush();let V=C.errors;if(0<V.length){let F=await Promise.all(V);if(F=F.filter(re=>re),0<F.length)throw Error(F.join(`\n`))}return k}finally{d.Cb=null}};d._OrtCreateSession=n(d._OrtCreateSession,()=>d._OrtCreateSession,f=>d._OrtCreateSession=f),d._OrtRun=l(n(d._OrtRun,()=>d._OrtRun,f=>d._OrtRun=f)),d._OrtRunWithBinding=l(n(d._OrtRunWithBinding,()=>d._OrtRunWithBinding,f=>d._OrtRunWithBinding=f)),d._OrtBindInput=n(d._OrtBindInput,()=>d._OrtBindInput,f=>d._OrtBindInput=f),v=void 0};d.jsepInit=(n,l)=>{if(v?.(),n==="webgpu"){[d.Kb,d.Wb,d.$b,d.Lb,d.Zb,d.ob,d.ac,d.cc,d.Xb,d.Yb,d.bc]=l;let f=d.Kb;d.jsepRegisterBuffer=(b,C,k,V)=>f.registerBuffer(b,C,k,V),d.jsepGetBuffer=b=>f.getBuffer(b),d.jsepCreateDownloader=(b,C,k)=>f.createDownloader(b,C,k),d.jsepOnReleaseSession=b=>{f.onReleaseSession(b)},d.jsepOnRunStart=b=>f.onRunStart(b)}};var S=Object.assign({},d),I="./this.program",A=(n,l)=>{throw l},x=typeof window=="object",E=typeof importScripts=="function",P=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",O=d.ENVIRONMENT_IS_PTHREAD||!1,R="";function H(n){return d.locateFile?d.locateFile(n,R):R+n}var N,K,Q;if(P){var he=(uo(),wr(so)),W=(co(),wr(lo));R=E?W.dirname(R)+"/":__dirname+"/",N=(n,l)=>(n=Vt(n)?new URL(n):W.normalize(n),he.readFileSync(n,l?void 0:"utf8")),Q=n=>(n=N(n,!0),n.buffer||(n=new Uint8Array(n)),n),K=(n,l,f,b=!0)=>{n=Vt(n)?new URL(n):W.normalize(n),he.readFile(n,b?void 0:"utf8",(C,k)=>{C?f(C):l(b?k.buffer:k)})},!d.thisProgram&&1<process.argv.length&&(I=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),A=(n,l)=>{throw process.exitCode=n,l},global.Worker=Pi().Worker}else(x||E)&&(E?R=self.location.href:typeof document<"u"&&document.currentScript&&(R=document.currentScript.src),typeof e<"u"&&e&&(R=e),R.startsWith("blob:")?R="":R=R.substr(0,R.replace(/[?#].*/,"").lastIndexOf("/")+1),P||(N=n=>{var l=new XMLHttpRequest;return l.open("GET",n,!1),l.send(null),l.responseText},E&&(Q=n=>{var l=new XMLHttpRequest;return l.open("GET",n,!1),l.responseType="arraybuffer",l.send(null),new Uint8Array(l.response)}),K=(n,l,f)=>{var b=new XMLHttpRequest;b.open("GET",n,!0),b.responseType="arraybuffer",b.onload=()=>{b.status==200||b.status==0&&b.response?l(b.response):f()},b.onerror=f,b.send(null)}));P&&typeof performance>"u"&&(global.performance=ki().performance);var se=console.log.bind(console),Ce=console.error.bind(console);P&&(se=(...n)=>he.writeSync(1,n.join(" ")+`\n`),Ce=(...n)=>he.writeSync(2,n.join(" ")+`\n`));var We=se,ee=Ce;Object.assign(d,S),S=null;var ae,Ae,me=!1,ie,ue,le,qe,G,ne,xe,Ke,De,Ge,Mt;function Ne(){var n=ae.buffer;d.HEAP8=ue=new Int8Array(n),d.HEAP16=qe=new Int16Array(n),d.HEAPU8=le=new Uint8Array(n),d.HEAPU16=G=new Uint16Array(n),d.HEAP32=ne=new Int32Array(n),d.HEAPU32=xe=new Uint32Array(n),d.HEAPF32=Ke=new Float32Array(n),d.HEAPF64=Mt=new Float64Array(n),d.HEAP64=De=new BigInt64Array(n),d.HEAPU64=Ge=new BigUint64Array(n)}var Ye=16777216;if(O)ae=d.wasmMemory;else if(d.wasmMemory)ae=d.wasmMemory;else if(ae=new WebAssembly.Memory({initial:Ye/65536,maximum:65536,shared:!0}),!(ae.buffer instanceof SharedArrayBuffer))throw ee("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),P&&ee("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Ne(),Ye=ae.buffer.byteLength;var mt=[],Ot=[],qt=[],Ut=0,sr=null,jt=null;function xr(){if(Ut--,Ut==0&&(sr!==null&&(clearInterval(sr),sr=null),jt)){var n=jt;jt=null,n()}}function Kt(n){throw n="Aborted("+n+")",ee(n),me=!0,ie=1,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),w(n),n}var je=n=>n.startsWith("data:application/octet-stream;base64,"),Vt=n=>n.startsWith("file://"),at;at="ort-wasm-simd-threaded.wasm",je(at)||(at=H(at));function Cr(n){if(Q)return Q(n);throw"both async and sync fetching of the wasm failed"}function ft(n){if(x||E){if(typeof fetch=="function"&&!Vt(n))return fetch(n,{credentials:"same-origin"}).then(l=>{if(!l.ok)throw`failed to load wasm binary file at \'${n}\'`;return l.arrayBuffer()}).catch(()=>Cr(n));if(K)return new Promise((l,f)=>{K(n,b=>l(new Uint8Array(b)),f)})}return Promise.resolve().then(()=>Cr(n))}function ur(n,l,f){return ft(n).then(b=>WebAssembly.instantiate(b,l)).then(f,b=>{ee(`failed to asynchronously prepare wasm: ${b}`),Kt(b)})}function Ar(n,l){var f=at;return typeof WebAssembly.instantiateStreaming!="function"||je(f)||Vt(f)||P||typeof fetch!="function"?ur(f,n,l):fetch(f,{credentials:"same-origin"}).then(b=>WebAssembly.instantiateStreaming(b,n).then(l,function(C){return ee(`wasm streaming compile failed: ${C}`),ee("falling back to ArrayBuffer instantiation"),ur(f,n,l)}))}var Ir={826468:(n,l,f,b)=>{if(typeof d>"u"||!d.Db)return 1;if(n=He(n>>>0),n.startsWith("./")&&(n=n.substring(2)),n=d.Db.get(n),!n)return 2;if(l>>>=0,f>>>=0,b>>>=0,l+f>n.byteLength)return 3;try{return o().set(n.subarray(l,l+f),b>>>0),0}catch{return 4}},826969:()=>{d.Xb()},827e3:()=>{d.Yb()},827029:()=>{d.bc()},827054:n=>d.Wb(n),827087:n=>d.$b(n),827119:(n,l,f)=>{d.Lb(n,l,f,!0)},827158:(n,l,f)=>{d.Lb(n,l,f)},827191:n=>{d.ob("Abs",n,void 0)},827242:n=>{d.ob("Neg",n,void 0)},827293:n=>{d.ob("Floor",n,void 0)},827346:n=>{d.ob("Ceil",n,void 0)},827398:n=>{d.ob("Reciprocal",n,void 0)},827456:n=>{d.ob("Sqrt",n,void 0)},827508:n=>{d.ob("Exp",n,void 0)},827559:n=>{d.ob("Erf",n,void 0)},827610:n=>{d.ob("Sigmoid",n,void 0)},827665:(n,l,f)=>{d.ob("HardSigmoid",n,{alpha:l,beta:f})},827744:n=>{d.ob("Log",n,void 0)},827795:n=>{d.ob("Sin",n,void 0)},827846:n=>{d.ob("Cos",n,void 0)},827897:n=>{d.ob("Tan",n,void 0)},827948:n=>{d.ob("Asin",n,void 0)},828e3:n=>{d.ob("Acos",n,void 0)},828052:n=>{d.ob("Atan",n,void 0)},828104:n=>{d.ob("Sinh",n,void 0)},828156:n=>{d.ob("Cosh",n,void 0)},828208:n=>{d.ob("Asinh",n,void 0)},828261:n=>{d.ob("Acosh",n,void 0)},828314:n=>{d.ob("Atanh",n,void 0)},828367:n=>{d.ob("Tanh",n,void 0)},828419:n=>{d.ob("Not",n,void 0)},828470:(n,l,f)=>{d.ob("Clip",n,{min:l,max:f})},828539:n=>{d.ob("Clip",n,void 0)},828591:(n,l)=>{d.ob("Elu",n,{alpha:l})},828649:n=>{d.ob("Relu",n,void 0)},828701:(n,l)=>{d.ob("LeakyRelu",n,{alpha:l})},828765:(n,l)=>{d.ob("ThresholdedRelu",n,{alpha:l})},828835:(n,l)=>{d.ob("Cast",n,{to:l})},828893:n=>{d.ob("Add",n,void 0)},828944:n=>{d.ob("Sub",n,void 0)},828995:n=>{d.ob("Mul",n,void 0)},829046:n=>{d.ob("Div",n,void 0)},829097:n=>{d.ob("Pow",n,void 0)},829148:n=>{d.ob("Equal",n,void 0)},829201:n=>{d.ob("Greater",n,void 0)},829256:n=>{d.ob("GreaterOrEqual",n,void 0)},829318:n=>{d.ob("Less",n,void 0)},829370:n=>{d.ob("LessOrEqual",n,void 0)},829429:(n,l,f,b,C)=>{d.ob("ReduceMean",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},829588:(n,l,f,b,C)=>{d.ob("ReduceMax",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},829746:(n,l,f,b,C)=>{d.ob("ReduceMin",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},829904:(n,l,f,b,C)=>{d.ob("ReduceProd",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830063:(n,l,f,b,C)=>{d.ob("ReduceSum",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830221:(n,l,f,b,C)=>{d.ob("ReduceL1",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830378:(n,l,f,b,C)=>{d.ob("ReduceL2",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830535:(n,l,f,b,C)=>{d.ob("ReduceLogSum",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830696:(n,l,f,b,C)=>{d.ob("ReduceSumSquare",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},830860:(n,l,f,b,C)=>{d.ob("ReduceLogSumExp",n,{keepDims:!!l,noopWithEmptyAxes:!!f,axes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},831024:n=>{d.ob("Where",n,void 0)},831077:(n,l,f)=>{d.ob("Transpose",n,{perm:l?Array.from(a().subarray(l>>>0,f>>>0)):[]})},831185:(n,l,f,b)=>{d.ob("DepthToSpace",n,{blocksize:l,mode:He(f),format:b?"NHWC":"NCHW"})},831318:(n,l,f,b)=>{d.ob("DepthToSpace",n,{blocksize:l,mode:He(f),format:b?"NHWC":"NCHW"})},831451:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we)=>{d.ob("ConvTranspose",n,{format:re?"NHWC":"NCHW",autoPad:l,dilations:[f],group:b,kernelShape:[C],pads:[k,V],strides:[F],wIsConst:()=>!!r()[J>>>0],outputPadding:ce?Array.from(a().subarray(ce>>>0,Re>>>0)):[],outputShape:ze?Array.from(a().subarray(ze>>>0,z>>>0)):[],activation:He(we)})},831852:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z)=>{d.ob("ConvTranspose",n,{format:F?"NHWC":"NCHW",autoPad:l,dilations:Array.from(a().subarray(f>>>0,(f>>>0)+2>>>0)),group:b,kernelShape:Array.from(a().subarray(C>>>0,(C>>>0)+2>>>0)),pads:Array.from(a().subarray(k>>>0,(k>>>0)+4>>>0)),strides:Array.from(a().subarray(V>>>0,(V>>>0)+2>>>0)),wIsConst:()=>!!r()[re>>>0],outputPadding:J?Array.from(a().subarray(J>>>0,ce>>>0)):[],outputShape:Re?Array.from(a().subarray(Re>>>0,ze>>>0)):[],activation:He(z)})},832417:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we)=>{d.ob("ConvTranspose",n,{format:re?"NHWC":"NCHW",autoPad:l,dilations:[f],group:b,kernelShape:[C],pads:[k,V],strides:[F],wIsConst:()=>!!r()[J>>>0],outputPadding:ce?Array.from(a().subarray(ce>>>0,Re>>>0)):[],outputShape:ze?Array.from(a().subarray(ze>>>0,z>>>0)):[],activation:He(we)})},832818:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z)=>{d.ob("ConvTranspose",n,{format:F?"NHWC":"NCHW",autoPad:l,dilations:Array.from(a().subarray(f>>>0,(f>>>0)+2>>>0)),group:b,kernelShape:Array.from(a().subarray(C>>>0,(C>>>0)+2>>>0)),pads:Array.from(a().subarray(k>>>0,(k>>>0)+4>>>0)),strides:Array.from(a().subarray(V>>>0,(V>>>0)+2>>>0)),wIsConst:()=>!!r()[re>>>0],outputPadding:J?Array.from(a().subarray(J>>>0,ce>>>0)):[],outputShape:Re?Array.from(a().subarray(Re>>>0,ze>>>0)):[],activation:He(z)})},833383:(n,l)=>{d.ob("GlobalAveragePool",n,{format:l?"NHWC":"NCHW"})},833474:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("AveragePool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},833758:(n,l)=>{d.ob("GlobalAveragePool",n,{format:l?"NHWC":"NCHW"})},833849:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("AveragePool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},834133:(n,l)=>{d.ob("GlobalMaxPool",n,{format:l?"NHWC":"NCHW"})},834220:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("MaxPool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},834500:(n,l)=>{d.ob("GlobalMaxPool",n,{format:l?"NHWC":"NCHW"})},834587:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("MaxPool",n,{format:Pe?"NHWC":"NCHW",auto_pad:l,ceil_mode:f,count_include_pad:b,storage_order:C,dilations:[k,V],kernel_shape:[F,re],pads:[J,ce,Re,ze],strides:[z,we]})},834867:(n,l,f,b,C)=>{d.ob("Gemm",n,{alpha:l,beta:f,transA:b,transB:C})},834971:n=>{d.ob("MatMul",n,void 0)},835025:(n,l,f,b)=>{d.ob("ArgMax",n,{keepDims:!!l,selectLastIndex:!!f,axis:b})},835133:(n,l,f,b)=>{d.ob("ArgMin",n,{keepDims:!!l,selectLastIndex:!!f,axis:b})},835241:(n,l)=>{d.ob("Softmax",n,{axis:l})},835304:(n,l)=>{d.ob("Concat",n,{axis:l})},835364:(n,l,f,b,C)=>{d.ob("Split",n,{axis:l,numOutputs:f,splitSizes:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},835504:n=>{d.ob("Expand",n,void 0)},835558:(n,l)=>{d.ob("Gather",n,{axis:Number(l)})},835629:(n,l)=>{d.ob("GatherElements",n,{axis:Number(l)})},835708:(n,l,f,b,C,k,V,F,re,J,ce)=>{d.ob("Resize",n,{antialias:l,axes:f?Array.from(a().subarray(f>>>0,b>>>0)):[],coordinateTransformMode:He(C),cubicCoeffA:k,excludeOutside:V,extrapolationValue:F,keepAspectRatioPolicy:He(re),mode:He(J),nearestMode:He(ce)})},836054:(n,l,f,b,C,k,V)=>{d.ob("Slice",n,{starts:l?Array.from(a().subarray(l>>>0,f>>>0)):[],ends:b?Array.from(a().subarray(b>>>0,C>>>0)):[],axes:k?Array.from(a().subarray(k>>>0,V>>>0)):[]})},836270:n=>{d.ob("Tile",n,void 0)},836322:(n,l,f,b)=>{d.ob("LayerNormalization",n,{axis:l,epsilon:f,simplified:!!b})},836433:(n,l,f)=>{d.ob("InstanceNormalization",n,{epsilon:l,format:f?"NHWC":"NCHW"})},836547:(n,l,f)=>{d.ob("InstanceNormalization",n,{epsilon:l,format:f?"NHWC":"NCHW"})},836661:n=>{d.ob("Range",n,void 0)},836714:(n,l)=>{d.ob("Einsum",n,{equation:He(l)})},836795:(n,l,f,b,C)=>{d.ob("Pad",n,{mode:l,value:f,pads:b?Array.from(a().subarray(b>>>0,C>>>0)):[]})},836922:(n,l,f,b,C,k)=>{d.ob("BatchNormalization",n,{epsilon:l,momentum:f,spatial:!!C,trainingMode:!!b,format:k?"NHWC":"NCHW"})},837091:(n,l,f,b,C,k)=>{d.ob("BatchNormalization",n,{epsilon:l,momentum:f,spatial:!!C,trainingMode:!!b,format:k?"NHWC":"NCHW"})},837260:(n,l,f)=>{d.ob("CumSum",n,{exclusive:Number(l),reverse:Number(f)})},837357:(n,l,f,b,C,k,V,F,re)=>{d.ob("Attention",n,{numHeads:l,isUnidirectional:f,maskFilterValue:b,scale:C,doRotary:k,qkvHiddenSizes:V?Array.from(a().subarray(Number(F)>>>0,Number(F)+V>>>0)):[],pastPresentShareBuffer:!!re})},837629:n=>{d.ob("BiasAdd",n,void 0)},837684:n=>{d.ob("BiasSplitGelu",n,void 0)},837745:n=>{d.ob("FastGelu",n,void 0)},837801:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze)=>{d.ob("Conv",n,{format:re?"NHWC":"NCHW",auto_pad:l,dilations:[f],group:b,kernel_shape:[C],pads:k?Array.from(a().subarray(k>>>0,V>>>0)):[],strides:[F],w_is_const:()=>!!r()[J>>>0],activation:He(ce),activation_params:Re?Array.from(p().subarray(Re>>>0,ze>>>0)):[]})},838171:(n,l,f,b,C,k,V,F,re,J,ce,Re,ze,z,we,Pe)=>{d.ob("Conv",n,{format:Re?"NHWC":"NCHW",auto_pad:l,dilations:[f,b],group:C,kernel_shape:[k,V],pads:F?Array.from(a().subarray(F>>>0,re>>>0)):[],strides:[J,ce],w_is_const:()=>!!r()[ze>>>0],activation:He(z),activation_params:we?Array.from(p().subarray(we>>>0,Pe>>>0)):[]})},838562:n=>{d.ob("Gelu",n,void 0)},838614:(n,l,f,b,C,k)=>{d.ob("MatMulNBits",n,{k:l,n:f,accuracyLevel:b,bits:C,blockSize:k})},838741:(n,l,f,b,C,k)=>{d.ob("MultiHeadAttention",n,{numHeads:l,isUnidirectional:f,maskFilterValue:b,scale:C,doRotary:k})},838900:(n,l,f,b,C)=>{d.ob("RotaryEmbedding",n,{interleaved:!!l,numHeads:f,rotaryEmbeddingDim:b,scale:C})},839039:(n,l,f)=>{d.ob("SkipLayerNormalization",n,{epsilon:l,simplified:!!f})},839141:(n,l,f)=>{d.ob("SkipLayerNormalization",n,{epsilon:l,simplified:!!f})},839243:(n,l,f,b)=>{d.ob("LayerNormalization",n,{axis:l,epsilon:f,simplified:!!b})},839354:n=>{d.ac(n)},839388:(n,l)=>d.cc(n,l,d.Cb.ec,d.Cb.errors)};function st(n){this.name="ExitStatus",this.message=`Program terminated with exit(${n})`,this.status=n}var Tr=n=>{n.terminate(),n.onmessage=()=>{}},ht=n=>{ge.xb.length==0&&(lr(),ge.Mb(ge.xb[0]));var l=ge.xb.pop();if(!l)return 6;ge.yb.push(l),ge.ub[n.wb]=l,l.wb=n.wb;var f={cmd:"run",start_routine:n.fc,arg:n.Rb,pthread_ptr:n.wb};return P&&l.unref(),l.postMessage(f,n.mc),0},bt=0,Er=n=>{var l=io();return n=n(),fn(l),n},Te=(n,l,...f)=>Er(()=>{for(var b=2*f.length,C=oo(8*b),k=C>>>3,V=0;V<f.length;V++){var F=f[V];typeof F=="bigint"?(De[k+2*V]=1n,De[k+2*V+1]=F):(De[k+2*V]=0n,h()[k+2*V+1>>>0]=F)}return gi(n,0,b,C,l)});function dr(n){if(O)return Te(0,1,n);ie=n,0<bt||(ge.hc(),d.onExit?.(n),me=!0),A(n,new st(n))}var Xe=n=>{if(ie=n,O)throw jr(n),"unwind";dr(n)};function ut(){for(var n=d.numThreads;n--;)lr();mt.unshift(()=>{Ut++,Fn(()=>xr())})}function lr(){var n=H("ort-wasm-simd-threaded.worker.js");n=new Worker(n),ge.xb.push(n)}function Fn(n){O?n():Promise.all(ge.xb.map(ge.Mb)).then(n)}var ge={xb:[],yb:[],Qb:[],ub:{},Gb(){O?(ge.receiveObjectTransfer=ge.dc,ge.threadInitTLS=ge.Pb,ge.setExitStatus=ge.Ob):ut()},Ob:n=>ie=n,pc:["$terminateWorker"],hc:()=>{for(var n of ge.yb)Tr(n);for(n of ge.xb)Tr(n);ge.xb=[],ge.yb=[],ge.ub=[]},Nb:n=>{var l=n.wb;delete ge.ub[l],ge.xb.push(n),ge.yb.splice(ge.yb.indexOf(n),1),n.wb=0,ro(l)},dc(){},Pb(){ge.Qb.forEach(n=>n())},Mb:n=>new Promise(l=>{n.onmessage=k=>{k=k.data;var V=k.cmd;if(k.targetThread&&k.targetThread!=pn()){var F=ge.ub[k.targetThread];F?F.postMessage(k,k.transferList):ee(`Internal error! Worker sent a message "${V}" to target pthread ${k.targetThread}, but that thread no longer exists!`)}else V==="checkMailbox"?rt():V==="spawnThread"?ht(k):V==="cleanupThread"?ge.Nb(ge.ub[k.thread]):V==="killThread"?(k=k.thread,V=ge.ub[k],delete ge.ub[k],Tr(V),ro(k),ge.yb.splice(ge.yb.indexOf(V),1),V.wb=0):V==="cancelThread"?ge.ub[k.thread].postMessage({cmd:"cancel"}):V==="loaded"?(n.loaded=!0,P&&!n.wb&&n.unref(),l(n)):V==="alert"?alert(`Thread ${k.threadId}: ${k.text}`):k.target==="setimmediate"?n.postMessage(k):V==="callHandler"?d[k.handler](...k.args):V&&ee(`worker sent an unknown command ${V}`)},n.onerror=k=>{throw ee(`worker sent an error! ${k.filename}:${k.lineno}: ${k.message}`),k},P&&(n.on("message",k=>n.onmessage({data:k})),n.on("error",k=>n.onerror(k)));var f=[],b=["onExit"],C;for(C of b)d.hasOwnProperty(C)&&f.push(C);n.postMessage({cmd:"load",handlers:f,urlOrBlob:d.mainScriptUrlOrBlob||e,wasmMemory:ae,wasmModule:Ae})})};d.PThread=ge;var Yt=n=>{for(;0<n.length;)n.shift()(d)};d.establishStackSpace=()=>{var n=pn(),l=c()[n+52>>>2>>>0];n=c()[n+56>>>2>>>0],bi(l,l-n),fn(l)};function jr(n){if(O)return Te(1,0,n);Xe(n)}d.invokeEntryPoint=(n,l)=>{bt=0,n=wi(n,l),0<bt?ge.Ob(n):no(n)};class qn{constructor(l){this.Ib=l-24}Gb(l,f){c()[this.Ib+16>>>2>>>0]=0,c()[this.Ib+4>>>2>>>0]=l,c()[this.Ib+8>>>2>>>0]=f}}var Kr=0,jn=0;function Yr(n,l,f,b){return O?Te(2,1,n,l,f,b):Zr(n,l,f,b)}function Zr(n,l,f,b){if(n>>>=0,l>>>=0,f>>>=0,b>>>=0,typeof SharedArrayBuffer>"u")return ee("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var C=[];return O&&C.length===0?Yr(n,l,f,b):(n={fc:f,wb:n,Rb:b,mc:C},O?(n.oc="spawnThread",postMessage(n,C),0):ht(n))}var cr=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Pr=(n,l,f)=>{l>>>=0;var b=l+f;for(f=l;n[f]&&!(f>=b);)++f;if(16<f-l&&n.buffer&&cr)return cr.decode(n.buffer instanceof SharedArrayBuffer?n.slice(l,f):n.subarray(l,f));for(b="";l<f;){var C=n[l++];if(C&128){var k=n[l++]&63;if((C&224)==192)b+=String.fromCharCode((C&31)<<6|k);else{var V=n[l++]&63;C=(C&240)==224?(C&15)<<12|k<<6|V:(C&7)<<18|k<<12|V<<6|n[l++]&63,65536>C?b+=String.fromCharCode(C):(C-=65536,b+=String.fromCharCode(55296|C>>10,56320|C&1023))}}else b+=String.fromCharCode(C)}return b},He=(n,l)=>(n>>>=0)?Pr(o(),n,l):"";function Xr(n,l,f){return O?Te(3,1,n,l,f):0}function Qr(n,l){if(O)return Te(4,1,n,l)}var gt=n=>{for(var l=0,f=0;f<n.length;++f){var b=n.charCodeAt(f);127>=b?l++:2047>=b?l+=2:55296<=b&&57343>=b?(l+=4,++f):l+=3}return l},dt=(n,l,f,b)=>{if(f>>>=0,!(0<b))return 0;var C=f;b=f+b-1;for(var k=0;k<n.length;++k){var V=n.charCodeAt(k);if(55296<=V&&57343>=V){var F=n.charCodeAt(++k);V=65536+((V&1023)<<10)|F&1023}if(127>=V){if(f>=b)break;l[f++>>>0]=V}else{if(2047>=V){if(f+1>=b)break;l[f++>>>0]=192|V>>6}else{if(65535>=V){if(f+2>=b)break;l[f++>>>0]=224|V>>12}else{if(f+3>=b)break;l[f++>>>0]=240|V>>18,l[f++>>>0]=128|V>>12&63}l[f++>>>0]=128|V>>6&63}l[f++>>>0]=128|V&63}}return l[f>>>0]=0,f-C},Rt=(n,l,f)=>dt(n,o(),l,f);function Zt(n,l){if(O)return Te(5,1,n,l)}function kr(n,l,f){if(O)return Te(6,1,n,l,f)}function Or(n,l,f){return O?Te(7,1,n,l,f):0}function Jr(n,l){if(O)return Te(8,1,n,l)}function pr(n,l,f){if(O)return Te(9,1,n,l,f)}function en(n,l,f,b){if(O)return Te(10,1,n,l,f,b)}function tn(n,l,f,b){if(O)return Te(11,1,n,l,f,b)}function rn(n,l,f,b){if(O)return Te(12,1,n,l,f,b)}function nn(n){if(O)return Te(13,1,n)}function Rr(n,l){if(O)return Te(14,1,n,l)}function Xt(n,l,f){if(O)return Te(15,1,n,l,f)}var on,nt=n=>{for(var l="";o()[n>>>0];)l+=on[o()[n++>>>0]];return l},mr={},Br={},Kn={},wt;function Yn(n,l,f={}){var b=l.name;if(!n)throw new wt(`type "${b}" must have a positive integer typeid pointer`);if(Br.hasOwnProperty(n)){if(f.Ub)return;throw new wt(`Cannot register type \'${b}\' twice`)}Br[n]=l,delete Kn[n],mr.hasOwnProperty(n)&&(l=mr[n],delete mr[n],l.forEach(C=>C()))}function Je(n,l,f={}){if(!("argPackAdvance"in l))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Yn(n,l,f)}var Dr=(n,l,f)=>{switch(l){case 1:return f?b=>r()[b>>>0]:b=>o()[b>>>0];case 2:return f?b=>i()[b>>>1>>>0]:b=>u()[b>>>1>>>0];case 4:return f?b=>a()[b>>>2>>>0]:b=>c()[b>>>2>>>0];case 8:return f?b=>De[b>>>3]:b=>Ge[b>>>3];default:throw new TypeError(`invalid integer width (${l}): ${n}`)}},fr=[],lt=[];function hr(n){n>>>=0,9<n&&--lt[n+1]===0&&(lt[n]=void 0,fr.push(n))}var Qe=n=>{if(!n)throw new wt("Cannot use deleted val. handle = "+n);return lt[n]},ot=n=>{switch(n){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let l=fr.pop()||lt.length;return lt[l]=n,lt[l+1]=1,l}};function Qt(n){return this.fromWireType(c()[n>>>2>>>0])}var Zn={name:"emscripten::val",fromWireType:n=>{var l=Qe(n);return hr(n),l},toWireType:(n,l)=>ot(l),argPackAdvance:8,readValueFromPointer:Qt,Bb:null},an=(n,l)=>{switch(l){case 4:return function(f){return this.fromWireType(p()[f>>>2>>>0])};case 8:return function(f){return this.fromWireType(h()[f>>>3>>>0])};default:throw new TypeError(`invalid float width (${l}): ${n}`)}},zr=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Xn=(n,l)=>{for(var f=n>>1,b=f+l/2;!(f>=b)&&u()[f>>>0];)++f;if(f<<=1,32<f-n&&zr)return zr.decode(o().slice(n,f));for(f="",b=0;!(b>=l/2);++b){var C=i()[n+2*b>>>1>>>0];if(C==0)break;f+=String.fromCharCode(C)}return f},sn=(n,l,f)=>{if(f??=2147483647,2>f)return 0;f-=2;var b=l;f=f<2*n.length?f/2:n.length;for(var C=0;C<f;++C){var k=n.charCodeAt(C);i()[l>>>1>>>0]=k,l+=2}return i()[l>>>1>>>0]=0,l-b},un=n=>2*n.length,gr=(n,l)=>{for(var f=0,b="";!(f>=l/4);){var C=a()[n+4*f>>>2>>>0];if(C==0)break;++f,65536<=C?(C-=65536,b+=String.fromCharCode(55296|C>>10,56320|C&1023)):b+=String.fromCharCode(C)}return b},Qn=(n,l,f)=>{if(l>>>=0,f??=2147483647,4>f)return 0;var b=l;f=b+f-4;for(var C=0;C<n.length;++C){var k=n.charCodeAt(C);if(55296<=k&&57343>=k){var V=n.charCodeAt(++C);k=65536+((k&1023)<<10)|V&1023}if(a()[l>>>2>>>0]=k,l+=4,l+4>f)break}return a()[l>>>2>>>0]=0,l-b},pe=n=>{for(var l=0,f=0;f<n.length;++f){var b=n.charCodeAt(f);55296<=b&&57343>=b&&++f,l+=4}return l},Mr=n=>{if(!me)try{if(n(),!(0<bt))try{O?no(ie):Xe(ie)}catch(l){l instanceof st||l=="unwind"||A(1,l)}}catch(l){l instanceof st||l=="unwind"||A(1,l)}};function Wt(n){n>>>=0,typeof Atomics.nc=="function"&&(Atomics.nc(a(),n>>>2,n).value.then(rt),n+=128,Atomics.store(a(),n>>>2,1))}d.__emscripten_thread_mailbox_await=Wt;var rt=()=>{var n=pn();n&&(Wt(n),Mr(yi))};d.checkMailbox=rt;var yr=[],br=(n,l)=>{var f=Br[n];if(f===void 0)throw n=fi(n),f=nt(n),Ct(n),new wt(`${l} has unknown type ${f}`);return f},Ur=(n,l,f)=>{var b=[];return n=n.toWireType(b,f),b.length&&(c()[l>>>2>>>0]=ot(b)),n},Jt=n=>{try{n()}catch(l){Kt(l)}};function dn(){var n=oe,l={};for(let[f,b]of Object.entries(n))l[f]=typeof b=="function"?(...C)=>{Bt.push(f);try{return b(...C)}finally{me||(Bt.pop(),ct&&vt===1&&Bt.length===0&&(vt=0,bt+=1,Jt($i),typeof Fibers<"u"&&Fibers.rc()))}}:b;return l}var vt=0,ct=null,ln=0,Bt=[],Vr={},s={},m=0,g=null,$=[];function T(){return new Promise((n,l)=>{g={resolve:n,reject:l}})}function B(){var n=mn(65548),l=n+12;c()[n>>>2>>>0]=l,c()[n+4>>>2>>>0]=l+65536,l=Bt[0];var f=Vr[l];return f===void 0&&(f=m++,Vr[l]=f,s[f]=l),l=f,a()[n+8>>>2>>>0]=l,n}function L(){var n=a()[ct+8>>>2>>>0];return n=oe[s[n]],--bt,n()}function q(n){if(!me){if(vt===0){var l=!1,f=!1;n((b=0)=>{if(!me&&(ln=b,l=!0,f)){vt=2,Jt(()=>_i(ct)),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.resume(),b=!1;try{var C=L()}catch(F){C=F,b=!0}var k=!1;if(!ct){var V=g;V&&(g=null,(b?V.reject:V.resolve)(C),k=!0)}if(b&&!k)throw C}}),f=!0,l||(vt=1,ct=B(),typeof Browser<"u"&&Browser.Hb.Tb&&Browser.Hb.pause(),Jt(()=>vi(ct)))}else vt===2?(vt=0,Jt(Si),Ct(ct),ct=null,$.forEach(Mr)):Kt(`invalid state: ${vt}`);return ln}}function te(n){return q(l=>{n().then(l)})}var X=[],de={},Ee=n=>{var l=de[n];return l===void 0?nt(n):l},Oe=()=>typeof globalThis=="object"?globalThis:Function("return this")(),D=n=>{var l=X.length;return X.push(n),l},be=(n,l)=>{for(var f=Array(n),b=0;b<n;++b)f[b]=br(c()[l+4*b>>>2>>>0],"parameter "+b);return f},Ie=(n,l)=>Object.defineProperty(l,"name",{value:n});function Dt(n){var l=Function;if(!(l instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof l} which is not a function`);var f=Ie(l.name||"unknownFunctionName",function(){});return f.prototype=l.prototype,f=new f,n=l.apply(f,n),n instanceof Object?n:f}var zt=n=>n%4===0&&(n%100!==0||n%400===0),Qo=[0,31,60,91,121,152,182,213,244,274,305,335],Jo=[0,31,59,90,120,151,181,212,243,273,304,334];function ei(n,l,f,b,C,k,V){return O?Te(16,1,n,l,f,b,C,k,V):-52}function ti(n,l,f,b,C,k){if(O)return Te(17,1,n,l,f,b,C,k)}var Jn=[],ri=(n,l)=>{Jn.length=0;for(var f;f=o()[n++>>>0];){var b=f!=105;b&=f!=112,l+=b&&l%8?4:0,Jn.push(f==112?c()[l>>>2>>>0]:f==106?De[l>>>3]:f==105?a()[l>>>2>>>0]:h()[l>>>3>>>0]),l+=b?8:4}return Jn},eo={},ni=()=>{if(!to){var n={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:I||"./this.program"},l;for(l in eo)eo[l]===void 0?delete n[l]:n[l]=eo[l];var f=[];for(l in n)f.push(`${l}=${n[l]}`);to=f}return to},to;function oi(n,l){if(O)return Te(18,1,n,l);n>>>=0,l>>>=0;var f=0;return ni().forEach((b,C)=>{var k=l+f;for(C=c()[n+4*C>>>2>>>0]=k,k=0;k<b.length;++k)r()[C++>>>0]=b.charCodeAt(k);r()[C>>>0]=0,f+=b.length+1}),0}function ii(n,l){if(O)return Te(19,1,n,l);n>>>=0,l>>>=0;var f=ni();c()[n>>>2>>>0]=f.length;var b=0;return f.forEach(C=>b+=C.length+1),c()[l>>>2>>>0]=b,0}function ai(n){return O?Te(20,1,n):52}function si(n,l,f,b){return O?Te(21,1,n,l,f,b):52}function ui(n,l,f,b){return O?Te(22,1,n,l,f,b):70}var Xd=[null,[],[]];function di(n,l,f,b){if(O)return Te(23,1,n,l,f,b);l>>>=0,f>>>=0,b>>>=0;for(var C=0,k=0;k<f;k++){var V=c()[l>>>2>>>0],F=c()[l+4>>>2>>>0];l+=8;for(var re=0;re<F;re++){var J=o()[V+re>>>0],ce=Xd[n];J===0||J===10?((n===1?We:ee)(Pr(ce,0)),ce.length=0):ce.push(J)}C+=F}return c()[b>>>2>>>0]=C,0}var li=[31,29,31,30,31,30,31,31,30,31,30,31],ci=[31,28,31,30,31,30,31,31,30,31,30,31];function Qd(n){var l=Array(gt(n)+1);return dt(n,l,0,l.length),l}var Jd=(n,l)=>{r().set(n,l>>>0)};function pi(n,l,f,b){function C(z,we,Pe){for(z=typeof z=="number"?z.toString():z||"";z.length<we;)z=Pe[0]+z;return z}function k(z,we){return C(z,we,"0")}function V(z,we){function Pe(Ci){return 0>Ci?-1:0<Ci?1:0}var er;return(er=Pe(z.getFullYear()-we.getFullYear()))===0&&(er=Pe(z.getMonth()-we.getMonth()))===0&&(er=Pe(z.getDate()-we.getDate())),er}function F(z){switch(z.getDay()){case 0:return new Date(z.getFullYear()-1,11,29);case 1:return z;case 2:return new Date(z.getFullYear(),0,3);case 3:return new Date(z.getFullYear(),0,2);case 4:return new Date(z.getFullYear(),0,1);case 5:return new Date(z.getFullYear()-1,11,31);case 6:return new Date(z.getFullYear()-1,11,30)}}function re(z){var we=z.zb;for(z=new Date(new Date(z.Ab+1900,0,1).getTime());0<we;){var Pe=z.getMonth(),er=(zt(z.getFullYear())?li:ci)[Pe];if(we>er-z.getDate())we-=er-z.getDate()+1,z.setDate(1),11>Pe?z.setMonth(Pe+1):(z.setMonth(0),z.setFullYear(z.getFullYear()+1));else{z.setDate(z.getDate()+we);break}}return Pe=new Date(z.getFullYear()+1,0,4),we=F(new Date(z.getFullYear(),0,4)),Pe=F(Pe),0>=V(we,z)?0>=V(Pe,z)?z.getFullYear()+1:z.getFullYear():z.getFullYear()-1}n>>>=0,l>>>=0,f>>>=0,b>>>=0;var J=c()[b+40>>>2>>>0];b={kc:a()[b>>>2>>>0],jc:a()[b+4>>>2>>>0],Eb:a()[b+8>>>2>>>0],Jb:a()[b+12>>>2>>>0],Fb:a()[b+16>>>2>>>0],Ab:a()[b+20>>>2>>>0],vb:a()[b+24>>>2>>>0],zb:a()[b+28>>>2>>>0],qc:a()[b+32>>>2>>>0],ic:a()[b+36>>>2>>>0],lc:J?He(J):""},f=He(f),J={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ce in J)f=f.replace(new RegExp(ce,"g"),J[ce]);var Re="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ze="January February March April May June July August September October November December".split(" ");J={"%a":z=>Re[z.vb].substring(0,3),"%A":z=>Re[z.vb],"%b":z=>ze[z.Fb].substring(0,3),"%B":z=>ze[z.Fb],"%C":z=>k((z.Ab+1900)/100|0,2),"%d":z=>k(z.Jb,2),"%e":z=>C(z.Jb,2," "),"%g":z=>re(z).toString().substring(2),"%G":re,"%H":z=>k(z.Eb,2),"%I":z=>(z=z.Eb,z==0?z=12:12<z&&(z-=12),k(z,2)),"%j":z=>{for(var we=0,Pe=0;Pe<=z.Fb-1;we+=(zt(z.Ab+1900)?li:ci)[Pe++]);return k(z.Jb+we,3)},"%m":z=>k(z.Fb+1,2),"%M":z=>k(z.jc,2),"%n":()=>`\n`,"%p":z=>0<=z.Eb&&12>z.Eb?"AM":"PM","%S":z=>k(z.kc,2),"%t":()=>"	","%u":z=>z.vb||7,"%U":z=>k(Math.floor((z.zb+7-z.vb)/7),2),"%V":z=>{var we=Math.floor((z.zb+7-(z.vb+6)%7)/7);if(2>=(z.vb+371-z.zb-2)%7&&we++,we)we==53&&(Pe=(z.vb+371-z.zb)%7,Pe==4||Pe==3&&zt(z.Ab)||(we=1));else{we=52;var Pe=(z.vb+7-z.zb-1)%7;(Pe==4||Pe==5&&zt(z.Ab%400-1))&&we++}return k(we,2)},"%w":z=>z.vb,"%W":z=>k(Math.floor((z.zb+7-(z.vb+6)%7)/7),2),"%y":z=>(z.Ab+1900).toString().substring(2),"%Y":z=>z.Ab+1900,"%z":z=>{z=z.ic;var we=0<=z;return z=Math.abs(z)/60,(we?"+":"-")+("0000"+(z/60*100+z%60)).slice(-4)},"%Z":z=>z.lc,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(ce in J)f.includes(ce)&&(f=f.replace(new RegExp(ce,"g"),J[ce](b)));return f=f.replace(/\\0\\0/g,"%"),ce=Qd(f),ce.length>l?0:(Jd(ce,n),ce.length-1)}ge.Gb();for(var mi=Array(256),cn=0;256>cn;++cn)mi[cn]=String.fromCharCode(cn);on=mi,wt=d.BindingError=class extends Error{constructor(n){super(n),this.name="BindingError"}},d.InternalError=class extends Error{constructor(n){super(n),this.name="InternalError"}},lt.push(0,1,void 0,1,null,1,!0,1,!1,1),d.count_emval_handles=()=>lt.length/2-5-fr.length;var el=[dr,jr,Yr,Xr,Qr,Zt,kr,Or,Jr,pr,en,tn,rn,nn,Rr,Xt,ei,ti,oi,ii,ai,si,ui,di],tl={ua:function(n,l,f){return te(async()=>{await d.Zb(n,l,f)})},b:function(n,l,f){throw n>>>=0,new qn(n).Gb(l>>>0,f>>>0),Kr=n,jn++,Kr},ia:function(n){hi(n>>>0,!E,1,!x,131072,!1),ge.Pb()},G:function(n){n>>>=0,O?postMessage({cmd:"cleanupThread",thread:n}):ge.Nb(ge.ub[n])},_:Zr,B:Xr,pa:Qr,W:Zt,Y:kr,qa:Or,na:Jr,fa:pr,ma:en,K:tn,X:rn,U:nn,oa:Rr,V:Xt,E:function(n,l,f){n>>>=0,f>>>=0,l=nt(l>>>0),Je(n,{name:l,fromWireType:b=>b,toWireType:function(b,C){if(typeof C!="bigint"&&typeof C!="number")throw C===null?C="null":(b=typeof C,C=b==="object"||b==="array"||b==="function"?C.toString():""+C),new TypeError(`Cannot convert "${C}" to ${this.name}`);return typeof C=="number"&&(C=BigInt(C)),C},argPackAdvance:8,readValueFromPointer:Dr(l,f,l.indexOf("u")==-1),Bb:null})},O:function(n,l,f,b){n>>>=0,l=nt(l>>>0),Je(n,{name:l,fromWireType:function(C){return!!C},toWireType:function(C,k){return k?f:b},argPackAdvance:8,readValueFromPointer:function(C){return this.fromWireType(o()[C>>>0])},Bb:null})},N:function(n){return Je(n>>>0,Zn)},D:function(n,l,f){n>>>=0,f>>>=0,l=nt(l>>>0),Je(n,{name:l,fromWireType:b=>b,toWireType:(b,C)=>C,argPackAdvance:8,readValueFromPointer:an(l,f),Bb:null})},t:function(n,l,f,b,C){if(n>>>=0,f>>>=0,l=nt(l>>>0),C===-1&&(C=4294967295),C=F=>F,b===0){var k=32-8*f;C=F=>F<<k>>>k}var V=l.includes("unsigned")?function(F,re){return re>>>0}:function(F,re){return re};Je(n,{name:l,fromWireType:C,toWireType:V,argPackAdvance:8,readValueFromPointer:Dr(l,f,b!==0),Bb:null})},p:function(n,l,f){function b(k){var V=c()[k>>>2>>>0];return k=c()[k+4>>>2>>>0],new C(r().buffer,k,V)}n>>>=0;var C=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][l];f=nt(f>>>0),Je(n,{name:f,fromWireType:b,argPackAdvance:8,readValueFromPointer:b},{Ub:!0})},F:function(n,l){n>>>=0,l=nt(l>>>0);var f=l==="std::string";Je(n,{name:l,fromWireType:function(b){var C=c()[b>>>2>>>0],k=b+4;if(f)for(var V=k,F=0;F<=C;++F){var re=k+F;if(F==C||o()[re>>>0]==0){if(V=He(V,re-V),J===void 0)var J=V;else J+=String.fromCharCode(0),J+=V;V=re+1}}else{for(J=Array(C),F=0;F<C;++F)J[F]=String.fromCharCode(o()[k+F>>>0]);J=J.join("")}return Ct(b),J},toWireType:function(b,C){C instanceof ArrayBuffer&&(C=new Uint8Array(C));var k=typeof C=="string";if(!(k||C instanceof Uint8Array||C instanceof Uint8ClampedArray||C instanceof Int8Array))throw new wt("Cannot pass non-string to std::string");var V=f&&k?gt(C):C.length,F=mn(4+V+1),re=F+4;if(c()[F>>>2>>>0]=V,f&&k)Rt(C,re,V+1);else if(k)for(k=0;k<V;++k){var J=C.charCodeAt(k);if(255<J)throw Ct(re),new wt("String has UTF-16 code units that do not fit in 8 bits");o()[re+k>>>0]=J}else for(k=0;k<V;++k)o()[re+k>>>0]=C[k];return b!==null&&b.push(Ct,F),F},argPackAdvance:8,readValueFromPointer:Qt,Bb(b){Ct(b)}})},A:function(n,l,f){if(n>>>=0,l>>>=0,f>>>=0,f=nt(f),l===2)var b=Xn,C=sn,k=un,V=F=>u()[F>>>1>>>0];else l===4&&(b=gr,C=Qn,k=pe,V=F=>c()[F>>>2>>>0]);Je(n,{name:f,fromWireType:F=>{for(var re=c()[F>>>2>>>0],J,ce=F+4,Re=0;Re<=re;++Re){var ze=F+4+Re*l;(Re==re||V(ze)==0)&&(ce=b(ce,ze-ce),J===void 0?J=ce:(J+=String.fromCharCode(0),J+=ce),ce=ze+l)}return Ct(F),J},toWireType:(F,re)=>{if(typeof re!="string")throw new wt(`Cannot pass non-string to C++ string type ${f}`);var J=k(re),ce=mn(4+J+l);return c()[ce>>>2>>>0]=J/l,C(re,ce+4,J+l),F!==null&&F.push(Ct,ce),ce},argPackAdvance:8,readValueFromPointer:Qt,Bb(F){Ct(F)}})},P:function(n,l){n>>>=0,l=nt(l>>>0),Je(n,{Vb:!0,name:l,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})},ta:()=>1,S:function(n,l){n>>>=0,n==l>>>0?setTimeout(rt):O?postMessage({targetThread:n,cmd:"checkMailbox"}):(n=ge.ub[n])&&n.postMessage({cmd:"checkMailbox"})},$:function(n,l,f,b,C){l>>>=0,f>>>=0,b/=2,yr.length=b,C=C>>>0>>>3;for(var k=0;k<b;k++)yr[k]=De[C+2*k]?De[C+2*k+1]:h()[C+2*k+1>>>0];return n=l?Ir[l]:el[n],ge.Sb=f,f=n(...yr),ge.Sb=0,f},ha:Wt,sa:function(n){P&&ge.ub[n>>>0].ref()},w:function(n,l,f){return l>>>=0,f>>>=0,n=Qe(n>>>0),l=br(l,"emval::as"),Ur(l,f,n)},z:function(n){return n>>>=0,te(()=>(n=Qe(n),n.then(ot)))},o:function(n,l,f,b){return f>>>=0,b>>>=0,n=X[n>>>0],l=Qe(l>>>0),n(null,l,f,b)},k:function(n,l,f,b,C){return f>>>=0,b>>>=0,C>>>=0,n=X[n>>>0],l=Qe(l>>>0),f=Ee(f),n(l,l[f],b,C)},c:hr,y:function(n,l){return l>>>=0,n=Qe(n>>>0),l=Qe(l),n==l},n:function(n){return n>>>=0,n===0?ot(Oe()):(n=Ee(n),ot(Oe()[n]))},j:function(n,l,f){l=be(n,l>>>0);var b=l.shift();n--;var C=`return function (obj, func, destructorsRef, args) {\n`,k=0,V=[];f===0&&V.push("obj");for(var F=["retType"],re=[b],J=0;J<n;++J)V.push("arg"+J),F.push("argType"+J),re.push(l[J]),C+=`  var arg${J} = argType${J}.readValueFromPointer(args${k?"+"+k:""});\n`,k+=l[J].argPackAdvance;return C+=`  var rv = ${f===1?"new func":"func.call"}(${V.join(", ")});\n`,b.Vb||(F.push("emval_returnValue"),re.push(Ur),C+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),F.push(C+`};\n`),n=Dt(F)(...re),f=`methodCaller<(${l.map(ce=>ce.name).join(", ")}) => ${b.name}>`,D(Ie(f,n))},s:function(n,l){return l>>>=0,n=Qe(n>>>0),l=Qe(l),ot(n[l])},d:function(n){n>>>=0,9<n&&(lt[n+1]+=1)},v:function(){return ot([])},m:function(n){n=Qe(n>>>0);for(var l=Array(n.length),f=0;f<n.length;f++)l[f]=n[f];return ot(l)},g:function(n){return ot(Ee(n>>>0))},l:function(){return ot({})},i:function(n){n>>>=0;for(var l=Qe(n);l.length;){var f=l.pop();l.pop()(f)}hr(n)},h:function(n,l,f){l>>>=0,f>>>=0,n=Qe(n>>>0),l=Qe(l),f=Qe(f),n[l]=f},e:function(n,l){return l>>>=0,n=br(n>>>0,"_emval_take_value"),n=n.readValueFromPointer(l),ot(n)},ca:function(n,l){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),l>>>=0,n=new Date(1e3*n),a()[l>>>2>>>0]=n.getUTCSeconds(),a()[l+4>>>2>>>0]=n.getUTCMinutes(),a()[l+8>>>2>>>0]=n.getUTCHours(),a()[l+12>>>2>>>0]=n.getUTCDate(),a()[l+16>>>2>>>0]=n.getUTCMonth(),a()[l+20>>>2>>>0]=n.getUTCFullYear()-1900,a()[l+24>>>2>>>0]=n.getUTCDay(),n=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[l+28>>>2>>>0]=n},da:function(n,l){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n),l>>>=0,n=new Date(1e3*n),a()[l>>>2>>>0]=n.getSeconds(),a()[l+4>>>2>>>0]=n.getMinutes(),a()[l+8>>>2>>>0]=n.getHours(),a()[l+12>>>2>>>0]=n.getDate(),a()[l+16>>>2>>>0]=n.getMonth(),a()[l+20>>>2>>>0]=n.getFullYear()-1900,a()[l+24>>>2>>>0]=n.getDay();var f=(zt(n.getFullYear())?Qo:Jo)[n.getMonth()]+n.getDate()-1|0;a()[l+28>>>2>>>0]=f,a()[l+36>>>2>>>0]=-(60*n.getTimezoneOffset()),f=new Date(n.getFullYear(),6,1).getTimezoneOffset();var b=new Date(n.getFullYear(),0,1).getTimezoneOffset();n=(f!=b&&n.getTimezoneOffset()==Math.min(b,f))|0,a()[l+32>>>2>>>0]=n},ea:function(n){n>>>=0;var l=new Date(a()[n+20>>>2>>>0]+1900,a()[n+16>>>2>>>0],a()[n+12>>>2>>>0],a()[n+8>>>2>>>0],a()[n+4>>>2>>>0],a()[n>>>2>>>0],0),f=a()[n+32>>>2>>>0],b=l.getTimezoneOffset(),C=new Date(l.getFullYear(),6,1).getTimezoneOffset(),k=new Date(l.getFullYear(),0,1).getTimezoneOffset(),V=Math.min(k,C);return 0>f?a()[n+32>>>2>>>0]=+(C!=k&&V==b):0<f!=(V==b)&&(C=Math.max(k,C),l.setTime(l.getTime()+6e4*((0<f?V:C)-b))),a()[n+24>>>2>>>0]=l.getDay(),f=(zt(l.getFullYear())?Qo:Jo)[l.getMonth()]+l.getDate()-1|0,a()[n+28>>>2>>>0]=f,a()[n>>>2>>>0]=l.getSeconds(),a()[n+4>>>2>>>0]=l.getMinutes(),a()[n+8>>>2>>>0]=l.getHours(),a()[n+12>>>2>>>0]=l.getDate(),a()[n+16>>>2>>>0]=l.getMonth(),a()[n+20>>>2>>>0]=l.getYear(),n=l.getTime(),BigInt(isNaN(n)?-1:n/1e3)},aa:ei,ba:ti,R:function(n,l,f,b){n>>>=0,l>>>=0,f>>>=0,b>>>=0;var C=new Date().getFullYear(),k=new Date(C,0,1),V=new Date(C,6,1);C=k.getTimezoneOffset();var F=V.getTimezoneOffset(),re=Math.max(C,F);c()[n>>>2>>>0]=60*re,a()[l>>>2>>>0]=+(C!=F),n=J=>J.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1],k=n(k),V=n(V),F<C?(Rt(k,f,17),Rt(V,b,17)):(Rt(k,b,17),Rt(V,f,17))},q:()=>{Kt("")},f:function(n,l,f){return n>>>=0,l=ri(l>>>0,f>>>0),Ir[n](...l)},M:function(n,l,f){return n>>>=0,l=ri(l>>>0,f>>>0),Ir[n](...l)},H:()=>{},L:()=>Date.now(),ra:()=>{throw bt+=1,"unwind"},T:function(){return 4294901760},u:()=>performance.timeOrigin+performance.now(),x:()=>P?(Ri(),wr(Oi)).cpus().length:navigator.hardwareConcurrency,Q:function(n){n>>>=0;var l=o().length;if(n<=l||4294901760<n)return!1;for(var f=1;4>=f;f*=2){var b=l*(1+.2/f);b=Math.min(b,n+100663296);var C=Math;b=Math.max(n,b);e:{C=(C.min.call(C,4294901760,b+(65536-b%65536)%65536)-ae.buffer.byteLength+65535)/65536;try{ae.grow(C),Ne();var k=1;break e}catch{}k=void 0}if(k)return!0}return!1},ja:oi,la:ii,Z:Xe,C:ai,J:si,ga:ui,I:di,a:ae||d.wasmMemory,ka:pi,r:function(n,l,f,b){return pi(n>>>0,l>>>0,f>>>0,b>>>0)}},oe=function(){function n(f,b){return oe=f.exports,oe=dn(),oe=rl(),ge.Qb.push(oe.cb),Ot.unshift(oe.va),Ae=b,xr(),oe}var l={a:tl};if(Ut++,d.instantiateWasm)try{return d.instantiateWasm(l,n)}catch(f){ee(`Module.instantiateWasm callback failed with error: ${f}`),w(f)}return Ar(l,function(f){n(f.instance,f.module)}).catch(w),{}}(),fi=n=>(fi=oe.wa)(n);d.__embind_initialize_bindings=()=>(d.__embind_initialize_bindings=oe.xa)(),d._OrtInit=(n,l)=>(d._OrtInit=oe.ya)(n,l),d._OrtGetLastError=(n,l)=>(d._OrtGetLastError=oe.za)(n,l),d._OrtCreateSessionOptions=(n,l,f,b,C,k,V,F,re,J)=>(d._OrtCreateSessionOptions=oe.Aa)(n,l,f,b,C,k,V,F,re,J),d._OrtAppendExecutionProvider=(n,l)=>(d._OrtAppendExecutionProvider=oe.Ba)(n,l),d._OrtAddFreeDimensionOverride=(n,l,f)=>(d._OrtAddFreeDimensionOverride=oe.Ca)(n,l,f),d._OrtAddSessionConfigEntry=(n,l,f)=>(d._OrtAddSessionConfigEntry=oe.Da)(n,l,f),d._OrtReleaseSessionOptions=n=>(d._OrtReleaseSessionOptions=oe.Ea)(n),d._OrtCreateSession=(n,l,f)=>(d._OrtCreateSession=oe.Fa)(n,l,f),d._OrtReleaseSession=n=>(d._OrtReleaseSession=oe.Ga)(n),d._OrtGetInputOutputCount=(n,l,f)=>(d._OrtGetInputOutputCount=oe.Ha)(n,l,f),d._OrtGetInputName=(n,l)=>(d._OrtGetInputName=oe.Ia)(n,l),d._OrtGetOutputName=(n,l)=>(d._OrtGetOutputName=oe.Ja)(n,l),d._OrtFree=n=>(d._OrtFree=oe.Ka)(n),d._OrtCreateTensor=(n,l,f,b,C,k)=>(d._OrtCreateTensor=oe.La)(n,l,f,b,C,k),d._OrtGetTensorData=(n,l,f,b,C)=>(d._OrtGetTensorData=oe.Ma)(n,l,f,b,C),d._OrtReleaseTensor=n=>(d._OrtReleaseTensor=oe.Na)(n),d._OrtCreateRunOptions=(n,l,f,b)=>(d._OrtCreateRunOptions=oe.Oa)(n,l,f,b),d._OrtAddRunConfigEntry=(n,l,f)=>(d._OrtAddRunConfigEntry=oe.Pa)(n,l,f),d._OrtReleaseRunOptions=n=>(d._OrtReleaseRunOptions=oe.Qa)(n),d._OrtCreateBinding=n=>(d._OrtCreateBinding=oe.Ra)(n),d._OrtBindInput=(n,l,f)=>(d._OrtBindInput=oe.Sa)(n,l,f),d._OrtBindOutput=(n,l,f,b)=>(d._OrtBindOutput=oe.Ta)(n,l,f,b),d._OrtClearBoundOutputs=n=>(d._OrtClearBoundOutputs=oe.Ua)(n),d._OrtReleaseBinding=n=>(d._OrtReleaseBinding=oe.Va)(n),d._OrtRunWithBinding=(n,l,f,b,C)=>(d._OrtRunWithBinding=oe.Wa)(n,l,f,b,C),d._OrtRun=(n,l,f,b,C,k,V,F)=>(d._OrtRun=oe.Xa)(n,l,f,b,C,k,V,F),d._OrtEndProfiling=n=>(d._OrtEndProfiling=oe.Ya)(n),d._JsepOutput=(n,l,f)=>(d._JsepOutput=oe.Za)(n,l,f),d._JsepGetNodeName=n=>(d._JsepGetNodeName=oe._a)(n);var pn=d._pthread_self=()=>(pn=d._pthread_self=oe.$a)(),mn=d._malloc=n=>(mn=d._malloc=oe.ab)(n),Ct=d._free=n=>(Ct=d._free=oe.bb)(n);d.__emscripten_tls_init=()=>(d.__emscripten_tls_init=oe.cb)();var hi=d.__emscripten_thread_init=(n,l,f,b,C,k)=>(hi=d.__emscripten_thread_init=oe.eb)(n,l,f,b,C,k);d.__emscripten_thread_crashed=()=>(d.__emscripten_thread_crashed=oe.fb)();var gi=(n,l,f,b,C)=>(gi=oe.gb)(n,l,f,b,C),ro=n=>(ro=oe.hb)(n),no=d.__emscripten_thread_exit=n=>(no=d.__emscripten_thread_exit=oe.ib)(n),yi=()=>(yi=oe.jb)(),bi=(n,l)=>(bi=oe.kb)(n,l),fn=n=>(fn=oe.lb)(n),oo=n=>(oo=oe.mb)(n),io=()=>(io=oe.nb)(),wi=d.dynCall_ii=(n,l)=>(wi=d.dynCall_ii=oe.pb)(n,l),vi=n=>(vi=oe.qb)(n),$i=()=>($i=oe.rb)(),_i=n=>(_i=oe.sb)(n),Si=()=>(Si=oe.tb)();d.___start_em_js=839500,d.___stop_em_js=839661;function rl(){var n=oe;n=Object.assign({},n);var l=b=>C=>b(C)>>>0,f=b=>()=>b()>>>0;return n.wa=l(n.wa),n.$a=f(n.$a),n.ab=l(n.ab),n.emscripten_main_runtime_thread_id=f(n.emscripten_main_runtime_thread_id),n.mb=l(n.mb),n.nb=f(n.nb),n}d.wasmMemory=ae,d.stackSave=()=>io(),d.stackRestore=n=>fn(n),d.stackAlloc=n=>oo(n),d.keepRuntimeAlive=()=>0<bt,d.UTF8ToString=He,d.stringToUTF8=Rt,d.lengthBytesUTF8=gt,d.ExitStatus=st,d.PThread=ge;var hn;jt=function n(){hn||xi(),hn||(jt=n)};function xi(){if(!(0<Ut))if(O)y(d),O||Yt(Ot),startWorker(d);else{if(d.preRun)for(typeof d.preRun=="function"&&(d.preRun=[d.preRun]);d.preRun.length;)mt.unshift(d.preRun.shift());Yt(mt),0<Ut||hn||(hn=!0,d.calledRun=!0,me||(O||Yt(Ot),y(d),O||Yt(qt)))}}return xi(),_}})();typeof Di=="object"&&typeof mo=="object"?mo.exports=Bi:typeof define=="function"&&define.amd&&define([],()=>Bi)});var Mi=Wr((gm,cl)=>{cl.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs"),vm=require("vm");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>vm.runInThisContext(fs.readFileSync(e,"utf8"),{filename:e}),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(...e){var a=e.join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,a+`\\n`);return}console.error(a)}function threadAlert(...e){var a=e.join(" ");postMessage({cmd:"alert",text:a,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,a)=>{var r=Module.wasmModule;Module.wasmModule=null;var t=new WebAssembly.Instance(r,e);return a(t)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let r=[];self.onmessage=t=>r.push(t),self.startWorker=t=>{Module=t,postMessage({cmd:"loaded"});for(let s of r)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const t of e.data.handlers)Module[t]=(...s)=>{postMessage({cmd:"callHandler",handler:t,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var a=URL.createObjectURL(e.data.urlOrBlob);importScripts(a),URL.revokeObjectURL(a)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(r){if(r!="unwind")throw r}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(r){throw Module.__emscripten_thread_crashed?.(),r}}self.onmessage=handleMessage;\\n\'});var go,Nt,tr,bn,Gr,Hi,yo,ye=Y(()=>{"use strict";go=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Nt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},tr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],bn=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Gr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Hi=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool",yo=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var wn=Y(()=>{"use strict"});var Fi=Y(()=>{"use strict";wn()});var qi,ji=Y(()=>{"use strict";qi="1.18.0-dev.20240424-218b6b0a73"});var Ki,pt,bo=Y(()=>{"use strict";ji();Ki="warning",pt={wasm:{},webgl:{},webgpu:{},versions:{common:qi},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Ki=e}},get logLevel(){return Ki}};Object.defineProperty(pt,"logLevel",{enumerable:!0})});var vr,Yi=Y(()=>{"use strict";bo();vr=pt});var Zi=Y(()=>{"use strict"});var Xi=Y(()=>{"use strict";vn()});var Ji=Y(()=>{"use strict"});var ea=Y(()=>{"use strict";vn()});var vn=Y(()=>{"use strict";Zi();Xi();Ji();ea()});var $n=Y(()=>{"use strict";vn()});var wo,ta,rr,Gt,vo=Y(()=>{"use strict";bo();wo=(e,t)=>{(typeof pt.trace>"u"?!pt.wasm.trace:!pt.trace)||console.timeStamp(`${e}::ORT::${t}`)},ta=(e,t)=>{let r=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],o=!1;for(let i=0;i<r.length;i++){if(o&&!r[i].includes("TRACE_FUNC")){let u=`FUNC_${e}::${r[i].trim().split(" ")[1]}`;t&&(u+=`::${t}`),wo("CPU",u);return}r[i].includes("TRACE_FUNC")&&(o=!0)}},rr=e=>{(typeof pt.trace>"u"?!pt.wasm.trace:!pt.trace)||ta("BEGIN",e)},Gt=e=>{(typeof pt.trace>"u"?!pt.wasm.trace:!pt.trace)||ta("END",e)}});var ra=Y(()=>{"use strict";wn();$n();vo()});var na=Y(()=>{"use strict";ra()});var oa=Y(()=>{"use strict"});var ia=Y(()=>{"use strict"});var aa=Y(()=>{"use strict"});var sa=Y(()=>{"use strict"});var ua=Y(()=>{"use strict";wn();$n()});var da=Y(()=>{"use strict";ua()});var $r=Y(()=>{"use strict";Fi();Yi();na();$n();oa();ia();vo();aa();sa();da()});var _l,Sl,la,ca,pa,xl,Ve,Ht=Y(()=>{"use strict";ye();_l=["V","I","W","E","F"],Sl=(e,t)=>{console.log(`[${_l[e]},${new Date().toISOString()}]${t}`)},pa=(e,t)=>{la=e,ca=t},xl=(e,t)=>{let r=Gr(e),o=Gr(la);r>=o&&Sl(r,typeof t=="function"?t():t)},Ve=(...e)=>{ca&&xl(...e)}});var ma,fa=Y(()=>{"use strict";ye();ma=(e,t)=>new(bn(t))(e)});var _n=Y(()=>{"use strict"});var ha,$o,_o,Cl,Al,ga,xo,So,ba,wa=Y(()=>{"use strict";Ht();_n();ha=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),$o=[],_o=e=>Math.ceil(e/16)*16,Cl=e=>{for(let t=0;t<$o.length;t++){let r=$o[t];if(e<=r)return r}return Math.ceil(e/16)*16},Al=1,ga=()=>Al++,xo=async(e,t,r,o)=>{let i=_o(r),u=e.device.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let a=e.getCommandEncoder();e.endComputePass(),a.copyBufferToBuffer(t,0,u,0,i),e.flush(),await u.mapAsync(GPUMapMode.READ);let c=u.getMappedRange();if(o){let p=o();return p.set(new Uint8Array(c,0,r)),p}else return new Uint8Array(c.slice(0,r))}finally{u.destroy()}},So=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map,this.capturedPendingBuffers=new Map;for(let[r]of ha)$o.push(r),this.freeBuffers.set(r,[]),this.freeUniformBuffers.set(r,[])}upload(t,r){let o=r.buffer,i=r.byteOffset,u=r.byteLength,a=_o(u),c=this.storageCache.get(t);if(!c)throw new Error("gpu data for uploading does not exist");if(c.originalSize!==u)throw new Error(`inconsistent data size. gpu data size=${c.originalSize}, data size=${u}`);let p=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),h=p.getMappedRange();new Uint8Array(h).set(new Uint8Array(o,i,u)),p.unmap();let d=this.backend.getCommandEncoder();this.backend.endComputePass(),d.copyBufferToBuffer(p,0,c.gpuData.buffer,0,a),Ve("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(p)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(r);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let u=_o(o.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(o.gpuData.buffer,0,i.gpuData.buffer,0,u)}registerExternalBuffer(t,r,o){let i;if(o){if(i=this.externalBuffers.get(o),i===void 0)throw new Error("previous buffer is not registered");if(t===o)return Ve("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, buffer is the same, skip.`),i;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`);this.externalBuffers.delete(o)}else i=ga();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,i),Ve("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${i}, registered.`),i}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Ve("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Cl(t),i,u=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(u||a){let h=(u?this.freeBuffers:this.freeUniformBuffers).get(o);h?h.length>0?i=h.pop():i=this.backend.device.createBuffer({size:o,usage:r}):i=this.backend.device.createBuffer({size:o,usage:r})}else i=this.backend.device.createBuffer({size:o,usage:r});let c={id:ga(),type:0,buffer:i};return this.storageCache.set(c.id,{gpuData:c,originalSize:t}),Ve("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${c.id}`),c}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Ve("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await xo(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let t of this.buffersPending){let r=ha.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let o=this.freeBuffers.get(t.size)||[];r===void 0||o.length>=r?t.destroy():o.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let o=this.freeUniformBuffers.get(t.size)||[];r===void 0||o.length>=r?t.destroy():o.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let r of this.buffersPending)t.push(r);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onReleaseSession(t){let r=this.capturedPendingBuffers.get(t);r&&(r.forEach(o=>{o.destroy()}),this.capturedPendingBuffers.delete(t))}},ba=(...e)=>new So(...e)});var Co,ve,Ze=Y(()=>{"use strict";Co=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},ve=e=>new Co(e)});var Ao,At,M,nr,Sn,xn,Cn,Se=Y(()=>{"use strict";Ao=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},At=class{static calcShape(t,r,o=!1){let i=t.length,u=r.length;if(i===0)return r;if(u===0)return t;let a=Math.max(t.length,r.length),c=new Array(a);if(o){if(i<2||u<2)return;let p=Ao.calcMatMulShape([t[i-2],t[i-1]],[r[u-2],r[u-1]]);if(p===void 0)return;[c[a-2],c[a-1]]=p}for(let p=o?3:1;p<=a;p++){let h=i-p<0?1:t[i-p],d=u-p<0?1:r[u-p];if(h!==d&&h>1&&d>1)return;let y=Math.max(h,d);if(h&&d)c[a-p]=Math.max(h,d);else{if(y>1)return;c[a-p]=0}}return c}static isValidBroadcast(t,r){let o=t.length,i=r.length;if(o>i)return!1;for(let u=1;u<=o;u++)if(t[o-u]!==1&&t[o-u]!==r[i-u])return!1;return!0}},M=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,r=4){let o=t.length;if(o===0)return[];let i=new Array(o),u=o-1;for(;u>=0;){if(t[u]%r===0){i[u]=t[u]/r;break}if(r%t[u]!==0)throw new Error("cannot convert shape");i[u]=1,r/=t[u],u--}for(u--;u>=0;u--)i[u]=t[u];return i}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let i=1;for(let u=r;u<o;u++){if(t[u]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");i*=t[u]}return i}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let i=r-3;i>=0;--i)o[i]=o[i+1]*t[i+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((i,u)=>i+r[u]+r[u+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,i)=>o===r[i])}},nr=class e{static adjustPoolAttributes(t,r,o,i,u,a){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let c=0;c<r.length-2;c++)c>=o.length?o.push(r[c+2]):o[c]=r[c+2];for(let c=0;c<o.length;c++)if(c<i.length){if(i[c]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let c=0;c<o.length;c++)if(c<u.length){if(u[c]<0)throw new Error("dilations should be greater than or equal to 1")}else u.push(1);for(let c=0;c<o.length*2;c++)if(c<a.length){if(a[c]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let c=0;c<o.length;c++){if(o[c]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[c]>=o[c]||a[c+o.length]>=o[c])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,i,u,a,c){if(c){if(u.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(i.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let p=0;p<t.length-2;p++)e.adjustPadAndReturnShape(t[p+(a?1:2)],r[p],o[p],i[p],u,p,p+t.length-2,c)}}static computePoolOutputShape(t,r,o,i,u,a,c){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let p=[r[0],r[1]];return e.computeShapeHelper(t,r,p,o,i,u,a,c),p}static computeConvOutputShape(t,r,o,i,u,a,c){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let p=[t[0],r[0]];return e.computeShapeHelper(!1,t,p,o,i,u,a,c),p}static computeShapeHelper(t,r,o,i,u,a,c,p){if(t)for(let h=0;h<r.length-2;h++)o.push(1);else for(let h=0;h<r.length-2;h++)o.push(e.adjustPadAndReturnShape(r[h+2],i[h],u[h],a[h],c,h,h+r.length-2,p))}static adjustPadAndReturnShape(t,r,o,i,u,a,c,p){let h=o*(i-1)+1;if(p&&p!=="NOTSET")switch(p){case"VALID":return u[a]=0,u[c]=0,Math.floor((t-h)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let y=((t+r-1)/r-1)*r+i-t;return u[a]=Math.floor(p==="SAME_LOWER"?(y+1)/2:y/2),u[c]=y-u[a],Math.floor((t+y-i)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+u[a]+u[c]-h)/r+1)}},Sn=class{static getShapeOfGemmResult(t,r,o,i,u){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let a,c,p;r?(a=t[1],c=t[0]):(a=t[0],c=t[1]);let h=-1;if(i?(p=o[0],h=1):(p=o[1],h=0),o[h]!==c)throw new Error("dimension mismatch");if(a<=0||p<=0||c<=0)throw new Error("invalid shape specified");if(u&&!At.isValidBroadcast(u,[a,p]))throw new Error("gemm: invalid bias shape for broadcast");return[a,p,c]}},xn=-34028234663852886e22,Cn=34028234663852886e22});var or,To,Be,et,Z,Me,Lt,ir,$t,fe,Eo,U,j,An,Io,va,_r,_e=Y(()=>{"use strict";ye();Se();or=64,To=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Be=(e,t=1)=>{let r=To(e,t);return typeof r=="string"?r:r[0]},et=(e,t=1)=>{let r=To(e,t);return typeof r=="string"?r:r[1]},Z=(...e)=>{let t=[];return e.forEach(r=>{r.length!==0&&t.push({type:12,data:r},{type:12,data:M.computeStrides(r)})}),t},Me=e=>e%4===0?4:e%2===0?2:1,Lt=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,ir=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}<f32>(${r})`,$t=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,fe=(e,t,r,o)=>e.startsWith("uniforms.")&&r>4?typeof t=="string"?o==="f16"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:o==="f16"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,Eo=(e,t,r,o,i)=>{let u=typeof r=="number",a=u?r:r.length,c=[...new Array(a).keys()],p=a<2?"u32":a<=4?`vec${a}<u32>`:`array<u32, ${a}>`,h=To(t,i),d=typeof h=="string"?h:h[1],y=typeof h=="string"?h:h[0],w={indices:p,value:d,storage:y,tensor:t},_=G=>typeof G=="string"?G:`${G}u`,v={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},S=u?"uniforms.":"",I=`${S}${e}_shape`,A=`${S}${e}_strides`,x="";for(let G=0;G<a-1;G++)x+=`\n    let dim${G} = current / ${fe(A,G,a)};\n    let rest${G} = current % ${fe(A,G,a)};\n    indices[${G}] = dim${G};\n    current = rest${G};\n    `;x+=`indices[${a-1}] = current;`;let E=a<2?"":`\n  fn o2i_${e}(offset: u32) -> ${w.indices} {\n    var indices: ${w.indices};\n    var current = offset;\n    ${x}\n    return indices;\n  }`,P=G=>(v.offsetToIndices=!0,a<2?G:`o2i_${e}(${G})`),O=[];if(a>=2)for(let G=a-1;G>=0;G--)O.push(`${fe(A,G,a)} * (indices[${G}])`);let R=a<2?"":`\n  fn i2o_${e}(indices: ${w.indices}) -> u32 {\n    return ${O.join("+")};\n  }`,H=G=>(v.indicesToOffset=!0,a<2?G:`i2o_${e}(${G})`),N=(...G)=>a===0?"0u":`${w.indices}(${G.map(_).join(",")})`,K=(G,ne)=>a<2?`${G}`:`${fe(G,ne,a)}`,Q=(G,ne,xe)=>a<2?`${G}=${xe};`:`${fe(G,ne,a)}=${xe};`,he={},W=(G,ne)=>{v.broadcastedIndicesToOffset=!0;let xe=`${ne.name}broadcastedIndicesTo${e}Offset`;if(xe in he)return`${xe}(${G})`;let Ke=[];for(let De=a-1;De>=0;De--){let Ge=ne.indicesGet("outputIndices",De+ne.rank-a);Ke.push(`${K(A,De)} * (${Ge} % ${K(I,De)})`)}return he[xe]=`fn ${xe}(outputIndices: ${ne.type.indices}) -> u32 {\n             return ${Ke.length>0?Ke.join("+"):"0u"};\n           }`,`${xe}(${G})`},se=(G,ne)=>(()=>{if(w.storage===w.value)return`${e}[${G}]=${ne};`;if(w.storage==="vec2<u32>"&&w.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${ne}), select(0u, 0xFFFFFFFFu, ${ne} < 0));`;if(w.storage==="vec2<u32>"&&w.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${ne}), 0u);`;if(w.storage==="u32"&&w.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${ne}));`;throw new Error(`not supported combination of storage type ${w.storage} and value type ${w.value} yet`)})(),Ce=G=>(()=>{if(w.storage===w.value)return`${e}[${G}]`;if(w.storage==="vec2<u32>"&&w.value==="i32")return`i32(${e}[${G}].x)`;if(w.storage==="vec2<u32>"&&w.value==="u32")return`u32(${e}[${G}].x)`;if(w.storage==="u32"&&w.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${w.storage} and value type ${w.value} yet`)})(),We=a<2?"":`\n  fn get_${e}ByIndices(indices: ${w.indices}) -> ${d} {\n    return ${Ce(`i2o_${e}(indices)`)};\n  }`,ee=a<2?"":(()=>{let G=c.map(xe=>`d${xe}: u32`).join(", "),ne=c.map(xe=>`d${xe}`).join(", ");return`\n  fn get_${e}(${G}) -> ${d} {\n    return get_${e}ByIndices(${N(ne)});\n  }`})(),ae=(...G)=>{if(G.length!==a)throw new Error(`indices length must be ${a}`);let ne=G.map(_).join(",");return a===0?Ce("0u"):a===1?Ce(ne[0]):(v.get=!0,v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}(${ne})`)},Ae=G=>a<2?Ce(G):(v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}ByIndices(${G})`),me=a<2?"":`\n  fn set_${e}ByIndices(indices: ${w.indices}, value: ${d}) {\n    ${se(`i2o_${e}(indices)`,"value")}\n  }`,ie=a<2?"":(()=>{let G=c.map(xe=>`d${xe}: u32`).join(", "),ne=c.map(xe=>`d${xe}`).join(", ");return`\n  fn set_${e}(${G}, value: ${d}) {\n    set_${e}ByIndices(${N(ne)}, value);\n  }`})();return{impl:()=>{let G=[],ne=!1;return v.offsetToIndices&&(G.push(E),ne=!0),v.indicesToOffset&&(G.push(R),ne=!0),v.broadcastedIndicesToOffset&&(Object.values(he).forEach(xe=>G.push(xe)),ne=!0),v.set&&(G.push(ie),ne=!0),v.setByIndices&&(G.push(me),ne=!0),v.get&&(G.push(ee),ne=!0),v.getByIndices&&(G.push(We),ne=!0),!u&&ne&&G.unshift(`const ${I} = ${w.indices}(${r.join(",")});`,`const ${A} = ${w.indices}(${M.computeStrides(r).join(",")});`),G.join(`\n`)},type:w,offsetToIndices:P,indicesToOffset:H,broadcastedIndicesToOffset:W,indices:N,indicesGet:K,indicesSet:Q,set:(...G)=>{if(G.length!==a+1)throw new Error(`indices length must be ${a}`);let ne=G[a];if(typeof ne!="string")throw new Error("value must be string");let xe=G.slice(0,a).map(_).join(",");return a===0?se("0u",ne):a===1?se(xe[0],ne):(v.set=!0,v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}(${xe}, ${ne})`)},setByOffset:se,setByIndices:(G,ne)=>a<2?se(G,ne):(v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${ne});`),get:ae,getByOffset:Ce,getByIndices:Ae,usage:o,name:e,strides:A,shape:I,rank:a}},U=(e,t,r,o=1)=>Eo(e,t,r,"input",o),j=(e,t,r,o=1)=>Eo(e,t,r,"output",o),An=(e,t,r,o=1)=>Eo(e,t,r,"internal",o),Io=class{constructor(t,r){this.normalizedDispatchGroup=t;this.limits=r;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=or){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],i=typeof t=="number"?1:t[2];if(r>this.limits.maxComputeWorkgroupSizeX||o>this.limits.maxComputeWorkgroupSizeY||i>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${r}, ${o}, ${i}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(r*o*i>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${r}, ${o}, ${i}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let u=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,a=u?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,c=u?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*o*i}u + local_idx;`;return`@compute @workgroup_size(${r}, ${o}, ${i})\n  fn main(${a}) {\n    ${c}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,r){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let o=t.usage==="input"?"read":"read_write",i=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${i}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,o=1){return this.uniforms.push({name:t,type:r,length:o}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o,length:i}of this.uniforms)if(i&&i>4)o==="f16"?t.push(`@align(16) ${r}:array<mat2x4<${o}>, ${Math.ceil(i/8)}>`):t.push(`${r}:array<vec4<${o}>, ${Math.ceil(i/4)}>`);else{let u=i==null||i===1?o:`vec${i}<${o}>`;t.push(`${r}:${u}`)}return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=r=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(r)];return this.uniforms.map(r=>[t(r.type),r.length??1])}},va=(e,t)=>new Io(e,t),_r=(e,t)=>{let r=e.length,o=[];for(let i=0;i<r;i++){let u=r-1-i,a=e[u]||1;(t[t.length-1-i]||1)>1&&a===1&&o.unshift(u)}return o}});var Il,$a,Tl,El,yt,_a,Sa,Sr=Y(()=>{"use strict";ye();Se();Ze();_e();Il=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},$a=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Tl=(e,t)=>M.sortBasedOnPerm(e,$a(e.length,t)),El=(e,t,r,o)=>{let i=[];i.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let u=0;u<t;++u)i.push(r.indicesSet("a",e[u],`i[${u}]`));return i.push("return a;}"),i.join(`\n`)},yt=(e,t)=>{let r=e.dataType,o=e.dims.length,i=$a(o,t),u=Tl(e.dims,i),a=j("output",r,u.length),c=U("a",r,o),p=h=>`\n  ${h.registerUniform("output_size","u32").declareVariables(c,a)}\n\n  ${El(i,o,c,a)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${a.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${a.setByOffset("global_idx",c.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:h=>{let d=M.size(u);return{outputs:[{dims:u,dataType:h[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},...Z(h[0].dims,u)]}},getShaderSource:p}},_a=(e,t)=>{Il(e.inputs),e.compute(yt(e.inputs[0],t.perm))},Sa=e=>ve({perm:e.perm})});var Pl,kl,Ol,Rl,Bl,Dl,zl,Ml,Ul,Vl,It,xa,Ca,Aa,Ia,Ta,Ea,Pa,ka,Oa,Ra,Ba=Y(()=>{"use strict";ye();Se();_e();In();Sr();Pl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},kl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Ol={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Rl={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Bl=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},Dl=(e,t)=>{let r=[],o=e.length;for(let u=0;u<o;u++)t.indexOf(u)===-1&&r.push(e[u]);let i=t.map(u=>e[u]);return[r,i]},zl=(e,t)=>{let r=e.length+t.length,o=[],i=0;for(let u=0;u<r;u++)t.indexOf(u)===-1?o.push(e[i++]):o.push(1);return o},Ml=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},Ul=(e,t)=>{let r=[];if(!Ml(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},Vl=(e,t,r,o,i,u,a)=>{let c=r[0].dims,p=M.size(u),h=M.size(a),d=U("_A",r[0].dataType,c),y=j("output",i,u),w=32,_=`\n          var<workgroup> aBestValues : array<f32, ${w}>;\n       `;return{name:e,shaderCache:t,getShaderSource:S=>`\n        ${S.registerUniform("reduceSize","u32").declareVariables(d,y)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${S.mainStart(w)}\n\n          let outputIndex = global_idx / ${w};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${Ol[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${w}) {\n           let candidate = f32(${d.getByOffset("offset + k")});\n           bestValue = ${Pl[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${w}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${kl[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${y.setByOffset("outputIndex",`${o==="mean"?`${y.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${y.type.storage}(${Rl[o]})`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:p},programUniforms:[{type:12,data:h}]})}},It=(e,t,r,o)=>{let i=e.inputs.length===1?r:Po(e.inputs,r),u=i.axes;u.length===0&&!i.noopWithEmptyAxes&&(u=e.inputs[0].dims.map((_,v)=>v));let a=M.normalizeAxes(u,e.inputs[0].dims.length),c=a,p=e.inputs[0],h=Ul(c,e.inputs[0].dims.length);h.length>0&&(p=e.compute(yt(e.inputs[0],h),{inputs:[0],outputs:[-1]})[0],c=Bl(c.length,p.dims.length));let[d,y]=Dl(p.dims,c),w=d;i.keepDims&&(w=zl(d,a)),e.compute(Vl(t,{hint:i.cacheKey,inputDependencies:["type"]},[p],o,e.inputs[0].dataType,w,y),{inputs:[p]})},xa=(e,t)=>{It(e,"ReduceMeanShared",t,"mean")},Ca=(e,t)=>{It(e,"ReduceL1Shared",t,"l1")},Aa=(e,t)=>{It(e,"ReduceL2Shared",t,"l2")},Ia=(e,t)=>{It(e,"ReduceLogSumExpShared",t,"logSumExp")},Ta=(e,t)=>{It(e,"ReduceMaxShared",t,"max")},Ea=(e,t)=>{It(e,"ReduceMinShared",t,"min")},Pa=(e,t)=>{It(e,"ReduceProdShared",t,"prod")},ka=(e,t)=>{It(e,"ReduceSumShared",t,"sum")},Oa=(e,t)=>{It(e,"ReduceSumSquareShared",t,"sumSquare")},Ra=(e,t)=>{It(e,"ReduceLogSumShared",t,"logSum")}});var Tt,Wl,Tn,Po,Et,Nl,Gl,Hl,Ll,Fl,ql,jl,Kl,Yl,Zl,Pt,Da,za,Ma,Ua,Va,Wa,Na,Ga,Ha,La,In=Y(()=>{"use strict";ye();Se();Ze();_e();Ba();Tt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Wl=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Tn=(e,t,r,o,i,u,a=!1,c=!1)=>{let p=[],h=r[0].dims,d=h.length,y=M.normalizeAxes(i,d),w=!c&&y.length===0;h.forEach((I,A)=>{w||y.indexOf(A)>=0?a&&p.push(1):p.push(I)});let _=p.length,v=M.size(p);return{name:e,shaderCache:t,getShaderSource:I=>{let A=[],x=U("_A",r[0].dataType,d),E=j("output",u,_),P=o(x,E,y),O=P[2];for(let R=0,H=0;R<d;R++)w||y.indexOf(R)>=0?(a&&H++,O=`for(var j${R}: u32 = 0; j${R} < ${h[R]}; j${R}++) {\n                  ${P[2].includes("last_index")?`let last_index = j${R};`:""}\n                  ${x.indicesSet("input_indices",R,`j${R}`)}\n                  ${O}\n                }`):(A.push(`${x.indicesSet("input_indices",R,E.indicesGet("output_indices",H))};`),H++);return`\n\n        ${I.registerUniform("output_size","u32").declareVariables(x,E)}\n\n        ${I.mainStart()}\n          ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${x.type.indices};\n          let output_indices = ${E.offsetToIndices("global_idx")};\n\n          ${A.join(`\n`)}\n          ${P[0]}       // init ops for reduce max/min\n          ${P[1]}\n          ${O}\n          ${P[3]}\n          ${P.length===4?E.setByOffset("global_idx","value"):P.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:p,dataType:u}],dispatchGroup:{x:Math.ceil(v/64)},programUniforms:[{type:12,data:v},...Z(h,p)]})}},Po=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ve({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},Et=(e,t,r,o)=>{let i=e.inputs,u=i.length===1?r:Po(i,r);e.compute(Tn(t,{hint:u.cacheKey,inputDependencies:["rank"]},[i[0]],u.noopWithEmptyAxes&&u.axes.length===0?Wl:o,u.axes,i[0].dataType,u.keepDims,u.noopWithEmptyAxes),{inputs:[0]})},Nl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceLogSum",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,"value = log(value);"])},Gl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceL1",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += abs(${o.getByIndices("input_indices")});`,""])},Hl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceL2",t,(o,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Ll=(e,t)=>{Tt(e.inputs),Et(e,"ReduceLogSumExp",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += exp(${o.getByIndices("input_indices")});`,"value = log(value);"])},Fl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceMax",t,(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(o.indicesSet("input_indices",c,0));return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = max(value, ${o.getByIndices("input_indices")});`,""]})},ql=(e,t)=>{Tt(e.inputs),Et(e,"ReduceMean",t,(o,i,u)=>{let a=1;for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&(a*=e.inputs[0].dims[c]);return["var sum = f32(0);","",`sum += f32(${o.getByIndices("input_indices")});`,`let value = ${i.type.value}(sum / ${a});`]})},jl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceMin",t,(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(`input_indices[${c}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = min(value, ${o.getByIndices("input_indices")});`,""]})},Kl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceProd",t,(o,i)=>[`var value = ${i.type.storage}(1);`,"",`value *= ${o.getByIndices("input_indices")};`,""])},Yl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceSum",t,(o,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,""])},Zl=(e,t)=>{Tt(e.inputs),Et(e,"ReduceSumSquare",t,(o,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += t * t;`,""])},Pt=(e,t,r)=>{if(t.length===0)return r;let o=1,i=1;for(let u=0;u<t.length;u++)t.indexOf(u)===-1?o*=e[u]:i*=e[u];return i<32&&o>1024},Da=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ql(e,t):xa(e,t)},za=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Gl(e,t):Ca(e,t)},Ma=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Hl(e,t):Aa(e,t)},Ua=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ll(e,t):Ia(e,t)},Va=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Fl(e,t):Ta(e,t)},Wa=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?jl(e,t):Ea(e,t)},Na=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Kl(e,t):Pa(e,t)},Ga=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Yl(e,t):ka(e,t)},Ha=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Zl(e,t):Oa(e,t)},La=(e,t)=>{Pt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Nl(e,t):Ra(e,t)}});var Fa,qa,ja,ko,Ka=Y(()=>{"use strict";ye();Ze();In();Fa=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},qa=(e,t)=>{Fa(e.inputs);let r=(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(`input_indices[${c}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(Tn("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ja=(e,t)=>{Fa(e.inputs);let r=(o,i,u)=>{let a=[];for(let c=0;c<o.rank;c++)(u.indexOf(c)>=0||u.length===0)&&a.push(`input_indices[${c}] = 0;`);return[`${a.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(Tn("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ko=e=>ve(e)});var Xl,Ql,Jl,En,Ya,Za,Oo=Y(()=>{"use strict";ye();Se();Ze();_e();Xl=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let r=0,o=e[r],i=o.dataType,u=o.dims.length;e.forEach((a,c)=>{if(c!==r){if(a.dataType!==i)throw new Error("input tensors should be one type");if(a.dims.length!==u)throw new Error("input tensors should have the same shape");a.dims.forEach((p,h)=>{if(h!==t&&p!==o.dims[h])throw new Error("non concat dimensions must match")})}})},Ql=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Jl=(e,t)=>{let r=e.length,o=[];for(let i=0;i<r;++i){let u=t.setByOffset("global_idx",e[i].getByIndices("indices"));r===1?o.push(u):i===0?o.push(`if (inputIndex == ${i}u) { ${u} }`):i===r-1?o.push(`else { ${u} }`):o.push(`else if (inputIndex == ${i}) { ${u} }`)}return o.join(`\n`)},En=(e,t,r,o)=>{let i=M.size(r),u=new Array(e.length),a=new Array(e.length),c=0,p=[],h=[],d=[{type:12,data:i}];for(let S=0;S<e.length;++S)c+=e[S].dims[t],u[S]=c,h.push(e[S].dims.length),a[S]=U(`input${S}`,o,h[S]),p.push("rank"),d.push({type:12,data:u[S]});for(let S=0;S<e.length;++S)d.push(...Z(e[S].dims));d.push(...Z(r));let y=j("output",o,r.length),w=y.indicesGet("indices",t),_=Array.from(Array(u.length).keys()).map(S=>`uniforms.sizeInConcatAxis${S}`).join(","),v=S=>`\n\n  ${(()=>{S.registerUniform("outputSize","u32");for(let I=0;I<e.length;I++)S.registerUniform(`sizeInConcatAxis${I}`,"u32");return S.declareVariables(...a,y)})()}\n\n  ${Ql(u.length,_)}\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${y.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${w});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${u.length}u>(${_});\n      ${w} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Jl(a,y)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:r,dataType:o}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:d}),getShaderSource:v}},Ya=(e,t)=>{let r=e.inputs,o=r[0].dims,i=M.normalizeAxis(t.axis,o.length);Xl(r,i);let u=o.slice();u[i]=r.reduce((c,p)=>c+(p.dims.length>i?p.dims[i]:0),0);let a=r.filter(c=>M.size(c.dims)>0);e.compute(En(a,i,u,r[0].dataType),{inputs:a})},Za=e=>ve({axis:e.axis})});var ec,tc,rc,nc,Pn,oc,Xa,Ro=Y(()=>{"use strict";ye();_n();_e();Oo();ec=(e,t)=>{let r=e[0],o=e[1],i=e[2],u=e[3],a=e[4],c=e[5];if(a&&c)throw new Error("Attention cannot have both past and relative_position_bias");if(r.dims.length!==3)throw new Error(\'Input "input" must have 3 dimensions\');let p=r.dims[0],h=r.dims[1],d=r.dims[2];if(i.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(o.dims.length!==2)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(o.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(i.dims[0]!==o.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let y=i.dims[0]/3,w=y,_=w;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let E of t.qkvHiddenSizes)if(E%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");y=t.qkvHiddenSizes[0],w=t.qkvHiddenSizes[1],_=t.qkvHiddenSizes[2]}let v=h;if(y!==w)throw new Error("qkv_hidden_sizes first element should be same as the second");if(i.dims[0]!==y+w+_)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let S=0;if(a){if(w!==_)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(a.dims.length!==5)throw new Error(\'Input "past" must have 5 dimensions\');if(a.dims[0]!==2)throw new Error(\'Input "past" first dimension must be 2\');if(a.dims[1]!==p)throw new Error(\'Input "past" second dimension must be batch_size\');if(a.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(a.dims[4]!==w/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||(S=a.dims[3])}let I=v+S,A=-1,x=0;if(u)throw new Error("Mask not supported");if(a)throw new Error("past is not supported");return{batchSize:p,sequenceLength:h,pastSequenceLength:S,kvSequenceLength:v,totalSequenceLength:I,maxSequenceLength:A,inputHiddenSize:d,hiddenSize:y,vHiddenSize:_,headSize:Math.floor(y/t.numHeads),vHeadSize:Math.floor(_/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:x,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},tc=(e,t,r,o)=>{let i=Me(o),u=64,a=o/i;a<u?u=1:a/8<64&&(u=Math.ceil(a/8));let c=Math.ceil(o/i/u),p=[{type:t.dataType,data:1/o},{type:12,data:a},{type:12,data:c}],h=Be(t.dataType,i),d=et(1,i),y=w=>{let _=j("x",t.dataType,t.dims,i),S=[{name:"d_inv",type:et(t.dataType)},{name:"d_comp",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`\n  var<workgroup> thread_max: array<f32, ${u}>;\n  var<workgroup> thread_sum: array<f32, ${u}>;\n  ${w.registerUniforms(S).declareVariables(_)}\n  ${w.mainStart([u,1,1])}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = workgroup_id.x * uniforms.d_comp + local_offset;\n\n    var thread_max_vector = ${d}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n      thread_max_vector = max(${d}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(i){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${i}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${u}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${d}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n      sum_vector += exp(${d}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(i){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${i}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${u}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n        x[offset + i] = ${_.type.value}(uniforms.d_inv);\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {\n        var f32input = ${d}(x[offset + i]);\n        x[offset + i] = ${_.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${h};${i}`},getShaderSource:y,getRunData:()=>({outputs:[],dispatchGroup:{x:r},programUniforms:p})}},rc=(e,t,r,o,i,u,a)=>{let c=a+i.kvSequenceLength,p=[i.batchSize,i.numHeads,i.sequenceLength,c],h=u.scale===0?1/Math.sqrt(i.headSize):u.scale,d=Me(i.headSize),y=i.headSize/d,w=12,_={x:Math.ceil(c/w),y:Math.ceil(i.sequenceLength/w),z:i.batchSize*i.numHeads},v=[{type:12,data:i.sequenceLength},{type:12,data:y},{type:12,data:c},{type:12,data:i.numHeads},{type:1,data:h}],S=o?["type","type","type"]:["type","type"],I=A=>{let x=U("q",t.dataType,t.dims,d),E=U("key",r.dataType,r.dims,d),P=[x,E];o&&P.push(U("relative_position_bias",o.dataType,o.dims));let O=j("output",t.dataType,p),R=et(1,d),H=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"alpha",type:"f32"}];return`\n  const TILE_SIZE = ${w}u;\n\n  var<workgroup> tileQ: array<${x.type.storage}, ${w*w}>;\n  var<workgroup> tileK: array<${x.type.storage}, ${w*w}>;\n  ${A.registerUniforms(H).declareVariables(...P,O)}\n  ${A.mainStart([w,w,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;\n    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;\n\n    var value = ${R}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n        value += ${R}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * uniforms.M * uniforms.N;\n    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(d){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${d}`)}})()};\n        output[outputIdx] = ${O.type.value} (sum * uniforms.alpha) + ${o?"relative_position_bias[outputIdx]":"0.0"};\n    }\n  }`};return{name:"AttentionProbs",shaderCache:{hint:`${d}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:p,dataType:t.dataType,gpuDataType:0}],dispatchGroup:_,programUniforms:v}),getShaderSource:I}},nc=(e,t,r,o,i)=>{let u=i+o.kvSequenceLength,a=[o.batchSize,o.sequenceLength,o.vHiddenSize],c=12,p={x:Math.ceil(o.vHeadSize/c),y:Math.ceil(o.sequenceLength/c),z:o.batchSize*o.numHeads},h=[{type:12,data:o.sequenceLength},{type:12,data:u},{type:12,data:o.vHeadSize},{type:12,data:o.numHeads},{type:12,data:o.vHiddenSize}];return{name:"AttentionScore",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType,gpuDataType:0}],dispatchGroup:p,programUniforms:h}),getShaderSource:w=>{let _=U("probs",t.dataType,t.dims),v=U("v",r.dataType,r.dims),S=j("output",t.dataType,a),I=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"v_hidden_size",type:"u32"}];return`\n  const TILE_SIZE = ${c}u;\n  var<workgroup> tileQ: array<${_.type.value}, ${c*c}>;\n  var<workgroup> tileK: array<${_.type.value}, ${c*c}>;\n  ${w.registerUniforms(I).declareVariables(_,v,S)}\n  ${w.mainStart([c,c,1])}\n   let headIdx = workgroup_id.z;\n   let m = global_id.y;\n   let n = global_id.x;\n\n   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;\n   let offsetB = headIdx * (uniforms.N * uniforms.K) + n;\n\n   var value = ${_.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n     if (m < uniforms.M && w + local_id.x < uniforms.K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < uniforms.N && w + local_id.y < uniforms.K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * uniforms.N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + currentBatchHeadNumber * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`}}},Pn=(e,t,r,o,i,u,a,c,p,h,d)=>{let y=e.outputCount>1,w=e.outputCount>2,_=y&&w?h.pastSequenceLength:0,v=_+h.kvSequenceLength,S=[h.batchSize,h.numHeads,v,h.headSize],I=a?[a,r]:[r],A=y?e.compute(En(I,2,S,r.dataType),{inputs:I,outputs:[1]})[0]:r,x=[h.batchSize,h.numHeads,v,h.headSize],E=c?[c,o]:[o],P=w?e.compute(En(E,2,x,o.dataType),{inputs:E,outputs:[2]})[0]:o,O=[t,A];p&&O.push(p);let R=e.compute(rc(e,t,A,p,h,d,_),{inputs:O,outputs:[-1]})[0];e.compute(tc(e,R,h.batchSize*h.numHeads*h.sequenceLength,v),{inputs:[R],outputs:[]});let H=[R,P];e.compute(nc(e,R,P,h,_),{inputs:H,outputs:[0]})},oc=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],o=t.sequenceLength,i=t.inputHiddenSize,u=t.headSize,a=12,c={x:Math.ceil(t.headSize/a),y:Math.ceil(t.sequenceLength/a),z:t.batchSize*t.numHeads},p=[e.inputs[0],e.inputs[1],e.inputs[2]],h=[{type:12,data:o},{type:12,data:i},{type:12,data:u},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],d=y=>{let w=j("output_q",p[0].dataType,r),_=j("output_k",p[0].dataType,r),v=j("output_v",p[0].dataType,r),S=U("input",p[0].dataType,p[0].dims),I=U("weight",p[1].dataType,p[1].dims),A=U("bias",p[2].dataType,p[2].dims),x=S.type.storage,E=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`\n  const TILE_SIZE = ${a}u;\n  var<workgroup> tileInput: array<${x}, ${a*a}>;\n  var<workgroup> tileWeightQ: array<${x}, ${a*a}>;\n  var<workgroup> tileWeightK: array<${x}, ${a*a}>;\n  var<workgroup> tileWeightV: array<${x}, ${a*a}>;\n  ${y.registerUniforms(E).declareVariables(S,I,A,w,_,v)}\n  ${y.mainStart([a,a,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${x}(0);\n    var valueK = ${x}(0);\n    var valueV = ${x}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:c,programUniforms:h}),getShaderSource:d},{inputs:p,outputs:[-1,-1,-1]})},Xa=(e,t)=>{let r=ec(e.inputs,t),[o,i,u]=oc(e,r);return Pn(e,o,i,u,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var ic,ac,sc,Qa,Ja=Y(()=>{"use strict";$r();ye();Se();Ze();_e();ic=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let r=(o,i,u)=>{let a=i.length;if(a!==o.length)throw new Error(`${u}: num dimensions != ${a}`);i.forEach((c,p)=>{if(c!==o[p])throw new Error(`${u}: dim[${p}] do not match`)})};if(e[0].dims.length>1){let o=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,o,"Invalid input scale"),r(e[2].dims,o,"Invalid input B"),r(e[3].dims,o,"Invalid input mean"),r(e[4].dims,o,"Invalid input var")}else r(e[1].dims,[1],"Invalid input scale"),r(e[2].dims,[1],"Invalid input B"),r(e[3].dims,[1],"Invalid input mean"),r(e[4].dims,[1],"Invalid input var")},ac=(e,t)=>{let{epsilon:r,spatial:o,format:i}=t,u=e[0].dims,a=o?Me(u[u.length-1]):1,c=i==="NHWC"&&u.length>1?a:1,p=M.size(u)/a,h=o,d=h?u.length:u,y=U("x",e[0].dataType,e[0].dims,a),w=U("scale",e[1].dataType,e[1].dims,c),_=U("bias",e[2].dataType,e[2].dims,c),v=U("inputMean",e[3].dataType,e[3].dims,c),S=U("inputVar",e[4].dataType,e[4].dims,c),I=j("y",e[0].dataType,d,a),A=()=>{let E="";if(o)E=`let cOffset = ${u.length===1?"0u":i==="NHWC"?`outputIndices[${u.length-1}] / ${a}`:"outputIndices[1]"};`;else if(i==="NCHW")E=`\n            ${I.indicesSet("outputIndices","0","0")}\n            let cOffset = ${I.indicesToOffset("outputIndices")};`;else{E=`var cIndices = ${w.type.indices}(0);\n                       cIndices[0] = outputIndices[${u.length-1}];`;for(let P=1;P<w.rank;P++)E+=`cIndices[${P}] = outputIndices[${P}];`;E+=`let cOffset = ${w.indicesToOffset("cIndices")};`}return E},x=E=>`\n  const epsilon = ${r};\n  ${E.registerUniform("outputSize","u32").declareVariables(y,w,_,v,S,I)}\n  ${E.mainStart()}\n  ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${I.offsetToIndices(`global_idx * ${a}`)};\n    ${A()}\n    let scale = ${w.getByOffset("cOffset")};\n    let bias = ${_.getByOffset("cOffset")};\n    let inputMean = ${v.getByOffset("cOffset")};\n    let inputVar = ${S.getByOffset("cOffset")};\n    let x = ${y.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${I.setByOffset("global_idx","value")}\n  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${o}_${a}`,inputDependencies:h?["rank","type","type","type","type"]:void 0},getShaderSource:x,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h?[{type:12,data:p},...Z(u)]:[{type:12,data:p}]})}},sc=e=>ve(e),Qa=(e,t)=>{let{inputs:r,outputCount:o}=e,i=sc({...t,outputCount:o});if(vr.webgpu.validateInputContent&&ic(r,i),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(ac(r,i))}});var uc,dc,es,ts=Y(()=>{"use strict";Se();_e();uc=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},dc=e=>{let t=e[0].dims,r=e[0].dims[2],o=M.size(t)/4,i=e[0].dataType,u=U("input",i,t,4),a=U("bias",i,[r],4),c=U("residual",i,t,4),p=j("output",i,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:d=>`\n  const channels = ${r}u / 4;\n  ${d.declareVariables(u,a,c,p)}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${u.getByOffset("global_idx")}\n      + ${a.getByOffset("global_idx % channels")} + ${c.getByOffset("global_idx")};\n    ${p.setByOffset("global_idx","value")}\n  }`}},es=e=>{uc(e.inputs),e.compute(dc(e.inputs))}});var lc,ke,rs,ns,os,is,as,ss,us,ds,ls,cc,cs,ps,ms,fs,kn,hs,On,gs,ys,bs,ws,vs,$s,_s,Ss,xs,Cs,As,Is,Ts,Es,Ps,ks,Os,Rs,Bo,Do,Bs,Ds,zs,Rn=Y(()=>{"use strict";ye();Se();Ze();_e();lc=(e,t,r,o,i,u)=>{let a=Math.ceil(t/4),c="";typeof i=="string"?c=`${i}(a)`:c=i("a");let p=U("inputData",r,[a],4),h=j("outputData",o,[a],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(p,h)}\n\n  ${u??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${p.getByOffset("global_idx")};\n    ${h.setByOffset("global_idx",c)}\n  }`},ke=(e,t,r,o,i,u=e.dataType)=>({name:t,shaderCache:{hint:i,inputDependencies:["type"]},getShaderSource:a=>lc(a,M.size(e.dims),e.dataType,u,r,o),getRunData:a=>({outputs:[{dims:e.dims,dataType:u}],dispatchGroup:{x:Math.ceil(M.size(a[0].dims)/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(e.dims)/4)}]})}),rs=e=>{e.compute(ke(e.inputs[0],"Abs","abs"))},ns=e=>{e.compute(ke(e.inputs[0],"Acos","acos"))},os=e=>{e.compute(ke(e.inputs[0],"Acosh","acosh"))},is=e=>{e.compute(ke(e.inputs[0],"Asin","asin"))},as=e=>{e.compute(ke(e.inputs[0],"Asinh","asinh"))},ss=e=>{e.compute(ke(e.inputs[0],"Atan","atan"))},us=e=>{e.compute(ke(e.inputs[0],"Atanh","atanh"))},ds=e=>ve(e),ls=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(ke(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},cc=e=>{let t=e.length>=2&&e[1].data!==0?e[1].getFloat32Array()[0]:xn,r=e.length>=3&&e[2].data!==0?e[2].getFloat32Array()[0]:Cn;return ve({min:t,max:r})},cs=(e,t)=>{let r=e.inputs.length===1?t:cc(e.inputs),o=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Clip",i=>`clamp(${i}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${o}> = vec4(${o}(${r.min}));\n    const clip_max_: vec4<${o}> = vec4(${o}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},ps=e=>{e.compute(ke(e.inputs[0],"Ceil","ceil"))},ms=e=>{e.compute(ke(e.inputs[0],"Cos","cos"))},fs=e=>{e.compute(ke(e.inputs[0],"Cosh","cosh"))},kn=e=>ve(e),hs=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Elu",o=>`elu_vf32(${o})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},On=(e="f32")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,gs=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,On(t)))},ys=e=>{e.compute(ke(e.inputs[0],"Exp","exp"))},bs=e=>{e.compute(ke(e.inputs[0],"Floor","floor"))},ws=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,On(t)))},vs=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"LeakyRelu",o=>`select(leaky_relu_alpha_ * ${o}, ${o}, ${o} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},$s=e=>{e.compute(ke(e.inputs[0],"Not",t=>`!${t}`))},_s=e=>{e.compute(ke(e.inputs[0],"Neg",t=>`-${t}`))},Ss=e=>{e.compute(ke(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},xs=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"Relu",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},Cs=e=>{e.compute(ke(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},As=e=>ve(e),Is=(e,t)=>{let r=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"HardSigmoid",o=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${o} + vec4<${r}>(${t.beta})))`,void 0,t.cacheKey))},Ts=e=>{e.compute(ke(e.inputs[0],"Sin","sin"))},Es=e=>{e.compute(ke(e.inputs[0],"Sinh","sinh"))},Ps=e=>{e.compute(ke(e.inputs[0],"Sqrt","sqrt"))},ks=e=>{e.compute(ke(e.inputs[0],"Tan","tan"))},Os=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,Rs=e=>{e.compute(ke(e.inputs[0],"Tanh",Os))},Bo=(e="f32")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${Os("v")};\n}\n`,Do=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,Bs=e=>{let t=et(e.inputs[0].dataType);e.compute(ke(e.inputs[0],"FastGelu",Do,Bo(t),void 0,e.inputs[0].dataType))},Ds=(e,t)=>{let r=et(e.inputs[0].dataType);return e.compute(ke(e.inputs[0],"ThresholdedRelu",o=>`select(vec4<${r}>(0.0), ${o}, ${o} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},zs=e=>{e.compute(ke(e.inputs[0],"Log","log"))}});var pc,mc,Us,Vs=Y(()=>{"use strict";Se();_e();Rn();pc=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},mc=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=U("input",e[0].dataType,e[0].dims,4),o=U("bias",e[0].dataType,[e[0].dims[2]],4),i=j("output",e[0].dataType,t,4),u=M.size(t)/4,a=Be(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:p=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${p.declareVariables(r,o,i)}\n\n  ${On(a)}\n\n  ${p.mainStart()}\n    ${p.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${i.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Us=e=>{pc(e.inputs),e.compute(mc(e.inputs))}});var fc,hc,kt,Ws,Ns,Gs,Hs,Ls,Fs,qs,js,Ks,Ys,Zs=Y(()=>{"use strict";ye();Se();_e();fc=(e,t,r,o,i,u,a,c,p,h,d,y)=>{let w,_;typeof c=="string"?w=_=(x,E)=>`${c}((${x}),(${E}))`:typeof c=="function"?w=_=c:(w=c.scalar,_=c.vector);let v=j("outputData",d,o.length,4),S=U("aData",p,t.length,4),I=U("bData",h,r.length,4),A;if(i)if(u){let x=M.size(t)===1,E=M.size(r)===1,P=t.length>0&&t[t.length-1]%4===0,O=r.length>0&&r[r.length-1]%4===0;x||E?A=v.setByOffset("global_idx",_(x?`${S.type.value}(${S.getByOffset("0")}.x)`:S.getByOffset("global_idx"),E?`${I.type.value}(${I.getByOffset("0")}.x)`:I.getByOffset("global_idx"))):A=`\n            let outputIndices = ${v.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${S.broadcastedIndicesToOffset("outputIndices",v)};\n            let offsetB = ${I.broadcastedIndicesToOffset("outputIndices",v)};\n            ${v.setByOffset("global_idx",_(a||P?S.getByOffset("offsetA / 4u"):`${S.type.value}(${S.getByOffset("offsetA / 4u")}[offsetA % 4u])`,a||O?I.getByOffset("offsetB / 4u"):`${I.type.value}(${I.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else A=v.setByOffset("global_idx",_(S.getByOffset("global_idx"),I.getByOffset("global_idx")));else{if(!u)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let x=(E,P,O="")=>{let R=`aData[indexA${P}][componentA${P}]`,H=`bData[indexB${P}][componentB${P}]`;return`\n            let outputIndices${P} = ${v.offsetToIndices(`global_idx * 4u + ${P}u`)};\n            let offsetA${P} = ${S.broadcastedIndicesToOffset(`outputIndices${P}`,v)};\n            let offsetB${P} = ${I.broadcastedIndicesToOffset(`outputIndices${P}`,v)};\n            let indexA${P} = offsetA${P} / 4u;\n            let indexB${P} = offsetB${P} / 4u;\n            let componentA${P} = offsetA${P} % 4u;\n            let componentB${P} = offsetB${P} % 4u;\n            ${E}[${P}] = ${O}(${w(R,H)});\n          `};d===9?A=`\n            var data = vec4<u32>(0);\n            ${x("data",0,"u32")}\n            ${x("data",1,"u32")}\n            ${x("data",2,"u32")}\n            ${x("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:A=`\n            ${x("outputData[global_idx]",0)}\n            ${x("outputData[global_idx]",1)}\n            ${x("outputData[global_idx]",2)}\n            ${x("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(S,I,v)}\n\n        ${y??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${A}\n      }`},hc=(e,t,r,o,i,u,a=r.dataType)=>{let c=!M.areEqual(r.dims,o.dims),p=r.dims,h=M.size(r.dims),d=!1,y=!1,w=[c];if(c){let _=At.calcShape(r.dims,o.dims,!1);if(!_)throw new Error("Can\'t perform binary op on the given tensors");p=_,h=M.size(p);let v=M.size(r.dims)===1,S=M.size(o.dims)===1,I=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,A=o.dims.length>0&&o.dims[o.dims.length-1]%4===0;w.push(v),w.push(S),w.push(I),w.push(A);let x=1;for(let E=1;E<p.length;E++){let P=r.dims[r.dims.length-E]??1,O=o.dims[o.dims.length-E]??1;if(P===O)x*=P;else break}x%4===0?(y=!0,d=!0):(v||S||I||A)&&(d=!0)}else d=!0;return w.push(d),{name:e,shaderCache:{hint:t+w.map(_=>_.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:_=>fc(_,r.dims,o.dims,p,d,c,y,i,r.dataType,o.dataType,a,u),getRunData:()=>({outputs:[{dims:p,dataType:a}],dispatchGroup:{x:Math.ceil(h/64/4)},programUniforms:[{type:12,data:Math.ceil(M.size(p)/4)},...Z(r.dims,o.dims,p)]})}},kt=(e,t,r,o,i,u)=>{e.compute(hc(t,i??"",e.inputs[0],e.inputs[1],r,o,u))},Ws=e=>{kt(e,"Add",(t,r)=>`${t}+${r}`)},Ns=e=>{kt(e,"Div",(t,r)=>`${t}/${r}`)},Gs=e=>{kt(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Hs=e=>{kt(e,"Mul",(t,r)=>`${t}*${r}`)},Ls=e=>{let t=U("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;kt(e,"Pow",{scalar:(o,i)=>`pow_custom(${o},${i})`,vector:(o,i)=>`pow_vector_custom(${o},${i})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Fs=e=>{kt(e,"Sub",(t,r)=>`${t}-${r}`)},qs=e=>{kt(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},js=e=>{kt(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Ks=e=>{kt(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Ys=e=>{kt(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var _t,St,xt,Bn,Ft=Y(()=>{"use strict";ye();Se();_t=(e,t,r="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},St=(e,t)=>{e.activation==="Clip"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation==="HardSigmoid"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation==="LeakyRelu"&&t.push({type:1,data:e.alpha})},xt=(e,t)=>{e.activation==="Clip"?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):e.activation==="HardSigmoid"?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):e.activation==="LeakyRelu"&&t.push({name:"alpha",type:"f32"})},Bn=e=>{let t=e?.activation||"";if(t==="HardSigmoid"){let[r,o]=e?.activation_params||[.2,.5];return{activation:t,alpha:r,beta:o}}else if(t==="Clip"){let[r,o]=e?.activation_params||[xn,Cn];return{activation:t,clipMax:o,clipMin:r}}else if(t==="LeakyRelu"){let[r]=e?.activation_params||[.01];return{activation:t,alpha:r}}return{activation:t}}});var tt,Dn,zn=Y(()=>{"use strict";tt=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Dn=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var Mn,zo=Y(()=>{"use strict";Mn=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var yc,bc,Hr,Xs,wc,Lr,vc,Un,Fr=Y(()=>{"use strict";ye();Se();_e();Ft();zn();yc=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,bc=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,Hr=(e,t,r="f32",o,i=!1,u=32,a=!1,c=32)=>{let p=t[1]*e[1],h=t[0]*e[0],d=i?p:u,y=i?u:p,w=d/t[0],_=u/t[1];if(!((i&&w===4&&e[1]===4||!i&&(w===3||w===4))&&d%t[0]===0&&u%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${i} is true, innerElementSize ${w} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${w} must be 3 or 4.\n  tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}. tileInner ${u} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${w}<${r}>, ${d/w}>, ${y}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${h/e[0]}>, ${u}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${w};\nconst tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${a?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${p};\n\n  let num_tiles = ${a?`${Math.ceil(c/u)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n  var kStart = ${a?`i32(globalId.z) * ${c}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${yc(i,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${w===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${bc(i,w)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Xs=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,wc=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Lr=(e,t,r="f32",o,i=!1,u=32,a=!1,c=32,p=!1)=>{let h=e[1]*t[1],d=e[0]*t[0],y=i?h:u,w=i?u:h;if(!(w%t[1]===0&&y%t[0]===0&&u%t[1]===0))throw new Error(`tileAHight ${w} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${y} must be divisible by workgroupSize[0]${t[0]}, tileInner ${u} must be divisible by workgroupSize[1]${t[1]}`);let _=w/t[1],v=y/t[0],S=u/t[1],I=p?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${h};\n    let globalColStart = i32(workgroupId.x) * ${d};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${w}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${y}; inputCol = inputCol + ${t[0]}) {\n          ${Xs(i,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${u}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${i?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${h};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${v};\nlet tileRowB = i32(localId.y) * ${S};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${v}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Xs(i,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${S}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${wc(i)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${y}>, ${w}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${d}>, ${u}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${u};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${a?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let num_tiles = ${a?`${Math.ceil(c/u)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n    var kStart = ${a?`i32(globalId.z) * ${c}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${I}\n  }\n`},vc=(e,t,r,o,i,u=!1)=>{let[a,c,p]=i,[h,d,y,w]=o,_=_r(a,p),v=_r(c,p),S=Be(o[0].type.tensor),I=()=>{let E=d.rank,P=h.rank,O=`var aIndices: ${d.type.indices};`;for(let R=E-2-1,H=P-1;R>=0;R--,H--)O+=`\naIndices[${R}] = ${P>1?`batchIndices[${H}]`:"batchIndices"};`;return _.forEach(R=>{O+=`\naIndices[${R}] = 0;`}),O+=`\naIndices[${E-2}] = u32(row);\n                   aIndices[${E-1}] = u32(colIn);`,O},A=()=>{let E=y.rank,P=h.rank,O=`var bIndices: ${y.type.indices};`;for(let R=E-2-1,H=P-1;R>=0;R--,H--)O+=`\nbIndices[${R}] = ${P>1?`batchIndices[${H}]`:"batchIndices"};`;return v.forEach(R=>{O+=`\nbIndices[${R}] = 0;`}),O+=`\nbIndices[${E-2}] = u32(row);\n                   bIndices[${E-1}] = u32(colIn);`,O};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${tt(e,S)} {\n      var value = ${tt(e,S)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        ${I()}\n        value = ${d.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${tt(e,S)} {\n      var value = ${tt(e,S)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        ${A()}\n        value = ${y.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${tt(e,S)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${u?"bias[colIn]":`${tt(e,S)}(bias[row])`};`:""}\n        ${r}\n        ${w.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Un=(e,t,r,o,i=!1)=>{let u=e[0].dims,a=e[1].dims,c=u.slice(0,-2),p=a.slice(0,-2),h=o?o.slice(0,-2):r.slice(0,-2),d=M.size(h),y=u[u.length-2],w=u[u.length-1],_=a[a.length-1],v=w%4===0&&_%4===0,S=y<=8?[4,1,1]:[4,4,1],I=[8,8,1],A=[Math.ceil(_/I[0]/S[0]),Math.ceil(y/I[1]/S[1]),Math.ceil(d/I[2]/S[2])],x=v?4:1,E=[...c,y,w/x],P=E.length,O=[...p,w,_/x],R=O.length,H=[d,y,_/x],N=[{type:6,data:y},{type:6,data:_},{type:6,data:w}];St(t,N),N.push(...Z(h,E,O));let K=["rank","rank"],Q=e.length>2;Q&&(N.push(...Z(e[2].dims)),K.push("rank")),N.push(...Z(H));let he=W=>{let se=h.length,Ce=An("batchDims",e[0].dataType,se,1),We=Be(e[0].dataType),ee=U("a",e[0].dataType,P,x),ae=U("b",e[1].dataType,R,x),Ae=j("result",e[0].dataType,H.length,x),me=[ee,ae];if(Q){let G=i?x:1;me.push(U("bias",e[2].dataType,e[2].dims.length,G))}let ie=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];xt(t,ie);let ue=Be(Ae.type.tensor),le=_t(t,Ae.type.value,ue),qe=vc(x,Q,le,[Ce,ee,ae,Ae],[c,p,h],i);return`\n  ${W.registerUniforms(ie).registerInternalVariables(Ce).declareVariables(...me,Ae)}\n  ${qe}\n  ${v?Hr(S,I,We,Ce):Lr(S,I,We,Ce)}\n                   `};return{name:"MatMul",shaderCache:{hint:`${S};${t.activation};${v};${i}`,inputDependencies:K},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:A[0],y:A[1],z:A[2]},programUniforms:N}),getShaderSource:he}}});var $c,Qs,Js=Y(()=>{"use strict";ye();Ht();_e();Ft();zn();zo();Fr();$c=(e,t,r,o,i=!1,u,a=4,c=4,p=4,h="f32")=>{let d=Q=>{switch(Q){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${h}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Q} is not supported.`)}},y=Q=>{switch(Q){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${Q} is not supported.`)}},w=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,_=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,v=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",S=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",I=e?"row":"col",A=e?"col":"row",x=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${I} / outWidth;\n    let outCol = ${I} % outWidth;\n\n    let WRow = ${A} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${A} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${A} % inChannels;\n    var resData = ${tt(a,h)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${v} && xCol >= 0 && xCol < ${S}) {\n      ${w}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${d(a)}\n    }\n    return resData;`,E=e?t&&o?`\n    let col = colIn * ${a};\n    ${x}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${x}\n    }\n    return ${tt(a,h)}(0.0);`:o&&r?`\n    let col = colIn * ${a};\n    ${x}`:`\n    let col = colIn * ${a};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${x}\n    }\n    return ${tt(a,h)}(0.0);`,P=`${y(c)}`,O=tt(p,h),R=e?tt(a,h):tt(c,h),H=e?tt(c,h):tt(a,h),N=_t(u,O,h);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${R} {\n      ${e?E:P}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${H} {\n      ${e?P:E}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${O}) {\n      let col = colIn * ${p};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${_}\n      ${Dn(i)}\n      ${N}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Qs=(e,t,r,o,i,u,a,c)=>{let p=t.format==="NHWC",h=p?e[0].dims[3]:e[0].dims[1],d=r[0],y=p?r[2]:r[3],w=p?r[1]:r[2],_=p?r[3]:r[1],v=p&&(h%4===0||h%3===0)&&_%4===0,S=p?_:y*w,I=p?y*w:_,A=[8,8,1],x=o<=8?[4,1,1]:[4,4,1],E=[Math.ceil(S/A[0]/x[0]),Math.ceil(I/A[1]/x[1]),Math.ceil(d/A[2]/x[2])];Ve("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${E}`);let P=v?p&&h%4!==0?3:4:1,O=A[1]*x[1],R=A[0]*x[0],H=Math.max(A[0]*P,A[1]),N=o%O===0,K=i%R===0,Q=u%H===0,he=v?[P,4,4]:[1,1,1],W=[{type:6,data:o},{type:6,data:i},{type:6,data:u},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];St(t,W),W.push(...Z(e[0].dims,e[1].dims));let se=["rank","rank"];a&&(W.push(...Z(e[2].dims)),se.push("rank")),W.push(...Z(r));let Ce=We=>{let ee=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];xt(t,ee);let ae=v?4:1,Ae=Be(e[0].dataType),me=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${v?`vec4<${Ae}>`:Ae}) {\n        result[flatIndex] = ${v?`vec4<${Ae}>`:Ae}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${v?`vec4<${Ae}>`:Ae}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${v?"/ 4":""}, value);\n      }`,ie=U("x",e[0].dataType,e[0].dims.length,P===3?1:P),ue=U("w",e[1].dataType,e[1].dims.length,ae),le=[ie,ue],qe=j("result",e[0].dataType,r.length,ae);if(a){let G=U("bias",e[2].dataType,e[2].dims.length,ae);le.push(G),me+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?`vec4<${Ae}>`:Ae} {\n          return bias[coords.${p?"w":"y"}${v?"/ 4":""}];\n        }`}return`\n        ${Mn("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${We.registerUniforms(ee).declareVariables(...le,qe)}\n        ${me}\n        ${$c(p,N,K,Q,a,t,he[0],he[1],he[2],Ae)}\n        ${v?Hr(x,A,Ae,void 0,!p,H):Lr(x,A,Ae,void 0,!p,H,!1,void 0,c)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${P};${v};${N};${K};${Q};${O};${R};${H}`,inputDependencies:se},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:W}),getShaderSource:Ce}}});var Mo,eu,tu=Y(()=>{"use strict";ye();Se();_e();Uo();Ft();Mo=(e,t,r)=>{let o=e.length>2,i=o?"value += b[output_channel];":"",u=e[0].dims,a=e[1].dims,c=a[0]/t.group,p=t.format==="NHWC",h=Vn(u,a,t.dilations,t.pads,t.strides,p),d=M.size(h),y=[{type:12,data:d},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:c}];St(t,y),y.push(...Z(u,a));let w=["rank","rank"];o&&(y.push(...Z(e[2].dims)),w.push("rank")),y.push(...Z(h));let _=v=>{let S=j("output",e[0].dataType,h.length),I=Be(S.type.tensor),A=_t(t,S.type.value,I),x=U("x",e[0].dataType,u.length),E=U("w",e[1].dataType,a.length),P=[x,E];o&&P.push(U("b",e[2].dataType,e[2].dims.length));let O=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];return xt(t,O),`\n  ${v.registerUniforms(O).declareVariables(...P,S)}\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let outputIndices = ${S.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${p?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${p?1:2}], outputIndices[${p?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel / uniforms.output_channels_per_group;\n\n    var value: ${S.type.value} = ${S.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[${p?1:2}]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[${p?2:3}]) {\n            continue;\n          }\n\n          let xVal = ${p?x.get("batch","xHeight","xWidth","input_channel"):x.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${E.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${i}\n    ${A}\n    ${S.setByOffset("global_idx","value")}\n  }`};return{name:"GroupedConv",shaderCache:{hint:t.cacheKey,inputDependencies:w},getRunData:()=>({outputs:[{dims:r?r(h):h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:y}),getShaderSource:_}},eu=(e,t,r)=>{let o=e.length>2,i=Me(r[3]),u=Me(r[2]),a=M.size(r)/i/u,c=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/i],p=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/i],h=[r[0],r[1],r[2],r[3]/i],d=[{type:12,data:a},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];St(t,d),d.push(...Z(c,p,h));let y=(u-1)*t.strides[1]+p[1],w=_=>{let v=j("output",e[0].dataType,h.length,i),S=Be(v.type.tensor),I=_t(t,v.type.value,S),A=U("x",e[0].dataType,c.length,i),x=U("w",e[1].dataType,p.length,i),E=[A,x];o&&E.push(U("b",e[2].dataType,e[2].dims,i));let P=o?"value += b[output_channel];":"",O=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return xt(t,O),`\n  ${_.registerUniforms(O).declareVariables(...E,v)}\n  ${_.mainStart()}\n    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${u}u;\n    let col = (index1 % width1) * ${u}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${A.type.value}, ${y}>;\n    var values: array<${v.type.value}, ${u}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w\'s height/width.\n    for (var w_height: u32 = 0u; w_height < ${p[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${y}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${A.get("batch","u32(x_height)","u32(x_width)","input_channel")};\n          } else {\n            x_vals[i] = ${A.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${p[1]}; w_width++) {\n          let w_val = ${x.get("w_height","w_width","0","output_channel")};\n          for (var i = 0u; i < ${u}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${u}u; i++) {\n      var value = values[i];\n      ${P}\n      ${I}\n      ${v.set("batch","row","col + i","output_channel","value")};\n    }\n  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${i};${u};${y};${p[0]};${p[1]}`,inputDependencies:o?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:d}),getShaderSource:w}}});var Vo,_c,ru,Wo=Y(()=>{"use strict";ye();Se();Fr();_e();Ft();Vo=(e,t,r,o,i=!1)=>{let u=e[0].dims,a=e[1].dims,c=u[u.length-2],p=a[a.length-1],h=u[u.length-1],d=Me(p),y=Me(h),w=Me(c),_=M.size(r)/d/w,v=e.length>2,S=o?o.slice(0,-2):r.slice(0,-2),A=[M.size(S),c,p],x=[{type:12,data:_},{type:12,data:c},{type:12,data:p},{type:12,data:h}];St(t,x),x.push(...Z(S,u,a)),v&&x.push(...Z(e[2].dims)),x.push(...Z(A));let E=P=>{let O=An("batch_dims",e[0].dataType,S.length),R=U("a",e[0].dataType,u.length,y),H=U("b",e[1].dataType,a.length,d),N=j("output",e[0].dataType,A.length,d),K=Be(N.type.tensor),Q=_t(t,N.type.value,K),he=[R,H],W="";if(v){let ie=i?d:1;he.push(U("bias",e[2].dataType,e[2].dims.length,ie)),W=`${i?`value += bias[col / ${ie}];`:`value += ${N.type.value}(bias[row + i]);`}`}let se=u.slice(0,-2),Ce=a.slice(0,-2),We=_r(se,S),ee=_r(Ce,S),ae=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];xt(t,ae);let Ae=(ie,ue)=>{let le=ie.rank,qe=ie.name;if(le===2)return`var ${qe}_indices = ${ie.type.indices}(0u, 0u);`;let G=O.rank,ne=`var ${qe}_indices: ${ie.type.indices};`;for(let xe=le-2-1,Ke=G-1;xe>=0;xe--,Ke--)ne+=`\n${qe}_indices[${xe}] = ${G>1?`batch_indices[${Ke}]`:"batch_indices"};`;return ue.forEach(xe=>{ne+=`\n${qe}_indices[${xe}] = 0;`}),ne+=`${qe}_indices[${le-2}] = 0u;\n                     ${qe}_indices[${le-1}] = 0u;`,ne},me=()=>{let ie=`var a_data: ${R.type.value};`;for(let ue=0;ue<y;ue++)ie+=`\n              let b_data${ue} = b[(b_offset + (k + ${ue}) * uniforms.N + col) / ${d}];`;for(let ue=0;ue<w;ue++){ie+=`a_data = a[(a_offset + (row + ${ue}) * uniforms.K + k) / ${y}];`;for(let le=0;le<y;le++)ie+=`\n            values[${ue}] = fma(${H.type.value}(a_data${y===1?"":`[${le}]`}), b_data${le}, values[${ue}]);\n`}return ie};return`\n  ${P.registerUniforms(ae).registerInternalVariables(O).declareVariables(...he,N)}\n  ${P.mainStart()}\n    ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let col = (global_idx % (uniforms.N / ${d})) * ${d};\n    var index1 = global_idx / (uniforms.N / ${d});\n    let stride1 = uniforms.M / ${w};\n    let row = (index1 % stride1) * ${w};\n    let batch = index1 / stride1;\n\n    ${r.length===2?"":`let batch_indices = ${O.offsetToIndices("batch")};`}\n    ${Ae(R,We)}\n    let a_offset = ${R.indicesToOffset("a_indices")};\n    ${Ae(H,ee)}\n    let b_offset = ${H.indicesToOffset("b_indices")};\n    var values: array<${N.type.value}, ${w}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${y}) {\n      ${me()}\n    }\n    for (var i = 0u; i < ${w}u; i++) {\n      var value = values[i];\n      ${W}\n      ${Q}\n      let cur_indices = ${N.type.indices}(batch, row + i, col);\n      let offset = ${N.indicesToOffset("cur_indices")};\n      ${N.setByOffset(`offset / ${d}`,"value")};\n    }\n  }\n  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${d};${y};${w};${i}`,inputDependencies:v?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:x}),getShaderSource:E}},_c=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},ru=e=>{_c(e.inputs);let t=At.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");let r=t[t.length-1],o=e.inputs[0].dims[e.inputs[0].dims.length-1];r<8&&o<8?e.compute(Vo(e.inputs,{activation:""},t)):e.compute(Un(e.inputs,{activation:""},t))}});var Vn,No,Sc,nu,Go,xc,Cc,Ho,Uo=Y(()=>{"use strict";Se();Js();Fr();tu();Ft();Wo();Sr();Vn=(e,t,r,o,i,u)=>{let a=e[0],c=e.slice(u?1:2,u?3:4),p=c.length,h=t[0],y=t.slice(2).map((v,S)=>v+(v-1)*(r[S]-1)),_=c.map((v,S)=>v+o[S]+o[S+p]).map((v,S)=>Math.floor((v-y[S]+i[S])/i[S]));return _.splice(0,0,a),_.splice(u?3:1,0,h),_},No=[2,3,1,0],Sc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let i=e[0].dims.length-2;if(t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},nu=(e,t)=>{let r=e.kernelShape.slice();for(let u=2;u<t[1].dims.length;++u)r[u-2]===0&&(r[u-2]=t[1].dims[u]);let o=e.pads.slice();nr.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let i=Object.assign({},e);return Object.assign(i,{kernelShape:r,pads:o}),i},Go=e=>{let t=Bn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],i=e.dilations,u=e.group,a=e.kernel_shape,c=e.pads,p=e.strides,h=e.w_is_const();return{autoPad:o,format:r,dilations:i,group:u,kernelShape:a,pads:c,strides:p,wIsConst:h,...t,cacheKey:`${e.format};${t.activation};`}},xc=(e,t,r)=>{let o=nu(r,t),i=r.format==="NHWC";if(r.group!==1){if(!e.adapterInfo.isArchitecture("ampere")&&i&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1){let H=Vn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,i),N=e.kernelCustomData.wT??e.compute(yt(t[1],No),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=N);let K=[t[0],N];t.length===3&&K.push(t[2]),e.compute(eu(K,o,H),{inputs:K})}else e.compute(Mo(t,o));return}let u=t.length===3,a=t[0].dims[i?1:2],c=t[0].dims[i?2:3],p=t[0].dims[i?3:1],h=t[1].dims[2],d=t[1].dims[3],y=Vn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,i),w=y[i?1:2],_=y[i?2:3],v=y[i?3:1],S=i&&h===a&&d===c&&r.pads[0]===0&&r.pads[1]===0;if(S||h===1&&d===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let R=y[0],H,N,K,Q=[];if(i){let se=e.kernelCustomData.wT??e.compute(yt(t[1],No),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=se),S){let Ce=a*c*p;H=t[0].reshape([1,R,Ce]),N=se.reshape([1,Ce,v]),K=[1,R,v]}else H=t[0].reshape([R,a*c,p]),N=se.reshape([1,p,v]),K=[R,w*_,v];Q.push(H),Q.push(N)}else H=t[0].reshape([R,p,a*c]),N=t[1].reshape([1,v,p]),K=[R,v,w*_],Q.push(N),Q.push(H);u&&Q.push(t[2]);let he=K[2],W=Q[0].dims[Q[0].dims.length-1];he<8&&W<8?e.compute(Vo(Q,o,y,K,i),{inputs:Q}):e.compute(Un(Q,o,y,K,i),{inputs:Q});return}let I=!0,A=e.kernelCustomData.wT??e.compute(yt(t[1],No),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let x=[t[0],A];u&&x.push(t[2]);let E=i?w*_:v,P=i?v:w*_,O=h*d*p;e.compute(Qs(x,o,y,E,P,O,u,I),{inputs:x})},Cc=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let i=[0,t.pads[0],0,t.pads[1]],u=[1].concat(t.strides),a=[1].concat(t.dilations),c=[1].concat(t.kernelShape),p=nu({...t,pads:i,strides:u,dilations:a,kernelShape:c},o);e.compute(Mo(o,p,h=>r?[h[0],h[2],h[3]]:[]))},Ho=(e,t)=>{Sc(e.inputs,t),e.inputs[0].dims.length===3?Cc(e,t):xc(e,e.inputs,t)}});var Ac,ou,iu=Y(()=>{"use strict";ye();Ht();_e();Ft();zn();zo();Fr();Ac=(e,t=!1,r,o,i=4)=>{let u=A=>{switch(A){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return ${o}(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${A} is not supported.`)}},a=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,c=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,p=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",h=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",d=e?"row":"col",y=e?"col":"row",w=`\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      let outRow = ${d} / outWidth;\n      let outCol = ${d} % outWidth;\n\n      let WRow = ${y} / (uniforms.filter_dims[1] * inChannels);\n      let WCol = ${y} / inChannels % uniforms.filter_dims[1];\n      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(${p}) || fract(xR) > 0.0) {\n        return ${o}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${h}) || fract(xC) > 0.0) {\n        return ${o}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${y} % inChannels;\n      ${a}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${i}];`,_=e?`\n      let col = colIn * ${i};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n        ${w}\n      }\n      return ${o}(0.0);`:`\n      let col = colIn * ${i};\n      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n        ${w}\n      }\n      return ${o}(0.0);`,v=`\n      let col = colIn * ${i};\n      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};\n      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);\n      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];\n      if (${e?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${u(i)}\n      }\n      return ${o}(0.0);\n      `,S=_t(r,o);return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${o} {\n    ${e?_:v}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${o} {\n    ${e?v:_}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${o}) {\n    let col = colIn * ${i};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n      var value = valueInput;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${c}\n      ${Dn(t)}\n      ${S}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${i}] = value;\n    }\n  }`},ou=(e,t,r,o,i,u,a,c)=>{let p=t.format==="NHWC",h=p?e[0].dims[3]:e[0].dims[1],d=r[0],y=p?r[2]:r[3],w=p?r[1]:r[2],_=p?r[3]:r[1],v=p&&h%4===0&&h%3&&_%4===0,S=p?_:y*w,I=p?y*w:_,A=[8,8,1],x=o<=8?[4,1,1]:[4,4,1],E=[Math.ceil(S/A[0]/x[0]),Math.ceil(I/A[1]/x[1]),Math.ceil(d/A[2]/x[2])];Ve("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${E}`);let P=v?4:1,O=Math.max(A[0]*P,A[1]),R=v?4:1,H=[t.kernelShape[p?1:2],t.kernelShape[p?2:3]],N=[H[0]+(t.dilations[0]<=1?0:(H[0]-1)*(t.dilations[0]-1)),H[1]+(t.dilations[1]<=1?0:(H[1]-1)*(t.dilations[1]-1))],K=[N[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),N[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],Q=[{type:6,data:o},{type:6,data:i},{type:6,data:u},{type:6,data:t.strides},{type:6,data:t.dilations},{type:6,data:H},{type:6,data:K}];St(t,Q),Q.push(...Z(e[0].dims,e[1].dims));let he=["rank","rank"];a&&(Q.push(...Z(e[2].dims)),he.push("rank")),Q.push(...Z(r));let W=se=>{let Ce=U("x",e[0].dataType,e[0].dims.length,R),We=U("w",e[1].dataType,e[1].dims.length,1),ee=j("result",e[0].dataType,r.length,R),ae=[Ce,We],Ae="";if(a){let ue=U("bias",e[2].dataType,e[2].dims.length,R);ae.push(ue),Ae+=`\n          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${ue.type.value} {\n            return bias[coords.${p?"w":"y"}${v?"/ 4":""}];\n          }`}let me=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:H.length},{name:"pads",type:"i32",length:K.length}];xt(t,me);let ie=Be(e[0].dataType,1);if(ie!=="f16"&&ie!=="f32")throw new Error(`elemType ${ie} is not supported.`);return`\n        ${Mn("uniforms.result_strides")}\n        ${se.registerUniforms(me).declareVariables(...ae,ee)};\n        ${Ae}\n        ${Ac(p,a,t,Ce.type.value,P)}\n        ${v?Hr(x,A,ie,void 0,!p,O):Lr(x,A,ie,void 0,!p,O,!1,void 0,c)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${t.cacheKey};${x};${A};${v}`,inputDependencies:he},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]},programUniforms:Q}),getShaderSource:W}}});var Ic,Lo,au=Y(()=>{"use strict";ye();Ht();Se();_e();Ic=(e,t,r,o,i,u=!1,a,c,p=!1)=>{let h=p?1:2,d=p?2:3,y=p?3:1,w=u?2:1,_=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${a}>`:a}) {\n    result[flatIndex] = ${u?`vec4<${a}>`:a}(value);\n  }`;o&&(_+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${a}>`:a} {\n      return bias[coords.${p?"w":"y"}${u?"/ 4":""}];\n    }`);let v=u?4:1,S=U("W",t[1].dataType,t[1].dims.length,v),I=U("Dy",t[0].dataType,t[0].dims.length,v),A=[I,S];o&&A.push(U("bias",t[2].dataType,[r[y]].length,v));let x=j("result",t[0].dataType,r.length,v),E=`{\n        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];\n        let r = ${i?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];\n        let c = ${i?"global_id.y":"workgroup_id.y"} * ${w};\n        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${a}>, ${w}>;\n        for (var i = 0; i < ${w}; i++) {\n          dotProd[i] = vec4<${a}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {\n          var dyR = (${a}(dyCorner.x) + ${a}(wR)) / ${a}(uniforms.strides.x);\n          let wRPerm = uniforms.filter_dims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${a}(uniforms.Dy_shape[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {\n            let dyC = (${a}(dyCorner.y) + ${a}(wC)) / ${a}(uniforms.strides.y);\n            let dyC2 = (${a}(dyCorner.y) + 1.0 + ${a}(wC)) / ${a}(uniforms.strides.y);\n            let wCPerm = uniforms.filter_dims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${a}(uniforms.Dy_shape[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${a}(uniforms.Dy_shape[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${I.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${I.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${a}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = uniforms.Dy_shape[${y}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${I.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = uniforms.Dy_shape[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${I.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${a}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${w}; i = i + 1) {\n          let value = dotProd[i] + ${o?"bias[c+i]":`vec4<${a}>(0.0)`};\n          ${x.set("batch","r","c + i","d1","value")};\n        }\n      }`,P=`\n          let outputIndices = ${x.offsetToIndices("global_idx")};\n          let batch = ${x.indicesGet("outputIndices",0)};\n          let d1 = ${x.indicesGet("outputIndices",y)};\n          let r = ${x.indicesGet("outputIndices",h)};\n          let c = ${x.indicesGet("outputIndices",d)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / uniforms.output_channels_per_group;\n          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = ${a}(0.0);\n          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n            if (wR % uniforms.dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${a}(dyRCorner) + ${a}(wR)) / ${a}(uniforms.strides[0]);\n            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n            if (dyR < 0.0 || dyR >= ${a}(uniforms.Dy_shape[${h}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n              if (wC % uniforms.dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${a}(dyCCorner) + ${a}(wC)) / ${a}(uniforms.strides.y);\n              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n              if (dyC < 0.0 || dyC >= ${a}(uniforms.Dy_shape[${d}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * uniforms.input_channels_per_group;\n              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {\n                let xValue = ${p?I.get("batch","idyR","idyC","inputChannel"):I.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${S.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${o?"bias[d1]":`${a}(0.0)`};\n          ${x.setByOffset("global_idx","value")};\n        `;return`\n  ${e.registerUniforms(c).declareVariables(...A,x)}\n  ${_}\n\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\n  ${u?E:P}}`},Lo=(e,t,r)=>{let o=e.length>2,i=t.outputShape,u=M.size(i),a=[Math.ceil(u/64),1,1];Ve("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${a}`);let c=t.format==="NHWC",p=["rank","rank"],h=[t.strides[0],t.strides[1]],d=[t.kernelShape[c?1:2],t.kernelShape[c?2:3]],y=[t.dilations[0],t.dilations[1]],w=[d[0]+(t.dilations[0]<=1?0:(t.kernelShape[c?1:2]-1)*(t.dilations[0]-1)),d[1]+(t.dilations[1]<=1?0:(t.kernelShape[c?2:3]-1)*(t.dilations[1]-1))],_=[w[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),w[1]-1-Math.floor(t.pads[1]+t.pads[3])/2],v=!1,S=t.group,I=e[1].dims,A=I[0]/S,x=I[1],E=[{type:12,data:u},{type:12,data:h},{type:12,data:d},{type:12,data:y},{type:12,data:w},{type:6,data:_},{type:12,data:A},{type:12,data:x},...Z(e[0].dims,e[1].dims)];o&&(E.push(...Z(e[2].dims)),p.push("rank")),E.push(...Z(i));let P=a[1]===1&&a[2]===1,O=R=>{let H=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:h.length},{name:"filter_dims",type:"u32",length:d.length},{name:"dilations",type:"u32",length:d.length},{name:"effective_filter_dims",type:"u32",length:w.length},{name:"pads",type:"i32",length:_.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],N=Be(e[0].dataType);return`${Ic(R,e,i,o,P,v,N,H,c)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};`,inputDependencies:p},getRunData:()=>({dispatchGroup:{x:a[0],y:a[1],z:a[2]},outputs:[{dims:r?r(i):i,dataType:e[0].dataType}],programUniforms:E}),getShaderSource:O}}});var Tc,Ec,Pc,su,uu,kc,Oc,Rc,Bc,du,lu=Y(()=>{"use strict";iu();au();Ft();Sr();Tc=(e,t,r,o,i,u)=>(e-1)*t+r+(o-1)*i+1-u,Ec=(e,t,r,o,i)=>{let u=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=u,r[i]=e-u):t==="SAME_LOWER"&&(r[o]=e-u,r[i]=u)},Pc=(e,t,r,o,i,u,a,c,p,h)=>{let d=e.length-2,y=h.length===0;if(p.length===0)for(let v=0;v<d;++v)p.push(0);let w=e[0],_=t[c?3:1]*i;for(let v=0,S=e.length-d-(c?1:0);v<d;++v,++S){let I=e[S],A=y?I*a[v]:h[v],x=Tc(I,a[v],u[v],t[S],r[v],A);Ec(x,o,u,v,v+d),y&&h.push(a[v]*(I-1)+p[v]+(t[S]-1)*r[v]+1-u[v]-u[v+d])}h.splice(0,0,w),h.splice(c?3:1,0,_)},su=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((y,w)=>y*w,1)===0){r.length=0;for(let y=2;y<t[1].dims.length;++y)r.push(t[1].dims[y])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let i=e.pads.slice(),u=e.outputShape.slice(),a=e.outputPadding.slice(),c=t[0].dims,p=e.dilations.slice();if(p.reduce((y,w)=>y+w,0)===0){let y=t[0].dims.length-2;p=new Array(y).fill(1)}let h=e.strides.slice();if(h.reduce((y,w)=>y+w,0)===0){let y=t[0].dims.length-2;h=new Array(y).fill(1)}Pc(c,r,p,e.autoPad,e.group,i,h,o,a,u);let d=Object.assign({},e);return Object.assign(d,{kernelShape:r,pads:i,outputPadding:a,outputShape:u,dilations:p,strides:h}),d},uu=e=>{let t=Bn(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],i=e.dilations,u=e.group,a=e.kernelShape,c=e.pads,p=e.strides,h=e.wIsConst(),d=e.outputPadding,y=e.outputShape;return{autoPad:o,format:r,dilations:i,group:u,kernelShape:a,outputPadding:d,outputShape:y,pads:c,strides:p,wIsConst:h,...t,cacheKey:`${e.format};${t.activation};`}},kc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==i))throw new Error("invalid bias");let u=e[0].dims.length-2;if(t.dilations.reduce((d,y)=>d+y,0)>0&&t.dilations.length!==u)throw new Error(`dilations should be ${u}D`);if(t.strides.reduce((d,y)=>d+y,0)>0&&t.strides.length!==u)throw new Error(`strides should be ${u}D`);if(t.pads.reduce((d,y)=>d+y,0)>0&&t.pads.length!==u*2)throw new Error(`pads should be ${u*2}D`);if(t.outputPadding.length!==u&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${u}D`);if(t.kernelShape.reduce((d,y)=>d+y,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Oc=[2,3,1,0],Rc=(e,t,r)=>{let o=su(r,t),i=r.format==="NHWC",u=o.outputShape,a=u[i?3:1],c=t[0].dims[i?3:1];if(o.group!==1||a===1&&c===1){e.compute(Lo(t,o));return}let p=u[i?1:2],h=u[i?2:3],d=t[1].dims[2],y=t[1].dims[3],w=i?p*h:a,_=i?a:p*h,v=d*y*c,S=!0,I=e.kernelCustomData.wT??e.compute(yt(t[1],Oc),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let A=[t[0],I],x=t.length===3;x&&(!i&&t[2].dims.length===1?A.push(t[2].reshape([t[2].dims[0],1,1])):A.push(t[2])),e.compute(ou(A,o,u,w,_,v,x,S),{inputs:A})},Bc=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let i=t.kernelShape;(i.length===0||i[0]===0)&&(i=[e.inputs[1].dims[2]]);let u=t.dilations;(u.length===0||u[0]===0)&&(u=[1]);let a=t.strides;(a.length===0||a[0]===0)&&(a=[1]);let c=t.pads;c.length===0&&(c=[0,0]),c=[0,c[0],0,c[1]],a=[1].concat(a),u=[1].concat(u),i=[1].concat(i);let p=su({...t,pads:c,strides:a,dilations:u,kernelShape:i},o);e.compute(Lo(o,p,h=>r?[h[0],h[2],h[3]]:[h[0],h[1],h[3]]))},du=(e,t)=>{kc(e.inputs,t),e.inputs[0].dims.length===3?Bc(e,t):Rc(e,e.inputs,t)}});var Dc,cu,pu,mu=Y(()=>{"use strict";ye();Se();Ze();_e();Dc=(e,t,r,o)=>{let i=M.size(t),u=t.length,a=U("input",e,u),c=j("output",e,u),p=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),h=M.normalizeAxis(p,u),d=y=>{let w=` i32(${a.indicesGet("inputIndices","uniforms.axis")}) `,_=fe("uniforms.input_shape","uniforms.axis",u),v=o.reverse?w+(o.exclusive?" + 1":""):"0",S=o.reverse?_:w+(o.exclusive?"":" + 1");return`\n                ${y.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(a,c)}\n                ${y.mainStart()}\n                  ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${c.offsetToIndices("global_idx")};\n                  var sum = ${c.type.value}(0);\n                  let first : i32 = ${v};\n                  let last : i32 = ${S};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${a.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${a.getByIndices("inputIndices")};\n                  }\n                  ${c.setByOffset("global_idx","sum")};\n                }`};return{name:"CumSum",shaderCache:{hint:o.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},{type:12,data:h},...Z(t,t)]}),getShaderSource:d}},cu=(e,t)=>{let r=e.inputs[0].dims,o=e.inputs[0].dataType,i=e.inputs[1];e.compute(Dc(o,r,i,t),{inputs:[0]})},pu=e=>{let t=e.exclusive===1,r=e.reverse===1;return ve({exclusive:t,reverse:r})}});var zc,Mc,Uc,fu,hu,gu=Y(()=>{"use strict";ye();Se();Ze();_e();zc=e=>{if(!e||e.length!==1)throw new Error("DepthToSpace requires 1 input.");if(e[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},Mc=(e,t,r,o)=>{let i=[];i.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let u=0;u<t;++u)i.push(r.indicesSet("a",e[u],`i[${u}]`));return i.push("return a;}"),i.join(`\n`)},Uc=(e,t)=>{let r,o,i,u,a,c,p=t.format==="NHWC",h=t.blocksize,d=t.mode==="DCR";p?([r,o,i,u]=e.dims,a=d?[r,o,i,h,h,u/h**2]:[r,o,i,u/h**2,h,h],c=d?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([r,o,i,u]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],a=d?[r,h,h,u/h**2,o,i]:[r,u/h**2,h,h,o,i],c=d?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let y=e.reshape(a),w=y.dims.length,_=e.dataType,v=U("a",_,w),S=j("output",_,w),I=A=>`\n  ${A.registerUniform("output_size","u32").declareVariables(v,S)}\n\n  ${Mc(c,w,v,S)}\n\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${S.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${S.setByOffset("global_idx",v.getByIndices("aIndices"))}\n  }`;return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:A=>{let x=p?[r,o*h,i*h,u/h**2]:[r,u/h**2,o*h,i*h],E=M.size(x),P=y.dims,O=M.sortBasedOnPerm(P,c);return{outputs:[{dims:x,dataType:A[0].dataType}],dispatchGroup:{x:Math.ceil(E/64)},programUniforms:[{type:12,data:E},...Z(P,O)]}},getShaderSource:I}},fu=(e,t)=>{zc(e.inputs),e.compute(Uc(e.inputs[0],t))},hu=e=>ve({blocksize:e.blocksize,mode:e.mode,format:e.format})});var Fo,Wn,yu,Vc,Wc,qo,jo,bu,Nc,wu,vu,$u=Y(()=>{"use strict";ye();Se();Ze();_e();Fo="[a-zA-Z]|\\\\.\\\\.\\\\.",Wn="("+Fo+")+",yu="^"+Wn+"$",Vc="("+Wn+",)*"+Wn,Wc="^"+Vc+"$",qo=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},jo=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,i]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(Wc)))throw new Error("Invalid LHS term");if(o.split(",").forEach((c,p)=>{let h=t[p].dims.slice();if(!c.match(RegExp(yu)))throw new Error("Invalid LHS term");let d=this.processTerm(c,!0,h,p);this.lhs.push(d)}),i==="")i+=[...this.symbolToInfo.entries()].filter(([c,p])=>p.count===1||c==="...").map(([c])=>c).join("");else if(!i.match(RegExp(Wn)))throw new Error("Invalid RHS");i.match(RegExp(Fo,"g"))?.forEach(c=>{if(c==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let p=this.symbolToInfo.get(c);if(p===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(p.dimValue)}}),this.rhs=this.processTerm(i,!1,this.outputDims)}addSymbol(t,r,o){let i=this.symbolToInfo.get(t);if(i!==void 0){if(i.dimValue!==r&&i.count!==1)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(o)}else i={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,i)}processTerm(t,r,o,i=-1){let u=o.length,a=!1,c=[],p=0;if(!t.match(RegExp(yu))&&!r&&t!=="")throw new Error("Invalid LHS term");let h=t.match(RegExp(Fo,"g")),d=new qo(i);return h?.forEach((y,w)=>{if(y==="..."){if(a)throw new Error("Only one ellipsis is allowed per input term");a=!0;let _=u-h.length+1;if(_<0)throw new Error("Ellipsis out of bounds");if(c=o.slice(p,p+_),this.hasEllipsis){if(this.ellipsisDims.length!==c.length||this.ellipsisDims.toString()!==c.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=c;else throw new Error("Ellipsis must be specified in the LHS");for(let v=0;v<c.length;v++){let S=String.fromCharCode("0".charCodeAt(0)+v);d.addSymbol(S,w+v),this.addSymbol(S,o[p++],i)}}else d.addSymbol(y,w+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(y,o[p++],i)}),d}},bu=e=>e+"_max",Nc=(e,t,r,o)=>{let u=e.map(d=>d.length).map((d,y)=>U(`input${y}`,t,d)),a=M.size(o),c=j("output",t,o.length),p=[...r.symbolToInfo.keys()].filter(d=>!r.rhs.symbolToIndices.has(d)),h=d=>{let y=[],w="var prod = 1.0;",_="var sum = 0.0;",v="sum += prod;",S=[],I=[],A=[],x=[],E=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((O,R)=>{if(r.rhs.symbolToIndices.has(R)){let H=r.rhs.symbolToIndices.get(R)?.[0];H!==void 0&&r.lhs.forEach((N,K)=>{if(O.inputIndices.includes(K)){let Q=N.symbolToIndices.get(R);if(Q===void 0)throw new Error("Invalid symbol error");Q.forEach(he=>{y.push(`${u[K].indicesSet(`input${K}Indices`,he,c.indicesGet("outputIndices",H))}`)})}})}else r.lhs.forEach((H,N)=>{if(O.inputIndices.includes(N)){let K=H.symbolToIndices.get(R);if(K===void 0)throw new Error("Invalid symbol error");K.forEach(Q=>{S.push(`${u[N].indicesSet(`input${N}Indices`,Q,`${R}`)}`)}),x.push(`prod *= ${u[N].getByIndices(`input${N}Indices`)};`)}}),I.push(`for(var ${R}: u32 = 0; ${R} < uniforms.${bu(R)}; ${R}++) {`),A.push("}")});let P=E?[...y,`let sum = ${u.map((O,R)=>O.getByIndices(`input${R}Indices`)).join(" * ")};`]:[...y,_,...I,...S,w,...x,v,...A];return`\n            ${d.registerUniforms(p.map(O=>({name:`${bu(O)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...u,c)}\n\n            ${d.mainStart()}\n            ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${c.offsetToIndices("global_idx")};\n            ${u.map((O,R)=>`var input${R}Indices: ${u[R].type.indices};`).join(`\n`)}\n            ${P.join(`\n`)};\n            ${c.setByOffset("global_idx","sum")};\n          }`};return{name:"Einsum",shaderCache:{hint:r.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let d=p.filter(w=>r.symbolToInfo.has(w)).map(w=>({type:12,data:r.symbolToInfo.get(w)?.dimValue||0}));d.push({type:12,data:a});let y=e.map((w,_)=>[...Z(w)]).reduce((w,_)=>w.concat(_),d);return y.push(...Z(o)),{outputs:[{dims:o,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:y}},getShaderSource:h}},wu=(e,t)=>{let r=new jo(e.inputs,t.equation),o=r.outputDims,i=e.inputs.map((u,a)=>u.dims);e.compute(Nc(i,e.inputs[0].dataType,r,o))},vu=e=>{let t=e.equation.replace(/\\s+/g,"");return ve({equation:t})}});var Gc,_u,Hc,Lc,Su,xu=Y(()=>{"use strict";ye();Se();_e();Gc=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,i=t.length<r.length?0:t.length-r.length;for(;o<r.length&&i<t.length;++o,++i)if(r[o]!==t[i]&&r[o]!==1&&t[i]!==1)throw new Error("Expand requires shape to be broadcastable to input")},_u=(e,t)=>{let r=e.length-t.length,o=[];for(let i=0;i<r;++i)o.push(e[i]);for(let i=0;i<t.length;++i)o.push(t[i]===1?e[i+r]:t[i]);return o},Hc=(e,t)=>e.length>t.length?_u(e,t):_u(t,e),Lc=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=Hc(t,r),i=e[0].dataType,u=i===9?4:1,a=Math.ceil(M.size(o)/u),c=h=>{let d=U("input",i,t.length,u),y=j("output",i,o.length,u),w;if(i===9){let _=(v,S,I="")=>`\n          let outputIndices${S} = ${y.offsetToIndices(`outputOffset + ${S}u`)};\n          let offset${S} = ${d.broadcastedIndicesToOffset(`outputIndices${S}`,y)};\n          let index${S} = offset${S} / 4u;\n          let component${S} = offset${S} % 4u;\n          ${v}[${S}] = ${I}(${d.getByOffset(`index${S}`)}[component${S}]);\n        `;w=`\n        let outputOffset = global_idx * ${u};\n        var data = vec4<u32>(0);\n        ${_("data",0,"u32")}\n        ${_("data",1,"u32")}\n        ${_("data",2,"u32")}\n        ${_("data",3,"u32")}\n        ${y.setByOffset("global_idx","data")}\n      }`}else w=`\n        let outputIndices = ${y.offsetToIndices("global_idx")};\n        let inputOffset = ${d.broadcastedIndicesToOffset("outputIndices",y)};\n        ${y.setByOffset("global_idx",d.getByOffset("inputOffset"))}\n      }`;return`\n    ${h.registerUniform("vec_size","u32").declareVariables(d,y)}\n    ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${w}`},p=[{type:12,data:a},...Z(t,o)];return{name:"Expand",shaderCache:{hint:`${o.length}`,inputDependencies:["rank"]},getShaderSource:c,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p})}},Su=e=>{Gc(e.inputs),e.compute(Lc(e.inputs),{inputs:[0]})}});var Fc,Cu,Au=Y(()=>{"use strict";ye();Se();_e();Rn();Fc=e=>{let t=e[0].dataType,r=M.size(e[0].dims),o=M.size(e[1].dims),i=o%4===0,u=a=>{let c=U("x",t,[1],4),p=U("bias",t,[1],4),h=j("y",t,[1],4),d=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],y=_=>`\n      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;\n      let bias${_} = ${p.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,w=i?`\n      let bias = ${p.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${y(0)}${y(1)}${y(2)}${y(3)}\n      let bias = ${c.type.value}(bias0, bias1, bias2, bias3);`;return`${a.registerUniforms(d).declareVariables(c,p,h)}\n\n    ${Bo(et(t))}\n\n    ${a.mainStart(or)}\n      ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\n\n      let x = ${c.getByOffset("global_idx")};\n      ${w}\n      let x_in = x + bias;\n      ${h.setByOffset("global_idx",Do("x_in"))}\n    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${i}`,inputDependencies:["type","type"]},getShaderSource:u,getRunData:a=>({outputs:[{dims:a[0].dims,dataType:a[0].dataType}],programUniforms:[{type:12,data:Math.ceil(r/4)},{type:12,data:o}],dispatchGroup:{x:Math.ceil(r/or/4)}})}},Cu=e=>{e.inputs.length<2||M.size(e.inputs[1].dims)===0?Bs(e):e.compute(Fc(e.inputs))}});var qc,jc,Iu,Tu,Eu=Y(()=>{"use strict";ye();Se();Ze();_e();qc=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},jc=(e,t)=>{let r=e[0].dims,o=e[1].dims,i=r.length,u=M.normalizeAxis(t.axis,i),a=r.slice(0);a.splice(u,1,...o);let c=r[u],p=e[0].dataType===9?4:1,h=Math.ceil(M.size(a)/p),d=[{type:12,data:h},{type:6,data:c},{type:12,data:u},...Z(e[0].dims,e[1].dims,a)],y=w=>{let _=U("data",e[0].dataType,e[0].dims.length,p),v=U("inputIndices",e[1].dataType,e[1].dims.length),S=j("output",e[0].dataType,a.length,p),I=x=>{let E=o.length,P=`var indicesIndices${x}  = ${v.type.indices}(0);`;for(let O=0;O<E;O++)P+=`${E>1?`indicesIndices${x}[${O}]`:`indicesIndices${x}`} = ${a.length>1?`outputIndices${x}[uniforms.axis + ${O}]`:`outputIndices${x}`};`;P+=`\n          var idx${x} = ${v.getByIndices(`indicesIndices${x}`)};\n          if (idx${x} < 0) {\n            idx${x} = idx${x} + uniforms.axisDimLimit;\n          }\n          var dataIndices${x} : ${_.type.indices};\n        `;for(let O=0,R=0;O<i;O++)O===u?(P+=`${i>1?`dataIndices${x}[${O}]`:`dataIndices${x}`} = u32(idx${x});`,R+=E):(P+=`${i>1?`dataIndices${x}[${O}]`:`dataIndices${x}`} = ${a.length>1?`outputIndices${x}[${R}]`:`outputIndices${x}`};`,R++);return P},A;if(e[0].dataType===9){let x=(E,P,O="")=>`\n          let outputIndices${P} = ${S.offsetToIndices(`outputOffset + ${P}u`)};\n          ${I(P)};\n          let offset${P} = ${_.indicesToOffset(`dataIndices${P}`)};\n          let index${P} = offset${P} / 4u;\n          let component${P} = offset${P} % 4u;\n          ${E}[${P}] = ${O}(${_.getByOffset(`index${P}`)}[component${P}]);\n        `;A=`\n        let outputOffset = global_idx * ${p};\n        var value = vec4<u32>(0);\n        ${x("value",0,"u32")}\n        ${x("value",1,"u32")}\n        ${x("value",2,"u32")}\n        ${x("value",3,"u32")}\n        ${S.setByOffset("global_idx","value")}\n      `}else A=`\n      let outputIndices = ${S.offsetToIndices("global_idx")};\n      ${I("")};\n      let value = ${_.getByIndices("dataIndices")};\n      ${S.setByOffset("global_idx","value")};\n      `;return`\n      ${w.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(_,v,S)}\n      ${w.mainStart()}\n        ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${A}\n      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:d}),getShaderSource:y}},Iu=e=>ve({axis:e.axis}),Tu=(e,t)=>{let r=e.inputs;qc(r),e.compute(jc(e.inputs,t))}});var Kc,Yc,Pu,ku,Ou=Y(()=>{"use strict";ye();Se();Ze();_e();Kc=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Yc=(e,t)=>{let r=e[0].dims,o=e[0].dataType,i=r.length,u=e[1].dims,a=e[1].dataType,c=M.normalizeAxis(t.axis,i),p=r[c],h=u.slice(0),d=M.size(h),y=U("input",o,i),w=U("indicesInput",a,u.length),_=j("output",o,h.length),v=[{type:12,data:d},{type:6,data:p},{type:12,data:c}];return v.push(...Z(r,u,h)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:v}),getShaderSource:A=>`\n      ${A.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(y,w,_)}\n      ${A.mainStart()}\n      ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${_.offsetToIndices("global_idx")};\n\n      var idx = ${w.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${y.type.indices}(outputIndices);\n      ${y.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${y.getByIndices("inputIndices")};\n\n      ${_.setByOffset("global_idx","value")};\n  }`}},Pu=e=>ve({axis:e.axis}),ku=(e,t)=>{let r=e.inputs;Kc(r),e.compute(Yc(e.inputs,t))}});var Zc,Xc,Ru,Bu,Du=Y(()=>{"use strict";ye();Se();_e();Zc=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Xc=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[i,u,a]=Sn.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),c=[i,u];if(!c)throw new Error("Can\'t use gemm on the given tensors");let p=M.size(c),h=[{type:12,data:p},{type:12,data:i},{type:12,data:u},{type:12,data:a},{type:1,data:t.alpha},{type:1,data:t.beta}],d=["type","type"];e.length===3&&(h.push(...Z(e[2].dims)),d.push("rank")),h.push(...Z(c));let y=w=>{let _="";t.transA&&t.transB?_="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?_="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?_="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(_="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let v=t.alpha===1?"":"value *= uniforms.alpha;",S=U("a",e[0].dataType,e[0].dims),I=U("b",e[1].dataType,e[1].dims),A=S.type.value,x=null,E=[S,I];e.length===3&&(x=U("c",e[2].dataType,e[2].dims.length),E.push(x));let P=j("output",e[0].dataType,c.length);E.push(P);let O=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`\n  ${w.registerUniforms(O).declareVariables(...E)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${A}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${_}\n    }\n\n    ${v}\n    ${(()=>x!=null?`let cOffset = ${x.broadcastedIndicesToOffset("vec2(m, n)",P)}; value += ${A}(uniforms.beta) * ${x.getByOffset("cOffset")};`:"")()}\n    output[global_idx] = value;\n  }`};return{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:c,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h}),getShaderSource:y}},Ru=e=>{let t=e.transA,r=e.transB,o=e.alpha,i=e.beta;return{transA:t,transB:r,alpha:o,beta:i,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},Bu=(e,t)=>{Zc(e.inputs),e.compute(Xc(e.inputs,t))}});var Qc,Jc,ep,zu,Mu=Y(()=>{"use strict";ye();Se();_e();Qc=(e,t)=>{let r=e[0].dims,o=r,i=2,u=M.sizeToDimension(r,i),a=M.sizeFromDimension(r,i),c=Me(a),p=a/c,h=[r[0],r[1],p],d=["rank","type","type"],y=[{type:12,data:a},{type:12,data:p}];y.push(...Z(h,h));let w=_=>{let v=U("x",e[0].dataType,h.length,c),S=U("scale",e[1].dataType,e[1].dims),I=U("bias",e[2].dataType,e[2].dims),A=j("output",e[0].dataType,h.length,c),x=[v,S,I,A],E=v.type.value,P=c===1?"f32":`vec${c}<f32>`,O=64,R=[{name:"normSize",type:"u32"},{name:"normPackedSize",type:"u32"}];return`\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${P}, ${O}>;\n  const workgroupSize = ${O}u;\n  ${_.registerUniforms(R).declareVariables(...x)}\n  ${_.mainStart(O)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / uniforms.x_shape[1];\n    let channel = norm % uniforms.x_shape[1];\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${P}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      initial = initial + ${P}(${v.get("batch","channel","h")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${$t("workgroupShared[0]",c)} / f32(uniforms.normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${P}(0);\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let deviation =  ${P}(${v.get("batch","channel","h")}) - ${P}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${$t("workgroupShared[0]",c)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${t.epsilon}));\n    let channelScale = invStdDev * f32(${S.getByOffset("channel")});\n    let channelShift = f32(${I.getByOffset("channel")}) - meanShared * channelScale;\n    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {\n      let value = ${v.get("batch","channel","h")} * ${E}(${P}(channelScale)) + ${E}(${P}(channelShift));\n      ${A.set("batch","channel","h","value")};\n    }\n  }`};return{name:"InstanceNormalization",shaderCache:{hint:`${t.epsilon};${c}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:u},programUniforms:y}),getShaderSource:w}},Jc=(e,t,r,o,i,u,a,c)=>{let p=Me(a),h=64,d=p===1?"vec2f":`mat2x${p}f`,y=p===1?"f32":`vec${p}f`,w=(R,H)=>`${d}(${R}, ${H})`,_=i*a/p,v=Math.ceil(u/h),S=["type"],I=[{type:12,data:v},{type:12,data:u},{type:12,data:Math.floor(a/p)},{type:12,data:Math.floor(u*a/p)}],A=R=>{let H=U("input",t.dataType,t.dims,p);return`\n  ${R.declareVariables(H)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${d}>;\n  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};\n  @group(0) @binding(2) var<uniform> uniforms: Uniforms;\n\n  ${R.mainStart(h)}\n    let currentImageNumber = global_idx / ${h} / uniforms.C;\n    let currentChannelNumber = (global_idx / ${h}) % uniforms.C;\n    let wgOffset = local_id.x * uniforms.wg_size;\n    if (wgOffset >= uniforms.H) {\n        return;\n    }\n    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);\n\n    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;\n    var sum = ${Lt("f32",p)};\n    var squaredSum = ${Lt("f32",p)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${y}(input[offset + i * uniforms.C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${w("sum","squaredSum")};\n  }`},x=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:`${p}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:[i,a,h,2],dataType:1}],dispatchGroup:{x:i*a/p},programUniforms:I}),getShaderSource:A},{inputs:[t],outputs:[-1]})[0],E=[{type:12,data:_},{type:12,data:u},{type:12,data:Math.floor(a/p)},{type:12,data:Math.floor(h*a/p)}],P=["type","type","type"],O=R=>{let H=U("scale",r.dataType,r.dims,p),N=U("bias",o.dataType,o.dims,p);return`\n  @group(0) @binding(0) var<storage, read> input : array<${d}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${H.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${N.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${d}>;\n  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};\n  @group(0) @binding(4) var<uniform> uniforms: Uniforms;\n\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}\n    let currentImageNumber = global_idx / uniforms.C;\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let offset = currentImageNumber * uniforms.image_size;\n    var sum = ${Lt("f32",p)};\n    var squaredSum = ${Lt("f32",p)};\n    for (var i: u32 = 0; i < min(${h}, uniforms.H); i++) {\n        let value = input[offset + i + currentChannelNumber * ${h}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(uniforms.H);\n    squaredSum = squaredSum / f32(uniforms.H);\n    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${c}));\n    let channelScale = invStdDev * ${y}(scale[currentChannelNumber]);\n    let channelShift = ${y}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${w("channelScale","channelShift")};\n  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${p};${c}`,inputDependencies:P},getRunData:()=>({outputs:[{dims:[i,a,2],dataType:1}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:E}),getShaderSource:O},{inputs:[x,r,o],outputs:[-1]})[0]},ep=(e,t,r)=>{let o=t[0].dims,i=o,u=o[0],a=o[o.length-1],c=M.sizeFromDimension(o,1)/a,p=Me(a),h=M.size(i)/p,d=[{type:12,data:c},{type:12,data:Math.floor(a/p)}],y=["type","type"],w=Jc(e,t[0],t[1],t[2],u,c,a,r.epsilon),_=v=>{let S=Be(t[0].dataType),I=p===1?"vec2f":`mat2x${p}f`,A=p===1?S:`vec${p}<${S}>`,x=U("input",t[0].dataType,t[0].dims,p),E=j("output",t[0].dataType,i,p);return`\n  @group(0) @binding(0) var<storage, read> input : array<${x.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${I}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${E.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${v.mainStart()}\n    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);\n    let currentChannelNumber = global_idx % uniforms.C;\n\n    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${A}(scale[0]), ${A}(scale[1]));\n  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${p}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:d}),getShaderSource:_},{inputs:[t[0],w]})},zu=(e,t)=>{t.format==="NHWC"?ep(e,e.inputs,t):e.compute(Qc(e.inputs,t))}});var tp,rp,Uu,Vu=Y(()=>{"use strict";ye();Se();_e();tp=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},rp=(e,t,r)=>{let o=t.simplified,i=e[0].dims,u=e[1],a=!o&&e[2],c=i,p=M.normalizeAxis(t.axis,i.length),h=M.sizeToDimension(i,p),d=M.sizeFromDimension(i,p),y=M.size(u.dims),w=a?M.size(a.dims):0;if(y!==d||a&&w!==d)throw new Error(`Size of X.shape()[axis:] == ${d}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${y} and bias size of ${w}`);let _=[];for(let O=0;O<i.length;++O)O<p?_.push(i[O]):_.push(1);let v=Me(d),S=["type","type"],I=[{type:12,data:h},{type:1,data:d},{type:12,data:Math.floor(d/v)},{type:1,data:t.epsilon}];a&&S.push("type");let A=r>1,x=r>2,E=O=>{let R=Be(e[0].dataType),H=[U("x",e[0].dataType,e[0].dims,v),U("scale",u.dataType,u.dims,v)];a&&H.push(U("bias",a.dataType,a.dims,v)),H.push(j("output",e[0].dataType,c,v)),A&&H.push(j("mean_data_output",1,_)),x&&H.push(j("inv_std_output",1,_));let N=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`\n  ${O.registerUniforms(N).declareVariables(...H)}\n  ${O.mainStart()}\n    ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${Lt("f32",v)};\n    var mean_square_vector = ${Lt("f32",v)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${ir(R,v,"x[h + offset]")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${$t("mean_vector",v)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${$t("mean_square_vector",v)} / uniforms.norm_size ${o?"":"- mean * mean"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${ir(R,v,"x[j + offset]")};\n      let f32scale = ${ir(R,v,"scale[j]")};\n      output[j + offset] = ${H[0].type.value}((f32input ${o?"":"- mean"}) * inv_std_dev * f32scale\n        ${a?`+ ${ir(R,v,"bias[j]")}`:""}\n      );\n    }\n\n    ${A?"mean_data_output[global_idx] = mean":""};\n    ${x?"inv_std_output[global_idx] = inv_std_dev":""};\n  }`},P=[{dims:c,dataType:e[0].dataType}];return A&&P.push({dims:_,dataType:1}),x&&P.push({dims:_,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${v};${r};${o}`,inputDependencies:S},getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(h/64)},programUniforms:I}),getShaderSource:E}},Uu=(e,t)=>{tp(e.inputs),e.compute(rp(e.inputs,t,e.outputCount))}});var np,op,Wu,Nu,Gu=Y(()=>{"use strict";ye();Se();Ze();_e();np=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let r=e[0],o=r.dims.length;if(r.dims[o-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let i=Math.floor((t.k+t.blockSize-1)/t.blockSize),u=t.blockSize/8*t.bits,a=e[1];if(!M.areEqual(a.dims,[t.n,i,u]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let p=e[2].dims;if(M.size(p)!==t.n*i)throw new Error("scales input size error.");if(e.length===4){let d=e[3].dims,y=t.bits>4?t.n*i:t.n*Math.floor((i+1)/2);if(M.size(d)!==y)throw new Error("zeroPoints input size error.")}},op=(e,t,r,o)=>{let i=e[0].dims,u=i.length,a=Math.floor((t.k+t.blockSize-1)/t.blockSize),c=i[u-2],p=t.k,h=t.n,d=i.slice(0,u-2),y=M.size(d),_=t.blockSize/8*t.bits/4,v=e[0].dataType,S=Me(c),I=Me(t.k),A=Me(_),x=tr(v),E=c*a*x,P=Math.floor(o/E),O=a<=r[0]&&P>0,R=!O||P>=4?Me(h):P>=2&&Me(h)>=2?2:1,H=d.concat([c,h]),N=M.size(H)/R/S,K=O?[]:[{type:12,data:N},{type:12,data:t.blockSize}],Q=[y,c,p/I],he=M.convertShape(e[1].dims).slice();he.splice(-1,1,_/A),K.push(...Z(Q)),K.push(...Z(he)),K.push(...Z(e[2].dims)),e.length===4&&K.push(...Z(M.convertShape(e[3].dims)));let W=[y,c,h/R];K.push(...Z(W));let se=Ce=>{let We=Q.length,ee=U("a",e[0].dataType,We,I),ae=U("b",12,he.length,A),Ae=U("scales",e[2].dataType,e[2].dims.length),me=[ee,ae,Ae],ie=e.length===4?U("zero_points",12,e[3].dims.length):void 0;ie&&me.push(ie);let ue=W.length,le=j("output",e[0].dataType,ue,R),qe=[{name:"output_size",type:"u32"},{name:"block_size",type:"u32"}],G=Be(e[0].dataType),ne=(()=>{switch(I){case 1:return`array<${G}, 8>`;case 2:return`mat4x2<${G}>`;case 4:return`mat2x4<${G}>`;default:throw new Error(`${I}-component is not supported.`)}})(),xe=`\n        for (var word: u32 = 0; word < ${_}; word += ${A}) {\n          ${ae.indicesSet("b_indices","2","word")};\n          let b_data = ${ae.getByIndices("b_indices")};\n          for (var i: u32 = 0; i < ${A}; i++) {\n            let b_value: u32 = ${A===1?"b_data":"b_data[word + i]"};\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            let b_value_lower: vec4<u32> = unpack4xU8(b_value & b_mask);\n            let b_value_upper: vec4<u32> = unpack4xU8((b_value >> 4) & b_mask);\n            let b_quantized_values = ${ne}(${Array.from({length:4},(De,Ge)=>`${G}(b_value_lower[${Ge}]), ${G}(b_value_upper[${Ge}])`).join(", ")});\n            let b_dequantized_values = ${(()=>I===1?`${ne}(${Array.from({length:8},(De,Ge)=>`(b_quantized_values[${Ge}] - zero_point) * scale`).join(", ")});`:`(b_quantized_values - ${ne}(${Array(8).fill("zero_point").join(",")})) * scale;`)()};\n            // Number of B elements per 32-bit word is 32/bits = 32/4 = 8\n            for (var m: u32 = 0; m < ${O?c:S}u; m++) {\n              ${ee.indicesSet("a_indices",We-2,O?"m":`row * ${S} + m`)};\n              ${ee.indicesSet("a_indices",We-1,"word_offset")};\n              var input_offset = ${ee.indicesToOffset("a_indices")};\n              var a_data: ${ne};\n              for (var j: u32 = 0; j < ${8/I}; j++) {\n                a_data[j] = ${ee.getByOffset("input_offset")};\n                input_offset++;\n              }\n              ${O?"workgroup_shared[workgroup_shared_offset + m]":"output_values[m]"}${R>1?"[c]":""} += ${Array.from({length:8/I},(De,Ge)=>`${I===1?`a_data[${Ge}] * b_dequantized_values[${Ge}]`:`dot(a_data[${Ge}], b_dequantized_values[${Ge}])`}`).join(" + ")};\n            }\n            word_offset += ${8/I};\n          }\n        }`,Ke=ie?`\n          zero_point_offset += 4;\n          if (zero_point_offset == 32) {\n            zero_point_offset = 0;\n            zero_point_index++;\n            zero_point_word = ${ie.getByOffset("zero_point_index")};\n          }`:"";return O?`\n        var<workgroup> workgroup_shared: array<${le.type.value}, ${c*a}>;\n        ${Ce.declareVariables(...me,le)}\n        ${Ce.mainStart([a,1,1])}\n          var a_indices: ${ee.type.indices};\n          var block = local_id.x;\n          var col = workgroup_id.y;\n          var batch = workgroup_id.z;\n          ${ee.indicesSet("a_indices","0","batch")};\n          // Two zero points are packed into one byte when uniforms.bits is 4.\n          for (var c: u32 = 0; c < ${R}; c++) {\n            let col_times_components_plus_c = col * ${R} + c;\n              ${ie?`\n            var zero_point_bytes_per_col: u32 = (${a} + 1) / 2;\n            var zero_point_byte_count: u32 = col_times_components_plus_c * zero_point_bytes_per_col + (block >> 0x1u);\n            var zero_point_word_index: u32 = zero_point_byte_count >> 0x2u;\n            var zero_point_byte_offset: u32 = zero_point_byte_count & 0x3u;\n            var zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32 = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            var zero_point_word: u32 = ${ie.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;`:""}\n            var b_indices: ${ae.type.indices};\n            ${ae.indicesSet("b_indices","0","col_times_components_plus_c")};\n            // The scale and zero points are computed per block.\n            var scales_index = col_times_components_plus_c * ${a} + block;\n            let scale = ${Ae.getByOffset("scales_index")};\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${G}(${ie?"(zero_point_word) & 0xFu":8});\n            ${ae.indicesSet("b_indices","1","block")};\n            var word_offset: u32 = block * ${t.blockSize/I};\n            var workgroup_shared_offset: u32 = block * ${c};\n            ${xe}\n          }\n          workgroupBarrier();\n          var output_indices: ${le.type.indices};\n          var elements_per_thread: u32 = ${Math.ceil(c/a)};\n          ${le.indicesSet("output_indices","0","batch")};\n          ${le.indicesSet("output_indices",ue-1,"col")};\n          ${le.indicesSet("output_indices",ue-2,"local_id.x * elements_per_thread")};\n          var output_offset = ${le.indicesToOffset("output_indices")};\n          for (var m: u32 = 0u; m < elements_per_thread; m++) {\n            var row = m + local_id.x * elements_per_thread;\n            if (row < ${c}) {\n              var output_value: ${le.type.value} = ${le.type.value}(0);\n              var workgroup_shared_offset: u32 = row;\n              for (var b: u32 = 0u; b < ${a}u; b++) {\n                output_value += workgroup_shared[workgroup_shared_offset];\n                workgroup_shared_offset += ${c};\n              }\n              ${le.setByOffset("output_offset","output_value")};\n              output_offset += ${h/R};\n            }\n          }\n        }`:`\n        ${Ce.registerUniforms(qe).declareVariables(...me,le)}\n        ${Ce.mainStart()}\n          ${Ce.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var output_values: array<${le.type.value}, ${S}>;\n          var output_indices = ${le.offsetToIndices("global_idx")};\n          var col = ${le.indicesGet("output_indices",ue-1)};\n          var row = ${le.indicesGet("output_indices",ue-2)};\n          var a_indices: ${ee.type.indices} = output_indices;\n          // Two zero points are packed into one byte because uniforms.bits <= 4.\n          // zero_point_offset is either 0 or 4. It is bit offset within one byte.\n          // TODO support zero_point_offset for bits > 4\n          ${ie?`\n          var zero_point_abs_offset = col * ${R} * ((${a} + 1) / 2);\n          var zero_point_index: u32 = zero_point_abs_offset / 4;\n          var zero_point_word: u32 = ${ie.getByOffset("zero_point_index")};\n          var zero_point_offset: u32 = (zero_point_abs_offset % 4) * 8;`:""}\n          var scale_index = col * ${a*R};\n          var b_indices: ${ae.type.indices};\n          for (var c: u32 = 0; c < ${R}; c++) {\n            ${ae.indicesSet("b_indices","0",`col * ${R} + c`)};\n            var block_offset: u32 = 0;\n            for (var block: u32 = 0; block < ${a}; block++) {\n              // The scale and zero points are computed per block.\n              let scale = ${Ae.getByOffset("scale_index")};\n              // The default zero point is 8 for unsigned 4-bit quantization.\n              let zero_point = ${G}(${ie?"extractBits(zero_point_word, zero_point_offset, 4)":8});\n              ${ae.indicesSet("b_indices","1","block")};\n              var word_offset: u32 = block_offset;\n              ${xe}\n              scale_index++;\n              ${Ke}\n              block_offset += uniforms.block_size / ${I};\n            }\n            // Drop the trailing 4 bits if the zero_poit_offset is not a byte boundary to align with the next byte.\n            ${ie?`if (zero_point_offset % 8 > 0) {\n                ${Ke}\n              }`:""}\n            }\n            for (var k: u32 = 0u; k < ${S}u; k++) {\n              ${le.indicesSet("output_indices",ue-2,`${S} * row + k`)};\n              ${le.setByIndices("output_indices","output_values[k]")}\n            }\n        }`};return{name:O?"BlockwiseMatMulNBits":"MatMulNBits",shaderCache:{hint:`${t.cacheKey};${c};${v};${e.length}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:H,dataType:v}],name:O?"BlockwiseMatMulNBits":"MatMulNBits",dispatchGroup:O?{x:1,y:Math.ceil(h/R),z:y}:{x:Math.ceil(N/64)},programUniforms:K}),getShaderSource:se}},Wu=(e,t)=>{np(e.inputs,t);let r=e.getMaxComputeWorkgroupSizes(),o=e.getMaxComputeWorkgroupStoragesize();e.compute(op(e.inputs,t,r,o))},Nu=e=>ve(e)});var it,ip,Lu,Hu,ap,Ko,Fu,qu=Y(()=>{"use strict";ye();Se();Ze();_n();Ro();_e();Sr();it=(e,t)=>e.length>t&&e[t].dims.length>0&&M.size(e[t].dims)>0?e[t]:void 0,ip=(e,t)=>{let r=e[0],o=it(e,1),i=it(e,2),u=it(e,3),a=it(e,4),c=it(e,5),p=it(e,6),h=it(e,7);if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let d=!1,y=r.dims[0],w=r.dims[1],_=r.dims.length===3?d?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],v=w,S=0,I=0,A=Math.floor(_/t.numHeads);if(p&&h){if(p.dims.length!==4)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(p.dims[0]!==y||p.dims[1]!==t.numHeads||p.dims[3]!==A)throw new Error(\'Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(h.dims[0]!==y||h.dims[1]!==t.numHeads||h.dims[3]!==A)throw new Error(\'Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)\');if(p.dims[2]!==h.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)\');if(h.dims.length!==4)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');S=p.dims[2],I=p.dims[2]}else if(p||h)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let x;if(o){if(r.dims.length!==3)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(o.dims.length<3||o.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(r.dims[0]!==o.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(o.dims.length===3){if(o.dims[2]!==r.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');x=2,v=o.dims[1]}else if(o.dims.length===5){if(o.dims[2]!==t.numHeads||o.dims[3]!==2||o.dims[4]!==A)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(i)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');x=5,v=o.dims[1]}else{if(o.dims[1]!==t.numHeads||o.dims[3]!==A)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');x=0,v=o.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');x=3}if(u){if(u.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(i&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let E=0;if(a){E=8;let N=a.dims;throw N.length===1?N[0]===y?E=1:N[0]===3*y+2&&(E=3):N.length===2&&N[0]===y&&N[1]===v&&(E=5),E===8?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)\'):new Error("Mask not supported")}let P=!1,O=_;if(i){if(i.dims.length!==3&&i.dims.length!==4)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(r.dims[0]!==i.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(i.dims.length===3){if(v!==i.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');O=i.dims[2]}else{if(v!==i.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');O=i.dims[1]*i.dims[3],P=!0}}let R=S+v,H=!1;if(a)throw new Error("Key padding mask is not supported");if(c){if(c.dims.length!==4)throw new Error(\'Input "relative_position_bias" is expected to have 4 dimensions\');if(c.dims[0]!==y&&c.dims[0]!==1||c.dims[1]!==t.numHeads||c.dims[2]!==w||c.dims[3]!==R)throw new Error(\'Input "relative_position_bias" shape (batch_size, 1, sequence_length, kv_sequence_length)\')}return{batchSize:y,sequenceLength:w,pastSequenceLength:S,kvSequenceLength:v,totalSequenceLength:R,maxSequenceLength:I,inputHiddenSize:0,hiddenSize:_,vHiddenSize:O,headSize:A,vHeadSize:Math.floor(O/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:E,scale:t.scale,broadcastResPosBias:H,passPastInKv:P,qkvFormat:x}},Lu=e=>ve({...e}),Hu=ve({perm:[0,2,1,3]}),ap=(e,t,r,o,i,u,a)=>{let c=[o,i,u],p=M.size(c),h=[{type:12,data:p},{type:12,data:a},{type:12,data:u}],d=y=>{let w=j("qkv_with_bias",t.dataType,c),_=U("qkv",t.dataType,c),v=U("bias",r.dataType,c),S=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`\n  ${y.registerUniforms(S).declareVariables(_,v,w)}\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:c,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:h}),getShaderSource:d},{inputs:[t,r],outputs:[-1]})[0]},Ko=(e,t,r,o,i,u,a,c)=>{let p=u;if(a){if(o===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return p=ap(e,u,a,t,o,r*i,c),p=p.reshape([t,o,r,i]),e.compute(yt(p,Hu.perm),{inputs:[p],outputs:[-1]})[0]}else return u.dims.length===3&&(p=u.reshape([t,o,r,i])),e.compute(yt(p,Hu.perm),{inputs:[p],outputs:[-1]})[0]},Fu=(e,t)=>{let r=ip(e.inputs,t),o=e.inputs[0],i=it(e.inputs,1),u=it(e.inputs,2),a=it(e.inputs,3),c=it(e.inputs,4),p=it(e.inputs,5),h=it(e.inputs,6),d=it(e.inputs,7);if(o.dims.length===5)throw new Error("Packed QKV is not implemented");if(i?.dims.length===5)throw new Error("Packed KV is not implemented");let y=i&&u&&i.dims.length===4&&u.dims.length===4,w=Ko(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,o,a,0);if(y)return Pn(e,w,i,u,c,void 0,h,d,p,r,t);if(!i||!u)throw new Error("key and value must be provided");let _=Ko(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,i,a,r.hiddenSize),v=Ko(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,u,a,2*r.hiddenSize);Pn(e,w,_,v,c,void 0,h,d,p,r,t)}});var sp,up,dp,lp,cp,pp,mp,fp,ju,Ku=Y(()=>{"use strict";ye();Se();_e();sp=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},up=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n            k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${fe("uniforms.x_shape",i,t)})) {\n              break;\n            }\n            offset += k * i32(${fe("uniforms.x_strides",i,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${o}\n            value = x[offset];\n          }\n      `},dp=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${fe("uniforms.x_shape",i,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${fe("uniforms.x_shape",i,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${fe("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},lp=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${fe("uniforms.x_shape",i,t)})) {\n                  k = i32(${fe("uniforms.x_shape",i,t)}) - 1;\n                }\n                offset += k * i32(${fe("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},cp=(e,t,r)=>{let o="";for(let i=t-1;i>=0;--i)o+=`\n                k = i32(${e.indicesGet("indices",i)}) - ${fe("uniforms.pads",i,r)};\n                if (k < 0)  {\n                  k += i32(${fe("uniforms.x_shape",i,t)}]);\n                }\n                if (k >= i32(${fe("uniforms.x_shape",i,t)})) {\n                  k -= i32(${fe("uniforms.x_shape",i,t)});\n                }\n                offset += k * i32(${fe("uniforms.x_strides",i,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${o}\n              value = x[offset];\n          `},pp=(e,t,r)=>{switch(r.mode){case 0:return up(e,t,r.pads.length);case 1:return dp(e,t,r.pads.length);case 2:return lp(e,t,r.pads.length);case 3:return cp(e,t,r.pads.length);default:throw new Error("Invalid mode")}},mp=(e,t)=>{let r=M.padShape(e[0].dims.slice(),t.pads),o=e[0].dims,i=M.size(r),u=[{type:12,data:i},{type:6,data:t.pads}];t.mode===0&&u.push({type:e[0].dataType,data:t.value}),u.push(...Z(e[0].dims,r));let a=["rank"],c=p=>{let h=j("output",e[0].dataType,r.length),d=U("x",e[0].dataType,o.length),y=d.type.value,w=pp(h,o.length,t),_=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&_.push({name:"constant_value",type:y}),`\n            ${p.registerUniforms(_).declareVariables(d,h)}\n            ${p.mainStart()}\n            ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${h.offsetToIndices("global_idx")};\n\n            var value = ${y}(0);\n            ${w}\n            output[global_idx] = value;\n        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}`,inputDependencies:a},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(r)/64)},programUniforms:u}),getShaderSource:c}},fp=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,i=e[0].dims.length,u=new Int32Array(2*i).fill(0);if(e.length>=4){let c=e[3].getBigInt64Array();for(let p=0;p<c.length;p++)u[Number(c[p])]=Number(r[p]),u[Number(c[p])+i]=Number(r[p+c.length])}else r.forEach((c,p)=>u[Number(p)]=Number(c));let a=[];return u.forEach(c=>a.push(c)),{mode:t.mode,value:o,pads:a}}else return t},ju=(e,t)=>{sp(e.inputs);let r=fp(e.inputs,t);e.compute(mp(e.inputs,r),{inputs:[0]})}});var Nn,Yu,Zu,Xu,Qu,hp,gp,Ju,ed,td,rd,nd,od,id,ad,sd,ud,dd,ld,cd=Y(()=>{"use strict";$r();ye();Se();_e();Nn=e=>{if(vr.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},Yu=(e,t,r)=>{let o=t.format==="NHWC",i=e.dims.slice();o&&i.splice(1,0,i.pop());let u=Object.hasOwnProperty.call(t,"dilations"),a=t.kernelShape.slice(),c=t.strides.slice(),p=u?t.dilations.slice():[],h=t.pads.slice();nr.adjustPoolAttributes(r,i,a,c,p,h);let d=nr.computePoolOutputShape(r,i,c,p,a,h,t.autoPad),y=Object.assign({},t);u?Object.assign(y,{kernelShape:a,strides:c,pads:h,dilations:p,cacheKey:t.cacheKey}):Object.assign(y,{kernelShape:a,strides:c,pads:h,cacheKey:t.cacheKey});let w=d.slice();return w.push(w.splice(1,1)[0]),[y,o?w:d]},Zu=(e,t)=>{let r=t.format==="NHWC",o=M.size(e),i=M.size(t.kernelShape),u=[{type:12,data:o},{type:12,data:i}],a=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let c=t.kernelShape[t.kernelShape.length-1],p=t.strides[t.strides.length-1],h=t.pads[t.pads.length/2-1],d=t.pads[t.pads.length-1],y=!!(h+d);u.push({type:12,data:c},{type:12,data:p},{type:12,data:h},{type:12,data:d}),a.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let w=!1;if(t.kernelShape.length===2){let _=t.kernelShape[t.kernelShape.length-2],v=t.strides[t.strides.length-2],S=t.pads[t.pads.length/2-2],I=t.pads[t.pads.length-2];w=!!(S+I),u.push({type:12,data:_},{type:12,data:v},{type:12,data:S},{type:12,data:I}),a.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[u,a,!0,y,w]}else{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let c=M.computeStrides(t.kernelShape);u.push({type:12,data:c},{type:12,data:t.pads},{type:12,data:t.strides}),a.push({name:"kernelStrides",type:"u32",length:c.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let p=t.pads.reduce((h,d)=>h+d);return[u,a,!!p,!1,!1]}},Xu=(e,t,r,o,i,u,a,c,p,h,d,y)=>{let w=i.format==="NHWC",_=t.type.value,v=j("output",t.type.tensor,o);if(i.kernelShape.length<=2){let S="",I="",A="",x=r-(w?2:1);if(d?S=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${x}] < 0 || xIndices[${x}]\n                      >= uniforms.x_shape[${x}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`:S=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${x}] = indices[${x}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${u}\n                }`,i.kernelShape.length===2){let P=r-(w?3:2);y?I=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${P}] = indices[${P}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${P}] < 0 || xIndices[${P}] >= uniforms.x_shape[${P}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:I=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${P}] = indices[${P}] * uniforms.sh - uniforms.phStart + j;\n                `,A=`\n              }\n            `}return`\n            ${e.registerUniforms(p).declareVariables(t,v)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${v.offsetToIndices("global_idx")};\n              var xIndices = ${v.offsetToIndices("global_idx")};\n\n              var value = ${_}(${c});\n              var pad = 0;\n              ${I}\n              ${S}\n              ${A}\n              ${a}\n\n              output[global_idx] = value;\n            }`}else{if(w)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let S=i.kernelShape.length,I=i.pads.length,A="";return h?A=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${u}\n              }`:A=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${u}\n            `,`\n            ${e.registerUniforms(p).declareVariables(t,v)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${v.offsetToIndices("global_idx")};\n              var xIndices = ${v.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${S}>;\n\n              var value = ${_}(${c});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${S-1}u; j++) {\n                  offsets[j] = offset / ${fe("uniforms.kernelStrides","j",S)};\n                  offset -= offsets[j] * ${fe("uniforms.kernelStrides","j",S)};\n                }\n                offsets[${S-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-S}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${fe("uniforms.strides",`j - ${r-S}u`,S)}\n                    + offsets[j - ${r-S}u] - ${fe("uniforms.pads","j - 2u",I)};\n                  ${A}\n              }\n              ${a}\n\n              output[global_idx] = value;\n            }`}},Qu=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,hp=e=>`${Qu(e)};${e.countIncludePad}`,gp=e=>`${Qu(e)};${e.storageOrder};${e.dilations}`,Ju=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),ed=(e,t,r,o)=>{let[i,u]=Yu(t,o,r),a=U("x",t.dataType,t.dims.length),c=a.type.value,p="value += x_val;",h="";i.countIncludePad?h+=`value /= ${c}(uniforms.kernelSize);`:h+=`value /= ${c}(i32(uniforms.kernelSize) - pad);`;let[d,y,w,_,v]=Zu(u,i);d.push(...Z(t.dims,u));let S=["rank"];return{name:e,shaderCache:{hint:`${o.cacheKey};${w};${_};${v}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(M.size(u)/64)},programUniforms:d}),getShaderSource:I=>Xu(I,a,t.dims.length,u.length,i,p,h,0,y,w,_,v)}},td=e=>{let t=e.count_include_pad!==0,r=Ju(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let o={countIncludePad:t,...r,cacheKey:""};return{...o,cacheKey:hp(o)}},rd=(e,t)=>{Nn(e.inputs),e.compute(ed("AveragePool",e.inputs[0],!1,t))},nd={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},od=e=>{let t=e.format;return{format:t,...nd,cacheKey:t}},id=(e,t)=>{Nn(e.inputs),e.compute(ed("GlobalAveragePool",e.inputs[0],!0,t))},ad=(e,t,r,o)=>{let[i,u]=Yu(t,o,r),a=`\n      value = max(x_val, value);\n    `,c="",p=U("x",t.dataType,t.dims.length),h=["rank"],[d,y,w,_,v]=Zu(u,i);return d.push(...Z(t.dims,u)),{name:e,shaderCache:{hint:`${o.cacheKey};${w};${_};${v}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(M.size(u)/64)},programUniforms:d}),getShaderSource:S=>Xu(S,p,t.dims.length,u.length,i,a,c,t.dataType===10?-65504:-1e5,y,w,_,v)}},sd=(e,t)=>{Nn(e.inputs),e.compute(ad("MaxPool",e.inputs[0],!1,t))},ud=e=>{let t=e.storage_order,r=e.dilations,o=Ju(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let i={storageOrder:t,dilations:r,...o,cacheKey:""};return{...i,cacheKey:gp(i)}},dd=e=>{let t=e.format;return{format:t,...nd,cacheKey:t}},ld=(e,t)=>{Nn(e.inputs),e.compute(ad("GlobalMaxPool",e.inputs[0],!0,t))}});var bp,wp,pd,md=Y(()=>{"use strict";$r();ye();_e();bp=(e,t,r)=>{let o=e===t,i=e<t&&r<0,u=e>t&&r>0;if(o||i||u)throw new Error("Range these inputs\' contents are invalid.")},wp=(e,t,r,o)=>{let i=Math.abs(Math.ceil((t-e)/r)),u=[i],a=i,c=[{type:12,data:a},{type:o,data:e},{type:o,data:r},...Z(u)],p=h=>{let d=j("output",o,u.length),y=d.type.value,w=[{name:"outputSize",type:"u32"},{name:"start",type:y},{name:"delta",type:y}];return`\n        ${h.registerUniforms(w).declareVariables(d)}\n        ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${y}(global_idx) * uniforms.delta;\n      }`};return{name:"Range",shaderCache:{hint:`${o}`},getShaderSource:p,getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:c})}},pd=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),vr.webgpu.validateInputContent&&bp(t,r,o),e.compute(wp(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var vp,$p,_p,Sp,xp,Cp,Ap,Ip,Tp,Ep,Pp,fd,kp,Op,Rp,Bp,Dp,hd,gd,yd=Y(()=>{"use strict";ye();Se();Ze();_e();vp=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},$p=(e,t,r)=>{t.every(i=>i>=0&&i<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((i,u)=>o[i]=e[u]),o},_p=(e,t,r,o,i,u)=>{let[a,c,p]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],h=e[0].dims.length;if(a>0&&e.length>a&&e[a].dims.length>0)e[a].getFloat32Array().forEach(d=>u.push(d));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(c>0&&e.length>c&&e[c].dims.length>0){if(e[c].getFloat32Array().forEach(d=>o.push(d)),o.length!==0&&o.length!==h&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");vp(o,t),t.axes.length>0&&$p(o,t.axes,h).forEach((d,y)=>o[y]=d)}if(p>0&&e.length>p&&(e[p].getBigInt64Array().forEach(d=>i.push(Number(d))),i.length!==h||r>=18&&i.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(i.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof i<"u"&&o.length>0&&i.length>h)throw new Error("Resize requires only of scales or sizes to be specified")},Sp=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`return ${t}(xResized) / ${t}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\n                    return whole + fract;\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",xp=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Cp=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),i=e.length===0?o:e.slice();return t.length>0?(t.forEach((u,a)=>{o[u]=i[a],o[a+r]=i[t.length+a]}),o):i},Ap=(e,t,r,o)=>{let i=[];if(r.length>0)if(o.length>0){if(e.forEach(u=>i.push(u)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((u,a)=>i[u]=r[a])}else r.forEach(u=>i.push(u));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");i=e.map((u,a)=>Math.round(u*t[a]))}return i},Ip=(e,t,r)=>{let o=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(u=>t[u]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(u=>t[u]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let i=e.slice();return r.axes.length>0?(r.axes.forEach(u=>t[u]=o),r.axes.forEach(u=>i[u]=Math.round(e[u]*t[u]))):(t.fill(o,0,t.length),i.forEach((u,a)=>i[a]=Math.round(u*t[a]))),i},Tp=(e,t,r,o,i)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${fe("uniforms.scales","i",o)};\n        var roi_low = ${fe("uniforms.roi","i",i)};\n        var roi_hi = ${fe("uniforms.roi",`i + ${t.length}`,i)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${fe("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${fe("uniforms.output_shape","i",r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Ep=(e,t,r,o,i,u,a)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${o.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${fe("uniforms.scales","i",i)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${fe("uniforms.roi","i",u)};\n          var roi_hi = ${fe("uniforms.roi",`i + ${r.length}`,u)};\n          var input_shape_i = ${fe("uniforms.input_shape","i",r.length)};\n          var output_shape_i = ${fe("uniforms.output_shape","i",o.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i"," input_index")}\n      }\n      return input_indices;\n    }`,Pp=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${fe("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,fd=(e,t,r,o)=>e.rank>o?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",r,"batch")};\n`:"",kp=(e,t,r,o,i)=>{let[a,c,p,h]=r.length===2?[-1,0,1,-1]:[0,2,3,1],d=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${d} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",c,`max(0, min(row, ${r[c]} - 1))`)};\n      ${e.indicesSet("input_indices",p,`max(0, min(col, ${r[p]} - 1))`)};\n      ${fd(e,h,a,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${d} = originalIndices[${c}];\n      var col:${d} = originalIndices[${p}];\n      ${o?`if (row < 0 || row > (${r[c]} - 1) || col < 0 || col > (${r[p]} - 1)) {\n        return ${i};\n      }`:""};\n      row = max(0, min(row, ${r[c]} - 1));\n      col = max(0, min(col, ${r[p]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length>2?`u32(originalIndices[${h}])`:"0"};\n      var batch: u32 =  ${r.length>2?`u32(originalIndices[${a}])`:"0"};\n      var x11: ${d} = getInputValue(batch, channel, row1, col1);\n      var x12: ${d} = getInputValue(batch, channel, row1, col2);\n      var x21: ${d} = getInputValue(batch, channel, row2, col1);\n      var x22: ${d} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${d} = abs(row - ${d}(row1));\n      var dx2: ${d} = abs(${d}(row2) - row);\n      var dy1: ${d} = abs(col - ${d}(col1));\n      var dy2: ${d} = abs(${d}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Op=(e,t,r,o,i,u,a,c,p,h)=>{let d=r.length===2,y=!0,[w,_]=d?[0,1]:y?[2,3]:[1,2],v=e.type.value,S=I=>{let A=I===w?"row":"col";return`\n      fn ${A}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${v} {\n        var output_index = ${t.indicesGet("output_indices",I)};\n        var originalIdx: ${v} = getOriginalCoordinateFromResizedCoordinate(output_index, ${i[I]},\n        ${o[I]}, ${r[I]}, ${u[I]}, ${u[I]} + ${r.length});\n        var fractOriginalIdx: ${v} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${c} && (originalIdx < 0 || originalIdx > (${r[I]} - 1))) {\n          return ${p};\n        }\n        var data: array<${v}, 4> = array<${v}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${A}: ${v} = originalIdx + ${v}(i);\n          if (${A} < 0 || ${A} >= ${r[I]}) {\n            ${(()=>h?`coefs[i + 1] = 0.0;\n                        continue;`:c?`return ${p};`:`${A} = max(0, min(${A}, ${r[I]} - 1));`)()};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",I,`u32(${A})`)};\n          data[i + 1] = ${I===w?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${S(w)};\n    ${S(_)};\n  fn getCubicInterpolationCoefs(s: ${v}) -> array<${v}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${v}, 4> = array<${v}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${v} = 1.0 - absS;\n    var twoMinusAbsS: ${v} = 2.0 - absS;\n    var onePlusAbsS: ${v} = 1.0 + absS;\n    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};\n    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${v}, 4>, coefs: array<${v}, 4>) -> ${v} {\n    var coefsSum: ${v} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${v} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},Rp=(e,t,r,o,i)=>{let[a,c,p,h,d]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],y=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${y} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",c,`max(0, min(depth, ${r[c]} - 1))`)};\n      ${e.indicesSet("input_indices",p,`max(0, min(height, ${r[p]} - 1))`)};\n      ${e.indicesSet("input_indices",h,`max(0, min(width, ${r[h]} - 1))`)};\n      ${fd(e,d,a,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${y} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${y} = originalIndices[${c}];\n      var height:${y} = originalIndices[${p}];\n      var width:${y} = originalIndices[${h}];\n      ${o?`if (depth < 0 || depth > (${r[c]} - 1) || height < 0 || height > (${r[p]} - 1) || width < 0 || (width > ${r[h]} - 1)) {\n      return ${i};\n        }`:""};\n\n    depth = max(0, min(depth, ${r[c]} - 1));\n      height = max(0, min(height, ${r[p]} - 1));\n      width = max(0, min(width, ${r[h]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length>3?`u32(originalIndices[${d}])`:"0"};\n      var batch: u32 =  ${r.length>3?`u32(originalIndices[${a}])`:"0"};\n\n      var x111: ${y} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${y} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${y} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${y} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${y} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${y} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${y} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${y} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${y} = abs(depth - ${y}(depth1));\n      var dx2: ${y} = abs(${y}(depth2) - depth);\n      var dy1: ${y} = abs(height - ${y}(height1));\n      var dy2: ${y} = abs(${y}(height2) - height);\n      var dz1: ${y} = abs(width - ${y}(width1));\n      var dz2: ${y} = abs(${y}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Bp=(e,t,r,o,i,u)=>{let a=e.dims,c=Cp(u,t.axes,a.length),p=Ap(a,o,i,t.axes),h=o.slice();o.length===0&&(h=a.map((x,E)=>x===0?1:p[E]/x),t.keepAspectRatioPolicy!=="stretch"&&(p=Ip(a,h,t)));let d=j("output",e.dataType,p.length),y=U("input",e.dataType,a.length),w=M.size(p),_=a.length===p.length&&a.every((x,E)=>x===p[E]),v=t.coordinateTransformMode==="tf_crop_and_resize",S=t.extrapolationValue,I=y.type.value,A=x=>`\n      ${_?"":`\n      ${Sp(t.coordinateTransformMode,I)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Pp(y,a)};\n              ${xp(t.nearestMode,r,I)};\n              ${Ep(y,d,a,p,h.length,c.length,v)};\n              `;case"linear":return`\n              ${Tp(d,a,p,h.length,c.length)};\n              ${(()=>{if(a.length===2||a.length===4)return`${kp(y,d,a,v,S)}`;if(a.length===3||a.length===5)return`${Rp(y,d,a,v,S)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(a.length===2||a.length===4)return`${Op(y,d,a,p,h,c,t.cubicCoeffA,v,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${x.registerUniform("output_size","u32").registerUniform("scales","f32",h.length).registerUniform("roi","f32",c.length).declareVariables(y,d)}\n      ${x.mainStart()}\n        ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${_?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${d.offsetToIndices("global_idx")};\n        var input_indices: ${y.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${y.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${a.length===2||a.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${h.length>0?h:""}|${i.length>0?i:""}|${c.length>0?c:""}|${_}|${a}`,inputDependencies:["rank"]},getShaderSource:A,getRunData:()=>({outputs:[{dims:p,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:[{type:12,data:w},{type:1,data:h},{type:1,data:c},...Z(a,p)]})}},Dp=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},hd=(e,t)=>{let r=[],o=[],i=[],u=Dp(e);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");_p(e.inputs,t,u,r,o,i),e.compute(Bp(e.inputs[0],t,u,r,o,i),{inputs:[0]})},gd=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,i=e.cubicCoeffA,u=e.excludeOutside!==0,a=e.extrapolationValue,c=e.keepAspectRatioPolicy,p=e.mode,h=e.nearestMode===""?"simple":e.nearestMode;return ve({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:i,excludeOutside:u,extrapolationValue:a,keepAspectRatioPolicy:c,mode:p,nearestMode:h})}});var zp,Mp,bd,wd=Y(()=>{"use strict";ye();Se();Ze();_e();zp=(e,t)=>{let[r,o,i,u]=e,{numHeads:a,rotaryEmbeddingDim:c}=t;if(r.dims.length!==3&&r.dims.length!==4)throw new Error(`Input \'x\' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);if(!M.areEqual(o.dims,[])&&!M.areEqual(o.dims,[1])&&o.dims.length!==2)throw new Error(`Input \'position_ids\' is expected to have 0, 1, or 2 dimensions, got ${o.dims.length}`);if(i.dims.length!==2)throw new Error(`Input \'cos_cache\' is expected to have 2 dimensions, got ${i.dims.length}`);if(u.dims.length!==2)throw new Error(`Input \'sin_cache\' is expected to have 2 dimensions, got ${u.dims.length}`);if(!M.areEqual(i.dims,u.dims))throw new Error("Inputs \'cos_cache\' and \'sin_cache\' are expected to have the same shape");if(c>0&&a===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let p=r.dims[0],h=r.dims[r.dims.length-2],d=i.dims[0],y=M.sizeFromDimension(r.dims,1)/h,w=c===0?i.dims[1]*2:y/a;if(c>w)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(o.dims.length===2){if(p!==o.dims[0])throw new Error(`Input \'position_ids\' dimension 0 should be of size batch_size, got ${o.dims[0]}`);if(h!==o.dims[1])throw new Error(`Input \'position_ids\' dimension 1 should be of size sequence_length, got ${o.dims[1]}`)}if(w/2!==i.dims[1]&&c/2!==i.dims[1])throw new Error(`Input \'cos_cache\' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${i.dims[1]}`);if(h>d)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},Mp=(e,t)=>{let{interleaved:r,numHeads:o,rotaryEmbeddingDim:i,scale:u}=t,a=e[0].dims[0],c=M.sizeFromDimension(e[0].dims,1),p=e[0].dims[e[0].dims.length-2],h=c/p,d=e[2].dims[1],y=i===0?d*2:h/o,w=new Array(a,p,h/y,y-d),_=M.computeStrides(w),v=[{type:1,data:u},{type:12,data:w},{type:12,data:_},...e[0].dims.length===3?new Array({type:12,data:[c,h,y,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[c,y,p*y,1]}):[],...Z(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],S=I=>{let A=U("input",e[0].dataType,e[0].dims.length),x=U("position_ids",e[1].dataType,e[1].dims.length),E=U("cos_cache",e[2].dataType,e[2].dims.length),P=U("sin_cache",e[3].dataType,e[3].dims.length),O=j("output",e[0].dataType,e[0].dims.length);return I.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:w.length},{name:"global_strides",type:"u32",length:_.length},{name:"input_output_strides",type:"u32",length:_.length}]),`\n        ${I.declareVariables(A,x,E,P,O)}\n\n        ${I.mainStart(or)}\n          let half_rotary_emb_dim = uniforms.${E.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${I.guardAgainstOutOfBoundsWorkgroupSizes("size")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${x.broadcastedIndicesToOffset("bsnh.xy",j("",x.type.tensor,2))};\n            let position_id =\n                u32(${x.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});\n            let j = i + select(half_rotary_emb_dim, 1, ${r});\n            let re = ${A.getByOffset("i")} * ${E.get("position_id","bsnh[3]")} -\n                ${A.getByOffset("j")} * ${P.get("position_id","bsnh[3]")};\n            ${O.setByOffset("i","re")}\n            let im = ${A.getByOffset("i")} * ${P.get("position_id","bsnh[3]")} +\n                ${A.getByOffset("j")} * ${E.get("position_id","bsnh[3]")};\n            ${O.setByOffset("j","im")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${O.setByOffset("k",A.getByOffset("k"))}\n          }\n        }`};return{name:"RotaryEmbedding",shaderCache:{hint:ve({interleaved:r}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:S,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(M.size(w)/or)},programUniforms:v})}},bd=(e,t)=>{zp(e.inputs,t),e.compute(Mp(e.inputs,t))}});var Up,Vp,vd,$d=Y(()=>{"use strict";ye();Se();_e();Up=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let i=t.dims[t.dims.length-1],u=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==i)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==u)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==i)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let a=e[3];if(a.dims.length!==1)throw new Error("Beta must be 1D");if(a.dims[a.dims.length-1]!==i)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let a=e[4];if(a.dims.length!==1)throw new Error("Bias must be 1D");if(a.dims[a.dims.length-1]!==i)throw new Error("Bias must have the same hidden size as input")}},Vp=(e,t,r,o)=>{let i=t.simplified,u=e[0].dims,a=M.size(u),c=u,p=a,h=u.slice(-1)[0],d=o?u.slice(0,-1).concat(1):[],y=!i&&e.length>3,w=e.length>4,_=o&&r>1,v=o&&r>2,S=r>3,I=64,A=Me(h),x=[{type:12,data:p},{type:12,data:A},{type:12,data:h},{type:1,data:t.epsilon}],E=O=>{let R=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],H=[U("x",e[0].dataType,e[0].dims,A),U("skip",e[1].dataType,e[1].dims,A),U("gamma",e[2].dataType,e[2].dims,A)];y&&H.push(U("beta",e[3].dataType,e[3].dims,A)),w&&H.push(U("bias",e[4].dataType,e[4].dims,A)),H.push(j("output",e[0].dataType,c,A)),_&&H.push(j("mean_output",1,d)),v&&H.push(j("inv_std_output",1,d)),S&&H.push(j("input_skip_bias_sum",e[0].dataType,c,A));let N=Be(e[0].dataType),K=Be(1,A);return`\n\n      ${O.registerUniforms(R).declareVariables(...H)}\n      var<workgroup> sum_shared : array<${K}, ${I}>;\n      var<workgroup> sum_squared_shared : array<${K}, ${I}>;\n\n      ${O.mainStart([I,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / ${I};\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / ${I};\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == ${I-1}) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${w?"bias[offset1d + i]":N+"(0.0)"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${S?"input_skip_bias_sum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32_value = ${ir(N,A,"value")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = ${I};\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${$t("sum",A)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${$t("square_sum",A)} / f32(uniforms.hidden_size) ${i?"":"- mean * mean"} + uniforms.epsilon);\n        ${_?"mean_output[global_idx] = mean;":""}\n        ${v?"inv_std_output[global_idx] = inv_std_dev;":""}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${i?"":`- ${N}(mean)`}) *\n            ${N}(inv_std_dev) * gamma[offset1d + i]\n            ${y?"+ beta[offset1d + i]":""};\n        }\n      }`},P=[{dims:c,dataType:e[0].dataType}];return r>1&&P.push({dims:d,dataType:1}),r>2&&P.push({dims:d,dataType:1}),r>3&&P.push({dims:u,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${A};${_};${v};${S}`,inputDependencies:e.map((O,R)=>"type")},getShaderSource:E,getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(p/h)},programUniforms:x})}},vd=(e,t)=>{Up(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(Vp(e.inputs,t,e.outputCount,!1),{outputs:o})}});var Wp,Gn,Np,_d,Gp,Hp,Sd,xd,Cd=Y(()=>{"use strict";ye();Se();Ze();_e();Wp=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},Gn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Np=(e,t)=>{if(e.length>1){let r=Gn(e,1),o=Gn(e,2),i=Gn(e,3);return i.length===0&&(i=[...Array(e[0].dims.length).keys()]),ve({starts:r,ends:o,axes:i})}else return t},_d=(e,t,r,o,i)=>{let u=e;return e<0&&(u+=r[o[t]]),i[t]<0?Math.max(0,Math.min(u,r[o[t]]-1)):Math.max(0,Math.min(u,r[o[t]]))},Gp=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${fe("uniforms.input_shape","i",r.length)};\n            let steps_i = ${fe("uniforms.steps","i",r.length)};\n            let signs_i = ${fe("uniforms.signs","i",r.length)};\n            let starts_i = ${fe("uniforms.starts","i",r.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,Hp=(e,t)=>{let r=e[0].dims,o=M.size(r),i=t.axes.length>0?M.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],u=Gn(e,4);u.forEach(A=>A!==0||(()=>{throw new Error("step cannot be 0")})),u.length===0&&(u=Array(i.length).fill(1));let a=t.starts.map((A,x)=>_d(A,x,r,i,u)),c=t.ends.map((A,x)=>_d(A,x,r,i,u));if(i.length!==a.length||i.length!==c.length)throw new Error("start, ends and axes should have the same number of elements");if(i.length!==r.length)for(let A=0;A<r.length;++A)i.includes(A)||(a.splice(A,0,0),c.splice(A,0,r[A]),u.splice(A,0,1));let p=u.map(A=>Math.sign(A));u.forEach((A,x,E)=>{if(A<0){let P=(c[x]-a[x])/A,O=a[x],R=O+P*u[x];a[x]=R,c[x]=O,E[x]=-A}});let h=r.slice(0);i.forEach((A,x)=>{h[A]=Math.ceil((c[A]-a[A])/u[A])});let d={dims:h,dataType:e[0].dataType},y=j("output",e[0].dataType,h.length),w=U("input",e[0].dataType,e[0].dims.length),_=M.size(h),v=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:a.length},{name:"signs",type:"i32",length:p.length},{name:"steps",type:"u32",length:u.length}],S=[{type:12,data:_},{type:12,data:a},{type:6,data:p},{type:12,data:u},...Z(e[0].dims,h)],I=A=>`\n      ${A.registerUniforms(v).declareVariables(w,y)}\n        ${Gp(w,y,r)}\n        ${A.mainStart()}\n          ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${y.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${y.setByOffset("global_idx",w.getByIndices("input_indices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${p.length}_${a.length}_${u.length}`,inputDependencies:["rank"]},getShaderSource:I,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:S})}},Sd=(e,t)=>{Wp(e.inputs,t);let r=Np(e.inputs,t);e.compute(Hp(e.inputs,r),{inputs:[0]})},xd=e=>{let t=e.starts,r=e.ends,o=e.axes;return ve({starts:t,ends:r,axes:o})}});var Lp,Fp,Ad,Id,Td=Y(()=>{"use strict";ye();Se();Ze();_e();Lp=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Fp=(e,t)=>{let r=e.dims,o=M.size(r),i=64,u=t.axis;if(u<0&&(u=r.length+u),u<r.length-1)throw new Error("softmax only supports last axis for now.");let a=r[u],c=o/a,p=Me(a),h=a/p,d=(I,A)=>A===4?`max(max(${I}.x, ${I}.y), max(${I}.z, ${I}.w))`:A===2?`max(${I}.x, ${I}.y)`:A===3?`max(max(${I}.x, ${I}.y), ${I}.z)`:I,y=U("x",e.dataType,e.dims,p),w=j("result",e.dataType,e.dims,p),_=y.type.value,v=Be(e.dataType)==="f32"?`var threadMax = ${_}(-3.402823e+38f);`:`var threadMax = ${_}(-65504.0h);`,S=I=>`\n      var<workgroup> rowMaxShared : ${_};\n      var<workgroup> rowSumShared : ${_};\n      var<workgroup> threadShared : array<${_}, ${i}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${_} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${_}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${I.registerUniform("packedCols","i32").declareVariables(y,w)}\n      ${I.mainStart()}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${i};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${v}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${_}(${d("threadShared[0]",p)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${_}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${_}(${$t("threadShared[0]",p)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${p}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:c},programUniforms:[{type:6,data:h}]}),getShaderSource:S}},Ad=(e,t)=>{Lp(e.inputs),e.compute(Fp(e.inputs[0],t))},Id=e=>ve({axis:e.axis})});var qp,jp,Kp,Yp,Zp,Ed,Pd,kd=Y(()=>{"use strict";ye();Se();Ze();_e();qp=e=>{if(!e||e.length<1)throw new Error("too few inputs")},jp=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(i=>r.push(Number(i))),o=r.length),ve({numOutputs:o,axis:t.axis,splitSizes:r})},Kp=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${fe("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Yp=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let i=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(i):o===0?r.push(`if (output_number == ${o}u) { ${i} }`):o===t-1?r.push(`else { ${i} }`):r.push(`else if (output_number == ${o}) { ${i} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},Zp=(e,t)=>{let r=e[0].dims,o=M.size(r),i=e[0].dataType,u=M.normalizeAxis(t.axis,r.length),a=new Array(t.numOutputs),c=U("input",i,r.length),p=new Array(t.numOutputs),h=[],d=[],y=0,w=[{type:12,data:o}];for(let v=0;v<t.numOutputs;v++){y+=t.splitSizes[v],p[v]=y;let S=r.slice();S[t.axis]=t.splitSizes[v],d.push(S),a[v]=j(`output${v}`,i,S.length),h.push({dims:d[v],dataType:e[0].dataType})}w.push({type:12,data:p},...Z(r,...d));let _=v=>`\n  ${v.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",p.length).declareVariables(c,...a)}\n  ${Kp(p.length)}\n  ${Yp(a)}\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${c.offsetToIndices("global_idx")};\n    var index = ${c.indicesGet("indices",u)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${fe("uniforms.size_in_split_axis","output_number - 1u",p.length)};\n      ${c.indicesSet("indices",u,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:_,getRunData:()=>({outputs:h,dispatchGroup:{x:Math.ceil(o/64)},programUniforms:w})}},Ed=(e,t)=>{qp(e.inputs);let r=e.inputs.length===1?t:jp(e.inputs,t);e.compute(Zp(e.inputs,r),{inputs:[0]})},Pd=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ve({axis:t,numOutputs:o,splitSizes:r})}});var Od,Xp,Qp,Jp,Rd,Bd=Y(()=>{"use strict";ye();Se();_e();Od=e=>Array.from(e.getBigInt64Array(),Number),Xp=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Od(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Qp=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},Jp=e=>{let t=e[0].dims,r=Od(e[1]),o=Qp(t,r),i=M.size(o),u=e[0].dataType,a=U("input",u,t.length),c=j("output",u,o.length),p=h=>`\n      const inputShape = ${a.indices(...t)};\n      ${h.registerUniform("output_size","u32").declareVariables(a,c)}\n      ${h.mainStart()}\n      ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${c.offsetToIndices("global_idx")};\n      var input_indices: ${a.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let input_dim_i = ${a.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${c.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${a.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${c.setByOffset("global_idx",a.getByIndices("input_indices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...Z(e[0].dims,o)]}),getShaderSource:p}},Rd=e=>{Xp(e.inputs),e.compute(Jp(e.inputs),{inputs:[0]})}});var em,tm,Dd,zd=Y(()=>{"use strict";ye();Se();_e();em=(e,t,r,o,i)=>{let u=j("output_data",i,r.length,4),a=U("a_data",t[1].dataType,t[1].dims.length,4),c=U("b_data",t[2].dataType,t[2].dims.length,4),p=U("c_data",t[0].dataType,t[0].dims.length,4),h,d=(y,w,_)=>`select(${w}, ${y}, ${_})`;if(!o)h=u.setByOffset("global_idx",d(a.getByOffset("global_idx"),c.getByOffset("global_idx"),p.getByOffset("global_idx")));else{let y=(w,_,v="")=>{let S=`a_data[index_a${_}][component_a${_}]`,I=`b_data[index_b${_}][component_b${_}]`,A=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`\n            let output_indices${_} = ${u.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${a.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let offset_b${_} = ${c.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let offset_c${_} = ${p.broadcastedIndicesToOffset(`output_indices${_}`,u)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            let component_c${_} = offset_c${_} % 4u;\n            ${w}[${_}] = ${v}(${d(S,I,A)});\n          `};i===9?h=`\n            var data = vec4<u32>(0);\n            ${y("data",0,"u32")}\n            ${y("data",1,"u32")}\n            ${y("data",2,"u32")}\n            ${y("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:h=`\n            ${y("output_data[global_idx]",0)}\n            ${y("output_data[global_idx]",1)}\n            ${y("output_data[global_idx]",2)}\n            ${y("output_data[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(p,a,c,u)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${h}\n      }`},tm=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,i=e[1].dataType,u=!(M.areEqual(t,r)&&M.areEqual(r,o)),a=t,c=M.size(t);if(u){let h=At.calcShape(At.calcShape(t,r,!1),o,!1);if(!h)throw new Error("Can\'t perform where op on the given tensors");a=h,c=M.size(a)}let p=Math.ceil(c/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:h=>em(h,e,a,u,i),getRunData:()=>({outputs:[{dims:a,dataType:i}],dispatchGroup:{x:Math.ceil(c/64/4)},programUniforms:[{type:12,data:p},...Z(o,t,r,a)]})}},Dd=e=>{e.compute(tm(e.inputs))}});var Md,Ud=Y(()=>{"use strict";Ka();Ro();Ja();ts();Vs();Zs();Oo();Uo();lu();mu();gu();$u();xu();Au();Eu();Ou();Du();Mu();Vu();Wo();Gu();qu();Ku();cd();md();In();yd();wd();$d();Cd();Td();kd();Bd();Sr();Rn();zd();Md=new Map([["Abs",[rs]],["Acos",[ns]],["Acosh",[os]],["Add",[Ws]],["ArgMax",[ja,ko]],["ArgMin",[qa,ko]],["Asin",[is]],["Asinh",[as]],["Atan",[ss]],["Atanh",[us]],["Attention",[Xa]],["AveragePool",[rd,td]],["BatchNormalization",[Qa]],["BiasAdd",[es]],["BiasSplitGelu",[Us]],["Cast",[ls,ds]],["Ceil",[ps]],["Clip",[cs]],["Concat",[Ya,Za]],["Conv",[Ho,Go]],["ConvTranspose",[du,uu]],["Cos",[ms]],["Cosh",[fs]],["CumSum",[cu,pu]],["DepthToSpace",[fu,hu]],["Div",[Ns]],["Einsum",[wu,vu]],["Elu",[hs,kn]],["Equal",[Gs]],["Erf",[gs]],["Exp",[ys]],["Expand",[Su]],["FastGelu",[Cu]],["Floor",[bs]],["FusedConv",[Ho,Go]],["Gather",[Tu,Iu]],["GatherElements",[ku,Pu]],["Gelu",[ws]],["Gemm",[Bu,Ru]],["GlobalAveragePool",[id,od]],["GlobalMaxPool",[ld,dd]],["Greater",[qs]],["GreaterOrEqual",[Ks]],["HardSigmoid",[Is,As]],["InstanceNormalization",[zu]],["LayerNormalization",[Uu]],["LeakyRelu",[vs,kn]],["Less",[js]],["LessOrEqual",[Ys]],["Log",[zs]],["MatMul",[ru]],["MatMulNBits",[Wu,Nu]],["MaxPool",[sd,ud]],["Mul",[Hs]],["MultiHeadAttention",[Fu,Lu]],["Neg",[_s]],["Not",[$s]],["Pad",[ju]],["Pow",[Ls]],["Range",[pd]],["Reciprocal",[Ss]],["ReduceMin",[Wa]],["ReduceMean",[Da]],["ReduceMax",[Va]],["ReduceSum",[Ga]],["ReduceProd",[Na]],["ReduceL1",[za]],["ReduceL2",[Ma]],["ReduceLogSum",[La]],["ReduceLogSumExp",[Ua]],["ReduceSumSquare",[Ha]],["Relu",[xs]],["Resize",[hd,gd]],["RotaryEmbedding",[bd]],["Sigmoid",[Cs]],["Sin",[Ts]],["Sinh",[Es]],["Slice",[Sd,xd]],["SkipLayerNormalization",[vd]],["Split",[Ed,Pd]],["Sqrt",[Ps]],["Softmax",[Ad,Id]],["Sub",[Fs]],["Tan",[ks]],["Tanh",[Rs]],["ThresholdedRelu",[Ds,kn]],["Tile",[Rd]],["Transpose",[_a,Sa]],["Where",[Dd]]])});var Hn,Vd=Y(()=>{"use strict";$r();Ht();_e();Hn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,i,u){rr(t.programInfo.name);let a=this.backend.device,c=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let p=[];for(let d of r)p.push({binding:p.length,resource:{buffer:d.buffer}});for(let d of o)p.push({binding:p.length,resource:{buffer:d.buffer}});u&&p.push({binding:p.length,resource:u});let h=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:p,label:t.programInfo.name});if(this.backend.sessionStatus==="capturing"){let d={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:h,dispatchGroup:i};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(d)}c.setPipeline(t.computePipeline),c.setBindGroup(0,h),c.dispatchWorkgroups(...i),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Gt(t.programInfo.name)}dispose(){}build(t,r){rr(t.name);let o=this.backend.device,i=[];o.features.has("shader-f16")&&i.push("enable f16;");let u=va(r,this.backend.device.limits),a=t.getShaderSource(u),c=`${i.join(`\n`)}\n${u.additionalImplementations}\n${a}`,p=o.createShaderModule({code:c,label:t.name});Ve("verbose",()=>`[WebGPU] ${t.name} shader code: ${c}`);let h=o.createComputePipeline({compute:{module:p,entryPoint:"main"},layout:"auto",label:t.name});return Gt(t.name),{programInfo:t,computePipeline:h,uniformVariablesInfo:u.variablesInfo}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,i=typeof t=="number"?1:t.z||1,u=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=u&&o<=u&&i<=u)return[r,o,i];let a=r*o*i,c=Math.ceil(Math.sqrt(a));if(c>u){if(c=Math.ceil(Math.cbrt(a)),c>u)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[c,c,c]}else return[c,c,1]}}});var rm,nm,Yo,Ln,Wd=Y(()=>{"use strict";$r();ye();Ht();fa();wa();Ud();Vd();rm=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let i=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${i}`);break}case"rank":{let u=e[o].dims.length;r.push(`${i};${u}`);break}case"dims":{let u=e[o].dims.join(",");r.push(`${i};${u}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},nm=(e,t,r)=>{let o=e.name;return e.shaderCache?.hint&&(o+="["+e.shaderCache.hint+"]"),o+=":"+r+`:${rm(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,o},Yo=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},Ln=class{constructor(){this.currentSessionId=null;this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionStatus="default";this.capturedCommandList=new Map;this.capturedPendingKernels=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,r){this.env=t;let o=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("chromium-experimental-timestamp-query-inside-passes")?o.push("chromium-experimental-timestamp-query-inside-passes"):r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(i),this.adapterInfo=new Yo(await r.requestAdapterInfo()),this.gpuDataManager=ba(this),this.programManager=new Hn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,pa(t.logLevel,!!t.debug),this.device.onuncapturederror=u=>{u.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${u.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:r,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),r={};this.queryType==="at-passes"&&(r.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(r)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;rr(),this.endComputePass();let t;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&t.mapAsync(GPUMapMode.READ).then(()=>{let r=new BigUint64Array(t.getMappedRange()),o=this.pendingQueries.get(t);for(let i=0;i<r.length/2;i++){let u=o[i],a=u.kernelId,c=this.kernels.get(a),p=c.kernelType,h=c.kernelName,d=u.programName,y=u.inputTensorViews,w=u.outputTensorViews,_=r[i*2],v=r[i*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=_);let S=Number(_-this.queryTimeBase),I=Number(v-this.queryTimeBase);if(!Number.isSafeInteger(S)||!Number.isSafeInteger(I))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:y.map(A=>({dims:A.dims,dataType:Nt(A.dataType)})),outputsMetadata:w.map(A=>({dims:A.dims,dataType:Nt(A.dataType)})),kernelId:a,kernelType:p,kernelName:h,programName:d,startTime:S,endTime:I});else{let A="";y.forEach((E,P)=>{A+=`input[${P}]: [${E.dims}] | ${Nt(E.dataType)}, `});let x="";w.forEach((E,P)=>{x+=`output[${P}]: [${E.dims}] | ${Nt(E.dataType)}, `}),console.log(`[profiling] kernel "${a}|${p}|${h}|${d}" ${A}${x}execution time: ${I-S} ns`)}wo("GPU",`${d}::${_}::${v}`)}t.unmap(),this.pendingQueries.delete(t)}),Gt()}run(t,r,o,i,u,a){rr(t.name);let c=[];for(let E=0;E<r.length;++E){let P=r[E].data;if(P===0)continue;let O=this.gpuDataManager.get(P);if(!O)throw new Error(`no GPU data for input: ${P}`);c.push(O)}let{outputs:p,dispatchGroup:h,programUniforms:d}=t.getRunData(r),y=o.length===0?p.map((E,P)=>P):o;if(y.length!==p.length)throw new Error(`Output size ${y.length} must be equal to ${p.length}.`);let w=[],_=[];for(let E=0;E<p.length;++E){if(!Number.isInteger(y[E])||y[E]<-3||y[E]>=a)throw new Error(`Invalid output index: ${y[E]}`);if(y[E]===-3)continue;let P=y[E]===-1,O=y[E]===-2,R=P||O?u(p[E].dataType,p[E].dims):i(y[E],p[E].dataType,p[E].dims);if(w.push(R),R.data===0)continue;let H=this.gpuDataManager.get(R.data);if(!H)throw new Error(`no GPU data for output: ${R.data}`);if(P&&this.temporaryData.push(H),O){let N=this.kernelPersistentData.get(this.currentKernelId);N||(N=[],this.kernelPersistentData.set(this.currentKernelId,N)),N.push(H)}_.push(H)}if(c.length!==r.length||_.length!==w.length){if(_.length===0)return Gt(t.name),w;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let v;if(d){let E=0,P=[];d.forEach(N=>{let K=typeof N.data=="number"?[N.data]:N.data;if(K.length===0)return;let Q=N.type===10?2:4,he,W;N.type===10?(W=K.length>4?16:K.length>2?8:K.length*Q,he=K.length>4?16:Q*K.length):(W=K.length<=2?K.length*Q:16,he=16),E=Math.ceil(E/W)*W,P.push(E);let se=N.type===10?8:4;E+=K.length>4?Math.ceil(K.length/se)*he:K.length*Q});let O=16;E=Math.ceil(E/O)*O;let R=new ArrayBuffer(E);d.forEach((N,K)=>{let Q=P[K],he=typeof N.data=="number"?[N.data]:N.data;if(N.type===6)new Int32Array(R,Q,he.length).set(he);else if(N.type===12)new Uint32Array(R,Q,he.length).set(he);else if(N.type===10)new Uint16Array(R,Q,he.length).set(he);else if(N.type===1)new Float32Array(R,Q,he.length).set(he);else throw new Error(`Unsupported uniform type: ${Nt(N.type)}`)});let H=this.gpuDataManager.create(E,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(H.buffer,0,R,0,E),this.gpuDataManager.release(H.id),v={offset:0,size:E,buffer:H.buffer}}let S=this.programManager.normalizeDispatchGroupSize(h),I=S[1]===1&&S[2]===1,A=nm(t,r,I),x=this.programManager.getArtifact(A);if(x||(x=this.programManager.build(t,S),this.programManager.setArtifact(A,x),Ve("info",()=>`[artifact] key: ${A}, programName: ${t.name}`)),d&&x.uniformVariablesInfo){if(d.length!==x.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${x.uniformVariablesInfo.length}, got ${d.length} in program "${x.programInfo.name}".`);for(let E=0;E<d.length;E++){let P=d[E],O=P.type,R=typeof P.data=="number"?1:P.data.length,[H,N]=x.uniformVariablesInfo[E];if(O!==H||R!==N)throw new Error(`Uniform variable ${E} mismatch: expect type ${H} with size ${N}, got type ${O} with size ${R} in program "${x.programInfo.name}".`)}}if(Ve("info",()=>`[ProgramManager] run "${t.name}" (key=${A}) with ${S[0]}x${S[1]}x${S[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let E={kernelId:this.currentKernelId,programName:x.programInfo.name,inputTensorViews:r,outputTensorViews:w};this.pendingKernels.push(E),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(E)}return this.programManager.run(x,c,_,S,v),Gt(t.name),w}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,i){let u=Md.get(t);if(!u)throw new Error(`kernel not implemented: ${t}`);let a={kernelType:t,kernelName:i,kernelEntry:u[0],attributes:[u[1],o]};this.kernels.set(r,a)}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let i=this.kernels.get(t);if(!i)throw new Error(`kernel not created: ${t}`);let u=i.kernelType,a=i.kernelName,c=i.kernelEntry,p=i.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${u}] ${a}" is not allowed to be called recursively`);this.currentKernelId=t,p[0]&&(p[1]=p[0](p[1]),p[0]=void 0),Ve("info",()=>`[WebGPU] Start to run kernel "[${u}] ${a}"...`);let h=this.env.debug;this.temporaryData=[];try{return h&&this.device.pushErrorScope("validation"),c(r,p[1]),0}catch(d){return o.push(Promise.resolve(`[WebGPU] Kernel "[${u}] ${a}" failed. ${d}`)),1}finally{h&&o.push(this.device.popErrorScope().then(d=>d?`GPU validation error for kernel "[${u}] ${a}": ${d.message}`:null));for(let d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,i){let u=this.sessionExternalDataMapping.get(t);u||(u=new Map,this.sessionExternalDataMapping.set(t,u));let a=u.get(r),c=this.gpuDataManager.registerExternalBuffer(o,i,a?.[1]);return u.set(r,[c,o]),c}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let i=await xo(this,t,r);return ma(i.buffer,o)}}writeTimestamp(t){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Ve("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Ve("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Ve("info","replay"),this.sessionStatus="replaying";let t=this.capturedCommandList.get(this.currentSessionId),r=this.capturedPendingKernels.get(this.currentSessionId),o=t.length;this.pendingKernels=[];for(let i=0;i<o;i++){let u=this.getComputePassEncoder(),a=t[i];this.writeTimestamp(this.pendingDispatchNumber*2),u.setPipeline(a.computePipeline),u.setBindGroup(0,a.bindGroup),u.dispatchWorkgroups(...a.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(r[i]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}});var Nd={};gn(Nd,{init:()=>om});var qr,Zo,om,Gd=Y(()=>{"use strict";ye();Wd();Ht();Se();qr=class e{constructor(t,r,o,i){this.module=t;this.dataType=r;this.data=o;this.dims=i}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=M.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(M.size(t)!==M.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Zo=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;this.adapterInfo=r.adapterInfo;let i=t.HEAPU32,u=o>>>2;this.opKernelContext=i[u++];let a=i[u++];this.outputCount=i[u++],this.customDataOffset=i[u++],this.customDataSize=i[u++];let c=[];for(let p=0;p<a;p++){let h=i[u++],d=i[u++],y=i[u++],w=[];for(let _=0;_<y;_++)w.push(i[u++]);c.push(new qr(t,h,d,w))}this.inputs=c}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(t,r){let o=r?.inputs?.map(c=>typeof c=="number"?this.inputs[c]:c)??this.inputs,i=r?.outputs??[],u=(c,p,h)=>new qr(this.module,p,this.output(c,h),h),a=(c,p)=>{let h=tr(c);if(!h)throw new Error(`Unsupported data type: ${c}`);let d=h*M.size(p),y=d>0?this.backend.gpuDataManager.create(d).id:0;return new qr(this.module,c,y,p)};return this.backend.run(t,o,i,u,a,this.outputCount)}output(t,r){let o=this.module.stackSave();try{let i=this.module.stackAlloc((1+r.length)*4),u=i>>2;this.module.HEAPU32[u++]=r.length;for(let a=0;a<r.length;a++)this.module.HEAPU32[u++]=r[a];return this.module._JsepOutput(this.opKernelContext,t,i)}catch(i){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${i}`)}finally{this.module.stackRestore(o)}}},om=async(e,t,r,o)=>{let i=t.jsepInit;if(!i)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(e==="webgpu"){let u=new Ln;await u.initialize(r,o),i("webgpu",[u,a=>u.alloc(a),a=>u.free(a),(a,c,p,h=!1)=>{if(h)Ve("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${a}, dst=${c}, size=${p}`),u.memcpy(a,c);else{Ve("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${a}, gpuDataId=${c}, size=${p}`);let d=t.HEAPU8.subarray(a>>>0,(a>>>0)+p);u.upload(c,d)}},async(a,c,p)=>{Ve("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${c}, size=${p}`),await u.download(a,()=>t.HEAPU8.subarray(c>>>0,(c>>>0)+p))},(a,c,p)=>u.createKernel(a,c,p,t.UTF8ToString(t._JsepGetNodeName(c))),a=>u.releaseKernel(a),(a,c,p,h)=>{Ve("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${p}, kernel=${a}, contextDataOffset=${c}`);let d=new Zo(t,u,c);return u.computeKernel(a,d,h)},()=>u.captureBegin(),()=>u.captureEnd(),()=>u.replay()])}else i("webnn")}});var Vi;Vi=Ei();var pl=zi(),fo,ho=!1,yn=!1,Ui=!1,ml=e=>{if(e===1)return!1;if(typeof SharedArrayBuffer>"u")return typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+e+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),!1;typeof process<"u"&&process.versions&&process.versions.node&&console.warn("env.wasm.numThreads is set to "+e+", however, currently onnxruntime-web does not support multi-threads in Node.js. Please consider using onnxruntime-node for performance critical scenarios.");try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},fl=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},hl=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Wi=async e=>{if(ho)return Promise.resolve();if(yn)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(Ui)throw new Error("previous call to \'initializeWebAssembly()\' failed.");yn=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,i=ml(r),u=o&&fl(),a=e.wasmPaths,c=typeof a=="string"?a:void 0,p=hl(u,i),h=typeof a=="object"?a[p]:void 0,d=!1,y=[];if(t>0&&y.push(new Promise(w=>{setTimeout(()=>{d=!0,w()},t)})),y.push(new Promise((w,_)=>{let v=i?pl:Vi,S={locateFile:(I,A)=>{if(i&&I.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Mi()],{type:"text/javascript"}));if(I.endsWith(".wasm")){if(h)return h;let x=c??A;return p==="ort-wasm-simd.wasm"?x+"ort-wasm-simd.jsep.wasm":p==="ort-wasm-simd-threaded.wasm"?x+"ort-wasm-simd-threaded.jsep.wasm":x+p}return A+I}};if(i)if(S.numThreads=r,typeof Blob>"u")S.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let I=`var ortWasmThreaded=${v.toString()};`;S.mainScriptUrlOrBlob=new Blob([I],{type:"text/javascript"})}v(S).then(I=>{yn=!1,ho=!0,fo=I,w()},I=>{yn=!1,Ui=!0,_(I)})})),await Promise.race(y),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Le=()=>{if(ho&&fo)return fo;throw new Error("WebAssembly is not initialized yet.")};var Fe=(e,t)=>{let r=Le(),o=r.lengthBytesUTF8(e)+1,i=r._malloc(o);return r.stringToUTF8(e,i,o),t.push(i),i},Nr=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([i,u])=>{let a=t?t+i:i;if(typeof u=="object")Nr(u,a+".",r,o);else if(typeof u=="string"||typeof u=="number")o(a,u.toString());else if(typeof u=="boolean")o(a,u?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof u}`)})},Ue=e=>{let t=Le(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let i=t.HEAP32[o/4],u=t.HEAPU32[o/4+1],a=u?t.UTF8ToString(u):"";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(r)}};var Ni=e=>{let t=Le(),r=0,o=[],i=e||{};try{if(e?.logSeverityLevel===void 0)i.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)i.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(i.terminate=!1);let u=0;return e?.tag!==void 0&&(u=Fe(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,u),r===0&&Ue("Can\'t create run options."),e?.extra!==void 0&&Nr(e.extra,"",new WeakSet,(a,c)=>{let p=Fe(a,o),h=Fe(c,o);t._OrtAddRunConfigEntry(r,p,h)!==0&&Ue(`Can\'t set a run config entry: ${a} - ${c}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(a=>t._free(a)),u}};var gl=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},yl=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},bl=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},wl=(e,t,r)=>{for(let o of t){let i=typeof o=="string"?o:o.name;switch(i){case"webnn":if(i="WEBNN",typeof o!="string"){let a=o;if(a?.deviceType){let c=Fe("deviceType",r),p=Fe(a.deviceType,r);Le()._OrtAddSessionConfigEntry(e,c,p)!==0&&Ue(`Can\'t set a session config entry: \'deviceType\' - ${a.deviceType}.`)}if(a?.numThreads){let c=a.numThreads;(typeof c!="number"||!Number.isInteger(c)||c<0)&&(c=0);let p=Fe("numThreads",r),h=Fe(c.toString(),r);Le()._OrtAddSessionConfigEntry(e,p,h)!==0&&Ue(`Can\'t set a session config entry: \'numThreads\' - ${a.numThreads}.`)}if(a?.powerPreference){let c=Fe("powerPreference",r),p=Fe(a.powerPreference,r);Le()._OrtAddSessionConfigEntry(e,c,p)!==0&&Ue(`Can\'t set a session config entry: \'powerPreference\' - ${a.powerPreference}.`)}}break;case"webgpu":if(i="JS",typeof o!="string"){let a=o;if(a?.preferredLayout){if(a.preferredLayout!=="NCHW"&&a.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${a.preferredLayout}`);let c=Fe("preferredLayout",r),p=Fe(a.preferredLayout,r);Le()._OrtAddSessionConfigEntry(e,c,p)!==0&&Ue(`Can\'t set a session config entry: \'preferredLayout\' - ${a.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${i}`)}let u=Fe(i,r);Le()._OrtAppendExecutionProvider(e,u)!==0&&Ue(`Can\'t append execution provider: ${i}.`)}},Gi=e=>{let t=Le(),r=0,o=[],i=e||{};bl(i);try{let u=gl(i.graphOptimizationLevel??"all"),a=yl(i.executionMode??"sequential"),c=typeof i.logId=="string"?Fe(i.logId,o):0,p=i.logSeverityLevel??2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);let h=i.logVerbosityLevel??0;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log verbosity level is not valid: ${h}`);let d=typeof i.optimizedModelFilePath=="string"?Fe(i.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(u,!!i.enableCpuMemArena,!!i.enableMemPattern,a,!!i.enableProfiling,0,c,p,h,d),r===0&&Ue("Can\'t create session options."),i.executionProviders&&wl(r,i.executionProviders,o),i.enableGraphCapture!==void 0){if(typeof i.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${i.enableGraphCapture}`);let y=Fe("enableGraphCapture",o),w=Fe(i.enableGraphCapture.toString(),o);t._OrtAddSessionConfigEntry(r,y,w)!==0&&Ue(`Can\'t set a session config entry: \'enableGraphCapture\' - ${i.enableGraphCapture}.`)}if(i.freeDimensionOverrides)for(let[y,w]of Object.entries(i.freeDimensionOverrides)){if(typeof y!="string")throw new Error(`free dimension override name must be a string: ${y}`);if(typeof w!="number"||!Number.isInteger(w)||w<0)throw new Error(`free dimension override value must be a non-negative integer: ${w}`);let _=Fe(y,o);t._OrtAddFreeDimensionOverride(r,_,w)!==0&&Ue(`Can\'t set a free dimension override: ${y} - ${w}.`)}return i.extra!==void 0&&Nr(i.extra,"",new WeakSet,(y,w)=>{let _=Fe(y,o),v=Fe(w,o);t._OrtAddSessionConfigEntry(r,_,v)!==0&&Ue(`Can\'t set a session config entry: ${y} - ${w}.`)}),[r,o]}catch(u){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(a=>t._free(a)),u}};ye();var Li=async e=>{if(typeof e=="string")if(typeof process<"u"&&process.versions&&process.versions.node)try{return new Uint8Array(await(void 0)(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let r=(void 0)(e),o=[];for await(let i of r)o.push(i);return new Uint8Array(Buffer.concat(o))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),o=r?parseInt(r,10):0;if(o<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let i=t.body.getReader(),u;try{u=new ArrayBuffer(o)}catch(c){if(c instanceof RangeError){let p=Math.ceil(o/65536);u=new WebAssembly.Memory({initial:p,maximum:p}).buffer}else throw c}let a=0;for(;;){let{done:c,value:p}=await i.read();if(c)break;let h=p.byteLength;new Uint8Array(u,a,h).set(p),a+=h}return new Uint8Array(u,0,o)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)};var im=(e,t)=>{Le()._OrtInit(e,t)!==0&&Ue("Can\'t initialize onnxruntime.")},Ld=async e=>{im(e.wasm.numThreads,Gr(e.logLevel))},Fd=async(e,t)=>{{let r=(Gd(),wr(Nd)).init;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let o=e.webgpu.adapter;if(o){if(typeof o.limits!="object"||typeof o.features!="object"||typeof o.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let i=e.webgpu.powerPreference;if(i!==void 0&&i!=="low-power"&&i!=="high-performance")throw new Error(`Invalid powerPreference setting: "${i}"`);let u=e.webgpu.forceFallbackAdapter;if(u!==void 0&&typeof u!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${u}"`);if(o=await navigator.gpu.requestAdapter({powerPreference:i,forceFallbackAdapter:u}),!o)throw new Error(\'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.\')}if(!e.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");await r("webgpu",Le(),e,o)}if(t==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await r("webnn",Le(),e)}}},ar=new Map,am=e=>{let t=Le(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ue("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},Xo=e=>{let t=Le(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},qd=async(e,t)=>{let r,o,i=Le();Array.isArray(e)?[r,o]=e:e.buffer===i.HEAPU8.buffer?[r,o]=[e.byteOffset,e.byteLength]:[r,o]=Xo(e);let u=0,a=0,c=0,p=[],h=[],d=[];try{if([a,p]=Gi(t),t?.externalData&&i.mountExternalData){let x=[];for(let E of t.externalData){let P=typeof E=="string"?E:E.path;x.push(Li(typeof E=="string"?E:E.data).then(O=>{i.mountExternalData(P,O)}))}await Promise.all(x)}u=await i._OrtCreateSession(r,o,a),u===0&&Ue("Can\'t create a session.");let[y,w]=am(u),_=!!t?.enableGraphCapture,v=[],S=[],I=[];for(let x=0;x<y;x++){let E=i._OrtGetInputName(u,x);E===0&&Ue("Can\'t get an input name."),h.push(E),v.push(i.UTF8ToString(E))}for(let x=0;x<w;x++){let E=i._OrtGetOutputName(u,x);E===0&&Ue("Can\'t get an output name."),d.push(E);let P=i.UTF8ToString(E);S.push(P);{if(_&&t?.preferredOutputLocation===void 0){I.push("gpu-buffer");continue}let O=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[P]??"cpu";if(O!=="cpu"&&O!=="cpu-pinned"&&O!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${O}.`);if(_&&O!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${O}. Only \'gpu-buffer\' location is supported when enableGraphCapture is true.`);I.push(O)}}let A=null;return I.some(x=>x==="gpu-buffer")&&(c=i._OrtCreateBinding(u),c===0&&Ue("Can\'t create IO binding."),A={handle:c,outputPreferredLocations:I,outputPreferredLocationsEncoded:I.map(x=>yo(x))}),ar.set(u,[u,h,d,A,_,!1]),[u,v,S]}catch(y){throw h.forEach(w=>i._OrtFree(w)),d.forEach(w=>i._OrtFree(w)),c!==0&&i._OrtReleaseBinding(c),u!==0&&i._OrtReleaseSession(u),y}finally{i._free(r),a!==0&&i._OrtReleaseSessionOptions(a),p.forEach(y=>i._free(y)),i.unmountExternalData?.()}},jd=e=>{let t=Le(),r=ar.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,i,u,a,c]=r;a&&(c&&t._OrtClearBoundOutputs(a.handle),t._OrtReleaseBinding(a.handle)),t.jsepOnReleaseSession?.(e),i.forEach(p=>t._OrtFree(p)),u.forEach(p=>t._OrtFree(p)),t._OrtReleaseSession(o),ar.delete(e)},Hd=(e,t,r,o,i,u=!1)=>{if(!e){t.push(0);return}let a=Le(),c=e[0],p=e[1],h=e[3],d,y;if(c==="string"&&h==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(u&&h!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${i} when enableGraphCapture is true.`);if(h==="gpu-buffer"){let v=e[2].gpuBuffer,S=tr(go(c));y=p.reduce((A,x)=>A*x,1)*S;let I=a.jsepRegisterBuffer;if(!I)throw new Error(\'Tensor location "gpu-buffer" is not supported without using WebGPU.\');d=I(o,i,v,y)}else{let v=e[2];if(Array.isArray(v)){y=4*v.length,d=a._malloc(y),r.push(d);let S=d/4;for(let I=0;I<v.length;I++){if(typeof v[I]!="string")throw new TypeError(`tensor data at index ${I} is not a string`);a.HEAPU32[S++]=Fe(v[I],r)}}else y=v.byteLength,d=a._malloc(y),r.push(d),a.HEAPU8.set(new Uint8Array(v.buffer,v.byteOffset,y),d)}let w=a.stackSave(),_=a.stackAlloc(4*p.length);try{let v=_/4;p.forEach(I=>a.HEAP32[v++]=I);let S=a._OrtCreateTensor(go(c),d,y,_,p.length,yo(h));S===0&&Ue(`Can\'t create tensor for input/output. session=${o}, index=${i}.`),t.push(S)}finally{a.stackRestore(w)}},Kd=async(e,t,r,o,i,u)=>{let a=Le(),c=ar.get(e);if(!c)throw new Error(`cannot run inference. invalid session id: ${e}`);let p=c[0],h=c[1],d=c[2],y=c[3],w=c[4],_=c[5],v=t.length,S=o.length,I=0,A=[],x=[],E=[],P=[],O=a.stackSave(),R=a.stackAlloc(v*4),H=a.stackAlloc(v*4),N=a.stackAlloc(S*4),K=a.stackAlloc(S*4);try{[I,A]=Ni(u);for(let ee=0;ee<v;ee++)Hd(r[ee],x,P,e,t[ee],w);for(let ee=0;ee<S;ee++)Hd(i[ee],E,P,e,v+o[ee],w);let Q=R/4,he=H/4,W=N/4,se=K/4;for(let ee=0;ee<v;ee++)a.HEAPU32[Q++]=x[ee],a.HEAPU32[he++]=h[t[ee]];for(let ee=0;ee<S;ee++)a.HEAPU32[W++]=E[ee],a.HEAPU32[se++]=d[o[ee]];if(y&&!_){let{handle:ee,outputPreferredLocations:ae,outputPreferredLocationsEncoded:Ae}=y;if(h.length!==v)throw new Error(`input count from feeds (${v}) is expected to be always equal to model\'s input count (${h.length}).`);for(let me=0;me<v;me++){let ie=t[me];await a._OrtBindInput(ee,h[ie],x[me])!==0&&Ue(`Can\'t bind input[${me}] for session=${e}.`)}for(let me=0;me<S;me++){let ie=o[me];i[me]?.[3]?a._OrtBindOutput(ee,d[ie],E[me],0)!==0&&Ue(`Can\'t bind pre-allocated output[${me}] for session=${e}.`):a._OrtBindOutput(ee,d[ie],0,Ae[ie])!==0&&Ue(`Can\'t bind output[${me}] to ${ae[me]} for session=${e}.`)}ar.set(e,[p,h,d,y,w,!0])}a.jsepOnRunStart?.(p);let Ce;y?Ce=await a._OrtRunWithBinding(p,y.handle,S,N,I):Ce=await a._OrtRun(p,H,R,v,K,S,N,I),Ce!==0&&Ue("failed to call OrtRun().");let We=[];for(let ee=0;ee<S;ee++){let ae=a.HEAPU32[N/4+ee];if(ae===E[ee]){We.push(i[ee]);continue}let Ae=a.stackSave(),me=a.stackAlloc(4*4),ie=!1,ue,le=0;try{a._OrtGetTensorData(ae,me,me+4,me+8,me+12)!==0&&Ue(`Can\'t access output tensor data on index ${ee}.`);let G=me/4,ne=a.HEAPU32[G++];le=a.HEAPU32[G++];let xe=a.HEAPU32[G++],Ke=a.HEAPU32[G++],De=[];for(let Ne=0;Ne<Ke;Ne++)De.push(a.HEAPU32[xe/4+Ne]);a._OrtFree(xe);let Ge=De.reduce((Ne,Ye)=>Ne*Ye,1);ue=Nt(ne);let Mt=y?.outputPreferredLocations[o[ee]];if(ue==="string"){if(Mt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ne=[],Ye=le/4;for(let mt=0;mt<Ge;mt++){let Ot=a.HEAPU32[Ye++],qt=mt===Ge-1?void 0:a.HEAPU32[Ye]-Ot;Ne.push(a.UTF8ToString(Ot,qt))}We.push([ue,De,Ne,"cpu"])}else if(Mt==="gpu-buffer"&&Ge>0){let Ne=a.jsepGetBuffer;if(!Ne)throw new Error(\'preferredLocation "gpu-buffer" is not supported without using WebGPU.\');let Ye=Ne(le),mt=tr(ne);if(mt===void 0||!Hi(ue))throw new Error(`Unsupported data type: ${ue}`);ie=!0,We.push([ue,De,{gpuBuffer:Ye,download:a.jsepCreateDownloader(Ye,Ge*mt,ue),dispose:()=>{a._OrtReleaseTensor(ae)}},"gpu-buffer"])}else{let Ne=bn(ue),Ye=new Ne(Ge);new Uint8Array(Ye.buffer,Ye.byteOffset,Ye.byteLength).set(a.HEAPU8.subarray(le,le+Ye.byteLength)),We.push([ue,De,Ye,"cpu"])}}finally{a.stackRestore(Ae),ue==="string"&&le&&a._free(le),ie||a._OrtReleaseTensor(ae)}}return y&&!w&&(a._OrtClearBoundOutputs(y.handle),ar.set(e,[p,h,d,y,w,!1])),We}finally{a.stackRestore(O),x.forEach(Q=>a._OrtReleaseTensor(Q)),E.forEach(Q=>a._OrtReleaseTensor(Q)),P.forEach(Q=>a._free(Q)),I!==0&&a._OrtReleaseRunOptions(I),A.forEach(Q=>a._free(Q))}},Yd=e=>{let t=Le(),r=ar.get(e);if(!r)throw new Error("invalid session id");let o=r[0],i=t._OrtEndProfiling(o);i===0&&Ue("Can\'t get an profile file name."),t._OrtFree(i)},Zd=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":Wi(r.wasm).then(()=>{Ld(r).then(()=>{postMessage({type:t})},o=>{postMessage({type:t,err:o})})},o=>{postMessage({type:t,err:o})});break;case"init-ep":{let{epName:o,env:i}=r;Fd(i,o).then(()=>{postMessage({type:t})},u=>{postMessage({type:t,err:u})});break}case"copy-from":{let{buffer:o}=r,i=Xo(o);postMessage({type:t,out:i});break}case"create":{let{model:o,options:i}=r;qd(o,i).then(u=>{postMessage({type:t,out:u})},u=>{postMessage({type:t,err:u})});break}case"release":jd(r),postMessage({type:t});break;case"run":{let{sessionId:o,inputIndices:i,inputs:u,outputIndices:a,options:c}=r;Kd(o,i,u,a,new Array(a.length).fill(null),c).then(p=>{p.some(h=>h[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:p},Zd([...u,...p]))},p=>{postMessage({type:t,err:p})});break}case"end-profiling":Yd(r),postMessage({type:t});break;default:}}catch(o){postMessage({type:t,err:o})}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'}),gr,St,sn,pi,mi,Sa,Ca,zr,Br,pf,ci,Wd,Nd,Vd,Hd,Gd,Ld,Fd,Ia=j(()=>{var i;_t(),Md(),Or(),gr=()=>!!ke.wasm.proxy&&typeof document<"u",sn=!1,pi=!1,mi=!1,Ca=new Map,zr=(e,o)=>{let a=Ca.get(e);a?a.push(o):Ca.set(e,[o])},Br=()=>{if(sn||!pi||mi||!St)throw new Error("worker not ready")},pf=e=>{switch(e.data.type){case"init-wasm":sn=!1,e.data.err?(mi=!0,Sa[1](e.data.err)):(pi=!0,Sa[0]());break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let o=Ca.get(e.data.type);e.data.err?o.shift()[1](e.data.err):o.shift()[0](e.data.out);break}}},ci=typeof document<"u"?(i=document==null?void 0:document.currentScript)==null?void 0:i.src:void 0,Wd=async()=>{if(!pi){if(sn)throw new Error("multiple calls to 'initWasm()' detected.");if(mi)throw new Error("previous call to 'initWasm()' failed.");if(sn=!0,gr())return ke.wasm.wasmPaths===void 0&&ci&&ci.indexOf("blob:")!==0&&(ke.wasm.wasmPaths=ci.substr(0,+ci.lastIndexOf("/")+1)),new Promise((e,o)=>{St==null||St.terminate();let a=URL.createObjectURL(new Blob([Ud()],{type:"text/javascript"}));St=new Worker(a,{name:"ort-wasm-proxy-worker"}),St.onerror=g=>o(g),St.onmessage=pf,URL.revokeObjectURL(a),Sa=[e,o];let d={type:"init-wasm",in:ke};St.postMessage(d)});try{await Fo(ke.wasm),await kd(ke),pi=!0}catch(e){throw mi=!0,e}finally{sn=!1}}},Nd=async e=>{if(gr())return Br(),new Promise((o,a)=>{zr("init-ep",[o,a]);let d={type:"init-ep",in:{epName:e,env:ke}};St.postMessage(d)});await Od(ke,e)},Vd=async e=>gr()?(Br(),new Promise((o,a)=>{zr("copy-from",[o,a]);let d={type:"copy-from",in:{buffer:e}};St.postMessage(d,[e.buffer])})):xa(e),Hd=async(e,o)=>{if(gr()){if(o!=null&&o.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Br(),new Promise((a,d)=>{zr("create",[a,d]);let g={type:"create",in:{model:e,options:{...o}}},h=[];e instanceof Uint8Array&&h.push(e.buffer),St.postMessage(g,h)})}else return Pd(e,o)},Gd=async e=>{if(gr())return Br(),new Promise((o,a)=>{zr("release",[o,a]);let d={type:"release",in:e};St.postMessage(d)});Rd(e)},Ld=async(e,o,a,d,g,h)=>{if(gr()){if(a.some(et=>et[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(g.some(et=>et))throw new Error("pre-allocated output tensor is not supported for proxy.");return Br(),new Promise((et,ot)=>{zr("run",[et,ot]);let it=a,$={type:"run",in:{sessionId:e,inputIndices:o,inputs:it,outputIndices:d,options:h}};St.postMessage($,Dd(it))})}else return zd(e,o,a,d,g,h)},Fd=async e=>{if(gr())return Br(),new Promise((o,a)=>{zr("end-profiling",[o,a]);let d={type:"end-profiling",in:e};St.postMessage(d)});Bd(e)}}),qd,mf,fi,jd=j(()=>{_t(),Ia(),ye(),qi(),qd=(i,e)=>{switch(i.location){case"cpu":return[i.type,i.dims,i.data,"cpu"];case"gpu-buffer":return[i.type,i.dims,{gpuBuffer:i.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${i.location} for ${e()}`)}},mf=i=>{switch(i[3]){case"cpu":return new tt(i[0],i[2],i[1]);case"gpu-buffer":{let e=i[0];if(!Vn(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:o,download:a,dispose:d}=i[2];return tt.fromGpuBuffer(o,{dataType:e,dims:i[1],download:a,dispose:d})}default:throw new Error(`invalid data location: ${i[3]}`)}},fi=class{async fetchModelAndCopyToWasmMemory(i){return Vd(await tn(i))}async loadModel(i,e){yt();let o;typeof i=="string"?typeof process<"u"&&process.versions&&process.versions.node?o=await tn(i):o=await this.fetchModelAndCopyToWasmMemory(i):o=i,[this.sessionId,this.inputNames,this.outputNames]=await Hd(o,e),ut()}async dispose(){return Gd(this.sessionId)}async run(i,e,o){yt();let a=[],d=[];Object.entries(i).forEach(c=>{let s=c[0],_=c[1],b=this.inputNames.indexOf(s);if(b===-1)throw new Error(`invalid input '${s}'`);a.push(_),d.push(b)});let g=[],h=[];Object.entries(e).forEach(c=>{let s=c[0],_=c[1],b=this.outputNames.indexOf(s);if(b===-1)throw new Error(`invalid output '${s}'`);g.push(_),h.push(b)});let et=a.map((c,s)=>qd(c,()=>`input "${this.inputNames[d[s]]}"`)),ot=g.map((c,s)=>c?qd(c,()=>`output "${this.outputNames[h[s]]}"`):null),it=await Ld(this.sessionId,d,et,h,ot,o),$={};for(let c=0;c<it.length;c++)$[this.outputNames[h[c]]]=g[c]??mf(it[c]);return ut(),$}startProfiling(){}endProfiling(){Fd(this.sessionId)}}}),ff,hi,Kd=j(()=>{_t(),Ia(),jd(),ff=()=>{if((typeof ke.wasm.initTimeout!="number"||ke.wasm.initTimeout<0)&&(ke.wasm.initTimeout=0),typeof ke.wasm.simd!="boolean"&&(ke.wasm.simd=!0),typeof ke.wasm.proxy!="boolean"&&(ke.wasm.proxy=!1),typeof ke.wasm.trace!="boolean"&&(ke.wasm.trace=!1),typeof ke.wasm.numThreads!="number"||!Number.isInteger(ke.wasm.numThreads)||ke.wasm.numThreads<=0){(typeof self<"u"&&!self.crossOriginIsolated||typeof process<"u"&&process.versions&&process.versions.node)&&(ke.wasm.numThreads=1);let i=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;ke.wasm.numThreads=Math.min(4,Math.ceil((i||1)/2))}},hi=class{async init(i){ff(),await Wd(),await Nd(i)}async createInferenceSessionHandler(i,e){let o=new fi;return await o.loadModel(i,e),Promise.resolve(o)}}}),Yd={};kr(Yd,{wasmBackend:()=>hf});var hf,Xd=j(()=>{Kd(),hf=new hi});_t();_t();_t();var ko="1.19.0-dev.20240509-69cfcba38a";{let i=(Xd(),sr(Yd)).wasmBackend;lr("webgpu",i,5),lr("webnn",i,5),lr("cpu",i,10),lr("wasm",i,10)}Object.defineProperty(ke.versions,"web",{value:ko,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MODELS={phi3:{name:"phi3",path:"microsoft/Phi-3-mini-4k-instruct-onnx-web",externaldata:!0},phi3dev:{name:"phi3dev",path:"schmuell/Phi-3-mini-4k-instruct-onnx-web",externaldata:!0}};function getConfig(){const i="";var e={model:"phi3",provider:"webgpu",profiler:0,verbose:0,threads:1,show_special:0,csv:0,max_tokens:9999,local:0};let o=i.split("&");for(var a=0;a<o.length;a++){let d=o[a].split("=");if(d[0]in e){const g=d[0],h=decodeURIComponent(d[1]);typeof e[g]=="number"?e[g]=parseInt(h):e[g]=h}else if(d[0].length>0)throw new Error("unknown argument: "+d[0])}return MODELS[e.model]!==void 0&&(e.model=MODELS[e.model]),e}async function hasWebGPU(){if(!("gpu"in navigator))return 2;try{return(await navigator.gpu.requestAdapter()).features.has("shader-f16")?0:1}catch{return 2}}async function fetchAndCache(i,e,o=""){e(`Loading ${o}...`);const a=1024*1024,d=await caches.open("onnx");try{const g=await d.match(i);if(g)return console.log(`${i} (cached)`),g.arrayBuffer();console.log(`${i} (network)`);const h=await fetch(i);if(!h.ok)throw new Error(`Failed to fetch ${i}: ${h.statusText}`);const et=h.headers.get("content-length"),ot=et?parseInt(et,10):0;let it=0,$=0;if(ot>a){const c=[],s=h.body.getReader();for(;;){const{done:b,value:st}=await s.read();if(b)break;if(c.push(st),it+=st.length,ot){const dt=Math.floor(it/ot*100);dt>$&&(e(dt+"% "+o),$=dt)}}const _=await new Blob(c).arrayBuffer();return await d.put(i,new Response(_.slice(0))),_}else{const c=await h.arrayBuffer();return await d.put(i,new Response(c.slice(0))),c}}catch(g){throw console.error(`Can't fetch ${i}:`,g),g}}ke.wasm.numThreads=1;ke.wasm.simd=!0;ke.wasm.wasmPaths="/task-coach-browser/dist/";class LLM{constructor(e=void 0){ir(this,"sess");ir(this,"profiler",!1);ir(this,"feed",{});ir(this,"output_tokens",[]);ir(this,"eos",2);ir(this,"need_position_ids",!0);ir(this,"stop",!1);ir(this,"kv_dims",[]);ir(this,"dtype","float16");ir(this,"max_tokens",9999);if(e){ke.wasm.wasmPaths=e.location.pathname.replace("index.html","")+"dist/";return}ke.wasm.wasmPaths="/task-coach-browser/dist/"}async load(e,o,a){const d=o.provider||"webgpu",g=o.verbose,h=o.local,et=d==="wasm"?!1:o.hasFP16;this.profiler=o.profiler;const ot=h?"models/"+e.path:"https://huggingface.co/"+e.path+"/resolve/main";let it=e.file||"model";it=et?it+"_q4f16.onnx":it+"_q4.onnx";const $=await fetchAndCache(ot+"/config.json",a,"config.json file");let c=new TextDecoder;const s=JSON.parse(c.decode($)),_=await fetchAndCache(ot+"/onnx/"+it,a,"Model file"),b=e.externaldata?await fetchAndCache(ot+"/onnx/"+it+"_data",a,"Model external data"):!1;let st=_.byteLength;b&&(st+=b.byteLength),console.log(`model size ${Math.round(st/1024/1024)} MB`);const dt={executionProviders:[d],preferredOutputLocation:{}};switch(d){case"webgpu":for(let ct=0;ct<s.num_hidden_layers;++ct)dt.preferredOutputLocation[`present.${ct}.key`]="gpu-buffer",dt.preferredOutputLocation[`present.${ct}.value`]="gpu-buffer";break}b!==void 0&&(dt.externalData=[{data:b,path:it+"_data"}]),g&&(dt.logSeverityLevel=0,dt.logVerbosityLevel=0,ke.logLevel="verbose"),ke.webgpu.profiling={},this.profiler&&(dt.enableProfiling=!0,ke.webgpu.profilingMode="default",ke.webgpu.profiling.mode="default"),this.sess=await uc.create(_,dt),this.eos=s.eos_token_id,this.kv_dims=[1,s.num_key_value_heads,0,s.hidden_size/s.num_attention_heads],this.dtype=et?"float16":"float32",this.num_layers=s.num_hidden_layers,this.initilize_feed(),a(null)}initilize_feed(){const e=this.feed;for(const a in e){const d=e[a];d.location==="gpu-buffer"&&d.dispose()}this.feed={};const o=this.dtype==="float16"?new Uint16Array:[];for(let a=0;a<this.num_layers;++a)this.feed[`past_key_values.${a}.key`]=new tt(this.dtype,o,this.kv_dims),this.feed[`past_key_values.${a}.value`]=new tt(this.dtype,o,this.kv_dims);this.output_tokens=[]}argmax(e){const o=e.data,a=e.dims[2]*(e.dims[1]-1);let d=o[a],g=0;for(let h=0;h<e.dims[2];h++){const et=o[h+a];if(!isFinite(et))throw new Error("found infinitive in logits");et>d&&(d=o[h+a],g=h)}return g}update_kv_cache(e,o){for(const a in o)if(a.startsWith("present")){let d=a.replace("present","past_key_values");const g=e[d];g.location==="gpu-buffer"&&g.dispose(),e[d]=o[a]}}abort(){this.stop=!0}async generate(e,o,a){const d=a.max_tokens||256,g=this.feed,h=new tt("int64",BigInt64Array.from(e.map(BigInt)),[1,e.length]);g.input_ids=h,this.stop=!1,this.output_tokens.push(...h.data);let et=0n,ot=this.output_tokens.length;const it=h.size;for(this.need_position_ids&&(g.position_ids=new tt("int64",BigInt64Array.from({length:it},($,c)=>BigInt(ot-it+c)),[1,it]));et!=this.eos&&et!=32007&&ot<d&&!this.stop;){ot=this.output_tokens.length,g.attention_mask=new tt("int64",BigInt64Array.from({length:ot},()=>1n),[1,ot]);const $=await this.sess.run(g);et=BigInt(this.argmax($.logits)),this.output_tokens.push(et),o&&!this.profiler&&o(this.output_tokens),this.update_kv_cache(g,$),g.input_ids=new tt("int64",BigInt64Array.from([et]),[1,1]),this.need_position_ids&&(g.position_ids=new tt("int64",BigInt64Array.from([BigInt(ot)]),[1,1]))}return this.profiler&&this.sess.endProfiling(),this.output_tokens}}const fy=class fy{constructor(e=void 0,o={}){if(fy.instance)return fy.instance;const a=getConfig();env$1.localModelPath="models",env$1.allowRemoteModels=a.local==0,env$1.allowLocalModels=a.local==1,this.document=e||void 0,this.config=a,this.llm={},this.tokenizer=null,this.isModelLoaded=!1,this.progress="starting progress",this.props=o,this.props&&this.props.setConfig(a),fy.instance=this}static getInstance(e=void 0,o={}){return fy.instance||(fy.instance=new fy(e,o)),fy.instance}async initialize(){this.isModelLoaded||(this.tokenizer=await AutoTokenizer.from_pretrained(this.config.model.path),this.llm=new LLM(this.document),await this.llm.load(this.config.model,{provider:this.config.provider,profiler:this.config.profiler,verbose:this.config.verbose,local:this.config.local,maxTokens:this.config.maxTokens,hasFP16:await hasWebGPU()===0},e=>{this.progress=e,this.props&&this.props.setProgress(e)}),this.isModelLoaded=!0,this.props&&this.props.setIsModelLoaded(!0))}getLLM(){return this.llm}getTokenizer(){return this.tokenizer}getConfig(){return this.config}getIsModelLoaded(){return this.isModelLoaded}getProgress(){return this.progress}getAll(){return{tokenizer:this.tokenizer,config:this.config,isModelLoaded:this.isModelLoaded,progress:this.progress,llm:this.llm}}};ir(fy,"instance",null);let ModelContextSingleton=fy;const ModelContext=reactExports.createContext(),useModel=()=>reactExports.useContext(ModelContext),defaultTokenizer=()=>null,ModelProvider=({children:i})=>{const[e,o]=reactExports.useState({}),[a,d]=reactExports.useState(defaultTokenizer),[g,h]=reactExports.useState(!1),[et,ot]=reactExports.useState("Starting progress"),[it,$]=reactExports.useState({}),c=reactExports.useRef(!1);return reactExports.useEffect(()=>{(async()=>{if(c.current)return;c.current=!0;const _=ModelContextSingleton.getInstance(document,{setProgress:ot,setIsModelLoaded:h,setConfig:$});await _.initialize(),o(_.getLLM()),d(()=>_.getTokenizer())})()},[]),jsxRuntimeExports.jsx(ModelContext.Provider,{value:{llm:e,tokenizer:a,isModelLoaded:g,progress:et,config:it},children:i})},StatusModel=()=>{const{progress:i,isModelLoaded:e}=useModel();return jsxRuntimeExports.jsxs("div",{className:"status-loading",children:[e?null:"Loading model...",jsxRuntimeExports.jsx("p",{children:i})]})},ASSISTANT_SYSTEM_PROMPT_VALIDATE_TASK=`
Your Main Task: to know if user input is a task needed to create subtasks.
1. you must analyze and think about the user input.
2. you must validate if its a valid task by task definition to monday, jira, todo's, or some task that can be divided .
3. think it and provide explanation how its valid or invalid with "explain" field.
4. must output only 1 json formatted response.
you must think and do this step by step.
JSON markdown format like this:
{
  "valid": true,
  "explain": "task is valid due to the user's input"
}`,App=()=>{const[i,e]=reactExports.useState([]),[o,a]=reactExports.useState(ASSISTANT_SYSTEM_PROMPT_VALIDATE_TASK),[d,g]=reactExports.useState(!1),h=reactExports.useRef(null),et=async ot=>{g(!0),h.current||(h.current=new Worker(new URL("/task-coach-browser/assets/worker-C2TmUhD7.js",import.meta.url),{type:"module",name:"ChatCompletion"})),h.current.postMessage({query:ot,systemPrompt:o,stream:!0});const it=await new Promise($=>{h.current.onmessage=c=>{const{status:s,text:_}=c.data;s==="final"&&(e(b=>[...b.slice(0,-1),{role:"assistant",content:_}]),h.current.terminate(),$(_)),s==="stream"&&e(b=>[...b.slice(0,-1),{...b[b.length-1],role:"assistant",content:_}])}});return g(!1),it};return jsxRuntimeExports.jsxs("div",{className:"App",children:[jsxRuntimeExports.jsx(StatusModel,{}),jsxRuntimeExports.jsx(ChatBot,{chatHistory:i,setChatHistory:e,onSubmit:et,isGenerating:d})]})};client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React.StrictMode,{children:jsxRuntimeExports.jsx(ModelProvider,{children:jsxRuntimeExports.jsx(App,{})})}));
